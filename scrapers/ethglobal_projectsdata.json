[
    {
        "title": "Versioned Walrus",
        "brief_description": "A lib based on walrus DB that supports the version control. A simple file system demo based on this versioned walrus lib.",
        "long_description": "This project involves the creation of a library built on top of WalrusDB, designed to provide robust version control functionality for document storage. The system utilizes WalrusDB as the underlying storage solution, while metadata is stored on the client side to track different versions of documents. Key Features:\nWalrusDB-Based Storage: The system uses WalrusDB to store contract files, ensuring data immutability and decentralized storage for long-term persistence. Version Control: Supports uploading different versions of the same contract, allowing agents to easily manage updates over time.\nPrevious versions of documents are tracked, allowing for easy navigation and auditability of historical changes.\nVersion control is handled at the metadata level, making it possible to skip uploading files that already exist to avoid redundancy.\nWhen a new version of a document is uploaded, the system automatically creates and links it as a new version, tracking the relationship between versions.\nContract Management: Agents can upload contracts onto WalrusDB, leveraging the version control system to manage multiple versions of a contract for clients.\nThe system allows agents and clients to sign a specific version of a document. Upon signing, a signature file is generated, which logs the action in the format: [addr] has signed [BlobID], providing cryptographic proof that a specific version has been signed by a particular party.\nSigning Workflow: Agents or clients can sign individual versions of documents, with the system automatically generating a signature file. This file contains details such as the signer\u2019s address and the BlobID of the signed document, ensuring traceability and proof of signature.\nUse Cases:\nContract Versioning: An agent can upload multiple versions of the same contract as needed, allowing for smooth management of changes over time. The system tracks all previous versions, ensuring complete transparency and traceability. Document Signing: Both agents and clients can sign specific versions of documents. The system generates signature metadata files that certify the signing event and provide an audit trail.",
        "how_its_made": "Key Features:\nWalrusDB-Based Storage: The system uses WalrusDB to store contract files, ensuring data immutability and decentralized storage for long-term persistence. Version Control: Supports uploading different versions of the same contract, allowing agents to easily manage updates over time.\nPrevious versions of documents are tracked, allowing for easy navigation and auditability of historical changes.\nVersion control is handled at the metadata level, making it possible to skip uploading files that already exist to avoid redundancy.\nWhen a new version of a document is uploaded, the system automatically creates and links it as a new version, tracking the relationship between versions.\nContract Management: Agents can upload contracts onto WalrusDB, leveraging the version control system to manage multiple versions of a contract for clients.\nThe system allows agents and clients to sign a specific version of a document. Upon signing, a signature file is generated, which logs the action in the format: [addr] has signed [BlobID], providing cryptographic proof that a specific version has been signed by a particular party.\nSigning Workflow: Agents or clients can sign individual versions of documents, with the system automatically generating a signature file. This file contains details such as the signer\u2019s address and the BlobID of the signed document, ensuring traceability and proof of signature.\nUse Cases:\nContract Versioning: An agent can upload multiple versions of the same contract as needed, allowing for smooth management of changes over time. The system tracks all previous versions, ensuring complete transparency and traceability. Document Signing: Both agents and clients can sign specific versions of documents. The system generates signature metadata files that certify the signing event and provide an audit trail.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3btjd/screenshots/gn4tq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3btjd/screenshots/3ygam/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3btjd/screenshots/gjspm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3btjd/screenshots/q68of/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wenlianglaw/versioned_walrus",
        "link": "https://ethglobal.com/showcase/versioned-walrus-3btjd"
    },
    {
        "title": "influencer swap",
        "brief_description": "Ai oracle swaps the influencer's photo onto brand's content. the influencer gets paid",
        "long_description": "Ai oracle swaps the influencer's photo onto brand's content. the influencer gets paid. \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\" layerzero to create omnichain nft, story's IP for licensing and for the influencer getting paid \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"",
        "how_its_made": "layerzero to create omnichain nft, story's IP for licensing and for the influencer getting paid \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zwff7/screenshots/3j1qp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zwff7/screenshots/8org0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zwff7/screenshots/yu0n1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kirilligum/story-protocol-boilerplate-sf24-sonft",
        "link": "https://ethglobal.com/showcase/influencer-swap-zwff7"
    },
    {
        "title": "Integration",
        "brief_description": "AI powered post-journey guide to serve theraphy clinics. \"Unlocking Lasting Insights, From Treatment to Transformation\"",
        "long_description": "Integration a revolutionary Web3 application designed to support individuals through the critical integration phase following a psychedelic experience. Harnessing the neuroplasticity triggered by psychedelics, this app provides a structured, self-guided journey to maximize personal growth and insight.\nBuilt on the robust MAPS (Multidisciplinary Association for Psychedelic Studies) psychological framework, Intergration ensures users follow scientifically-backed steps for effective integration. The app guides you through three core pillars: Intentional Preparation and Reflection, Holistic Integration into Daily Life, and Community Support and Ethical Practice.\nSecurity and privacy are paramount. Utilizing blockchain technology, all journal entries are encrypted and stored safely ensuring your most intimate reflections remain private and secure. Key features include: Customizable integration plans\nEncrypted journaling tools\nProgress tracking with tokenized rewards\nGuided meditation and mindfulness exercises\nCreative expression prompts\nCommunity support options\nEducational resources on psychedelic integration Whether you're processing insights, working through emotions, or implementing life changes, provides the structure and support you need. It's not just a journal; it's a comprehensive tool for transforming profound experiences into lasting positive change. Our project harnesses the power of cutting-edge AI, intuitive design, and adaptive functionality to create a truly revolutionary psychedelic integration experience: Claude AI: Leveraging advanced language models to provide personalized guidance, intelligent prompts, and adaptive content based on user input and progress. Claude's deep understanding of psychedelic experiences and integration practices ensures relevant, empathetic support throughout your journey.\nFigma-Crafted Interface: A meticulously designed user interface created in Figma, offering an intuitive, visually appealing experience. The design prioritizes ease of use, emotional resonance, and a calming aesthetic to support the integration process.\nDynamic Functionality: An adaptive system that evolves with your needs, offering personalized integration pathways, real-time adjustments to your plan based on your progress and feedback, and interactive elements that respond to your unique journey. This powerful combination creates a fluid, intelligent, and beautifully designed tool that adapts to your individual integration needs, making the process of translating profound insights into lasting change both effective and engaging.",
        "how_its_made": "Our project harnesses the power of cutting-edge AI, intuitive design, and adaptive functionality to create a truly revolutionary psychedelic integration experience: Claude AI: Leveraging advanced language models to provide personalized guidance, intelligent prompts, and adaptive content based on user input and progress. Claude's deep understanding of psychedelic experiences and integration practices ensures relevant, empathetic support throughout your journey.\nFigma-Crafted Interface: A meticulously designed user interface created in Figma, offering an intuitive, visually appealing experience. The design prioritizes ease of use, emotional resonance, and a calming aesthetic to support the integration process.\nDynamic Functionality: An adaptive system that evolves with your needs, offering personalized integration pathways, real-time adjustments to your plan based on your progress and feedback, and interactive elements that respond to your unique journey. This powerful combination creates a fluid, intelligent, and beautifully designed tool that adapts to your individual integration needs, making the process of translating profound insights into lasting change both effective and engaging.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xuj1k/screenshots/j5h08/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xuj1k/screenshots/tcng3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xuj1k/screenshots/0t157/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/matthew1809/integration",
        "link": "https://ethglobal.com/showcase/integration-xuj1k"
    },
    {
        "title": "Probana",
        "brief_description": "User Powered Prediction Market for Real-World Events on Flow Chain",
        "long_description": "Probana is a prediction market on flow that allows users to bet on anything. Users can create markets and set rules for those markets.  We created an order book from scratch that has limit orders, this allows people to queue up prices that they want to buy at, straight in the contract. The project uses Flow EVM as the chain we utilize this due to the extremely low block times and extremely affordable gas fees. In order to index the blockchain data we decided to use Alchemy subgraph feature. As our betting token we decided to use USDC because of its stable nature.",
        "how_its_made": "The project uses Flow EVM as the chain we utilize this due to the extremely low block times and extremely affordable gas fees. In order to index the blockchain data we decided to use Alchemy subgraph feature. As our betting token we decided to use USDC because of its stable nature.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sn7tu/screenshots/ubw3g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sn7tu/screenshots/n2nz3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sn7tu/screenshots/yhd31/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ElliotSlusky/Probana",
        "link": "https://ethglobal.com/showcase/probana-sn7tu"
    },
    {
        "title": "P3-FV",
        "brief_description": "Auto-generating formal verification specs from Plonky3 circuits",
        "long_description": "This project is an experimental devtool for more easily generating formal verification specs from existing Plonky3 circuits. First you extract the symbolic constraints from your Rust circuit and then pass it through a Python transpiler to output a Z3 Python program, which you use to run the Z3 solver. This project uses the Z3 theorem prover and Polygon's Plonky3 ZK framework. The Plonky3 framework has nice abstractions around building AIRs which was very beneficial for extracting the constraints before passing them through the Z3 transpiling pipeline in Python (for which Z3 has a far more ergonomic library than in Rust).",
        "how_its_made": "This project uses the Z3 theorem prover and Polygon's Plonky3 ZK framework. The Plonky3 framework has nice abstractions around building AIRs which was very beneficial for extracting the constraints before passing them through the Z3 transpiling pipeline in Python (for which Z3 has a far more ergonomic library than in Rust).",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/95jy3/screenshots/gzukb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/95jy3/screenshots/1tcwa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/95jy3/screenshots/pn8cu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/rpalakkal/p3-fv",
        "link": "https://ethglobal.com/showcase/p3-fv-95jy3"
    },
    {
        "title": "NBA MOMENTUM",
        "brief_description": "NBA Momentum is a strategy-driven trading card game that transforms NBA Top Shot moments into competitive, stats-based gameplay. Players build decks and compete by using real NBA moments with custom abilities.",
        "long_description": "NBA Momentum leverages NBA Top Shot\u2019s blockchain moments to create a trading card game where each moment becomes a playable card with attributes like offense, defense, and special abilities. Players build decks using various types of cards\u2014Player Moments, Hype, Playbook, Equipment, and Arena cards\u2014and engage in strategic gameplay to reach 21 points, simulating a fast-paced pickup basketball game. The game\u2019s innovation lies in its integration with Flow blockchain, giving players ownership over their moments while adding strategic layers through custom stats and abilities, making it a more immersive experience. NBA Momentum is built using the Flow blockchain and Cadence for smart contracts, enabling us to tokenize and add metadata to existing NBA Top Shot moments. We used Python scripts and the OpenAI API to dynamically generate custom stats for each moment, which is stored as metadata on the Flow network. The frontend uses React for a seamless user experience, allowing players to view their moment collections, build decks, and engage in card battles. Postman was used to interact with the NBA Top Shot API, and the game\u2019s backend utilizes Node.js to manage game logic and deck building.",
        "how_its_made": "NBA Momentum is built using the Flow blockchain and Cadence for smart contracts, enabling us to tokenize and add metadata to existing NBA Top Shot moments. We used Python scripts and the OpenAI API to dynamically generate custom stats for each moment, which is stored as metadata on the Flow network. The frontend uses React for a seamless user experience, allowing players to view their moment collections, build decks, and engage in card battles. Postman was used to interact with the NBA Top Shot API, and the game\u2019s backend utilizes Node.js to manage game logic and deck building.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9shz6/screenshots/bzqm6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9shz6/screenshots/5k7vs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9shz6/screenshots/9oy6z/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/bombfriedrice/nbamomentum",
        "link": "https://ethglobal.com/showcase/nba-momentum-9shz6"
    },
    {
        "title": "Engagemint",
        "brief_description": "Engagemint empowers users to earn, tokenize, and unlock rewards for their attention on their favorite artists and influencers. Mint unique tokens, track engagement, and redeem exclusive perks\u2014all in a Web3 ecosystem.",
        "long_description": "Engagemint is an Web3 platform designed to transform user engagement into a valuable currency. Engagemint enables users to earn, tokenize, and unlock exclusive rewards for their interactions with artists and influencers. Upon logging in, users are greeted with a personalized dashboard that displays metrics reflecting their engagement activity, such as time spent streaming specific artists or influencers. This data is essential for tracking progress and rewards. One of the platform's standout features is the influencer tokens, which users can browse to find various artists. These tokens are approved through a community voting process, ensuring users feel connected to the content they engage with. Community members can also propose new artist tokens, and once an artist receives 150 affirmative votes, a new token is minted through a Solidity smart contract on Skale\u2019s Calypso testnet. This process allows underground and emerging artists to gain visibility while providing users with a wider range of tokens to accumulate. As users engage with their favorite artists, they earn engagement points, which contribute to the minting of new tokens and can lead to exclusive perks. Additionally, users accumulate digital proof of their interactions, displayed as achievement collections, which serve as badges of loyalty and enhance the overall experience. The redemption page allows users to exchange their tokens for exclusive rewards, such as backstage passes and limited-edition merchandise, incentivizing ongoing interaction and loyalty. Engagemint fosters a sense of community by allowing users to participate in the decision-making process regarding which artists receive tokens. This collaborative approach not only enhances user satisfaction but also encourages fans to support their favorite artists, driving more engagement on the platform. Overall, Engagemint is revolutionizing the way fans and creators interact in the digital space, making engagement a rewarding experience and transforming casual listeners into invested community members. Whether you\u2019re a dedicated fan or an emerging artist, Engagemint makes it easy to be recognized and rewarded for your engagement. This project is deployed on the Skale Calypso Testnet and we implemented a voting system to that allow users to vote on new tokens. It also tracks how long people are spending on the applications to mint these tokens using a Solidity smart contract.The entire goal is to let creators get to advertise themselves and let fans of those creators get to promote themself",
        "how_its_made": "This project is deployed on the Skale Calypso Testnet and we implemented a voting system to that allow users to vote on new tokens. It also tracks how long people are spending on the applications to mint these tokens using a Solidity smart contract.The entire goal is to let creators get to advertise themselves and let fans of those creators get to promote themself",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/yffv6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/rpexa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/g2rni/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/9nygn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/tem4n/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ssarahmou/engagemint",
        "link": "https://ethglobal.com/showcase/engagemint-t6caw"
    },
    {
        "title": "BlockLingo",
        "brief_description": "A decentralized protocol enabling direct asset transfers between different blockchains.",
        "long_description": "This image illustrates a cross-chain transfer protocol system, focusing on the user experience and the underlying technical process. At the top, we see a user interface represented by a wallet. The wallet shows the source (ETH) and destination (Layer 0 OTP) for a transfer. This represents the user's intent to move assets from one blockchain (Ethereum) to another (a Layer 0 protocol). The lower section of the image depicts the internal workings of the transfer system. The central component is labeled \"Main AI ORCHESTRATOR,\" which appears to be the core logic coordinating the entire process. Connected to this main orchestrator is a \"Translator\" module. This translator interacts with multiple blockchain networks: ETH (Ethereum), EURC (possibly a fictional or newer blockchain), EURC (another blockchain or network), and Layer 0 OTP (the destination chain from the user's perspective). The translator's role seems to be facilitating communication and transaction formatting between these different blockchain protocols. The flow suggests that when a user initiates a transfer, the main orchestrator processes the request, then utilizes the translator to interact with the necessary blockchains. This likely involves creating and verifying transactions on the source chain (ETH in this case), translating the asset or data into a format compatible with the destination chain, and then finalizing the transfer on the Layer 0 OTP network. The bottom of the image states \"Source reaches final destination,\" indicating the successful completion of the cross-chain transfer. This system appears designed to abstract away the complexity of cross-chain interactions from the user, providing a seamless experience for transferring assets between different blockchain networks, while handling the intricate details of protocol translation and transaction orchestration behind the scenes. The frontend is built in react, Coinbase SDK Wallet connect, Tailwind CSS. The backend is comprised of integrations between Metamask, Layer 0, Morph, and Solidity Smart Contracts. Layer 0 was a great benefit to the project as it helped us use hardhat and contracts to simplify our workflow.",
        "how_its_made": "The frontend is built in react, Coinbase SDK Wallet connect, Tailwind CSS. The backend is comprised of integrations between Metamask, Layer 0, Morph, and Solidity Smart Contracts. Layer 0 was a great benefit to the project as it helped us use hardhat and contracts to simplify our workflow.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9pf20/screenshots/bjezt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9pf20/screenshots/jp470/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9pf20/screenshots/ytduw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/U1tra-Labs/blockLingo",
        "link": "https://ethglobal.com/showcase/blocklingo-9pf20"
    },
    {
        "title": "ToneRight",
        "brief_description": "TuneRight is a web marketplace where artists and production companies trade music licensing as intellectual property. It empowers users to register their music, set licensing terms, manage royalties, and ensures the original artist is always credited and compensated.",
        "long_description": "Our web service acts as a marketplace where artists and production companies come to buy and sell licensing to their Music, which is their Intellectual Property. Our webspace allows users to register their music as Intellectual Property Assets, set personalized Licensing Terms and sell rights to their music without any human intervention or requirement of delegation. It also takes care of flow of royalties and makes sure that the original artist is always credited and compensated according to their own accord. The project leverages Story Protocol to streamline intellectual property management, licensing, and royalty distribution. It also integrates Dynamic to offer users an easy and seamless onboarding experience. Built with Next.js, Solidity, viem, and wagmi, the platform ensures a decentralized and efficient approach to music rights and usage.",
        "how_its_made": "The project leverages Story Protocol to streamline intellectual property management, licensing, and royalty distribution. It also integrates Dynamic to offer users an easy and seamless onboarding experience. Built with Next.js, Solidity, viem, and wagmi, the platform ensures a decentralized and efficient approach to music rights and usage.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xdj7q/screenshots/oouav/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xdj7q/screenshots/1m7qg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xdj7q/screenshots/9g5y7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xdj7q/screenshots/qr8tx/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sreekar9601/tone-right/",
        "link": "https://ethglobal.com/showcase/toneright-xdj7q"
    },
    {
        "title": "Build Villager",
        "brief_description": "An interface to write community benefits into intellectual patent acquisitions",
        "long_description": "Mint projects on Story that allow the use of derivatives access to rights within a community. One use case is if I write a novel and mint intellectual copyright on Story, I can allow some parts of the novel to be editable by the reader and others to be uneditable. I can also add multimedia patents such as music to add to the experience of the novel. Token holders of the parent novel and its derivatives can use those tokens to gain access to community events such as concerts, healthcare, and other benefits. Story's Proof of Creativity Protocol would be the origination and host of the parent intellectual properties. Then write the benefits into the individual copyrights during the minting. The ERC-20 tokens could have unique properties allowing easy access for downstream benefit recognition. The project gives token holders access to a community called Villager.",
        "how_its_made": "Story's Proof of Creativity Protocol would be the origination and host of the parent intellectual properties. Then write the benefits into the individual copyrights during the minting. The ERC-20 tokens could have unique properties allowing easy access for downstream benefit recognition. The project gives token holders access to a community called Villager.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qsadf/screenshots/gr1tk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qsadf/screenshots/4og5m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qsadf/screenshots/e5dvp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/eldarina/villager",
        "link": "https://ethglobal.com/showcase/build-villager-qsadf"
    },
    {
        "title": "APIWink",
        "brief_description": "APIWink at core is an API micro-lending service, ideal to attract more users and reduce costs. It's developed on Skale contracts, invisible custodial experience, Europa testnet and program money.",
        "long_description": "APIs traditionally have a monthly/yearly subscription models, for developers who want to just try out APIs for their application, this model becomes a rather costly option. We've developed a micro-lending service enabling devs to purchase \"number of API calls\" for Skale programmed money. This model not only charges per use, but also splits the money between us (the service providers) and creators (api creators). These people are welcome to join our marketplace, we have specially designed an SDK to attach to our eco-system along with robust documentation. The application is heavily centered around Skale, utilizing it's zero gas fees. It's present in our project in the following ways - Skale contracts, Invisible custodial experience, Europa testnet for DeFI and programmable monday. The backend and SDK are developed using python, frontent uses nextjs.\nWe have deployed the backend on render, docs on gitbook, MongoDb for database",
        "how_its_made": "The application is heavily centered around Skale, utilizing it's zero gas fees. It's present in our project in the following ways - Skale contracts, Invisible custodial experience, Europa testnet for DeFI and programmable monday. The backend and SDK are developed using python, frontent uses nextjs.\nWe have deployed the backend on render, docs on gitbook, MongoDb for database",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2ogub/screenshots/2fwif/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2ogub/screenshots/r2c4z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2ogub/screenshots/4wb7r/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ApiWink",
        "link": "https://ethglobal.com/showcase/apiwink-2ogub"
    },
    {
        "title": "Photo Booth",
        "brief_description": "Photo Booth is a fun tool that lets people take photos and add fun overlays including Nouns glasses and their ENS.",
        "long_description": "Photo Booth is a web application built with Next.js that allows users to take photos, add fun overlays including Nouns glasses and their ENS, and see all images uploaded by users from the same event. When you access this app you connect your wallet, then are able to take an photo with your webcam. We then allow you to add cool overlays like Noun glasses and your ENS. We also leverage walrus aggregator and publisher however it was down during the event. We built the project using Next.js and used libraries like wagmi. We let the user take photos and we created an upload route to upload images to Walrus and a route to get images from the walrus aggregator. We used partners like Walrus (for the images hostings), Nouns (for their IP and incorporating their IP in as overlays), ENS (we let users connect wallet and then add their ENS overlayed on the image). This help increase and promote Nouns and ENS visibility and adoption.",
        "how_its_made": "We built the project using Next.js and used libraries like wagmi. We let the user take photos and we created an upload route to upload images to Walrus and a route to get images from the walrus aggregator. We used partners like Walrus (for the images hostings), Nouns (for their IP and incorporating their IP in as overlays), ENS (we let users connect wallet and then add their ENS overlayed on the image). This help increase and promote Nouns and ENS visibility and adoption.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h1pz9/screenshots/b9t1t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h1pz9/screenshots/qpphk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h1pz9/screenshots/fqukd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h1pz9/screenshots/ikub1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jarrensj/photo-booth",
        "link": "https://ethglobal.com/showcase/photo-booth-h1pz9"
    },
    {
        "title": "zk-checkpoint",
        "brief_description": "ZK proofs for checkpointing on Polygon PoS to save on settlement gas and faster interop",
        "long_description": "Polygon PoS being one of the most used chains has a mechanism where it settles to Ethereum (L1) at regular intervals through checkpoints which is helpful for bridging. As a result, the consensus signatures are sent to L1 contract and signature verification for all validators is done on-chain. This incurs a lot of gas on ethereum and ~86% of total gas used is taken by signature verification for all validators (on mainnet, roughly 105). The costs gas go >250$ in case of high demand. This settlement workflow can be improved using ZK proofs which asserts that majority of validator set (>2/3) voted on a particular checkpoint. This can lead to 2 things: The project is made with the help of SP1, which allows to write the signature verification and validation logic in Rust and generate a proof out of it which can be verified on-chain. While the crux is pretty simple, there were lots of challenges while building this. Moreover, the circuit has certain strict constraints which eliminates the risk of prover generating false/fake proofs.",
        "how_its_made": "The project is made with the help of SP1, which allows to write the signature verification and validation logic in Rust and generate a proof out of it which can be verified on-chain. While the crux is pretty simple, there were lots of challenges while building this. Moreover, the circuit has certain strict constraints which eliminates the risk of prover generating false/fake proofs.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1humr/screenshots/3ciie/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1humr/screenshots/fhhp6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1humr/screenshots/h7ktj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/manav2401/zk-checkpoint",
        "link": "https://ethglobal.com/showcase/zk-checkpoint-1humr"
    },
    {
        "title": "bloq",
        "brief_description": "search on-chain data with a prompt, we enable users to search on-chain data and consume it in layman language",
        "long_description": "Using LlamaIndex with The Graph protocol for indexing and serving on-chain data, and then leveraging that with agentic RAG (Retrieval-Augmented Generation) LLMs is a powerful approach. This setup allows for intelligent, context-aware querying of blockchain data with the added benefit of AI-driven insights. We have used llama-index framework to semantically search on-chain data.Using LlamaIndex (formerly GPT Index) for semantically searching on-chain data is an innovative approach. It allows you to create more intelligent and context-aware searches of blockchain data. his setup allows for intelligent, context-aware querying of blockchain data with the added benefit of AI-driven insights.",
        "how_its_made": "We have used llama-index framework to semantically search on-chain data.Using LlamaIndex (formerly GPT Index) for semantically searching on-chain data is an innovative approach. It allows you to create more intelligent and context-aware searches of blockchain data. his setup allows for intelligent, context-aware querying of blockchain data with the added benefit of AI-driven insights.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9k8fv/screenshots/1qnvy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9k8fv/screenshots/1x1ns/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9k8fv/screenshots/qijwb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/DV0x/bloq",
        "link": "https://ethglobal.com/showcase/bloq-9k8fv"
    },
    {
        "title": "SecurityModuleForAA",
        "brief_description": "The user enabled Safe Guard with 2FA (via email) to protect the Smart Account from the risk of a compromised EOA key.",
        "long_description": "A traditional EOA wallet is vulnerable, as a single exposure of the private key can immediately put all assets at risk. Additionally, when managing a smart account through multi-signature, there is the inconvenience of requiring signatures above the threshold every time a transaction occurs. To address these issues, two accounts can be created to manage a single smart account. One account is attached to the smart account to manage transactions via a module, while the other serves as the owner of the smart account and handles signing responsibilities. This approach distributes responsibilities and enhances the user experience. The process is as follows: First, the user creates a smart wallet using their EOA. Simultaneously, they log into our app (SPOT) using another method or another EOA. In SPOT, they create a module that manages transactions and attach this module to the smart wallet created with the previous EOA. By doing so, the management of the smart account is divided into two (the module and the user's EOA), each managed through different methods. This ensures much stronger security than managing everything with a single private key. Since transactions are automatically handled according to the rules set in the module, the hassle of multiple signatures for every transaction is reduced. Furthermore, by incorporating advanced security measures like encryption oracles such as Lit Protocol, users can manage account security at a more sophisticated level (e.g., based on IP address). As more data accumulates, AI-powered fraud detection systems (FDS) can also be provided through the module, further enhancing security. This project implemented smart accounts and attached the appropriate module using Safe Wallet. To create a management point separate from the EOA, we onboarded users through SPOT by utilizing Dynamic.xyz. Additionally, to reduce gas fee conflicts during user onboarding, we used Alchemy's Account Kit and Paymaster to eliminate gas fees associated with creating modules and changing settings. Moving forward, we plan to provide modules that allow users to encrypt their IP addresses and specific actions using Lit Protocol, enabling privacy-preserving configuration.",
        "how_its_made": "This project implemented smart accounts and attached the appropriate module using Safe Wallet. To create a management point separate from the EOA, we onboarded users through SPOT by utilizing Dynamic.xyz. Additionally, to reduce gas fee conflicts during user onboarding, we used Alchemy's Account Kit and Paymaster to eliminate gas fees associated with creating modules and changing settings. Moving forward, we plan to provide modules that allow users to encrypt their IP addresses and specific actions using Lit Protocol, enabling privacy-preserving configuration.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/n7kyk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/9nycn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/iz60v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/mwcka/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/o3fpn/default.jpg"
        ],
        "live_demo": "https://ethglobal-24-sf.vercel.app/",
        "source_code": "https://github.com/PermissionLabs/ethglobal-24-sf",
        "link": "https://ethglobal.com/showcase/securitymoduleforaa-ufcg7"
    },
    {
        "title": "BenderBite",
        "brief_description": "AI Employee Bender: get AI advices based on previous winners, vote for other project and get prices and meet friends!",
        "long_description": "BenderBite is an AI-powered assistant designed to enhance the EthGlobal hackathon experience by serving as a virtual employee with multiple interactive features. Here's a detailed breakdown: Tailored Advice from Previous Winners: Users can receive tailored advice based on insights from previous hackathon winners.\nBender uses historical data to offer actionable suggestions on project development, presentation, and strategies for winning.\nProject Bidding and Rewards: Users can add projects to the platform using the XMTP bot and automatically receive an ENS domain through the ENS smart contract, along with a wallet created programmatically using Circle\u2019s wallet service.\nUsers can place bids on other projects during the hackathon.\nAutomated reward distribution is facilitated through the Circle API.\nSocial Networking and Collaboration: Bender helps users find friends and collaborate with others.\nIt enables networking by matching users with potential partners. I have integrated XMTP for seamless messaging capabilities, allowing users to communicate effectively within the platform. To provide tailored guidance, I\u2019ve utilized AI for context learning, drawing insights from previous hackathon winners to offer strategic advice on project development and presentation. For identity management, I\u2019ve implemented smart contracts that facilitate ENS subdomain registration, ensuring that users can establish their unique digital identities on the blockchain. Additionally, I\u2019ve incorporated Circle\u2019s programmable wallets API, enabling the automatic generation of secure wallets for users, as well as Circle\u2019s smart contract platform and used Circle for automated and transparent transaction processing, including bidding and reward distribution.",
        "how_its_made": "I have integrated XMTP for seamless messaging capabilities, allowing users to communicate effectively within the platform. To provide tailored guidance, I\u2019ve utilized AI for context learning, drawing insights from previous hackathon winners to offer strategic advice on project development and presentation. For identity management, I\u2019ve implemented smart contracts that facilitate ENS subdomain registration, ensuring that users can establish their unique digital identities on the blockchain. Additionally, I\u2019ve incorporated Circle\u2019s programmable wallets API, enabling the automatic generation of secure wallets for users, as well as Circle\u2019s smart contract platform and used Circle for automated and transparent transaction processing, including bidding and reward distribution.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/z2f7s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/6h54g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/dxvbh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/x19yj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/s5mdj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wisemik/benderbite",
        "link": "https://ethglobal.com/showcase/benderbite-331m7"
    },
    {
        "title": "EssenSwap",
        "brief_description": "EssenSwap is a limit orderbook-based exchange built on the Essential blockchain.",
        "long_description": "In EssenSwap, the bids and asks are submitted as constraints, as required by Essential's declarative virtual machine. Every time there is a positive spread, an external solver bot is created that matches bids and asks and submits a solution to propose a new state of the system, viz., the updated balances of the bidders and askers. EssenSwap consists of three components: front-end, solver bot, and blockend. First, we deploy smart contracts for standard fungible token contracts currently available on Essential. Then, we deploy a unique smart contract for every bid and ask order, with predicates that impose constraints on the swap price of a trade. After that, we build a rust-based script that performs on-behalf of a solver by sorting, and then matching bids and asks orders. The final solution is then submitted to the Essential blockchain through their API. Once the rust script receives a confirmation receipt, it updates the front-end display.",
        "how_its_made": "EssenSwap consists of three components: front-end, solver bot, and blockend. First, we deploy smart contracts for standard fungible token contracts currently available on Essential. Then, we deploy a unique smart contract for every bid and ask order, with predicates that impose constraints on the swap price of a trade. After that, we build a rust-based script that performs on-behalf of a solver by sorting, and then matching bids and asks orders. The final solution is then submitted to the Essential blockchain through their API. Once the rust script receives a confirmation receipt, it updates the front-end display.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/qy5hd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/6rru4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/cw9at/default.jpg",
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/azcmt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/06nj9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jeffklinck/EthSF",
        "link": "https://ethglobal.com/showcase/essenswap-82ygd"
    },
    {
        "title": "Wilson:sound intents",
        "brief_description": "Execute, Attest, Validate, and Share Communicated data via agent-assisted contracts.",
        "long_description": "Bringing insights on chain, and generating value for data gatherings. Wilson is a toolset built on the Friend SDK that turns your voice into secure triggers for onchain actions. Simply pair your Omi, or other compatible wearable with your Omi app, add the Wilson extension, and tap the screen to complete the memory block whenever you want to process a command. Upon processing, Wilson will send the parsed statement to a server that will generate a response based on your trigger statement. If this is Friend SDK produces a prompt that is sent to a webhook parsed before being sent to an available DA layer, where the request is staged to produce a response from Dynamic for wallet info, or XMTP for external actions. All Dynamic responses return as Sign attestation, under a schema that allows recipient to authenticate the response if they wish the result to be onchain. Otherwise, the insights from the contributor's personal device are shared with the local network once they submit a 'register' command, then all further insights are contributed to local pool until insight stream is 'plugged'. While streaming your insights via Wilson, you can use your device to capture and cultivate local data, post, share, and challenge others from your personal onchain history, and generate new historic intents. Each change in permissions possible thanks to zk toolset from Polygon, and assignable via ENS retrieval contracts.",
        "how_its_made": "Friend SDK produces a prompt that is sent to a webhook parsed before being sent to an available DA layer, where the request is staged to produce a response from Dynamic for wallet info, or XMTP for external actions. All Dynamic responses return as Sign attestation, under a schema that allows recipient to authenticate the response if they wish the result to be onchain. Otherwise, the insights from the contributor's personal device are shared with the local network once they submit a 'register' command, then all further insights are contributed to local pool until insight stream is 'plugged'. While streaming your insights via Wilson, you can use your device to capture and cultivate local data, post, share, and challenge others from your personal onchain history, and generate new historic intents. Each change in permissions possible thanks to zk toolset from Polygon, and assignable via ENS retrieval contracts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/x147v/screenshots/ict2t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x147v/screenshots/tz4nr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x147v/screenshots/ahn5y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x147v/screenshots/4wqhx/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/paulman5/ETHGlobalSF",
        "link": "https://ethglobal.com/showcase/wilson-sound-intents-x147v"
    },
    {
        "title": "Real Lend",
        "brief_description": "Borrowers pledge real-world assets as collateral. An oracle sets the asset\u2019s value and posts a bond. Lenders provide loans with interest. If borrowers default, lenders sell the asset to the oracle to recover funds. Loans can also be sold early through Dutch auctions.",
        "long_description": "Real Lend bridges real-world assets (RWAs) with decentralized finance, allowing borrowers to unlock liquidity and lenders to earn yields. Borrowers pledge assets like vacation cottages as collateral, with an oracle setting the value and posting it as a bond to guarantee the lender\u2019s recovery. Lenders provide loans (e.g., 100k USDC at 10% interest) based on the asset's value. If the borrower repays, they reclaim the asset; if not, the lender recovers funds by selling the asset to the oracle at the bonded value. Lenders can exit early by selling their loan position through a Dutch auction, which starts at a high price and drops until purchased. Pools on protocols like Morpho improve liquidity, ensuring a smooth, secure, and flexible lending experience for both parties. We built a decentralized protocol for real-world asset lending using Solidity smart contracts and the Foundry toolkit. Our core components include USDC.sol for managing loan payments, Cottage.sol to tokenize real estate collateral like vacation homes, and Protocol.sol to oversee loan issuance, repayments, and defaults. An oracle sets asset values and posts bonds, ensuring lenders are protected by guaranteeing recovery if borrowers default. In such cases, lenders can recover their funds by selling the assets to the oracle at the bonded value. To offer flexibility, we implemented a Dutch auction mechanism in DutchAuction.sol, allowing lenders to exit their loan positions early by dynamically selling them as prices adjust over time. We streamlined deployment using Foundry tools such as forge and automated the process with custom Bash scripts for contract deployment and verification. Anvil was used to fork the Ethereum mainnet locally, creating realistic test environments that simulated live network conditions. This setup allowed us to efficiently identify and resolve issues before deployment. Our automation framework ensured a seamless and repeatable workflow, making the development process smooth and scalable from testing through deployment.",
        "how_its_made": "We built a decentralized protocol for real-world asset lending using Solidity smart contracts and the Foundry toolkit. Our core components include USDC.sol for managing loan payments, Cottage.sol to tokenize real estate collateral like vacation homes, and Protocol.sol to oversee loan issuance, repayments, and defaults. An oracle sets asset values and posts bonds, ensuring lenders are protected by guaranteeing recovery if borrowers default. In such cases, lenders can recover their funds by selling the assets to the oracle at the bonded value. To offer flexibility, we implemented a Dutch auction mechanism in DutchAuction.sol, allowing lenders to exit their loan positions early by dynamically selling them as prices adjust over time. We streamlined deployment using Foundry tools such as forge and automated the process with custom Bash scripts for contract deployment and verification. Anvil was used to fork the Ethereum mainnet locally, creating realistic test environments that simulated live network conditions. This setup allowed us to efficiently identify and resolve issues before deployment. Our automation framework ensured a seamless and repeatable workflow, making the development process smooth and scalable from testing through deployment.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/11w4v/screenshots/74sjp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11w4v/screenshots/tnvd3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11w4v/screenshots/6suru/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/mergd/reallend-ui",
        "link": "https://ethglobal.com/showcase/real-lend-11w4v"
    },
    {
        "title": "Omi FM",
        "brief_description": "Decentralized music player, let smart contracts take care of creating the vibes.",
        "long_description": "AI powered Dapp that plays curated music for you based on the conversations analyzed by Omi. DApp created using Omi SDK for conversation analysis with its AI models. UI/UX is command line, using Python and Solidity to communication with Smart Contracts deployed to Skale, Flow, and Avail. Those contracts contain the logic for creating playlists and getting new songs. DApp created using Omi SDK for conversation analysis with its AI models. UI/UX is command line, using Python and Solidity to communication with Smart Contracts deployed to Skale, Flow, and Avail. Those contracts contain the logic for creating playlists and getting new songs. ZK rollups handle bulk song creation off chain.",
        "how_its_made": "DApp created using Omi SDK for conversation analysis with its AI models. UI/UX is command line, using Python and Solidity to communication with Smart Contracts deployed to Skale, Flow, and Avail. Those contracts contain the logic for creating playlists and getting new songs. ZK rollups handle bulk song creation off chain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/i6xxx/screenshots/jyupj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/i6xxx/screenshots/24xk4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/i6xxx/screenshots/g16q8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Derricks-DApps/Omi-FM",
        "link": "https://ethglobal.com/showcase/omi-fm-i6xxx"
    },
    {
        "title": "Block-Jack 21",
        "brief_description": "I have build a multiplayer Blackjack game on the blockchain with one smart contract using Phoenix Solidity for data encryption and privacy. Web3.js and React with Tailwind CSS will handle the UI for smooth player interaction.",
        "long_description": "I have deployed a multiplayer Blackjack game on the blockchain using a single smart contract that integrates the Phoenix Solidity library for encrypting sensitive data. The smart contract handles the entire game logic, including dealing cards, tracking bets, and determining winners, while ensuring that private information like players\u2019 hands remains secure and hidden. This setup allows players to trust that the game operates fairly and securely on the blockchain. The front-end of the game connects to the blockchain using web3.js or ethers.js, while the interface itself is built using React and styled with Tailwind CSS for a user-friendly and visually appealing experience. Players can join games, place bets, and view results in real-time, with the blockchain managing all interactions in the background. The use of Phoenix encryption guarantees that private data is never exposed on the public ledger, adding an extra layer of security, which is crucial for a blockchain-based game. This project balances the transparency of blockchain with the privacy needed for multiplayer gaming, offering a secure and fair platform for players. I started with creating the smart contracts using solidity, Fhenix (FOH.sol) hardhat, and then deployed on sepolia for testing. Then, created the frontend with reactJS and Tailwind. At the end, used Helium PoW Faucet to get the tokens for Fhenix testnet and deploying the smart contract over there.",
        "how_its_made": "I started with creating the smart contracts using solidity, Fhenix (FOH.sol) hardhat, and then deployed on sepolia for testing. Then, created the frontend with reactJS and Tailwind. At the end, used Helium PoW Faucet to get the tokens for Fhenix testnet and deploying the smart contract over there.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t68nv/screenshots/37dcm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t68nv/screenshots/0ent9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t68nv/screenshots/too3b/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/saniddhyaDubey/BlockJack-21",
        "link": "https://ethglobal.com/showcase/block-jack-21-t68nv"
    },
    {
        "title": "Rhizome",
        "brief_description": "Rhizome Markets is a synthetics protocol built on the Rootstock EVM. Rhizome enhances capital efficiency and risk diversification with multicollateralization, allowing users to engage in hedging, yield farming, and collateralized debt positions directly on Rootstock.",
        "long_description": "A Bitcoin synthetics protocol allows users to create and trade synthetic assets\u2014tokens that represent and track the value of other assets like fiat currencies, commodities, or equities\u2014while using Bitcoin as collateral. With Rhizome, Bitcoin holders can participate on complex financial activities such as hedging, yield farming, and CDPs directly on the Rootstock EVM. Capital Efficiency Through Multicollateralization of rhUSD\nSynthetics, primarily the rhUSD dollar pegged instance deployed as an example of the Rootstock EVM mainnet, offers multicollateral support for collateralizing rhUSD, which offers significant advantages: Capital Efficiency: Utilizing multiple assets (rBTC, RIF, USDRIF, ETHs) as collateral allows for more efficient use of capital, enabling users to leverage a broader asset base.\nRehypothecation: Assets used as collateral can be rehypothecated, meaning they can be used simultaneously in multiple financial operations, enhancing liquidity.\nEcosystem: Promotes interoperability within the Rootstock DeFi ecosystem, increasing the utility of various tokens.\nMulticollateralization of assets with rBTC also allows a singular efficient pool of collateral to mint multiple synthetic assets on top of the pool. Additionally, relying solely on Bitcoin as collateral exposes the system to Bitcoin's price volatility. This can be mitigated with stablecoins or more stable assets in the multicollateral pool for all rh synthetics. Liquidation Risks: Sharp declines in Bitcoin's price can trigger collateral liquidations, destabilizing the system.\nOver-Collateralization: Users may need to provide excessive collateral to safeguard against volatility, reducing capital efficiency.\nRisk Diversification: The volatility of Bitcoin can be offset by the stablecoins, by default decreasing risk compared to a purely BTC collateralized CDP protocol.\nStability: A diversified collateral pool enhances the stability of the synthetic stablecoin and decreasing the risk of liquidation for debt positions, maintaining its peg more effectively.\nStabilizers\nStabilizers are multiple modules in the Rhizome protocol that strengthen the peg price for minted rh synthetic assets. For instance, each synthetic can have it's own Peg Stability Modules (PSM) based on the MakerDAO DAI-USDC PSM with various customizations to the swap fee. In the case of rhUSD, the alternative asset to rhUSD would be rUSDT, the fiat stablecoin with the largest dominance on Rootstock at 34.44%. Additionally, as utilized by MakerDAO and Inverse, the amount of synthetics can be controlled by governance or an administrator address through increasing and decreasing the liquidity of mintable synthetics. In these deployed contracts, only a US-dollar pegged synthetic, rhUSD, has been deployed, but any synthetic can be deployed as long as there is a secure oracle for the asset on Rootstock EVM. In the case for rhUSD, the price is hardcoded at 1. This project was based on the Compound v2 lending markets and heavily modified to support synthetic assets, but the synthetics protocol relies on stabilizers, which are optimized modules to keep the theoretical price of Rhizome synthetic assets. The entirety of the contracts were made used with Solidity, and integrated major Rootstock ecosystem tokens such as rBTC, rUSDT, RIF, and USDRIF in the code. The contract deployments were configured to use Umbrella Network oracles for rBTC/rUSDT prices, and were deployed on Rootstock mainnet as well to support all these assets.",
        "how_its_made": "This project was based on the Compound v2 lending markets and heavily modified to support synthetic assets, but the synthetics protocol relies on stabilizers, which are optimized modules to keep the theoretical price of Rhizome synthetic assets. The entirety of the contracts were made used with Solidity, and integrated major Rootstock ecosystem tokens such as rBTC, rUSDT, RIF, and USDRIF in the code. The contract deployments were configured to use Umbrella Network oracles for rBTC/rUSDT prices, and were deployed on Rootstock mainnet as well to support all these assets.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1a0t5/screenshots/8hk52/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1a0t5/screenshots/hzv84/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1a0t5/screenshots/sj3xr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/in70/rhizome-protocol/",
        "link": "https://ethglobal.com/showcase/rhizome-1a0t5"
    },
    {
        "title": "Kiss Or Slap 2.0",
        "brief_description": "A gamified mobile social app that people can earn under prisoner's dilemma",
        "long_description": "Kiss or Slap is a gamified dating app where users make strategic decisions in a fun social experience based on game theory's prisoner's dilemma. Players engage with each other by choosing either a \"Kiss\" or a \"Slap.\" The outcomes vary: The app has an onboarding process where users create profiles, upload live photos, and link their social media accounts to earn initial points. Users can browse a feed resembling Tinder, view profiles, and see if others have interacted with them. A hot score and karma system reflect user engagement and behavior, with scores visible on profiles. Tech Stack:\nnextjs + prisma Sponsor used:\n@walrus for all image upload and hosting in the app\n@coinbase-sdk for MPC wallet Payout, User Onramp\n@polygon gas-less rail for onramp with USDC Onramp, In app purchase\n@flow Onramp, In App purchase for user want extra rewards\n@privy for login & user identity management\n@circle USDC for in-app payment/payout",
        "how_its_made": "Tech Stack:\nnextjs + prisma Sponsor used:\n@walrus for all image upload and hosting in the app\n@coinbase-sdk for MPC wallet Payout, User Onramp\n@polygon gas-less rail for onramp with USDC Onramp, In app purchase\n@flow Onramp, In App purchase for user want extra rewards\n@privy for login & user identity management\n@circle USDC for in-app payment/payout",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/hyi4i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/5kqpn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/b4yxa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/o87d7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/h54i0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/2mvu2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/yayashuxue/kissorslap-ethsf2024",
        "link": "https://ethglobal.com/showcase/kiss-or-slap-2-0-5yxze"
    },
    {
        "title": "artist-popup",
        "brief_description": "Short Description: A decentralized platform for artist pop-up events, enabling artists to mint NFTs for their physical artwork and attendees to collect digital assets with exclusive content",
        "long_description": "The Artist Pop-Up NFT Platform is an innovative decentralized application that connects artists, attendees, and event organizers by combining physical pop-up art events with digital NFT technology. This platform allows artists to showcase their artwork and create NFTs that represent their pieces, giving collectors and attendees the opportunity to own unique digital collectibles linked to exclusive content. Using MetaMask, users can securely connect and interact with the platform, including minting new NFTs, transferring ownership, and accessing special content. Revised Replit Instructions for Artist Pop-Up Event with NFT Integration We\u2019re simplifying the process for developing your artist pop-up event application, focusing on security, user experience, and reducing complexity by leveraging MetaMask for all user interactions\u2014including admins, artists, and attendees. Here\u2019s a comprehensive guide to set up and deploy your app on Replit, incorporating what we\u2019ve learned so far. Step 1: Set Up the Replit Project Create a New Replit Project: Install Required Dependencies: Add Environment Variables: Step 2: Hardhat Local Deployment for Smart Contract Write the NFT Smart Contract: Deploy the Contract Using Hardhat: Step 3: Implement MetaMask Wallet Interactions Add MetaMask Login Functionality: Use MetaMask for Admin and User Actions: Step 4: Build a Unified Dashboard Create a Role-Based Dashboard (dashboard.html): Show/Hide Features Based on Role: Step 5: Exclusive Content Using Lit Protocol Set Up Exclusive Content Encryption: Front-End Interaction: Step 6: Testing and Deployment on Replit Test the Interaction Flow: Deploy on Replit: Step 7: No API Required for Sign Protocol Key Security Practices Summary\nThe entire app\u2014including Admin, Artist, and Attendee roles\u2014operates securely using MetaMask for authentication and blockchain transactions. Hosting on Replit is focused on the front-end, while smart contracts are managed securely using Hardhat and MetaMask to ensure a consistent, user-friendly experience without compromising security.",
        "how_its_made": "Revised Replit Instructions for Artist Pop-Up Event with NFT Integration We\u2019re simplifying the process for developing your artist pop-up event application, focusing on security, user experience, and reducing complexity by leveraging MetaMask for all user interactions\u2014including admins, artists, and attendees. Here\u2019s a comprehensive guide to set up and deploy your app on Replit, incorporating what we\u2019ve learned so far. Step 1: Set Up the Replit Project Create a New Replit Project: Install Required Dependencies: Add Environment Variables: Step 2: Hardhat Local Deployment for Smart Contract Write the NFT Smart Contract: Deploy the Contract Using Hardhat: Step 3: Implement MetaMask Wallet Interactions Add MetaMask Login Functionality: Use MetaMask for Admin and User Actions: Step 4: Build a Unified Dashboard Create a Role-Based Dashboard (dashboard.html): Show/Hide Features Based on Role: Step 5: Exclusive Content Using Lit Protocol Set Up Exclusive Content Encryption: Front-End Interaction: Step 6: Testing and Deployment on Replit Test the Interaction Flow: Deploy on Replit: Step 7: No API Required for Sign Protocol Key Security Practices Summary\nThe entire app\u2014including Admin, Artist, and Attendee roles\u2014operates securely using MetaMask for authentication and blockchain transactions. Hosting on Replit is focused on the front-end, while smart contracts are managed securely using Hardhat and MetaMask to ensure a consistent, user-friendly experience without compromising security.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8tqgc/screenshots/fxwf3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8tqgc/screenshots/ynvg0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8tqgc/screenshots/q5hui/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/devsodhirao/ArtConnectNFT",
        "link": "https://ethglobal.com/showcase/artist-popup-8tqgc"
    },
    {
        "title": "EZLaunch",
        "brief_description": "A platform for launching meme tokens with an innovative trading curve that optimizes liquidity and token price discovery. Users can easily mint and trade meme tokens, while the enhanced curve ensures better liquidity dynamics, fostering a smoother trading experience.",
        "long_description": "Our platform revolutionizes the meme token space by introducing an improved trading curve that outperforms traditional bonding curves. This curve ensures better liquidity management, providing users with an efficient and more balanced token trading experience. Meme token creators can easily launch their tokens, while traders benefit from improved price discovery mechanisms that stabilize market activity. The platform is designed to make token minting and trading accessible and intuitive, catering to the ever-growing meme economy and offering tools to ensure market sustainability. This project was built using Solidity for smart contract development, leveraging the Uniswap v4 framework to implement custom hooks and an enhanced custom trading curve.\nThis curve ensures better liquidity management, providing users with an efficient and more balanced token trading experience. Meme token creators can easily launch their tokens, while traders benefit from improved price discovery mechanisms that stabilize market activity. The platform is designed to make token minting and trading accessible and intuitive, catering to the ever-growing meme economy and offering tools to ensure market sustainability.",
        "how_its_made": "This project was built using Solidity for smart contract development, leveraging the Uniswap v4 framework to implement custom hooks and an enhanced custom trading curve.\nThis curve ensures better liquidity management, providing users with an efficient and more balanced token trading experience. Meme token creators can easily launch their tokens, while traders benefit from improved price discovery mechanisms that stabilize market activity. The platform is designed to make token minting and trading accessible and intuitive, catering to the ever-growing meme economy and offering tools to ensure market sustainability.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/p1gfa/screenshots/aj4rb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/p1gfa/screenshots/nxexn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/p1gfa/screenshots/aknx3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/DMomot/EZLaunch",
        "link": "https://ethglobal.com/showcase/ezlaunch-p1gfa"
    },
    {
        "title": "RPFT",
        "brief_description": "RPFT stands for Royalty Points Fungible Token is like transfer Royaltypoints of one brands to another one",
        "long_description": "the basic idea is to get Brand A and Brand B collab with each other and once they collab the user from Band A and Brand B should be able to transfer Points from one Brand to another one. and user/consumer should be able to use that points to redeem the things which he wants to buy. This Project mostly uses the LayerZero's standards contract since we assumed that different brand might have their own chain some day with RoyaltyPoint in the smartcontract. smartcontract are developed for EVM on solidity and Test on HardHat using LayerZero CLI.\nsince I have used LayerZero technology it gave me so easy and smooth transaction of messages from one Layer to another Layer. with their builtin CLI hardhat testing.",
        "how_its_made": "This Project mostly uses the LayerZero's standards contract since we assumed that different brand might have their own chain some day with RoyaltyPoint in the smartcontract. smartcontract are developed for EVM on solidity and Test on HardHat using LayerZero CLI.\nsince I have used LayerZero technology it gave me so easy and smooth transaction of messages from one Layer to another Layer. with their builtin CLI hardhat testing.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jygem/screenshots/5n7yy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jygem/screenshots/hux8s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jygem/screenshots/0vy6n/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Nishchit-Dev/EthGlobal-RPFT.git",
        "link": "https://ethglobal.com/showcase/rpft-jygem"
    },
    {
        "title": "Earnify",
        "brief_description": "An all-in-one platform that helps aspiring influencers earn instantly by completing brand tasks, while enabling companies to boost engagement and advertise effectively through real people.",
        "long_description": "A comprehensive platform that empowers aspiring influencers to earn instantly by completing tasks for brands, while helping companies boost engagement and promote their projects through real people.\nWe utilize dynamic wallet creation, account abstraction, task verification, and secure data handling to deliver a seamless experience. This project utilizes the dynamic wallet for account abstraction and onboarding new users to web3. We also leverage the LIT protocol for encrypting/decrypting and running verification tasks in LIT actions. The sign protocol is used to attest the verified task and store information. Finally, we utilize the Coinbase developer pack to create an instant payment system for quick payouts.",
        "how_its_made": "This project utilizes the dynamic wallet for account abstraction and onboarding new users to web3. We also leverage the LIT protocol for encrypting/decrypting and running verification tasks in LIT actions. The sign protocol is used to attest the verified task and store information. Finally, we utilize the Coinbase developer pack to create an instant payment system for quick payouts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/nbo5u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/57vuu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/t49qv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/mpwvm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/whj5t/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shubhank-saxena/eth-sf-submission",
        "link": "https://ethglobal.com/showcase/earnify-4hks7"
    },
    {
        "title": "Loop",
        "brief_description": "Loop is an onchain platform for reinforcement learning with human feedback (RLHF)",
        "long_description": "Loop is an onchain platform for reinforcement learning with human feedback (RLHF). Developers or corporate teams can upload models from HuggingFace (by submitting a link) and issue cryptocurrency bounties for crowdsourcing output validation. Users can sign in via web3 wallet (or web2 social platforms) and utilize the chat interface for regular functionality (i.e., writing essays), while being prompted to validate outputs. These prompts thereby disseminate the crypto rewards, effectively creating a Validate-to-Earn model. Subsequently, the prompts, outputs, and users' scores are stored off-chain in a dataset, accessible to the devs/teams behind the associated model. On the front-end, we built a responsive interface using React.js, implementing custom hooks for state management and modular components for content display and user interactions. Tailwind CSS provided a utility-first styling approach that dramatically accelerated our development cycle, while thirdweb's SDK facilitated seamless wallet connections and blockchain interactions across multiple networks. We deployed our front-end to Vercel. The back-end infrastructure centers around Foundry-developed smart contracts, meticulously unit tested and deployed for multi-chain usage. We've successfully deployed these contracts across nine different testnet environments: Polygon, Hedera, Neon EVM, Zircuit, Story, AirDAO, Rootstock, Morph, Unichain, and Story testnets. For AI processing, we leveraged HuggingFace's model hub to deploy both Llama 3.1 8B and Mixtral 8x-7B models, fine-tuned on our custom dataset. We leveraged Prime Intellect for decentralized GPU orchestration, allowing us to run LLM inference across distributed compute providers like Akash and RunPod during preliminary testing. Firebase serves as our human-verified dataset repository, chosen for its real-time database capabilities and seamless integration with our scoring system.",
        "how_its_made": "On the front-end, we built a responsive interface using React.js, implementing custom hooks for state management and modular components for content display and user interactions. Tailwind CSS provided a utility-first styling approach that dramatically accelerated our development cycle, while thirdweb's SDK facilitated seamless wallet connections and blockchain interactions across multiple networks. We deployed our front-end to Vercel. The back-end infrastructure centers around Foundry-developed smart contracts, meticulously unit tested and deployed for multi-chain usage. We've successfully deployed these contracts across nine different testnet environments: Polygon, Hedera, Neon EVM, Zircuit, Story, AirDAO, Rootstock, Morph, Unichain, and Story testnets. For AI processing, we leveraged HuggingFace's model hub to deploy both Llama 3.1 8B and Mixtral 8x-7B models, fine-tuned on our custom dataset. We leveraged Prime Intellect for decentralized GPU orchestration, allowing us to run LLM inference across distributed compute providers like Akash and RunPod during preliminary testing. Firebase serves as our human-verified dataset repository, chosen for its real-time database capabilities and seamless integration with our scoring system.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yjppn/screenshots/z946j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yjppn/screenshots/4yhr2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yjppn/screenshots/j67sm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shreybirmiwal/eth-sf",
        "link": "https://ethglobal.com/showcase/loop-yjppn"
    },
    {
        "title": "splitoon",
        "brief_description": "imagine giving ai access to your venmo account (real) (they could never)",
        "long_description": "imagine: you and your friends go out to eat and near the end, the bill comes. your friends all don't want to front the bill and neither do you. why? it's a hassle, you're out 30 bucks until they venmo you back. even worse, you have to keep reminding them to pay you or you might completely forget that you paid for this meal (unwillingly) and pretend they are on top of things and pay you your share right there and then. venmo will take 3-5 biz days to settle in your bank account as you definitely aren\u2019t paying them 3% to get your funds quicker. screw that. so let\u2019s leverage crypto and base to ensure you get your share of funds right as you spend it. ex: get paid by your friends before your uber gets here or split your dinner bill before the waiter takes your card. we want to empower ai with mpc wallets so that you can enable your favorite ai agent to manage your crypto wallet and send/transfer funds as you need.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/s5j5c/screenshots/vjkgk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s5j5c/screenshots/dmsha/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s5j5c/screenshots/ifg2k/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/mrbrianhobo/splitoon",
        "link": "https://ethglobal.com/showcase/splitoon-s5j5c"
    },
    {
        "title": "SuperTweets",
        "brief_description": "Do Crypto Transactions on your Twitter Feed - Now on any chain!",
        "long_description": "Project Description: This project is designed to tackle one of the most significant barriers to Web3 adoption\u2014its poor user experience. Most decentralized applications (DApps) have interfaces that are difficult and intimidating for everyday users, creating a significant gap between potential users and the opportunities that Web3 can offer. Both creators and consumers miss out on the potential of decentralized technologies because they are restricted to unfamiliar, isolated platforms. Our solution bridges this gap by allowing users to conduct crypto transactions, such as minting NFTs, making wagers, selling assets, and collecting tips, directly on the platforms where they already spend most of their time. This approach minimizes friction, creating a seamless experience by integrating crypto functionalities into familiar environments like their Twitter feed. Meeting Users Where They Are:\nOne of the keys to unlocking mainstream Web3 adoption is integrating it into the platforms where users already spend their time. Most users are not willing to switch between multiple apps or platforms, especially if they don\u2019t understand the complex blockchain processes behind the scenes. Social media, in particular, is a huge untapped frontier for crypto and blockchain adoption. By bringing crypto functionality to popular social platforms like Twitter, users can easily interact with blockchain features in a setting they are already comfortable with, removing the learning curve and making the process as intuitive as possible. This \u201cmeet-the-user-where-they-are\u201d approach will help drive both consumer and creator adoption, allowing them to seamlessly participate in Web3 without needing to leave their everyday platforms. As social media continues to evolve, it represents the next major frontier for Web3 growth, where digital ownership, peer-to-peer transactions, and decentralized assets can thrive naturally. Problem: Web3 has poor UX: Despite its potential, Web3 is hindered by complicated interfaces and systems that deter average users.\nMost DApps are intimidating to use: Decentralized apps often have steep learning curves, which limits their adoption by a broader audience.\nMissed opportunity for creators and consumers: Both groups miss out on the potential of Web3 technologies because the platforms they are familiar with do not support seamless integration of crypto functionalities.\nSolution: Meet the user where they are: Rather than forcing users to navigate entirely new platforms, we enable them to interact with blockchain functionalities on the platforms they already use every day\u2014whether that\u2019s social media, e-commerce, or content creation platforms.\nEnable Crypto transactions effortlessly: Users can easily mint NFTs, make wagers, sell digital assets, or even collect tips without leaving the environment they are comfortable with. This creates a smooth, user-friendly gateway to blockchain technology.\nOne more thing: Solana\u2019s Blinks integration was promising, but limited: Solana\u2019s Blinks allowed for some interaction within its ecosystem, but the limitation was that it only supported Solana, and the ecosystem was very closed. Therefore we built this as an add-on that leverages Blinks\u2019 infrastructure, but instead of being confined to one blockchain, it supports all major chains, creating a truly decentralized and interoperable solution. This enables a much wider range of users to participate, across multiple blockchains, without being restricted by ecosystem boundaries. The core of this project revolves around creating a seamless integration between social media content and blockchain transactions. We built a Chrome extension that interacts directly with the user's Twitter feed. The extension uses the Blinks SDK to dynamically replace standard links within tweets with interactive \"SuperTweets\" that allow users to engage in blockchain-based activities like minting NFTs, tipping creators, and more, all without leaving the platform. When a user wants to conduct a transaction, they can easily connect their wallet through the Wallet Context Providers injected by MetaMask. By leveraging MetaMask\u2019s environment, users gain access to all Ethereum Virtual Machine (EVM) compatible chains, meaning they can interact with a wide variety of blockchains, making it a truly decentralized experience. What\u2019s particularly innovative about this setup is the way we handle the interactions. The Blinks SDK gives us the infrastructure to support a high-speed experience, while the MetaMask integration ensures compatibility with every EVM chain. This combination provides a frictionless and familiar experience for users, allowing them to engage in Web3 activities directly on their Twitter page without needing to jump between different platforms or learn new interfaces. THE HARD PART: Was making MetaMask work with all the chains using the browser inject provider also building multiple actions for every chain!",
        "how_its_made": "The core of this project revolves around creating a seamless integration between social media content and blockchain transactions. We built a Chrome extension that interacts directly with the user's Twitter feed. The extension uses the Blinks SDK to dynamically replace standard links within tweets with interactive \"SuperTweets\" that allow users to engage in blockchain-based activities like minting NFTs, tipping creators, and more, all without leaving the platform. When a user wants to conduct a transaction, they can easily connect their wallet through the Wallet Context Providers injected by MetaMask. By leveraging MetaMask\u2019s environment, users gain access to all Ethereum Virtual Machine (EVM) compatible chains, meaning they can interact with a wide variety of blockchains, making it a truly decentralized experience. What\u2019s particularly innovative about this setup is the way we handle the interactions. The Blinks SDK gives us the infrastructure to support a high-speed experience, while the MetaMask integration ensures compatibility with every EVM chain. This combination provides a frictionless and familiar experience for users, allowing them to engage in Web3 activities directly on their Twitter page without needing to jump between different platforms or learn new interfaces. THE HARD PART: Was making MetaMask work with all the chains using the browser inject provider also building multiple actions for every chain!",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/urhdz/screenshots/5vteo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/urhdz/screenshots/vjcrs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/urhdz/screenshots/v7frg/default.jpg"
        ],
        "live_demo": "https://ethactions.vercel.app/",
        "source_code": "https://github.com/Rishabhjava/ethactions",
        "link": "https://ethglobal.com/showcase/supertweets-urhdz"
    },
    {
        "title": "ReadyVU",
        "brief_description": "SaaS platform for Teleradiology, remote reporting tools for medical Imaging for various stake holders",
        "long_description": "A few emerging tools are trying to offer useful and practical solutions for Radiology houses, Hospitals, etc., who are in real need of Solutions where they can outsource radiology writing expertise to remotely skilled doctors.\nCurrent situation have many urging needs from patients\u2019 point of view;\n1- specialized radiologists exist in specific cities, lowering the quality of healthcare given to people living outside capital cities\n2- cost and time involved by travelling doctors, travelling patients and thier famililes\n3- untimely report writing, you may have you exam performed and then wait a day or two, in many place it can easily get longer\nAlso apparently problem does affect hospital businesses, radiologist looking to work conveniently remotely, and more free market, etc. Challenges;\nPatient Privacy\nRegulations compliance, HIPAA, ONC,\nQA processes involved, insurance requirements\nNo \u201cone size fits all\u201d for workflow models in different business sizes, geographical areas, specialty level etc.\ncloud/on prem restrictions etc.\nIT experitise need to mainatin such systems are not generlly available\nIT expertise needed from health care providers themsleves, doctors, nurses etc.\nLegacy systems, sometimes from the 80s\u2019\nVarying requirements for compensating  and managing workforce , remote freelance payment models, etc.\nNeed to negotiate and setup long list of custom tools for various stakeholders involved\nMedical imaging has its own \u201cfile\u201d formats, for different kinds of modality and usages\nMedical imaging has a protocol not based http, cannot work with most of common software backend stacks directly, DICOM, HL7, IHE profiles etc. Solution\nReadyVU aim to be a decentralized, healthcare compliant platform for doctors to be able to view medical images and write radiology reports remotely,\nOnly Radiology center need to know about crypto or have a special setup - little as it is but still;\nOn Boarding new Doctors does not require them installing any special software, be that for crypto or medical imaging special software Hospital user story;\nHospital sets up it own infrastructure or have it through a certified partner\nHospital sponsors fees, sets up regulatory compliant workflows using standard business process modeling tools\nUpon receiving images for radiology modalities, its routed to preselected / newly certified doctors. Doctor user story;\nReceive shared document link\naccepts , goes to google doc\nSee info as per need basis\nopen medical images from within google doc, again no special software\nLogs in to the viewer using his google login, no browser extension wallets,etc.\nWrites findings, add images and annotations etc.\nSignal finishing the report when done Similar user stories for all other parties involved, no special tools, see info as per need basis.\nSystem is not hardcoded to public clouds, user can move to a fully decentralized self governed experience when he needs to Technology components in action; bmpn.io, Business process standard modeling tools to model and enforce business compliance\nConvert business process model and deploy as a Pint contract to essential network\nDICOM router to receive studies from radiology machines, CTs, PET, MRIs etc.\nHigh scalable PACS system to store images, for short periods, or commonly 5 to  7 years\nSecure function to dispatch workflow upon recieving a patient study, run as a LIT protocol action\nDiffernet google documents are shared from same template, set by various requirements, like dr pref, business, exam type etc.\nUser logs in to Flow network, using his google login, through Dynamic wallet social login\nGoogle docs have embedded scripts to talk to TEE LIT Action, to get information assinged to each individual user\nRadiologist opens CornerStone DICOM viewer, from inside google docs, adds annotations, take images, write findings etc.\nRadiologist finishes\nQA approves doc\nReport is sent to patient and referring doctor\nThe above workflow is enforced from Essential network using Pint contract generated from workflow",
        "how_its_made": "Technology components in action; bmpn.io, Business process standard modeling tools to model and enforce business compliance\nConvert business process model and deploy as a Pint contract to essential network\nDICOM router to receive studies from radiology machines, CTs, PET, MRIs etc.\nHigh scalable PACS system to store images, for short periods, or commonly 5 to  7 years\nSecure function to dispatch workflow upon recieving a patient study, run as a LIT protocol action\nDiffernet google documents are shared from same template, set by various requirements, like dr pref, business, exam type etc.\nUser logs in to Flow network, using his google login, through Dynamic wallet social login\nGoogle docs have embedded scripts to talk to TEE LIT Action, to get information assinged to each individual user\nRadiologist opens CornerStone DICOM viewer, from inside google docs, adds annotations, take images, write findings etc.\nRadiologist finishes\nQA approves doc\nReport is sent to patient and referring doctor\nThe above workflow is enforced from Essential network using Pint contract generated from workflow",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/q3p2s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/vx6x5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/957d6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/tdgnf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/djw30/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/melnaquib/ReadyVU",
        "link": "https://ethglobal.com/showcase/readyvu-yc4hu"
    },
    {
        "title": "GovernEase",
        "brief_description": "GovernEase is a cross-chain DAO tooling platform that simplifies DAO creation. It enables users to configure governance, manage tokens, and select voting methods through a seamless interface, allowing quick and efficient setup across multiple blockchains.",
        "long_description": "GovernEase is an innovative cross-chain DAO tooling platform that simplifies the creation and management of decentralized autonomous organizations (DAOs). Traditionally, setting up a DAO involves a complex process of coding, testing, and deployment. GovernEase streamlines this workflow, allowing users to create a DAO quickly and effortlessly by filling out a user-friendly form. One of the standout features of GovernEase is its support for quadratic voting, a unique governance mechanism that enhances fairness in decision-making by giving members more voting power on issues that matter most to them. This innovative approach fosters more democratic and nuanced governance within the DAO. GovernEase also excels in its cross-chain capabilities, enabling the seamless transfer of DAO data between different blockchains. For example, I successfully managed to send DAO data from the Sepolia testnet to the Polygon Cardano testnet, demonstrating the platform's versatility and interoperability across blockchain ecosystems. In addition to these core features, GovernEase offers various functionalities that enhance user experience and collaboration. DAO members can upload and store files directly within the DAO\u2019s storage, facilitating easy access to important documents and resources. Communication among members is also made simple through an integrated chat feature, promoting engagement and collaboration within the community. Furthermore, GovernEase leverages SKALE's sFuel distribution, allowing for zero gas fee transactions. This ensures that users can interact with the DAO without worrying about transaction costs, making the platform more accessible and user-friendly. Overall, GovernEase stands out not only for its cross-chain capabilities but also for its unique voting mechanism and a comprehensive set of features designed to empower users in managing their DAOs efficiently and effectively. At the heart of GovernEase are two key features: zero gas fee transactions and cross-chain capabilities. By utilizing SKALE, users can engage with the DAO without incurring any gas fees, greatly enhancing both accessibility and user satisfaction. Additionally, I successfully bridged DAO data from the Sepolia testnet to the Polygon Cardano testnet using the Unified Bridge (Agglayer), highlighting the platform\u2019s ability to operate seamlessly across multiple blockchain networks. The project leverages a comprehensive tech stack that ensures smooth functionality and an intuitive user interface: Frontend Development: The user interface for GovernEase is built with Next.js, a powerful React framework that supports server-side rendering and static site generation for optimal performance. To create a sleek and responsive design, I incorporated Chakra UI, a versatile and accessible component library that facilitates rapid UI development. Smart Contract Development: The backbone of GovernEase consists of smart contracts written in Solidity. These contracts are deployed and verified across various testnets, including Sepolia, Polygon Cardano, the EVM Flow testnet, and the SKALE Calypso hub. This multi-network deployment empowers users to interact with the DAO on any of these networks, ensuring flexibility and accessibility. Storage Solutions: For handling images and files uploaded by DAO members, I utilized Lighthouse. This decentralized storage service guarantees that files are stored securely and can be easily accessed by users within the DAO. Blockchain Integration: To seamlessly connect the frontend with the deployed smart contracts, I employed Ether.js and Wagmi. Ether.js offers a robust library for Ethereum blockchain interactions, while Wagmi streamlines the integration of React applications with Ethereum-based smart contracts, simplifying the development process. User Onboarding: To provide a smooth wallet connection experience, I implemented Rainbow Kit. This library makes it easy for users to connect their wallets to the application, which is essential for interacting with the DAO. Enhanced User Features: GovernEase also includes additional functionalities that foster collaboration among DAO members, such as integrated file storage and a chat feature for real-time communication. By combining these technologies and tools, GovernEase presents a powerful, user-friendly platform for creating and managing DAOs. The integration of zero gas fees, cross-chain capabilities, innovative voting mechanisms, and efficient user onboarding solidifies GovernEase as a pioneering solution in the blockchain landscape.",
        "how_its_made": "At the heart of GovernEase are two key features: zero gas fee transactions and cross-chain capabilities. By utilizing SKALE, users can engage with the DAO without incurring any gas fees, greatly enhancing both accessibility and user satisfaction. Additionally, I successfully bridged DAO data from the Sepolia testnet to the Polygon Cardano testnet using the Unified Bridge (Agglayer), highlighting the platform\u2019s ability to operate seamlessly across multiple blockchain networks. The project leverages a comprehensive tech stack that ensures smooth functionality and an intuitive user interface: Frontend Development: The user interface for GovernEase is built with Next.js, a powerful React framework that supports server-side rendering and static site generation for optimal performance. To create a sleek and responsive design, I incorporated Chakra UI, a versatile and accessible component library that facilitates rapid UI development. Smart Contract Development: The backbone of GovernEase consists of smart contracts written in Solidity. These contracts are deployed and verified across various testnets, including Sepolia, Polygon Cardano, the EVM Flow testnet, and the SKALE Calypso hub. This multi-network deployment empowers users to interact with the DAO on any of these networks, ensuring flexibility and accessibility. Storage Solutions: For handling images and files uploaded by DAO members, I utilized Lighthouse. This decentralized storage service guarantees that files are stored securely and can be easily accessed by users within the DAO. Blockchain Integration: To seamlessly connect the frontend with the deployed smart contracts, I employed Ether.js and Wagmi. Ether.js offers a robust library for Ethereum blockchain interactions, while Wagmi streamlines the integration of React applications with Ethereum-based smart contracts, simplifying the development process. User Onboarding: To provide a smooth wallet connection experience, I implemented Rainbow Kit. This library makes it easy for users to connect their wallets to the application, which is essential for interacting with the DAO. Enhanced User Features: GovernEase also includes additional functionalities that foster collaboration among DAO members, such as integrated file storage and a chat feature for real-time communication. By combining these technologies and tools, GovernEase presents a powerful, user-friendly platform for creating and managing DAOs. The integration of zero gas fees, cross-chain capabilities, innovative voting mechanisms, and efficient user onboarding solidifies GovernEase as a pioneering solution in the blockchain landscape.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/k2cc0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/7ofon/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/9cqv0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/zg6td/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/ymyby/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/7zxad/default.jpg"
        ],
        "live_demo": "https://ethsf-seven.vercel.app/",
        "source_code": "https://github.com/Sohamkayal4103/ETHSF",
        "link": "https://ethglobal.com/showcase/governease-17pde"
    },
    {
        "title": "FlowBets",
        "brief_description": "A transparent, crowdsourced sports betting platform on Flow's network utilizing smart contracts",
        "long_description": "This project uses a combination of smart contracts and web2 frontend frameworks to design a onchain betting application that allows users to wage predictions on sports games, specifically football (NFL). We deployed smart contracts on Flow's testnet and enabled wallet integration. Users can also see the average price, their shares, and potential returns per bet. Additionally, we integrated a chatting feature where users on the platform can communicate regarding bets. For this project, we used Solidity smart contracts deployed on Flow's testnet through hardhat. For the frontend, we utilized Next.js with shadcn components and rainbowkit for wallet integration. We used wagmi to connect the backend with the frontend. We implemented the odds by using a crowdsourcing model where the probability of an event happening was equivalent to the amount of money bet for this event. People's willingness to bet on an outcome directly correlates to the odds for that event.",
        "how_its_made": "For this project, we used Solidity smart contracts deployed on Flow's testnet through hardhat. For the frontend, we utilized Next.js with shadcn components and rainbowkit for wallet integration. We used wagmi to connect the backend with the frontend. We implemented the odds by using a crowdsourcing model where the probability of an event happening was equivalent to the amount of money bet for this event. People's willingness to bet on an outcome directly correlates to the odds for that event.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/9gfsz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/uft1h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/bqeag/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shrithan1/betflow",
        "link": "https://ethglobal.com/showcase/flowbets-u48sh"
    },
    {
        "title": "FlowBets",
        "brief_description": "A transparent, crowdsourced sports betting platform on Flow's network utilizing smart contracts",
        "long_description": "This project uses a combination of smart contracts and web2 frontend frameworks to design a onchain betting application that allows users to wage predictions on sports games, specifically football (NFL). We deployed smart contracts on Flow's testnet and enabled wallet integration. Users can also see the average price, their shares, and potential returns per bet. Additionally, we integrated a chatting feature where users on the platform can communicate regarding bets. For this project, we used Solidity smart contracts deployed on Flow's testnet through hardhat. For the frontend, we utilized Next.js with shadcn components and rainbowkit for wallet integration. We used wagmi to connect the backend with the frontend. We implemented the odds by using a crowdsourcing model where the probability of an event happening was equivalent to the amount of money bet for this event. People's willingness to bet on an outcome directly correlates to the odds for that event.",
        "how_its_made": "For this project, we used Solidity smart contracts deployed on Flow's testnet through hardhat. For the frontend, we utilized Next.js with shadcn components and rainbowkit for wallet integration. We used wagmi to connect the backend with the frontend. We implemented the odds by using a crowdsourcing model where the probability of an event happening was equivalent to the amount of money bet for this event. People's willingness to bet on an outcome directly correlates to the odds for that event.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/9gfsz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/uft1h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/bqeag/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shrithan1/betflow",
        "link": "https://ethglobal.com/showcase/flowbets-u48sh"
    },
    {
        "title": "PixelProof",
        "brief_description": "A Web Platform for Image Authenticity Verification Using Zero-Knowledge Proofs",
        "long_description": "In today\u2019s digital world, the ability to create, modify, and distribute visual content has become more accessible than ever. With advancements in artificial intelligence (AI), it\u2019s now possible to manipulate images in ways that are nearly undetectable to the human eye. AI-driven tools like deepfakes, image generators, and sophisticated photo-editing software have made it easy to alter or fabricate images that appear authentic. While these technologies offer creative and practical benefits, they also present serious challenges\u2014especially in terms of trust, authenticity, and misinformation. Also in today\u2019s social media-driven world, digital content spreads faster than ever. Unfortunately, false information and tampered images can go viral just as quickly as the truth. Whether it\u2019s fake news, altered photos of public figures, or images designed to mislead audiences, the potential for misinformation to have real-world consequences is significant. Pixel-Proof is a cutting-edge web platform that leverages zero-knowledge proofs (ZKPs) to allow users to verify the authenticity and integrity of digital images without exposing the actual content of the image. The platform provides a privacy-preserving method for determining whether an image has been modified or tampered with, ensuring users can verify the origin and authenticity of their images securely and efficiently. Using advanced cryptographic techniques, particularly ZKPs, the platform allows users to generate proofs of image integrity, proving whether an image is identical to the original version or has undergone changes\u2014without revealing the image itself. This is particularly useful for industries such as media, law enforcement, content verification, and intellectual property management, where proving image authenticity is crucial. Image Authentication verification\nThe platform allows users to capture the photo, edit the photo at which zkProof will be created which basically attests the photo whether the image was edited or not.\nThe interface has an option to upload the image where users can upload the edited image and verify whether the image was altered or not along with it\u2019s history. Zero-Knowledge Proofs (ZKPs) for Privacy\nBy utilizing ZKPs, the platform proves the integrity of the image without revealing its content to the verifier. This preserves the privacy of sensitive images while enabling secure verification.\nVerifiers can check the proof to validate the authenticity of the image without ever seeing the original image. Seamless Web-Based Interface\nPixelProof offers an intuitive and user-friendly web interface where users can easily upload images, generate proofs, and share the proof for verification. Secure Proof Sharing\nAs proof will be stored on-chain, any user from other chain can do the verification Image Capture\nUsers can capture an image on our platform. This will capture the metadata and allow the user to download that image.\nImage Edit\nUsers can select their captured photo and edit the image accordingly. Currently we have only supported grayscale operation because of the time constraints.\nUsing zero-knowledge proof techniques, proof for that edited image will be generated at the end of edit operation and the cryptographic proof is stored on-chain so anyone can use that proof and verify that image.\nEdited Image Upload\nUsers can upload the edited image to verify whether the image was modified or not. At this moment, proof will be verified against the original image and results will be given to the user. The history for that edited image will also be given to the user.\nAs soon as the proof is validated, the user will be shown the results of the verification and the user can see the series of edits on that original image if it was done on the Pixel-Proof platform. Our project, PixelProof, is a novel application of zero-knowledge proofs to verify various image conversions without revealing the original images. Here's a breakdown of how we built it: Circom: We used Circom, a domain-specific language for building zero-knowledge circuits. Circom allowed us to define the constraints for our grayscale verification process in a clear, declarative manner. snarkjs: This JavaScript library was crucial for generating and verifying zero-knowledge proofs based on our Circom circuits. Node.js: We leveraged Node.js for our backend processing, particularly for generating input data from images. canvas: This Node.js library was essential for image processing, allowing us to extract pixel data from both color and grayscale images. Circom Circuit (no_round.circom`): Input Generator (generate_grayscale_inputs.js): Proof Generation and Verification: Precision Handling: One of the trickiest parts was dealing with floating-point precision in grayscale calculations. We implemented a remainder system in our circuit to account for small discrepancies between calculated and given grayscale values. Scale Matching: We had to carefully manage the scale of our calculations. In the Circom circuit, we work with values scaled up by 100 to avoid floating-point operations, which aren't supported in Circom. Efficient Constraint Writing: Writing efficient constraints in Circom was crucial for keeping the proving time reasonable. We optimized our circuit to minimize the number of constraints while maintaining accuracy. This project demonstrates the powerful combination of zero-knowledge proofs and image processing, opening up new possibilities for privacy-preserving image verification systems.",
        "how_its_made": "Our project, PixelProof, is a novel application of zero-knowledge proofs to verify various image conversions without revealing the original images. Here's a breakdown of how we built it: Circom: We used Circom, a domain-specific language for building zero-knowledge circuits. Circom allowed us to define the constraints for our grayscale verification process in a clear, declarative manner. snarkjs: This JavaScript library was crucial for generating and verifying zero-knowledge proofs based on our Circom circuits. Node.js: We leveraged Node.js for our backend processing, particularly for generating input data from images. canvas: This Node.js library was essential for image processing, allowing us to extract pixel data from both color and grayscale images. Circom Circuit (no_round.circom`): Input Generator (generate_grayscale_inputs.js): Proof Generation and Verification: Precision Handling: One of the trickiest parts was dealing with floating-point precision in grayscale calculations. We implemented a remainder system in our circuit to account for small discrepancies between calculated and given grayscale values. Scale Matching: We had to carefully manage the scale of our calculations. In the Circom circuit, we work with values scaled up by 100 to avoid floating-point operations, which aren't supported in Circom. Efficient Constraint Writing: Writing efficient constraints in Circom was crucial for keeping the proving time reasonable. We optimized our circuit to minimize the number of constraints while maintaining accuracy. This project demonstrates the powerful combination of zero-knowledge proofs and image processing, opening up new possibilities for privacy-preserving image verification systems.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/exdzo/screenshots/vrovk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/exdzo/screenshots/b47u2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/exdzo/screenshots/99sex/default.jpg",
            "https://ethglobal.b-cdn.net/projects/exdzo/screenshots/bnyrs/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shyam-patel-kira/pixelProof",
        "link": "https://ethglobal.com/showcase/pixelproof-exdzo"
    },
    {
        "title": "PintAuction",
        "brief_description": "A Dutch auction platform written in Pint, Essential's DSL for declarative smart contracts, focused on logic rather than execution.",
        "long_description": "A Dutch auction platform written in Pint, Essential's DSL for declarative smart contracts, focused on logic rather than execution. The users can mint new currency, transfer currency via the essential-wallet. The users can create auctions from item_id, owner and initial_cost, since it is a Dutch based auction platform, the right to lower the cost of the auction item depends solely on the owner and owner can use the step-auction using item_id, decrease_amount. Once a bidder places bid higher than the cost of the item, and respective validity constraints meet, the amount is deducted from the bidder, and awarded to the owner and the state changes and new owner of the item becomes the bidder. The auction is also marked as closed and the earliest bidder gets the ownership. The smart contracts are written in Pint, and the CLI is written in rust(taking essential-contributions/token example) as a base. The frontend is written in next.js and there is also a small python server that eases the interaction between the frontend and provides the details of all the items i.e item_id, owner, auction_active status, cost. It is deployed on the test-net \"https://bigbangblock.builders\".",
        "how_its_made": "The smart contracts are written in Pint, and the CLI is written in rust(taking essential-contributions/token example) as a base. The frontend is written in next.js and there is also a small python server that eases the interaction between the frontend and provides the details of all the items i.e item_id, owner, auction_active status, cost. It is deployed on the test-net \"https://bigbangblock.builders\".",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jpwjo/screenshots/acrsa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jpwjo/screenshots/dfujy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jpwjo/screenshots/p9vjy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jpwjo/screenshots/6m4ur/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xn4utilus/PintAuction",
        "link": "https://ethglobal.com/showcase/pintauction-jpwjo"
    },
    {
        "title": "Bet",
        "brief_description": "An accountability app to share goals with your friends. put your money where your mouth is",
        "long_description": "Share your goals with friends and set up a system of accountability. You create a goal and place a financial stake as motivation. If you complete the goal, your friends must attest to your success. If they don\u2019t verify the accomplishment within the set time, you forfeit the stake. This encourages commitment by putting real value on your progress. Whether it's personal or professional, the system ensures you stay motivated, with rewards for follow-through or a financial loss if you don't succeed. This app is developed using Solidity as the primary smart contract language. I had initially planned to integrate Sign Protocol for handling the peer attestations, which would have allowed for decentralized verification of goals and claims. Unfortunately, due to time constraints and the complexity of the integration process, I wasn't able to incorporate it before the deadline. However, adding this feature in the future would greatly enhance the functionality and ensure a more robust and decentralized attestation process.",
        "how_its_made": "This app is developed using Solidity as the primary smart contract language. I had initially planned to integrate Sign Protocol for handling the peer attestations, which would have allowed for decentralized verification of goals and claims. Unfortunately, due to time constraints and the complexity of the integration process, I wasn't able to incorporate it before the deadline. However, adding this feature in the future would greatly enhance the functionality and ensure a more robust and decentralized attestation process.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/nqbcs/screenshots/9wrv2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nqbcs/screenshots/hiu28/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nqbcs/screenshots/zb2gn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/finessevanes/bet",
        "link": "https://ethglobal.com/showcase/bet-nqbcs"
    },
    {
        "title": "Socialfly",
        "brief_description": "A decentralized social app where you store your encrypted data once and then use it across multiple apps",
        "long_description": "This project combines Sign protocol with Lit protocol to create the foundation of a social networking app. Data is encrypted using Lit, and then stored using Sign.  Sign's attestations ensure that a user's data is associated with their account. Sign's schemas and indexing are combined to let us define data in a way that lets us efficiently query for it. The schema is used as the identifier for a certain piece of data that could be used for a social app (example: profile_photo_001, bio_short, location, etc.), and the data can be arbitrary - it can be a photo, some text about a user, or structured data such as a location. Using Lit's access controls, we're able to give specific apps (which are ultimately Lit actions) permission to decrypt our data.  From here the data can be used in creative ways, to demonstrate this I created two basic apps: The first is a centralized messageboard where user's data is just used to gain access to the ability to post on the messageboard, it's fundamentally a centralized service but via reusing a user's profile data it lowers the friction of starting to use the app. The second is a matching app where users can swipe through profiles, and connect with people nearby.  User's encrypted location data is decrypted inside a lit action, and the rest of their profile is only decrypted if they're close enough to the user's location.  The app never has access to user data, it only facilitates making the connections. Lit and Sign are used.  Lit is used for encrypting data, Lit actions are used for decrypting the data, and Sign is used for storing the data.  Sign's schemas are used to represent particular types of data, while Sign's query functionality is used to efficiently access the data that's relevant for a given app. Note that there are actually four repos associated with this project: Repo for creating/managing user account\nhttps://github.com/tms7331/socialfly-account Repo for gating access control based on an IPFS hash\nhttps://github.com/tms7331/socialfly-contracts Repo for example app 1  - public messageboard\nhttps://github.com/tms7331/socialfly-messageboard Repo for example app 2 - privacy preserving networking app\nhttps://github.com/tms7331/socialfly-matching",
        "how_its_made": "Lit and Sign are used.  Lit is used for encrypting data, Lit actions are used for decrypting the data, and Sign is used for storing the data.  Sign's schemas are used to represent particular types of data, while Sign's query functionality is used to efficiently access the data that's relevant for a given app. Note that there are actually four repos associated with this project: Repo for creating/managing user account\nhttps://github.com/tms7331/socialfly-account Repo for gating access control based on an IPFS hash\nhttps://github.com/tms7331/socialfly-contracts Repo for example app 1  - public messageboard\nhttps://github.com/tms7331/socialfly-messageboard Repo for example app 2 - privacy preserving networking app\nhttps://github.com/tms7331/socialfly-matching",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qa3o7/screenshots/a2e8d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qa3o7/screenshots/odyh6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qa3o7/screenshots/cabiq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/tms7331/socialfly-account",
        "link": "https://ethglobal.com/showcase/socialfly-qa3o7"
    },
    {
        "title": "Web3Warfare",
        "brief_description": "An IRL laser tag game with onchain components and fun. Place bounties on adverseries, mint powerup NFTs, and win the space race!",
        "long_description": "Web3Warfare is an immersive, real-life laser tag game that merges physical action with the innovative possibilities of blockchain technology. Players engage in thrilling laser tag battles, equipped with real-world hardware components like laser guns, sensors, and 3D-printed gear. These hardware elements track player performance, hits, and gameplay metrics in real time. What sets Web3Warfare apart is its integration of on-chain components. The game leverages blockchain for player stats, rewards, and progression tracking. Each player's achievements, game results, and in-game assets are stored on-chain, creating a permanent and tamper-proof record of their performance. This also enables players to own unique in-game assets, such as special abilities or gear, represented as NFTs, which can be earned, traded, or sold. The hardware ensures that every shot, hit, and movement in the physical world is accurately reflected in the game's digital ecosystem, combining the excitement of laser tag with the innovation of Web3 technology. How It's Made: Web3Warfare Web3Warfare is built with a blend of blockchain technologies, hardware, and software integration. Here's how it all comes together: Smart Contract Architecture: The game uses a custom-built factory design pattern smart contract, managing duels and payout logic. This contract is deployed across multiple blockchain networks including SKALE, Flow, Zircuit, and Ethereum mainnet. The factory design pattern allows for scalable and efficient deployment of new duels, with automated logic governing payouts and challenge results. Each duel is governed by blockchain rules, ensuring transparency and immutability. Frontend Development: The game's frontend is developed using React, hosted on Vercel for fast deployment and scalability. For user wallet onboarding, Dynamic is used, allowing seamless integration of blockchain wallets directly into the frontend experience. This ensures players can easily manage their on-chain interactions like asset ownership and game data. Hardware Integration: The physical components of Web3Warfare are built around an ESP32 module acting as the brain of each laser blaster. The hardware setup includes a breadboard, infrared LED, and code developed in Arduino IDE to manage the interactions between the laser blasters and the game. Each ESP32 module contains an embedded wallet with the firmware, thanks to Dynamic, which enables direct blockchain interaction from the physical devices. On-Chain Authentication: To guarantee the authenticity of in-game data being written to the blockchain, Web3Warfare uses Sign Protocol's schema hooks. A custom whitelist address contract is implemented, allowing only approved laser blasters to write data. Each laser blaster is whitelisted to ensure only genuine hardware can sign and submit events to the blockchain. Since the ESP32 module serves as a smart wallet, each device is the sole owner of its private key, preventing unauthorized devices from participating. Embedded Wallets & Signing: The ESP32 modules act as both the game\u2019s sensor and its on-chain identity, with embedded wallets stored within the firmware. This design allows each laser blaster to sign blockchain transactions directly, securing game events and ensuring the only valid signing devices are the blasters themselves. By flashing the wallets and private keys onto the hardware, the game eliminates the need for external signing mechanisms. Notable Hacks: One particularly hacky aspect of this project is embedding private key functionality directly into the ESP32 modules, allowing each blaster to function as a fully operational smart wallet. This allows for direct interaction with the blockchain from the physical game world, creating a seamless bridge between the real-world gameplay and on-chain logic.",
        "how_its_made": "How It's Made: Web3Warfare Web3Warfare is built with a blend of blockchain technologies, hardware, and software integration. Here's how it all comes together: Smart Contract Architecture: The game uses a custom-built factory design pattern smart contract, managing duels and payout logic. This contract is deployed across multiple blockchain networks including SKALE, Flow, Zircuit, and Ethereum mainnet. The factory design pattern allows for scalable and efficient deployment of new duels, with automated logic governing payouts and challenge results. Each duel is governed by blockchain rules, ensuring transparency and immutability. Frontend Development: The game's frontend is developed using React, hosted on Vercel for fast deployment and scalability. For user wallet onboarding, Dynamic is used, allowing seamless integration of blockchain wallets directly into the frontend experience. This ensures players can easily manage their on-chain interactions like asset ownership and game data. Hardware Integration: The physical components of Web3Warfare are built around an ESP32 module acting as the brain of each laser blaster. The hardware setup includes a breadboard, infrared LED, and code developed in Arduino IDE to manage the interactions between the laser blasters and the game. Each ESP32 module contains an embedded wallet with the firmware, thanks to Dynamic, which enables direct blockchain interaction from the physical devices. On-Chain Authentication: To guarantee the authenticity of in-game data being written to the blockchain, Web3Warfare uses Sign Protocol's schema hooks. A custom whitelist address contract is implemented, allowing only approved laser blasters to write data. Each laser blaster is whitelisted to ensure only genuine hardware can sign and submit events to the blockchain. Since the ESP32 module serves as a smart wallet, each device is the sole owner of its private key, preventing unauthorized devices from participating. Embedded Wallets & Signing: The ESP32 modules act as both the game\u2019s sensor and its on-chain identity, with embedded wallets stored within the firmware. This design allows each laser blaster to sign blockchain transactions directly, securing game events and ensuring the only valid signing devices are the blasters themselves. By flashing the wallets and private keys onto the hardware, the game eliminates the need for external signing mechanisms. Notable Hacks: One particularly hacky aspect of this project is embedding private key functionality directly into the ESP32 modules, allowing each blaster to function as a fully operational smart wallet. This allows for direct interaction with the blockchain from the physical game world, creating a seamless bridge between the real-world gameplay and on-chain logic.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qq1r9/screenshots/vuzag/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qq1r9/screenshots/5bt1o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qq1r9/screenshots/usg8o/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/pane2004/web3warfare",
        "link": "https://ethglobal.com/showcase/web3warfare-qq1r9"
    },
    {
        "title": "Liquid",
        "brief_description": "A crowd-sourced and incentivised bridging protocol using Layer Zero's OApp interface.",
        "long_description": "Liquid is a crowd-sourced and incentivized bridging protocol using Layer Zero's OApp interface. Users can provide liquidity to the bridge on either side and when their liquidity is used by somebody trying to bridge, they are incentivised for providing liquidity to the protocol. Liquid provides an alternate source of income for yield farming and helps users to de-fragment themselves across chains and get rewarded for the same. It also reduces reliance on institutional run bridges. We made use of Layer Zero's cross-chain messaging protocol (OApp), to send messages across chains. For the MVP we used Morph and Arbitrum Sepolia testnet to deploy our contracts, and one can provide liquidity of USDT on either side and others can use that liquidity to bridge their USDT tokens.",
        "how_its_made": "We made use of Layer Zero's cross-chain messaging protocol (OApp), to send messages across chains. For the MVP we used Morph and Arbitrum Sepolia testnet to deploy our contracts, and one can provide liquidity of USDT on either side and others can use that liquidity to bridge their USDT tokens.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yo7bg/screenshots/7d6n6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yo7bg/screenshots/exy4h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yo7bg/screenshots/c6t27/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/arvindkalra/SmartBridge",
        "link": "https://ethglobal.com/showcase/liquid-yo7bg"
    },
    {
        "title": "AI Fans",
        "brief_description": "An AI x Crypto OnlyFans. Uses Generative AI to create text responses and Images for the AI avatars, and faciiltates onchain transactions done by users and agents.",
        "long_description": "This projects combines the technologies of AI and crypto to create a user experience similar to OnlyFans. The idea of the project is to enable users to create their own AI partners, with each partner having control of their own wallet. This means that users can create their partners, but anyone can chat with them, and they are able to make their own decisions and transact onchain. The project uses XMTP, Walrus, and Phala at its core to power the user interface, storage, and security respectively. XMTP allows users to easily chat with their AI partners, tip them, perform onchain transactions all within one interface. Walrus is used directly in the solidity code, as each AI avatar is given a Soulbound NFT, in which the imageUri is actually a blob on walrus. In addition, the actual walrus site is stored onchain, linking the agent to their respective walrus site. Phala is used on the backend with docker to enable a trustless system where AI agents can be created at runtime. Each agent has their own wallet that is deterministic, enabling these agents to transact onchain. This is also done through a trustless manner, as all backend code is secured by TRS and execution is done within TEEs.",
        "how_its_made": "The project uses XMTP, Walrus, and Phala at its core to power the user interface, storage, and security respectively. XMTP allows users to easily chat with their AI partners, tip them, perform onchain transactions all within one interface. Walrus is used directly in the solidity code, as each AI avatar is given a Soulbound NFT, in which the imageUri is actually a blob on walrus. In addition, the actual walrus site is stored onchain, linking the agent to their respective walrus site. Phala is used on the backend with docker to enable a trustless system where AI agents can be created at runtime. Each agent has their own wallet that is deterministic, enabling these agents to transact onchain. This is also done through a trustless manner, as all backend code is secured by TRS and execution is done within TEEs.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/k8x9r/screenshots/aoezm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k8x9r/screenshots/47dk8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k8x9r/screenshots/d36qb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k8x9r/screenshots/08g90/default.jpg"
        ],
        "live_demo": "https://ai-fans.vercel.app",
        "source_code": "https://github.com/RevanthGundala/AIFans",
        "link": "https://ethglobal.com/showcase/ai-fans-k8x9r"
    },
    {
        "title": "AutoWebChain",
        "brief_description": "decentralised fine tuning of web agents and rag on chain, using lit and walrus",
        "long_description": "Websites are considered out-of-distribution data for LLMs, meaning they aren't naturally optimized to handle such content efficiently. While LLMs can navigate websites, their performance could greatly improve with specialized fine-tuning. During our work, we managed to integrate support for models like 4o-mini, SLMs (which we later removed for performance reasons), and LLama 3.2 B. Additionally, we explored optimizations for better handling of web data and improving interaction across various web environments. We utilized Walrus to simulate the addition of model weights into a network for efficient storage and retrieval as blobs. This allowed users to download these blobs and run the models directly, enabling them to automate tasks in their browsers. The automation was based on a simplified DOM model inspired by Taxy AI's implementation, making it more user-friendly and streamlined for common web interactions. Throughout this process, we added support for models like 4o-mini, SLMs (which we later phased out for performance reasons), and LLama 3.2 B. Though the latter models were eventually removed, their integration provided valuable insights into handling model storage and execution. Additionally, we enhanced the compatibility between model blobs and browser automations, improving overall flexibility and performance for end users.",
        "how_its_made": "We utilized Walrus to simulate the addition of model weights into a network for efficient storage and retrieval as blobs. This allowed users to download these blobs and run the models directly, enabling them to automate tasks in their browsers. The automation was based on a simplified DOM model inspired by Taxy AI's implementation, making it more user-friendly and streamlined for common web interactions. Throughout this process, we added support for models like 4o-mini, SLMs (which we later phased out for performance reasons), and LLama 3.2 B. Though the latter models were eventually removed, their integration provided valuable insights into handling model storage and execution. Additionally, we enhanced the compatibility between model blobs and browser automations, improving overall flexibility and performance for end users.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8jbmi/screenshots/v3a9i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jbmi/screenshots/tknn4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jbmi/screenshots/juobq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/EladWarshawsky/browser-extension",
        "link": "https://ethglobal.com/showcase/autowebchain-8jbmi"
    },
    {
        "title": "Gains Gladiator",
        "brief_description": "Gains Gladiator is an AI agent tournament simulator. It pits two AI's against each other in a battle to the riches!",
        "long_description": "The project uses LLM AI agents to power the reasoning and decision making behind the trading bots. Additionally, the project has a marketplace where user's can buy, sell, or lend their prompts behind their agents. The project also features a bridge for the Agents to use in their investing that relies upon Lit Network for trust less swap of assets on either chain.  The project also has a prediction market where user's can bet on which gladiator that they believe will win the competition. The project also makes use of Lit protocol for the trust-less execution of cross chain swaps. These work by creating a programmable key pair on each chain that waits until both assets on each chain have been received. When they are received then the lit action can be executed which produces the signed transactions that complete the transfers on both chains. The protocol also makes use of Story Network for the management of the data relevant towards the agents. The prompts that each AI agent has is first registered as an NFT and then onto Story. After the IP is created, then another user is able to mint a license token which they can use to then implement a copy or they can use a derivative to create their own agent. The royalties module was also configured so that the initial creator could receive rewards. A simple lending system was also built on top of this that allowed for a license token holder to lend their license out to any other user.\nThe prediction market was custom made and deployed to Flow Blockchain, where we used the advantage of them being a consumer focused app.",
        "how_its_made": "The project also makes use of Lit protocol for the trust-less execution of cross chain swaps. These work by creating a programmable key pair on each chain that waits until both assets on each chain have been received. When they are received then the lit action can be executed which produces the signed transactions that complete the transfers on both chains. The protocol also makes use of Story Network for the management of the data relevant towards the agents. The prompts that each AI agent has is first registered as an NFT and then onto Story. After the IP is created, then another user is able to mint a license token which they can use to then implement a copy or they can use a derivative to create their own agent. The royalties module was also configured so that the initial creator could receive rewards. A simple lending system was also built on top of this that allowed for a license token holder to lend their license out to any other user.\nThe prediction market was custom made and deployed to Flow Blockchain, where we used the advantage of them being a consumer focused app.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/qxbtc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/r3ugn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/jpmio/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/j386u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/izksw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/m5rg8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Gnome101/GainsGladiatorD",
        "link": "https://ethglobal.com/showcase/gains-gladiator-qvbnj"
    },
    {
        "title": "Fuse",
        "brief_description": "Infinite crafting game using GenAI and awarding NFTs, this game involves combining concepts and exploring what they might create",
        "long_description": "Craft to explore what is possible! Combining concepts with GenAI you'll get NFTs for new pairs that haven't been discovered. In Fuse, you'll combine words to create new ones, like water and fire making steam together. The catch is that these are generated by an LLM, so it is infinite! Compete with others to be the first to discover a new pair, and get an NFT for it! We're storing NFT metadata in Walrus, a decentralized storage service. For signup we're using Dynamic, to lower the barrier for new crypto users. On the web2 side of things, we have a backend using FastAPI that calls OpenAI with our custom agent instructions to generate both a new concept and choose a matching emoji. We have fun optimizations to run background tasks that keep the experience snappier, like uploading to Walrus. We also keep a PostgresDB database to keep track of our Walrus blob ids and some user session data. On the frontend we have Next.js and React, using Dynamic for login and signup",
        "how_its_made": "We're storing NFT metadata in Walrus, a decentralized storage service. For signup we're using Dynamic, to lower the barrier for new crypto users. On the web2 side of things, we have a backend using FastAPI that calls OpenAI with our custom agent instructions to generate both a new concept and choose a matching emoji. We have fun optimizations to run background tasks that keep the experience snappier, like uploading to Walrus. We also keep a PostgresDB database to keep track of our Walrus blob ids and some user session data. On the frontend we have Next.js and React, using Dynamic for login and signup",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5wsiz/screenshots/jjf6z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5wsiz/screenshots/cjuqv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5wsiz/screenshots/mx06c/default.jpg"
        ],
        "live_demo": "https://fuse-flax.vercel.app/",
        "source_code": "https://github.com/DiegoJRR/fuse",
        "link": "https://ethglobal.com/showcase/fuse-5wsiz"
    },
    {
        "title": "Photo-Danksharding",
        "brief_description": "Instagram, but the photos are in EIP-4844 blobs. Ephemeral on-chain social.",
        "long_description": "Social media doesn't need to be permanent! Blobs are a great way to have data available for a known period of time while automatically expiring. Gas fees would be paid by advertisers, who contribute funds to a FIFO queue, and have their logo displayed while they're at the top of the queue. Also, L2's are too cheap, and this helps fix that :) Alchemy Account Kit v4 for user wallet creation. Viem for on-chain interactions. Next.js frontend eployed to Vercel and leveraging Vercel KV for Redis caching of available posts on-chain. Explored using thirdweb engine for the backend wallet to submit the blob transactions, but found that the only efficient way to move forward was a private key in my env vars \ud83e\udd74",
        "how_its_made": "Alchemy Account Kit v4 for user wallet creation. Viem for on-chain interactions. Next.js frontend eployed to Vercel and leveraging Vercel KV for Redis caching of available posts on-chain. Explored using thirdweb engine for the backend wallet to submit the blob transactions, but found that the only efficient way to move forward was a private key in my env vars \ud83e\udd74",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/zurt2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/wsxmy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/jiekz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/ggky4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/q835w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/7rrqa/default.jpg"
        ],
        "live_demo": "https://photo-danksharding.vercel.app/",
        "source_code": "https://github.com/0xPenryn/photo-danksharding",
        "link": "https://ethglobal.com/showcase/photo-danksharding-11yph"
    },
    {
        "title": "MySFGame",
        "brief_description": "A simple, browser-based game where players s navigate through a foggy San Francisco, collecting and trading NFTs",
        "long_description": "This is a simple browser-based game that uniquely blends the elements of San Francisco with blockchain technology. Players navigate a stylized, fog-covered San Francisco cityscape as a customizable pixelated cable car, their goal being to collect valuable, city-themed NFTs such as the Golden Gate Bridge, Painted Ladies, and sourdough bread. The game's core mechanic revolves around using \"Fog Coins,\" the in-game cryptocurrency, to disperse the virtual fog and reveal hidden NFTs. As players accumulate these digital assets, they can engage in peer-to-peer trading using smart contracts on the game's simplified blockchain. The gameplay loop is enriched by San Francisco-themed quests, which not only provide players with additional Fog Coins but are also recorded as transactions on the blockchain. A blockchain-based leaderboard adds a competitive element, ranking players based on their NFT collection's value. This game concept not only serves as an entertaining introduction to blockchain technology and NFTs but also captures the essence of San Francisco's tech-forward culture and iconic landmarks in a playful, accessible format. I've created a basic implementation of the CryptoFog game using HTML, CSS, and JavaScript. This version includes the following features: A 5x5 grid representing the foggy San Francisco map.\nFog Coins that decrease when revealing cells.\nRandom placement of San Francisco-themed NFTs (represented by emojis).\nA counter for collected NFTs. This implementation is a simplified version and doesn't include all the features mentioned in the original concept, such as trading NFTs or a full blockchain integration. However, it demonstrates the core gameplay loop and can serve as a starting point for further development.",
        "how_its_made": "I've created a basic implementation of the CryptoFog game using HTML, CSS, and JavaScript. This version includes the following features: A 5x5 grid representing the foggy San Francisco map.\nFog Coins that decrease when revealing cells.\nRandom placement of San Francisco-themed NFTs (represented by emojis).\nA counter for collected NFTs. This implementation is a simplified version and doesn't include all the features mentioned in the original concept, such as trading NFTs or a full blockchain integration. However, it demonstrates the core gameplay loop and can serve as a starting point for further development.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fsd4k/screenshots/53qcc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fsd4k/screenshots/n1ysq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fsd4k/screenshots/wpuxm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/xinsianna/ethsf",
        "link": "https://ethglobal.com/showcase/mysfgame-fsd4k"
    },
    {
        "title": "Roblox Coin Exchange",
        "brief_description": "Enabling Roblox's 300 million (MAUs) to create, buy, and sell meme coins using bonding curves.",
        "long_description": "This project is designed to enable Roblox's 300 million monthly active users (MAU) to create, buy, and sell meme coins through a system that integrates bonding curves, which determine the price of the coins based on supply and demand. The project introduces several key features, including the creation of a Multi-Party Computation (MPC) wallet for each user. This MPC wallet is essential for securely managing users' cryptocurrency transactions and their interactions with the meme coins they create. We used the Coinbase Developer Platform and Coinbase SDK to manage wallets and facilitate meme coin transactions across Base, Polygon, and Flow blockchains. We built a custom ERC20-based bonding curve smart contract to control token prices based on supply and demand. For the game, we used Roblox Studio to create the user interface and integrate meme coins into the Roblox ecosystem. The backend was developed with NestJS for server logic and MongoDB for handling user data and transaction history. One hacky aspect was integrating real crypto transactions with Roblox gameplay, syncing blockchain and in-game interactions smoothly using Coinbase\u2019s SDK and bonding curve contracts.",
        "how_its_made": "We used the Coinbase Developer Platform and Coinbase SDK to manage wallets and facilitate meme coin transactions across Base, Polygon, and Flow blockchains. We built a custom ERC20-based bonding curve smart contract to control token prices based on supply and demand. For the game, we used Roblox Studio to create the user interface and integrate meme coins into the Roblox ecosystem. The backend was developed with NestJS for server logic and MongoDB for handling user data and transaction history. One hacky aspect was integrating real crypto transactions with Roblox gameplay, syncing blockchain and in-game interactions smoothly using Coinbase\u2019s SDK and bonding curve contracts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/nytuo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/ibrkx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/x0z88/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/rc2vk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/dpewj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/a0f53/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/iganbold/roblox-memecoin",
        "link": "https://ethglobal.com/showcase/roblox-coin-exchange-833sq"
    },
    {
        "title": "Intellijack",
        "brief_description": "AI Oracle on Fhenix enabling inference over private data to go on chain. Demonstrated application of an agent and data economy",
        "long_description": "Intellijack is an AI oracle framework for managing and monetizing AI agents and datasets using blockchain technology. The core of the project is a the oracle service that has been adapted from Galadriel's oracle system. However, rather than relying on a single payee for the AI API calls, Lit Protocol's open and secure platform enables self payment. In addition, since we are deployed on Fhenix we can retrieve private data and inference over it with the output from the call going on chain. This opens up a vast frontier of applications. The purpose of Intellijack GPT's is to enable a decentralized marketplace for AI agents and datasets. It allows creators to: The system also includes mechanisms for: The use of blockchain technology provides transparency, immutability, and decentralized control over these AI assets. The integration with AI services allows for dynamic interaction with the AI agents. This project could be particularly useful in scenarios where AI model ownership, licensing, and fair compensation are important, such as in collaborative AI development or AI-as-a-service marketplaces. The oracle system can work on any chain and could potentially be developed into a massively multichain and super scalable oracle service I first got started with Lit Protocol, and eventually decided on using Lit rather than Blockless. Some guy handed out free AI calls on Redpill which was super clutch. I worked all night on Friday and by noon Saturday I had set up the oracle service on Fhenix. After that, I wasn't totally sure what to do next so I ideated but eventually just settled on trying to do something like OpenAI's GPT's with Story protocol.\nThe coolest most hacky thing about the project to me is that I can store API keys and wallet seed phrase on Lit and run the oracle without exposing that information.",
        "how_its_made": "I first got started with Lit Protocol, and eventually decided on using Lit rather than Blockless. Some guy handed out free AI calls on Redpill which was super clutch. I worked all night on Friday and by noon Saturday I had set up the oracle service on Fhenix. After that, I wasn't totally sure what to do next so I ideated but eventually just settled on trying to do something like OpenAI's GPT's with Story protocol.\nThe coolest most hacky thing about the project to me is that I can store API keys and wallet seed phrase on Lit and run the oracle without exposing that information.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/75p06/screenshots/3okjx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/75p06/screenshots/rd932/default.jpg",
            "https://ethglobal.b-cdn.net/projects/75p06/screenshots/1o67i/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/madschristensen99/intellijack/",
        "link": "https://ethglobal.com/showcase/intellijack-75p06"
    },
    {
        "title": "ChainSplash",
        "brief_description": "ChainSplash revolutionizes charitable giving using blockchain. We ensure transparency, efficiency, and privacy in donations through smart contracts, NFTs, and zero-knowledge proofs. Empower trust in global giving with real-time tracking and reduced overhead costs.",
        "long_description": "ChainSplash is a blockchain-based donation platform that aims to revolutionize the NGO sector. Key features include: Transparency: All transactions are recorded on public blockchains.\nEfficiency: Smart contracts enable instant transactions, reducing overhead costs.\nPrivacy: Donors have the option to remain anonymous through zero-knowledge proofs.\nReal-time tracking: Donors can track their contributions as they flow through the system.\nNFT integration: When projects reach 100% funding, smart contracts generate NFTs for NGOs, which can be exchanged for physical goods. The platform allows donors to contribute to various NGO projects using cryptocurrency, addressing issues of trust and fraud in charitable giving. ChainSplash builds on successes like UNICEF's CryptoFund and the World Food Programme's blockchain initiative, offering a scalable solution for NGOs of all sizes. ChainSplash leverages several technologies: Frontend: Next.js, heavily inspired by NousDAO's community-driven approach.\nBackend: SQLite and Python, deployed on Polygon blockchain.\nSmart contracts: Developed using Solidity.\nPrivacy: Implemented zero-knowledge proofs (ZKP) for donor anonymity.",
        "how_its_made": "ChainSplash leverages several technologies: Frontend: Next.js, heavily inspired by NousDAO's community-driven approach.\nBackend: SQLite and Python, deployed on Polygon blockchain.\nSmart contracts: Developed using Solidity.\nPrivacy: Implemented zero-knowledge proofs (ZKP) for donor anonymity.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/m5db8/screenshots/g8e5j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m5db8/screenshots/i9ru9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m5db8/screenshots/5kcvq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/twliu-dorian/ethglobal-sf-hackathon.git",
        "link": "https://ethglobal.com/showcase/chainsplash-m5db8"
    },
    {
        "title": "DeForms",
        "brief_description": "Buy, sell and trade datasets as tokens to boost it's credibility, tracking ownership starting with survey data today",
        "long_description": "Problem:\nTrust and Data Ownership: Traditional marketplaces require users to trust a central authority with their data.\nData Quality and Authenticity: Ensuring the quality and provenance of data is challenging.\nPricing and Value Assessment: Data is difficult to price, and its value varies greatly depending on use case.\nInefficient Transactions: Traditional marketplaces involve intermediaries, leading to higher costs and slower processes.\nLimited Access and Control: Users often have limited control over their data and how it's used.\nData Silos: Lack of interoperability between different data sources and platforms.\nSolution:\nDecentralization and Smart Contracts:\nEliminates the need for a central authority, enhancing trust and transparency.\nAutomates transactions and licensing through smart contracts, reducing intermediaries.\nTokenization of Datasets:\nRepresents datasets as unique tokens (NFTs), allowing for clear ownership and provenance tracking.\nEnables fractional ownership, making valuable datasets more accessible. We are deploying this on @rootstock to leverage both BTC and ETH network in-case of staking powers in the future. We are using @privy for account abstraction that enables smooth onboarding for crypto and non-crypto users (facing one obstacle) Integration and Interaction:\nUser Interface: Built with React, providing a dynamic, responsive interface.\nBlockchain Interaction: Ether.js facilitates communication between the frontend and the Ethereum blockchain, enabling seamless smart contract interaction and wallet integration.\nSmart Contracts: Solidity contracts handle core business logic, including minting DataTokens, managing listings, and facilitating transactions.\nDeployment: Contracts are deployed on Rootstock, leveraging Bitcoin network interoperability while utilizing Ethereum's smart contract functionality. Stack used: React, Supabase, Rootstock, Privy SDK",
        "how_its_made": "We are deploying this on @rootstock to leverage both BTC and ETH network in-case of staking powers in the future. We are using @privy for account abstraction that enables smooth onboarding for crypto and non-crypto users (facing one obstacle) Integration and Interaction:\nUser Interface: Built with React, providing a dynamic, responsive interface.\nBlockchain Interaction: Ether.js facilitates communication between the frontend and the Ethereum blockchain, enabling seamless smart contract interaction and wallet integration.\nSmart Contracts: Solidity contracts handle core business logic, including minting DataTokens, managing listings, and facilitating transactions.\nDeployment: Contracts are deployed on Rootstock, leveraging Bitcoin network interoperability while utilizing Ethereum's smart contract functionality. Stack used: React, Supabase, Rootstock, Privy SDK",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/2cheu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/hzdni/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/mw2y4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/z5a6z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/18jw6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/72a41/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Kashyab19/deforms-ethglobal-sf-2024",
        "link": "https://ethglobal.com/showcase/deforms-a8jbh"
    },
    {
        "title": "ConversationStation",
        "brief_description": "Novel agent chat interface lets users interact with their autonomous agents",
        "long_description": "We\u2019ve developed an innovative agent chat interface that enables users to interact with and monitor their autonomous agents in real-time. This project leverages Large Language Models (LLM) and XMTP to create a seamless user interface for querying and commanding agents. Users can ask questions like \u201cWhat are you built to do?\u201d and the agent will summarize its skills, or ask \u201cWhat state are you in?\u201d for real-time updates. Users can even prompt actions such as \u201cchange parameter X to Y,\u201d and the agent will modify parameters on the fly. Agents can be customized with distinct personalities and deliver unprompted updates based on specific triggers. A mobile app consolidates all messages and updates from connected agents in one place. By leveraging XMTP, agents can also broadcast updates across multiple social channels, ensuring that critical information reaches users wherever they are. As autonomous agents become more essential for tasks like trading, selling, gathering information, and developing new actions, our project bridges the gap, enabling smooth interaction between humans and agents. This chat interface will be key in the evolving landscape of human-agent collaboration. We built this project using the Autonolas framework, which provided the foundation for our agent-based services. The architecture revolves around a set of core skill\u2014 Chit_chat \u2014 running as individual or multi-agent services that communicate and interact within an agent-economy. The chat skill integrates LLMs and XMTP: this allows us to bring together a decentralised chat interface for interacting with users, and LLMs which provide context-aware responses. Technologies Used:",
        "how_its_made": "We built this project using the Autonolas framework, which provided the foundation for our agent-based services. The architecture revolves around a set of core skill\u2014 Chit_chat \u2014 running as individual or multi-agent services that communicate and interact within an agent-economy. The chat skill integrates LLMs and XMTP: this allows us to bring together a decentralised chat interface for interacting with users, and LLMs which provide context-aware responses. Technologies Used:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mnhr4/screenshots/2z5o5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnhr4/screenshots/k5d1r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnhr4/screenshots/y7wd6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnhr4/screenshots/bkgso/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/xiuxiuxar/conversation_station/",
        "link": "https://ethglobal.com/showcase/conversationstation-mnhr4"
    },
    {
        "title": "Plutus",
        "brief_description": "Plutus is financial assistant that can help you with managing money, boosting credit score and paying off debts with lowest interests.",
        "long_description": "Our financial management app integrates with Plaid to provide users with real-time insights into their financial data, such as credit card history, bank balances, and more. The app analyzes this data to help users make informed financial decisions, like whether they can afford large purchases or how to maintain a strong credit score. If users are short on funds, the app seamlessly connects them to decentralized lending pools, such as Aave, enabling them to access loans and pay off debts or complete transactions. Key Features: Tech Stack: Our app bridges the gap between traditional finance and decentralized finance, empowering users to take control of their financial future. Project Build: We built a financial management app that connects traditional and decentralized finance using the following stack: Frontend (React): Provides a clean and intuitive interface for users to view and manage their financial data, including credit card history and bank balances. We used React hooks to manage state and ensure seamless navigation. Plaid Integration: We used Plaid to securely access real-time financial data, such as credit card transactions and bank balances. This allows users to make informed decisions, like whether they can afford large purchases or need to borrow funds. Web3 Tools: Smart Contract Development: We developed custom smart contracts to interact with Aave, enabling users to borrow funds when needed and track repayments. Contracts also handle decision-making logic, such as suggesting loans when funds are insufficient. Hacky Bits: We implemented an encryption layer using Fhenix, ensuring that all sensitive financial data is encrypted before any analysis or blockchain interaction. This keeps user data private while integrating seamlessly with both traditional and decentralized finance. By bridging traditional finance data (Plaid) and DeFi (Aave), our app allows users to move smoothly between fiat and crypto environments, providing a powerful financial management tool.",
        "how_its_made": "Project Build: We built a financial management app that connects traditional and decentralized finance using the following stack: Frontend (React): Provides a clean and intuitive interface for users to view and manage their financial data, including credit card history and bank balances. We used React hooks to manage state and ensure seamless navigation. Plaid Integration: We used Plaid to securely access real-time financial data, such as credit card transactions and bank balances. This allows users to make informed decisions, like whether they can afford large purchases or need to borrow funds. Web3 Tools: Smart Contract Development: We developed custom smart contracts to interact with Aave, enabling users to borrow funds when needed and track repayments. Contracts also handle decision-making logic, such as suggesting loans when funds are insufficient. Hacky Bits: We implemented an encryption layer using Fhenix, ensuring that all sensitive financial data is encrypted before any analysis or blockchain interaction. This keeps user data private while integrating seamlessly with both traditional and decentralized finance. By bridging traditional finance data (Plaid) and DeFi (Aave), our app allows users to move smoothly between fiat and crypto environments, providing a powerful financial management tool.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/fe70s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/i2zyb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/myuge/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/wbdd1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/0cndn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/r638r/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/bunsamosa/plutus",
        "link": "https://ethglobal.com/showcase/plutus-mtwx0"
    },
    {
        "title": "Lit Data Market",
        "brief_description": "Marketplace for data vendors and inference vendors. Run AI inference on any data vendor with your choice of open source models, without knowing the data.",
        "long_description": "Marketplace for data vendors and inference vendors. Run AI inference on any data vendor with your choice of open source models. Data vendors don't need to give up their data, since it's passed to specific inference models and vendors through secure Lit actions. -data vendors can better monetize their data (users don't get all the data) -data privacy; users can run queries on data without all the data -unlocks data from inference Example is Linkedin. Linkedin doesn't want to give up their entire database. Users don't want to be restricted to Linkedin search. Lit Data Marketplace allows users to run Llama 3.2, etc on Linkedin data without getting Linkedin data.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/v2ms0/screenshots/58fgg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v2ms0/screenshots/7vh74/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v2ms0/screenshots/k5siv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v2ms0/screenshots/x9ftn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/financegeek-org/ethsf2024",
        "link": "https://ethglobal.com/showcase/lit-data-market-v2ms0"
    },
    {
        "title": "FriendlyIntent",
        "brief_description": "Intent bridging, but only your friends can fill them! No more whitelisted market makers. You pick who can fill your intent!",
        "long_description": "For a user that doesn't care about being instantly filled (can take their time) and wants to share the intent with their friends rather than market makers, introducing FriendlyIntent! Why let market makers have all the fun? Only let your friends fill your intents, by first encrypting the intent, then giving your friends the decryption key! I spent a stupid amount of time debugging my Stackr rollup so I apologize for the lack of progress.\nI envisioned allowing the User encrypt using Lit Protocol, then put the encrypted intent on a stackr (using Avail) chain. Then, LayerZero would propagate the intent to other chains (using the initial chain as a hub in a hub and spoke model)\nThe decryption key would be sent to friends via a message group or broadcast.\nThen, any user can decrypt the intent on chain and fulfil it. I only really got to launching the group chat built with message kit and the stackr rollup because I spent waaaay too long on dumb bugs on the stackr rollup.",
        "how_its_made": "I spent a stupid amount of time debugging my Stackr rollup so I apologize for the lack of progress.\nI envisioned allowing the User encrypt using Lit Protocol, then put the encrypted intent on a stackr (using Avail) chain. Then, LayerZero would propagate the intent to other chains (using the initial chain as a hub in a hub and spoke model)\nThe decryption key would be sent to friends via a message group or broadcast.\nThen, any user can decrypt the intent on chain and fulfil it. I only really got to launching the group chat built with message kit and the stackr rollup because I spent waaaay too long on dumb bugs on the stackr rollup.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ipu74/screenshots/g2txt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ipu74/screenshots/zzc6g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ipu74/screenshots/ttsfp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Zeebradoom/testtt",
        "link": "https://ethglobal.com/showcase/friendlyintent-ipu74"
    },
    {
        "title": "VVLDrizzy",
        "brief_description": "Mint, watermark, license, and protect your viral short form videos. Get paid by media outlets on your terms. Powered by Story Protocol, Walrus.",
        "long_description": "VVLDrizzy (Viral Video Licensor) aims to make it easy for both content creators and media outlets to get paid for or pay to license video content, helping bridge the legacy media outlets' Web3 adoption gap. As a content creator: As a media agency: VVLDrizzy was part-inspired by my friend, PK, who was riding the TTC (Toronto's subway - hence Drizzy) when he filmed a section of the train with a broken window, popping his phone out the windowsill to show the danger. His video went semi-viral (127K views) after he uploaded it to TikTok, and was contacted by multiple news outlets to show it on live news. It was stolen and reuploaded a few times without permission too.\nHe didn't make any money from it, but now with VVLDrizzy, he easily could have set his own licensing terms and prevented it from being stolen without attribution and earned some money. Features: Inspiration for the name: https://youtu.be/AF2MqFnPotc?feature=shared Stack: Notable hacks:\nOne notable hack I pulled off was the client-side watermarking. Typically, video processing is done server-side, but by using WASM and FFmpeg, I was able to process videos directly in the user's browser, preventing the user from needing to send their video to a third-party server for processing, reducing server costs and keeping video ownership fully on the client side, creating a decentralized-first approach. Another hacky thing I did was leverage the IPA hash from the Story license to store the blob id of the video on Walrus to be used later when the video is retrieved after licensing, creating a single-source-of-truth to reduce the friction of content licensing. This combination of technologies made VVLDrizzy a seamless and decentralized solution for both content creators and media organizations.",
        "how_its_made": "Stack: Notable hacks:\nOne notable hack I pulled off was the client-side watermarking. Typically, video processing is done server-side, but by using WASM and FFmpeg, I was able to process videos directly in the user's browser, preventing the user from needing to send their video to a third-party server for processing, reducing server costs and keeping video ownership fully on the client side, creating a decentralized-first approach. Another hacky thing I did was leverage the IPA hash from the Story license to store the blob id of the video on Walrus to be used later when the video is retrieved after licensing, creating a single-source-of-truth to reduce the friction of content licensing. This combination of technologies made VVLDrizzy a seamless and decentralized solution for both content creators and media organizations.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/socxw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/1qced/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/eip9h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/yahk2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/a7a8f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/b90qk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/dynamicduho/ETHGlobalSF-VVLDrizzy",
        "link": "https://ethglobal.com/showcase/vvldrizzy-he09i"
    },
    {
        "title": "DMNO - PKP secrets",
        "brief_description": "dmno.dev plugin - encrypted secrets using a PKP gated by Github auth + teams",
        "long_description": "This hackathon project is a web3-related plugin for an existing open source devtool called  DMNO (https://dmno.dev) - of which I am the creator. So first some context: DMNO is a powerful tool for managing configuration and secrets that aims to solve all the common paper-cuts of dealing with config. Aside from validation, coercion, type-safety, composability, and leak prevention, sensitive values can be pulled from various backends using plugins. Currently there are plugins to store secrets in an encrypted file within your repo, 1password, and more (ex: bitwarden, aws, etc) are on the way. The existing encrypted file plugin (https://dmno.dev/docs/plugins/encrypted-vault/) uses a single symmetric key which must be shared with all teammates who need access. This is obviously a naive approach and not ideal... Other sensible approaches would require a centralized manager of the private key, which is also not ideal and comes with serious liability/security risks, and compliance requirements. This hackathon project introduces a new encrypted vault plugin (powered by web3) with a far superior decentralized approach to encryption/decryption. This plugin bridges the gap to web2 by relying on Github for access control, and hiding all web3 interactions after initial setup is complete. Encrypted secrets are still stored in a file within your repository, but encryption uses a PKP (powered by Lit Protocol). Using an on-chain PKP allows all devs to update secret values (encrypting using the public key), but decrypting those secrets can be set using programmable conditions - without ever exposing the private key to anyone. The plugin uses Github personal access tokens to identify users, and membership in Github org \"teams\" for access control at the vault level. Secrets can be segmented into multiple vault instances, and access to each vault can be granted to multiple teams, and changed over time, as the access list is also on-chain. The goal is to make this all as seamless as possible, and take advantage of the benefits of decentralization, without forcing the end users to deal with wallets/keys/etc. While a wallet is needed to set up the vault (and corresponding PKP), after that everything is handled via github auth tokens, so most users may not even realize they are using web3 at all. Even this is not necessary as a centralized service could handle setting things up for end users,  taking fiat payments, and hiding all web3 interactions. Future work will need to be done to move this onto mainnet, deal with payments and delegation, complete access management, etc... I ALSO created a simple package with a few web3-related data types for DMNO. This lets us set config items as being web3 addresses and private keys, and we get some basic validations. In the future, I will add more options to check certain conditions as validations - for example checking a balance, or checking that an address is a certain type of contract, etc... THis is just generally useful and will help stop typos turning into huge catastrophes :) This project relies heavily on Lit Protocol - which manages the PKP and talks to Github using Lit actions to restrict access. The access list is stored using Sign protocol as attestations (on a different chain). These attestations hold an encrypted Github Team ID.  The Lit action fetches those attestations, decrypts them, and compares the users current teams to the list. In an ideal world, the PKP would also be used to manage the attestations, also using Lit actions, so that after the initial setup, users never have to deal with a wallet again. This was initially attempted, but dealing with signing and submitting transactions involving multiple wallets and delegating payments proved to add too much complexity for the hackathon. Honestly had Lit protocol not been here, whatever I would have hacked together myself would have been a naive proof of concept... Using Lit solved my exact problem - and one that I had been pondering how to solve more generally, with or without web3, much before this hackathon. Using Sign Protocol was extremely convenient because of the schema, revokability, built-in indexing service, and helpful UI! In the future we could use sign hooks to trigger notifications when things change - or even to affect keys. A next step is to allow Lit actions to access keys that the user may not have access to - to do things like use a master key to generate dev or deployment specific keys. Also an alternative access control mechanism will need to be developed for server-to-server access, but it would look fairly similar, just using keypairs and signed messages, rather than relying on github.",
        "how_its_made": "This project relies heavily on Lit Protocol - which manages the PKP and talks to Github using Lit actions to restrict access. The access list is stored using Sign protocol as attestations (on a different chain). These attestations hold an encrypted Github Team ID.  The Lit action fetches those attestations, decrypts them, and compares the users current teams to the list. In an ideal world, the PKP would also be used to manage the attestations, also using Lit actions, so that after the initial setup, users never have to deal with a wallet again. This was initially attempted, but dealing with signing and submitting transactions involving multiple wallets and delegating payments proved to add too much complexity for the hackathon. Honestly had Lit protocol not been here, whatever I would have hacked together myself would have been a naive proof of concept... Using Lit solved my exact problem - and one that I had been pondering how to solve more generally, with or without web3, much before this hackathon. Using Sign Protocol was extremely convenient because of the schema, revokability, built-in indexing service, and helpful UI! In the future we could use sign hooks to trigger notifications when things change - or even to affect keys. A next step is to allow Lit actions to access keys that the user may not have access to - to do things like use a master key to generate dev or deployment specific keys. Also an alternative access control mechanism will need to be developed for server-to-server access, but it would look fairly similar, just using keypairs and signed messages, rather than relying on github.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/a4f6a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/u38zd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/dp6ug/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/7jp3i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/qwdc5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/dmno-dev/ethsf-2024",
        "link": "https://ethglobal.com/showcase/dmno-pkp-secrets-vaytr"
    },
    {
        "title": "OmiSwap",
        "brief_description": "OmiSwap is an innovative platform that enables voice-activated on-chain transactions through an AI wearable device, allowing users to seamlessly interact with multiple blockchain networks using natural language commands.",
        "long_description": "OmiSwap is an innovative platform that simplifies blockchain interactions through voice-activated commands using an AI wearable device. The system allows users to initiate transactions by speaking into their Omi device, recognizing trigger phrases like \"start transaction\" and \"end transaction\" to capture user intent. The platform utilizes advanced AI, powered by OpenAI's GPT models, to interpret natural language commands. For example, a user can say \"I want to send five bucks to Rohan on Polygon,\" and the system will translate this into structured transaction data. OmiSwap leverages the Omi AI wearable device, which is part of a larger ecosystem integrating with smartphones and companion apps. This integration allows users to receive notifications, make transactions, and access blockchain functionalities directly from their wearable device. The seamless connection between the wearable and the user's smartphone enhances the overall utility and convenience of the OmiSwap platform. The system supports multiple blockchain networks, including Base, Polygon, Arbitrum, and Ethereum. Users can specify the network in their voice command, enabling seamless cross-chain transactions. OmiSwap creates and manages wallets for users across different blockchain networks using the Coinbase CDP (Crypto Development Platform) SDK. This integration allows for efficient wallet provisioning, sending crypto into and out of wallets, tracking balances, and trading crypto assets. OmiSwap supports two main types of transactions: transfers of cryptocurrencies (ETH or USDC) to other users on the platform, and currency swaps between ETH and USDC on the Base network. Notably, for USDC transfers, OmiSwap leverages Coinbase Wallet's recent update that enables instant, fee-free USDC sends. This feature eliminates the need for gas fees when sending USDC, making transactions more cost-effective for users. In terms of backend processing, the system extracts transaction details from voice transcripts, verifies user identities, and retrieves wallet information from a Supabase database. Transactions are executed using the Coinbase SDK, and all transactions and swaps are logged in the database for record-keeping. OmiSwap aims to provide a seamless, intuitive interface for blockchain interactions, eliminating the need for complex UIs or deep technical knowledge. The system prioritizes security by using server-side processing for sensitive operations and integrating with secure wallet providers. The technology stack includes Next.js with shadcn/ui for the frontend, Node.js with Next.js API routes for serverless backend functions, Supabase for user data and transaction logging, Coinbase SDK for wallet management and transactions, and integration with OpenAI's GPT models for natural language processing. The system also incorporates robust error handling to manage issues such as invalid transactions, network errors, or AI interpretation failures. OmiSwap represents a significant advancement in making blockchain technology more accessible to a broader audience by leveraging voice commands, AI wearables, and innovative features like gasless USDC transfers to simplify complex cryptocurrency operations. How it's made:\nOmiSwap is built using a cutting-edge tech stack that combines AI, blockchain, and wearable technology to create a seamless voice-activated crypto transaction platform.\nVoice Input and AI Processing:\nThe system starts with the Omi wearable device, which captures user voice commands. Voice transcripts are sent to our backend, where we use OpenAI's GPT-4 model (via the Red Pill API) to interpret natural language commands into structured transaction intents. We implemented custom prompt engineering to extract specific transaction details like recipient, amount, currency, and network from user utterances.\nBackend Architecture:\nThe core backend is built using Next.js API routes, providing a serverless architecture that scales efficiently. We use TypeScript for type safety and better code maintainability. We also created API routes for webhooks to stream transcription events from the Omi to our backend.\nBlockchain Integration:\nThe heart of our blockchain interactions is the Coinbase CDP (Crypto Development Platform) SDK. This powerful tool allows us to create and manage wallets across multiple networks (Base, Polygon, Arbitrum, Ethereum), execute transfers and swaps, and check balances and transaction statuses. We've implemented support for gasless USDC transfers, leveraging Coinbase Wallet's recent feature update. Multi-chain support is baked into our system, with special emphasis on Polygon & Coinbase for their scalability and low fees.\nDatabase and User Management:\nSupabase serves as our primary database, storing user information, wallet data, and transaction logs. We stream data from Supabase through our backend to enable real-time  frontend updates with the latest transaction data.\nFrontend:\nThe user interface is built with Next.js and shadcn/ui, providing a responsive and accessible dashboard for users to view their transactions and wallet balances.\nSecurity:\nAll sensitive operations, including wallet management and transaction signing, happen server-side to enhance security. We implement proper error handling and input validation to prevent potential exploits.\nInnovative Features:\nWe've created a unique system for extracting transaction intents from natural language using custom regex patterns and AI processing. The integration with the Omi wearable device allows for a truly hands-free crypto experience, bridging the gap between wearable tech and blockchain.\nChallenges and Hacks:\nOne of our biggest challenges was accurately parsing varied user inputs. We implemented a flexible system using regex and AI to handle different phrasings and potential speech-to-text errors. To optimize performance, we parallelized API calls where possible, using Promise.all for concurrent processing of multiple transactions or swaps.\nPartner Technologies:\nCoinbase CDP SDK: This was crucial for our project, providing a unified interface for multi-chain wallet management and transactions. It significantly reduced the complexity of supporting multiple networks.\nPolygon: We leveraged Polygon's fast and cost-effective infrastructure to provide users with an optimal experience for frequent, small-value transactions.\nOmi Wearable: This innovative device forms the core of our user interface, enabling voice-activated blockchain interactions in a way that's never been done before.\nBy combining these technologies, we've created a unique platform that makes blockchain interactions as simple as speaking a command, truly bringing crypto to the masses through the power of AI and wearable tech.",
        "how_its_made": "How it's made:\nOmiSwap is built using a cutting-edge tech stack that combines AI, blockchain, and wearable technology to create a seamless voice-activated crypto transaction platform.\nVoice Input and AI Processing:\nThe system starts with the Omi wearable device, which captures user voice commands. Voice transcripts are sent to our backend, where we use OpenAI's GPT-4 model (via the Red Pill API) to interpret natural language commands into structured transaction intents. We implemented custom prompt engineering to extract specific transaction details like recipient, amount, currency, and network from user utterances.\nBackend Architecture:\nThe core backend is built using Next.js API routes, providing a serverless architecture that scales efficiently. We use TypeScript for type safety and better code maintainability. We also created API routes for webhooks to stream transcription events from the Omi to our backend.\nBlockchain Integration:\nThe heart of our blockchain interactions is the Coinbase CDP (Crypto Development Platform) SDK. This powerful tool allows us to create and manage wallets across multiple networks (Base, Polygon, Arbitrum, Ethereum), execute transfers and swaps, and check balances and transaction statuses. We've implemented support for gasless USDC transfers, leveraging Coinbase Wallet's recent feature update. Multi-chain support is baked into our system, with special emphasis on Polygon & Coinbase for their scalability and low fees.\nDatabase and User Management:\nSupabase serves as our primary database, storing user information, wallet data, and transaction logs. We stream data from Supabase through our backend to enable real-time  frontend updates with the latest transaction data.\nFrontend:\nThe user interface is built with Next.js and shadcn/ui, providing a responsive and accessible dashboard for users to view their transactions and wallet balances.\nSecurity:\nAll sensitive operations, including wallet management and transaction signing, happen server-side to enhance security. We implement proper error handling and input validation to prevent potential exploits.\nInnovative Features:\nWe've created a unique system for extracting transaction intents from natural language using custom regex patterns and AI processing. The integration with the Omi wearable device allows for a truly hands-free crypto experience, bridging the gap between wearable tech and blockchain.\nChallenges and Hacks:\nOne of our biggest challenges was accurately parsing varied user inputs. We implemented a flexible system using regex and AI to handle different phrasings and potential speech-to-text errors. To optimize performance, we parallelized API calls where possible, using Promise.all for concurrent processing of multiple transactions or swaps.\nPartner Technologies:\nCoinbase CDP SDK: This was crucial for our project, providing a unified interface for multi-chain wallet management and transactions. It significantly reduced the complexity of supporting multiple networks.\nPolygon: We leveraged Polygon's fast and cost-effective infrastructure to provide users with an optimal experience for frequent, small-value transactions.\nOmi Wearable: This innovative device forms the core of our user interface, enabling voice-activated blockchain interactions in a way that's never been done before.\nBy combining these technologies, we've created a unique platform that makes blockchain interactions as simple as speaking a command, truly bringing crypto to the masses through the power of AI and wearable tech.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/b3ma8/screenshots/ehyi9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b3ma8/screenshots/h2b9q/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b3ma8/screenshots/gvemk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/raviriley/omitx",
        "link": "https://ethglobal.com/showcase/omiswap-b3ma8"
    },
    {
        "title": "Earn Your Story AI",
        "brief_description": "Using AI to registering your most personal identity IP, based on your open tabs",
        "long_description": "A quick and easy way to monetize your personal identity IP. Advertisers pay me good money if I can show who I am. Academic researchers yearn to know more about my behavioral patterns. And, I want AI to personalize my online user experience based on who I am. I need a quick and bullet-proof way to define and sell my personal interest IP ! I use the data that defines my most personal self: my browser tabs.\nTo understand (!) and explain who I am - transparent, IP-protected, automated in 1 click, thanks to LLMs. Now I only need a self-sovereign way to protect my personal identity:\nI register my identity as IP NFT on Story Protocol. This way my personal identity becomes IP, clearly attributed, and protected. Finally, I sell My Story to advertisers and researchers who are curious to learn more about my interests. Protected by IP licensing terms - e.g. restricting commercial use, but allowing academic research. https://testnet.storyscan.xyz/tx/0xe73588e2a449dfbb164eff645cf5f49682b7dd05e3a01a5dbcec96a9261f1087 The Chrome extension uses the Chrome API to read information such as open browser tabs. Only an extension has access to this personal data. The data then shows in your Chrome tab. GPT summarizes the titles of open browser tabs. A more private local LLM could be used, too, but doesn't quite work for demo purposes here. Then Story Protocol creates an NFT defining your personal interest.",
        "how_its_made": "The Chrome extension uses the Chrome API to read information such as open browser tabs. Only an extension has access to this personal data. The data then shows in your Chrome tab. GPT summarizes the titles of open browser tabs. A more private local LLM could be used, too, but doesn't quite work for demo purposes here. Then Story Protocol creates an NFT defining your personal interest.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tp1jd/screenshots/9z6tq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tp1jd/screenshots/j8f5r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tp1jd/screenshots/vcty6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tp1jd/screenshots/hj6wc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/p0s/earn-your-story",
        "link": "https://ethglobal.com/showcase/earn-your-story-ai-tp1jd"
    },
    {
        "title": "SmartSign",
        "brief_description": "Transform conversations into contracts instantly with our app, combining advanced language models and blockchain for secure, efficient, and transparent deal closures.",
        "long_description": "Imagine instantly transforming your business conversations into legally binding contracts with just a few clicks. Our app effortlessly captures discussions between parties and extracting crucial details. Leveraging advanced language models, it generates comprehensive written contracts instantly. Once both parties agree on the contract, it is AES encrypted, providing passwords exclusively to the involved parties, and stored on the walrus network. A smart contract referencing the encrypted contract is then created and stored on the Rootstock blockchain, ensuring transparency, security, and immutability. Say goodbye to lengthy negotiations and paperwork \u2013 with our app, closing deals has never been easier or more efficient. Say goodbye to pricey subscription services like Docusign, PandaDoc, and SignNow! And say hello to SmartSign! Example use cases:\nTwo parties negotiating a sale of an item.\nWarranty contracts.\nFreelance agreements and project scopes.\nRental and lease agreements.\nService contracts between businesses and clients.\nNon-disclosure agreements (NDAs).\nEmployment contracts and offer letters.\nPartnership agreements.\nLicensing and royalty agreements.\nLoan agreements and repayment terms The project uses XMTP (Converse) for chatting capability between users.  It uses Openai for legal contract capability.  It uses Walrus to store the encrypted contract data.  It uses Solidity contract for signing, timestamp of the contract.  The solidity contract is deployed on Rootstock chain. App Workflow: Two users engage in a conversation on XMTP. Once they finish discussing business details and exchanging personal information, they trigger the /generate contract bot command. The bot gathers the entire chat history and is fed into OpenAI's gpt-4o LLM, which generates a legal contract in text form. The bot then creates a random encryption key and uses it to AES encrypt the PDF contract. The bot sends the encrypted PDF and the encryption key to both users in the chat, allowing them to review the AI-generated contract. If needed, they can regenerate the contract by issuing the command again. No other people have access to the encryption key as XMTP is an end to end encrypted messenger. Either user can deploy the contract when ready. By invoking the /deploy command, the bot generates a link to a page where users can log into their MetaMask wallet and deploy the smart contract. The AES encrypted contract is first deployed on the Walrus Network. Once deployed, a hash for the blob id is stored on the smart contract when it's deployed. Users can sign the smart contract by using the /sign command which uses their Rootstock wallet to officially sign the contract.",
        "how_its_made": "The project uses XMTP (Converse) for chatting capability between users.  It uses Openai for legal contract capability.  It uses Walrus to store the encrypted contract data.  It uses Solidity contract for signing, timestamp of the contract.  The solidity contract is deployed on Rootstock chain. App Workflow: Two users engage in a conversation on XMTP. Once they finish discussing business details and exchanging personal information, they trigger the /generate contract bot command. The bot gathers the entire chat history and is fed into OpenAI's gpt-4o LLM, which generates a legal contract in text form. The bot then creates a random encryption key and uses it to AES encrypt the PDF contract. The bot sends the encrypted PDF and the encryption key to both users in the chat, allowing them to review the AI-generated contract. If needed, they can regenerate the contract by issuing the command again. No other people have access to the encryption key as XMTP is an end to end encrypted messenger. Either user can deploy the contract when ready. By invoking the /deploy command, the bot generates a link to a page where users can log into their MetaMask wallet and deploy the smart contract. The AES encrypted contract is first deployed on the Walrus Network. Once deployed, a hash for the blob id is stored on the smart contract when it's deployed. Users can sign the smart contract by using the /sign command which uses their Rootstock wallet to officially sign the contract.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/9ss1i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/fx3d7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/9vpur/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/k5nt5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/znbxr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/kvhqd/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/swswsw/contractbot1",
        "link": "https://ethglobal.com/showcase/smartsign-zjyn1"
    },
    {
        "title": "Dream Green",
        "brief_description": "A blockchain-based payment solution for the cannabis industry. We eliminate cash-related risks and complexities for dispensaries by enabling secure crypto and fiat transactions, all settled in USDC. Simplifying operations, ensuring compliance, and improving customer experience.",
        "long_description": "Core Functionality: Hybrid Payment System: Cultivates flexibility by accepting both cryptocurrency and fiat currency payments.\nIntegrates with Stripe for processing traditional card payments.\nSupports various cryptocurrencies for direct crypto transactions. USDC Settlement: All transactions, regardless of input method, bloom into USD Coin (USDC) settlements.\nUtilizes Circle's infrastructure for stable, regulated cryptocurrency transactions. Blockchain-Based Ledger: Plants a secure record of all transactions on a blockchain, ensuring transparency and immutability.\nGrows easy pathways for auditing and regulatory compliance. User-Friendly Interface: Intuitive mobile app for customers to make purchases as easily as watering a plant.\nRobust dashboard for dispensaries to manage transactions, inventory, and analytics. Key Benefits: For Dispensaries: Prunes away cash handling, minimizing security risks and operational costs.\nFertilizes growth by providing a cryptocurrency-based financial solution.\nCultivates compliance with automatic record-keeping and reporting tools.\nEnables businesses to branch out and scale operations more easily. For Customers: Blossoms multiple convenient payment options (crypto, card, bank transfer).\nGrows a canopy of privacy and security around purchases.\nPollinates the overall purchasing experience with fast, digital transactions. For the Cannabis Industry: Bridges the gap between state-level legalization and federal banking regulations.\nPromotes transparency and legitimacy, helping the industry flourish.\nFacilitates easier tax collection and reporting for authorities.\nPayment Integration with Circle, Stripe, and Crypto Wallets\nThis project integrates Circle payments with Stripe to enable checkout using both traditional payment methods (credit/debit cards) and cryptocurrencies (via wallets like MetaMask and Phantom). It facilitates automatic conversions to USDC and ensures that the correct dispensary (dispo) wallet receives the payment. PoW (Proof of Weed)\nRevolutionizing payments in the marijuana industry using Circle, Stripe, and Flow blockchain. Payment Integration with Circle, Stripe, and Crypto Wallets\nThis project integrates Circle payments with Stripe to enable checkout using both traditional payment methods (credit/debit cards) and cryptocurrencies (via wallets like MetaMask and Phantom). It facilitates automatic conversions to USDC and ensures that the correct dispensary (dispo) wallet receives the payment. Features\nMulti-Method Payments: Users can checkout via Stripe (credit/debit) or using cryptocurrency wallets (e.g., MetaMask, Phantom).\nAutomatic USDC Conversion: Fiat payments are converted to USDC using Circle\u2019s API.\nWallet-Based Payment Routing: Each dispensary has a unique USDC wallet, and payments are automatically routed to the respective wallet.\nReal-Time Notifications: Webhooks from Stripe and Circle are used to notify and handle payments in real-time.\nPrerequisites\nAPI Keys: You will need API keys from Circle and Stripe to interact with their services.\nCrypto Wallets: For crypto payments, wallets such as MetaMask and Phantom should be supported.\nUSDC Support: Ensure that your Stripe account is configured to support cryptocurrency payments (specifically USDC).\nHow It Works\nCreate a Wallet for Each Dispensary: Circle API is used to create and manage wallets for each dispensary.\nEach wallet is identified by a unique ID.\nInitiate a Stripe Checkout Session: The user selects a product and starts a checkout session.\nStripe allows the user to pay via credit card, debit card, or cryptocurrency (USDC).\nThe dispensary\u2019s wallet ID is included in the session metadata to ensure the payment is routed correctly.\nConvert Fiat to USDC (if using traditional payment methods): Once the payment is processed via Stripe, a backend process is triggered to convert the fiat currency to USDC using Circle\u2019s API.\nThe USDC is transferred to the correct dispensary wallet.\nHandle Direct Crypto Payments (e.g., MetaMask or Phantom): For users paying directly in USDC via a crypto wallet, the payment is automatically routed to the respective dispensary\u2019s wallet.\nWebhooks for Real-Time Updates: Stripe webhooks notify the backend when a payment is completed.\nCircle webhooks notify the backend when USDC transfers are successfully completed.\nFile Structure\napp.py: Flask application to handle Stripe and Circle webhooks.\nstripe_checkout.py: Code to create Stripe Checkout Sessions.\ncircle_api.py: Code to handle Circle API interactions (wallet creation, fiat-to-USDC conversion).\nREADME.md: This documentation.\nSetup\nClone this repository:\ngit clone https://github.com/your-repo/payment-integration.git\ncd payment-integration\nComplete Setup for Payment Integration with Circle, Stripe, and Crypto Wallets\nInstall Python: Ensure Python 3.6+ is installed from python.org. (Optional) Create Virtual Environment: python -m venv venv\nsource venv/bin/activate (Windows: venv\\Scripts\\activate)\nInstall Required Packages: pip install requests flask stripe python-dotenv\nCreate .env File in your project directory and add the following environment variables: STRIPE_SECRET_KEY=your_stripe_secret_key\nCIRCLE_API_KEY=your_circle_api_key\nSTRIPE_ENDPOINT_SECRET=your_stripe_webhook_endpoint_secret\nCIRCLE_WEBHOOK_SECRET=your_circle_webhook_secret\nLoad Environment Variables in Your Code: from dotenv import load_dotenv\nimport os load_dotenv()\nstripe.api_key = os.getenv(\"STRIPE_SECRET_KEY\")\ncircle_api_key = os.getenv(\"CIRCLE_API_KEY\")",
        "how_its_made": "PoW (Proof of Weed)\nRevolutionizing payments in the marijuana industry using Circle, Stripe, and Flow blockchain. Payment Integration with Circle, Stripe, and Crypto Wallets\nThis project integrates Circle payments with Stripe to enable checkout using both traditional payment methods (credit/debit cards) and cryptocurrencies (via wallets like MetaMask and Phantom). It facilitates automatic conversions to USDC and ensures that the correct dispensary (dispo) wallet receives the payment. Features\nMulti-Method Payments: Users can checkout via Stripe (credit/debit) or using cryptocurrency wallets (e.g., MetaMask, Phantom).\nAutomatic USDC Conversion: Fiat payments are converted to USDC using Circle\u2019s API.\nWallet-Based Payment Routing: Each dispensary has a unique USDC wallet, and payments are automatically routed to the respective wallet.\nReal-Time Notifications: Webhooks from Stripe and Circle are used to notify and handle payments in real-time.\nPrerequisites\nAPI Keys: You will need API keys from Circle and Stripe to interact with their services.\nCrypto Wallets: For crypto payments, wallets such as MetaMask and Phantom should be supported.\nUSDC Support: Ensure that your Stripe account is configured to support cryptocurrency payments (specifically USDC).\nHow It Works\nCreate a Wallet for Each Dispensary: Circle API is used to create and manage wallets for each dispensary.\nEach wallet is identified by a unique ID.\nInitiate a Stripe Checkout Session: The user selects a product and starts a checkout session.\nStripe allows the user to pay via credit card, debit card, or cryptocurrency (USDC).\nThe dispensary\u2019s wallet ID is included in the session metadata to ensure the payment is routed correctly.\nConvert Fiat to USDC (if using traditional payment methods): Once the payment is processed via Stripe, a backend process is triggered to convert the fiat currency to USDC using Circle\u2019s API.\nThe USDC is transferred to the correct dispensary wallet.\nHandle Direct Crypto Payments (e.g., MetaMask or Phantom): For users paying directly in USDC via a crypto wallet, the payment is automatically routed to the respective dispensary\u2019s wallet.\nWebhooks for Real-Time Updates: Stripe webhooks notify the backend when a payment is completed.\nCircle webhooks notify the backend when USDC transfers are successfully completed.\nFile Structure\napp.py: Flask application to handle Stripe and Circle webhooks.\nstripe_checkout.py: Code to create Stripe Checkout Sessions.\ncircle_api.py: Code to handle Circle API interactions (wallet creation, fiat-to-USDC conversion).\nREADME.md: This documentation.\nSetup\nClone this repository:\ngit clone https://github.com/your-repo/payment-integration.git\ncd payment-integration\nComplete Setup for Payment Integration with Circle, Stripe, and Crypto Wallets\nInstall Python: Ensure Python 3.6+ is installed from python.org. (Optional) Create Virtual Environment: python -m venv venv\nsource venv/bin/activate (Windows: venv\\Scripts\\activate)\nInstall Required Packages: pip install requests flask stripe python-dotenv\nCreate .env File in your project directory and add the following environment variables: STRIPE_SECRET_KEY=your_stripe_secret_key\nCIRCLE_API_KEY=your_circle_api_key\nSTRIPE_ENDPOINT_SECRET=your_stripe_webhook_endpoint_secret\nCIRCLE_WEBHOOK_SECRET=your_circle_webhook_secret\nLoad Environment Variables in Your Code: from dotenv import load_dotenv\nimport os load_dotenv()\nstripe.api_key = os.getenv(\"STRIPE_SECRET_KEY\")\ncircle_api_key = os.getenv(\"CIRCLE_API_KEY\")",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hk30m/screenshots/3eezu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hk30m/screenshots/01gdg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hk30m/screenshots/a8201/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/j-ble/proof_of_green ",
        "link": "https://ethglobal.com/showcase/dream-green-hk30m"
    },
    {
        "title": "DeFi-Calendly",
        "brief_description": "A defi calendly, book appointments onchain with a staked deposit",
        "long_description": "A web3 version of calendly. Service providers can allow their clients to book appointments onchain with a staked deposit. Clients get it back when you are marked as attended by the owner of the appointment. Once the appointments are resolved they will either be returned to the client or transferred to the Service Provider. I built this solo, the idea is to expand and create an easy way for service providers (think hairdressers, lawyers, consultants) to provide a booking platform with deposits paid for each appointment. Smart contract written in Sol.\nIntegrated with Metamask and Coinbase Wallet.\nDeployed on Remix and Vercel.\nQA with Polygon Testnet.",
        "how_its_made": "I built this solo, the idea is to expand and create an easy way for service providers (think hairdressers, lawyers, consultants) to provide a booking platform with deposits paid for each appointment. Smart contract written in Sol.\nIntegrated with Metamask and Coinbase Wallet.\nDeployed on Remix and Vercel.\nQA with Polygon Testnet.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h3cis/screenshots/t66tk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h3cis/screenshots/2houh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h3cis/screenshots/aovpz/default.jpg"
        ],
        "live_demo": "https://ethglobal-sf-24-q2kw15vw6-ram-sharmas-projects-7ad2ce07.vercel.app/",
        "source_code": "https://github.com/ram-sharma/ethglobalSF24",
        "link": "https://ethglobal.com/showcase/defi-calendly-h3cis"
    },
    {
        "title": "PQP",
        "brief_description": "Post-Quantum Digital Signature on Trusted Execution Environment",
        "long_description": "Background\nPost-Quantum Proofs (PQP) aims to build a quantum resistant future. Our mission is to implement cryptographic algorithms that remain secure against the potential threats posed by quantum computers, to create a robust Web3 infrastructure. As quantum computing technology advances, it is anticipated that many Web3 protocols which use cryptographic systems, particularly those based on integer factorization and discrete logarithm problems, will become vulnerable to attacks using algorithms like Shor's algorithm. Therefore, the development of quantum-resistant signature schemes is essential for ensuring long-term blockchain security. Problem\nIn quantum computing, a possible Q-day attack would be a hypothetical cyberattack, similar to zero-day vulnerabilities in the cybersecurity field. If quantum technology matures, blockchain protocols and Web3 transactions will become vulnerable to quantum algorithms. Moreover, many of the underlying cryptographic primitives would become vulnerable to quantum attacks. Idea\nPost-quantum signatures are digital signatures designed to be secure against attacks from quantum computers and can verify the validity of onchain cryptographic encryptions. These signatures rely on mathematical problems that are believed to be difficult even for quantum computers to solve. The objective is to create a signature scheme that allows a signer to produce a signature using a private key while enabling anyone with access to the corresponding public key to verify the authenticity of the signature without revealing the private key. We implemented a post-quantum lattice-based digital signature on a trusted execution environment as a proof of concept of PQ in Web3. In our project, we implemented a state-of-the-art post-quantum Digital Signature Algorithm (DSA) on Trusted Execution Environments (TEEs) using TypeScript. We integrated lattice-based cryptographic techniques, leveraging TEEs from Lit and Phala. We experimented and recorded 16ms latency.",
        "how_its_made": "In our project, we implemented a state-of-the-art post-quantum Digital Signature Algorithm (DSA) on Trusted Execution Environments (TEEs) using TypeScript. We integrated lattice-based cryptographic techniques, leveraging TEEs from Lit and Phala. We experimented and recorded 16ms latency.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/s48yc/screenshots/2rkrh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s48yc/screenshots/8uxc2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s48yc/screenshots/ac882/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s48yc/screenshots/oc1h1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/lipet2k/ethsf",
        "link": "https://ethglobal.com/showcase/pqp-s48yc"
    },
    {
        "title": "Anti Swan",
        "brief_description": "An ERC-4626 tokenized vault designed to protect capital by betting against black swan events (P < 5%). Using market data, Kelly Criterion, and advanced strategies, we generate consistent yield while minimizing risk in prediction markets. Protect, profit, repeat.",
        "long_description": "BlackSwan Shield is a tokenized 4626-compliant vault designed to collectively manage user funds while betting against black swan events (with a probability of less than 5%) in prediction markets like Polymarket. Users deposit funds into the vault and receive shares representing their ownership. The vault then autonomously places bets, with a specific focus on events that are statistically unlikely to occur (black swans). In essence, SwanGuard Vault transforms complex prediction market strategies into an accessible, efficient product that allows users to earn consistent returns by betting against highly improbable events. This \u201canti-black swan\u201d approach, combined with yield optimization, provides users with a robust DeFi product focused on risk-adjusted returns.\nOur main product called SwanGuard Vault, and here's how it works:",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/kxtyk/screenshots/fsbb3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxtyk/screenshots/mb8o3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxtyk/screenshots/dafdh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/anti-black-swan/eth-global-sf-submission",
        "link": "https://ethglobal.com/showcase/anti-swan-kxtyk"
    },
    {
        "title": "OmniMemeFoodFactory",
        "brief_description": "Launch your own AI-powered food meme coin as Omni Fungible Token (OFT) on 70+ chains in ONE click(*), made possible by LayerZero V2",
        "long_description": "Launch your own AI-powered food meme coin as Omni Fungible Token (OFT) on 70+ chains in ONE click(*), made possible by LayerZero V2. Contracts are written, organized, and deployed by Foundry (forge, anvil). See description and README, and submitted feedback on partner section for how LayerZero made our project possible Frontend is based on Chakra, Viem, Wagmi, Rainbow Kit, Typescript + React, with full ESLint and dev environment configured Server is powered by Python Flask, and OpenAI dall-e-3 and GPT-4",
        "how_its_made": "Contracts are written, organized, and deployed by Foundry (forge, anvil). See description and README, and submitted feedback on partner section for how LayerZero made our project possible Frontend is based on Chakra, Viem, Wagmi, Rainbow Kit, Typescript + React, with full ESLint and dev environment configured Server is powered by Python Flask, and OpenAI dall-e-3 and GPT-4",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/yc4xf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/5asep/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/do1gj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/4g12t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/5227h/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/polymorpher/omni-meme-food-factory",
        "link": "https://ethglobal.com/showcase/omnimemefoodfactory-fkwf7"
    },
    {
        "title": "Cara IP",
        "brief_description": "Let your imagination flow and your creativity go, with the power of AI and IP",
        "long_description": "In the world of AI, we want to make sure artist feel empowered to be their creative selfs. Cara is ment as a playground, where you can upload your photographs or any image, and with words edit it in any way you want.  At the same time, each piece or art is being tracker by Mentaport off chain and is being registered as an IP to Story protocol. This combination is very powerful because if you find an image in the web2 land,   now you can edit it with Cara and automatically Cara will detect the owner and allow you to create a  new IP but with the incredible add-on of derivatives from Story. The project was broken into three main parts.\nPart 1: Gen AI: Part 2: Story: Part 3: Mentaport Part 4: Dynamic:",
        "how_its_made": "The project was broken into three main parts.\nPart 1: Gen AI: Part 2: Story: Part 3: Mentaport Part 4: Dynamic:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/nfx44/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/uwio1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/k5651/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/uxpk2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/f0icx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/nirxd/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/thinkmariale/cara-ip",
        "link": "https://ethglobal.com/showcase/cara-ip-x03th"
    },
    {
        "title": "Carbon Wheel",
        "brief_description": "CarbonWheel is a platform that incentivizes electric vehicle (EV) users by rewarding them with carbon credits for their contributions to environmental sustainability.",
        "long_description": "EVs inherently track the number of miles driven, and we leverage this data to calculate the environmental impact. Specifically, driving a gasoline car emits approximately 404 grams of carbon per mile, which is avoided by EV users. Through this calculation, EV drivers contribute to saving the planet by reducing around 0.4 metric tons of carbon for every 1,000 miles driven. When users choose to redeem their carbon credits through our dashboard, the saved carbon is added to a pool, which is then auctioned to the highest bidder. The profits from these auctions are automatically redistributed to the credit holders, with a portion retained by the platform as a fee for facilitation. The foundation of CarbonWheel was built using the Scaffold-ETH 2 template to accelerate development. I created the core smart contract using Remix, which facilitates the minting of carbon credit NFTs. This contract was deployed on Flow's testnet to ensure scalability and efficient transaction handling. To manage the minting process, I integrated WAGMI for seamless interaction between the frontend and blockchain, while leveraging ethers.js for asynchronous contract management. Ethers.js allowed me to handle contract operations with a high degree of flexibility and efficiency. Additionally, I developed frontend simulations to model future features and scenarios that are planned but not yet implemented, ensuring the project remains adaptable for future growth. By incorporating these technologies, the project achieves an efficient, scalable structure with clear pathways for further enhancements and real-world application.",
        "how_its_made": "The foundation of CarbonWheel was built using the Scaffold-ETH 2 template to accelerate development. I created the core smart contract using Remix, which facilitates the minting of carbon credit NFTs. This contract was deployed on Flow's testnet to ensure scalability and efficient transaction handling. To manage the minting process, I integrated WAGMI for seamless interaction between the frontend and blockchain, while leveraging ethers.js for asynchronous contract management. Ethers.js allowed me to handle contract operations with a high degree of flexibility and efficiency. Additionally, I developed frontend simulations to model future features and scenarios that are planned but not yet implemented, ensuring the project remains adaptable for future growth. By incorporating these technologies, the project achieves an efficient, scalable structure with clear pathways for further enhancements and real-world application.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/ach4g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/7arh4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/ny24e/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kgobin2000/carbon-wheel-v1",
        "link": "https://ethglobal.com/showcase/carbon-wheel-2x3ta"
    },
    {
        "title": "Carbon Wheel",
        "brief_description": "CarbonWheel is a platform that incentivizes electric vehicle (EV) users by rewarding them with carbon credits for their contributions to environmental sustainability.",
        "long_description": "EVs inherently track the number of miles driven, and we leverage this data to calculate the environmental impact. Specifically, driving a gasoline car emits approximately 404 grams of carbon per mile, which is avoided by EV users. Through this calculation, EV drivers contribute to saving the planet by reducing around 0.4 metric tons of carbon for every 1,000 miles driven. When users choose to redeem their carbon credits through our dashboard, the saved carbon is added to a pool, which is then auctioned to the highest bidder. The profits from these auctions are automatically redistributed to the credit holders, with a portion retained by the platform as a fee for facilitation. The foundation of CarbonWheel was built using the Scaffold-ETH 2 template to accelerate development. I created the core smart contract using Remix, which facilitates the minting of carbon credit NFTs. This contract was deployed on Flow's testnet to ensure scalability and efficient transaction handling. To manage the minting process, I integrated WAGMI for seamless interaction between the frontend and blockchain, while leveraging ethers.js for asynchronous contract management. Ethers.js allowed me to handle contract operations with a high degree of flexibility and efficiency. Additionally, I developed frontend simulations to model future features and scenarios that are planned but not yet implemented, ensuring the project remains adaptable for future growth. By incorporating these technologies, the project achieves an efficient, scalable structure with clear pathways for further enhancements and real-world application.",
        "how_its_made": "The foundation of CarbonWheel was built using the Scaffold-ETH 2 template to accelerate development. I created the core smart contract using Remix, which facilitates the minting of carbon credit NFTs. This contract was deployed on Flow's testnet to ensure scalability and efficient transaction handling. To manage the minting process, I integrated WAGMI for seamless interaction between the frontend and blockchain, while leveraging ethers.js for asynchronous contract management. Ethers.js allowed me to handle contract operations with a high degree of flexibility and efficiency. Additionally, I developed frontend simulations to model future features and scenarios that are planned but not yet implemented, ensuring the project remains adaptable for future growth. By incorporating these technologies, the project achieves an efficient, scalable structure with clear pathways for further enhancements and real-world application.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/ach4g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/7arh4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/ny24e/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kgobin2000/carbon-wheel-v1",
        "link": "https://ethglobal.com/showcase/carbon-wheel-2x3ta"
    },
    {
        "title": "LensChain",
        "brief_description": "Lens Chain is a user-friendly NFT platform specifically designed for photographers to mint, showcase, and trade their unique prints. (not fully done yet)",
        "long_description": "Lens Chain is a user-friendly NFT platform specifically designed for photographers to mint, showcase, and trade their unique prints NFTs. Users can easily upload their images, provide descriptions, and set prices. They can explore and appreciate a diverse collection of photographic art on the chain created by others, fostering community engagement. With seamless wallet connectivity and integrated custom poem generation to give the prints and their artists an opportunity to add a classical dimension to their appeal. We used Scaffold-ETH2 to build this Ethereum dApp and simplify the interactions with the smart contract - solidity. Therefore Wagmi and Next.js - React - Tailwind CSS on the Frontend/styling. We used IPFS for the  decentralized uploading functionality.\nWe added a fun feature using OpenAI to generate poems for the minted prints.",
        "how_its_made": "We used Scaffold-ETH2 to build this Ethereum dApp and simplify the interactions with the smart contract - solidity. Therefore Wagmi and Next.js - React - Tailwind CSS on the Frontend/styling. We used IPFS for the  decentralized uploading functionality.\nWe added a fun feature using OpenAI to generate poems for the minted prints.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2n6nx/screenshots/2kjky/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2n6nx/screenshots/t3330/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2n6nx/screenshots/1dqh0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AndrewRot/lens-chain",
        "link": "https://ethglobal.com/showcase/lenschain-2n6nx"
    },
    {
        "title": "Decl Prediction Mrkt",
        "brief_description": "A very simply prediction market implementation on using Essential's declarative smart contracts.",
        "long_description": "Essential smart contracts are declarative, meaning that you only define the constraints that state transitions must satisfy rather than the details of how those state transitions are accomplished. This project defines a system with Users, Oracles, and Markets. Each User is controlled by its creator and has a balance and can bet on Markets. An Oracle is controlled by its creator, starts unresolved, and can become resolved as true or false at any time (but stays resolved once resolved). A Market is not controlled by anyone, but is linked to an Oracle upon creation. When the Market is unresolved, then any user can bet on either the true or false outcome of the Market. When the Oracle resolves, then the Market resolves, and the money bet on the Market is distributed only to the winning bettors. All of this happens only within the contracts system, so no actual tokens are being transferred (that would be for future work). I also made a simplifying assumption that only two bettors (one for true and one for false) can bet on a Market. I was able to model the entire system in the Pint smart contract, but I was not able to finish writing all of the Rust interactions for testing it. Please note that I forked the Essential example integrations repository, and my contributions are only in the apps/prediction-market sub-directory. I used the basic setup that Essential recommends -- the contracts are written in Pint, and the interactions are written in Rust using the setup demonstrated in the essential-integration/apps examples. In particular, the Rust implements two things: the library for reflecting interactions with the contract, and a test suite that uses the library to test scripted sequences of interactions.",
        "how_its_made": "Please note that I forked the Essential example integrations repository, and my contributions are only in the apps/prediction-market sub-directory. I used the basic setup that Essential recommends -- the contracts are written in Pint, and the interactions are written in Rust using the setup demonstrated in the essential-integration/apps examples. In particular, the Rust implements two things: the library for reflecting interactions with the contract, and a test suite that uses the library to test scripted sequences of interactions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/nocgs/screenshots/wg80r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nocgs/screenshots/vhojt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nocgs/screenshots/fwtqt/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/rybla/essential-integration/",
        "link": "https://ethglobal.com/showcase/decl-prediction-mrkt-nocgs"
    },
    {
        "title": "BuildBlocks",
        "brief_description": "With BuildBlocks, we have created drag and drop dynamic smart contract components and a platform that allows *anyone* to develop, compile, and deploy audited smart contracts on Rootstock",
        "long_description": "There is a huge barrier of entry when it comes to entering the web3 space. A minor mistake in your code can cost you thousands of dollars! Firms and companies spend hundreds of thousands of dollars auditing their smart contracts to ensure that there are no exploits in their code, but with BuildBlocks, we have created drag and drop dynamic smart contract components and a platform that allows anyone to develop, compile, and deploy reviewed smart contracts on Rootstock. Using a Retrieval pipeline on audited DeFi contracts from resources such as Uniswap, OpenZeppelin, etc., BuildBlocks allows for users to use easy-to-understand blocks to create extremely intensive smart contracts in the blink of an eye. We built BuildingBlocks using the standard NextJS, Tailwind stack, but on top of that, we used injectable wallets, the Rootstock deployment and test network, the SolC compiler for automated Solidity contract compilation, and SIDAI's RAG pipeline generation service which we created buckets of audited Solidity smart contracts.",
        "how_its_made": "We built BuildingBlocks using the standard NextJS, Tailwind stack, but on top of that, we used injectable wallets, the Rootstock deployment and test network, the SolC compiler for automated Solidity contract compilation, and SIDAI's RAG pipeline generation service which we created buckets of audited Solidity smart contracts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/6s6f2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/x2db3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/awpza/default.jpg",
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/ggjs9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/mri2g/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sanjayamirthraj/blockbuild",
        "link": "https://ethglobal.com/showcase/buildblocks-af74h"
    },
    {
        "title": "Swapped",
        "brief_description": "Monetize your digital persona with ethical deep fakes\u2014upload, create, and earn through secure face-swap videos while preserving your anonymity",
        "long_description": "Swapped is a revolutionary NFT marketplace where your digital persona becomes a monetizable asset. Ideal for creators, influencers, public figures and brands, Swapped lets you upload your photos or AI-generated identities as NFTs, granting you full ownership and control over your digital identity. Swappers can use these NFTs to create safe, secure deep fakes via face-swap videos, allowing your persona to generate income while ensuring anonymity and ethical use. Flow is the trust, payment and NFT marketplace. We created a custom NFT that is used to manage users purchasing and selling likenesses. NFT's can be used to validate content was authorized by it's creator. Walrus for hosting distributed files. We needed defi storage for the NFTs. Dynamic for decentralized identity management and smooth Web3 onboarding. This allows us to onboard users to our platform easily. We use a Python server we built to process videos, images and swap their faces",
        "how_its_made": "Flow is the trust, payment and NFT marketplace. We created a custom NFT that is used to manage users purchasing and selling likenesses. NFT's can be used to validate content was authorized by it's creator. Walrus for hosting distributed files. We needed defi storage for the NFTs. Dynamic for decentralized identity management and smooth Web3 onboarding. This allows us to onboard users to our platform easily. We use a Python server we built to process videos, images and swap their faces",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/xuobm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/4e5tj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/tttrw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/xtrn9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/goasn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/j-sp4/ethglobal-SF-2024",
        "link": "https://ethglobal.com/showcase/swapped-yhddc"
    },
    {
        "title": "Walruspecs",
        "brief_description": "Client-side object detection app deployed as a Walrus site. The app's dependencies are packaged into the project and published as a Walrus blob. The object detection model runs on the client's browser (thanks to transformers.js) without needing a web server for computation.",
        "long_description": "The project demonstrates the feasibility of deploying a packaged AI model to a Walrus blob, which would charge its users based on their usage. e.g. every time someone runs the object detection model, the user will pay the creator a fixed amount of money. The application has no external dependencies, which makes the app safe from other points of failures. This project uses transformers.js to enable an AI model run on the client side. For object detection, it uses detr-resnet-50 model with the confidence threshold of 50% i.e. any predictions with a confidence level below 50% will be omitted in the results. The application has been uploaded with Bootstrap's minified CSS/JS, transformers.js, and detr-resnet-50 ONNX model weights.",
        "how_its_made": "This project uses transformers.js to enable an AI model run on the client side. For object detection, it uses detr-resnet-50 model with the confidence threshold of 50% i.e. any predictions with a confidence level below 50% will be omitted in the results. The application has been uploaded with Bootstrap's minified CSS/JS, transformers.js, and detr-resnet-50 ONNX model weights.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mtyf9/screenshots/bkycn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtyf9/screenshots/djm75/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtyf9/screenshots/kxyp0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/walrusblob/object-detection",
        "link": "https://ethglobal.com/showcase/walruspecs-mtyf9"
    },
    {
        "title": "Baldr",
        "brief_description": "Baldr is an open source gaming escrow platform which aims to resolve disputes and provide clear resolution for all users. With trust and transparency using sign protocol upon user attestations.",
        "long_description": "Traditional trading of gaming items often lacks transparency and security, leading to disputes and fraudulent activities. Current escrow services may not adequately address these issues, leaving users vulnerable to scams and conflicts. Baldr aims to solve these problems by providing a decentralized escrow platform that leverages AI and blockchain technology to ensure transparent and secure trading of gaming items. By integrating features like the Sign protocol for trade confirmations, dynamic wallets for multi-chain connectivity, and custom subgraphs for transaction analysis, Baldr seeks to establish trust and prevent fraudulent activities in the gaming ecosystem. Baldr is an open-source gaming escrow platform designed to facilitate trading of gaming items while resolving disputes with transparency. It integrates AI to monitor trades and detect suspicious behavior, using a custom subgraph to analyze historical trade events. Baldr employs the Sign protocol for trade confirmations and uses dynamic wallets to connect buyers and sellers across multiple blockchains. It supports Near and Solana ecosystems for trade monitoring and plans to leverage SKALE for gasless transactions. The platform also incorporates Story protocol to protect intellectual property rights of gaming items.",
        "how_its_made": "Baldr is an open-source gaming escrow platform designed to facilitate trading of gaming items while resolving disputes with transparency. It integrates AI to monitor trades and detect suspicious behavior, using a custom subgraph to analyze historical trade events. Baldr employs the Sign protocol for trade confirmations and uses dynamic wallets to connect buyers and sellers across multiple blockchains. It supports Near and Solana ecosystems for trade monitoring and plans to leverage SKALE for gasless transactions. The platform also incorporates Story protocol to protect intellectual property rights of gaming items.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/2fsug/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/hey0w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/cjt8p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/bibkh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/zfybe/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/SwineCoder101/baldr",
        "link": "https://ethglobal.com/showcase/baldr-wyv9f"
    },
    {
        "title": "PPP",
        "brief_description": "An app that allows users to set up and manage personal pension funds using any ERC-20 token",
        "long_description": "Create your own pension fund linked to any ERC-20 token. This app allows you to deposit, withdraw, invest, and pass on your funds to another person if no proof of life is provided within three years. Features: ERC-20 Compatibility: The contract supports any ERC-20 token (USDC is used in this demo).\nFlexible Withdrawals: The account holder can withdraw funds anytime.\nProof of Life: Regular interactions with the contract ensure continued access and can be manually updated. The project was built using Scaffold-ETH 2 as the foundation for both the frontend and smart contracts. A security layer was added with OpenZeppelin, implementing ReentrancyGuard, Ownable, and Pausable functions. Additionally, a frame was created to interact directly with the  smart contract in Farcaster, along with an XMTP bot to enable chat-based communication. The smart contract is deployed across multiple blockchains, offering users broad interoperability.",
        "how_its_made": "The project was built using Scaffold-ETH 2 as the foundation for both the frontend and smart contracts. A security layer was added with OpenZeppelin, implementing ReentrancyGuard, Ownable, and Pausable functions. Additionally, a frame was created to interact directly with the  smart contract in Farcaster, along with an XMTP bot to enable chat-based communication. The smart contract is deployed across multiple blockchains, offering users broad interoperability.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zzjn9/screenshots/d51yy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zzjn9/screenshots/nmkca/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zzjn9/screenshots/uou6n/default.jpg"
        ],
        "live_demo": "https://secure-retire.vercel.app/",
        "source_code": "https://github.com/fedeloterstein/ethglobal-sf",
        "link": "https://ethglobal.com/showcase/ppp-zzjn9"
    },
    {
        "title": "NeoGraph",
        "brief_description": "NeoGraph is a highly powerful and extensible data visualization tool, that seeks to provide new and interactive ways of deriving meaning of otherwise hard to sift through data.",
        "long_description": "NeoGraph is a powerful and extensible tool for building highly interactive data visualizations. As developers and people in tech, we often rely on text to convey meaning, because it is highly interoperable with other text. Which makes up the majority of our tooling with things like log files and code. However text is not a rich medium for expression, because our brains did not evolve to read text. They evolved to identify patterns in visual data. Think of the difference in trying to understand the raw data of an image file, compared to the image it actually represents! The problem with most solutions to this problems, are that most data visualizations are \"lossy\", that is the output of a visualization is only a picture, and not data itself. This heavily restricts how useful these kinds of programs can be. However this is not true in the case of our tool. So what we built, is a tool that is as extensible and usable as text, but provides a much richer medium for visual expression. And with this tool, we can render data sets that your brain can immediately draw meaningful conclusions from, without needing to parse through text or take someone elses word. All while not sacrificing the contextual power that raw data provides. The way our program achieve this, is by making all visualizations living programs that can be modified and used on the fly. What this means, in a visualization, you can interact with an element in the data set, and use it as the starting point of the next meaningful query. Because all elements in the visualization are just a special view on the underlying data object. The uses for this are widespread. Let's walk through a few. DAO Tooling\nIn the case of DAO tooling, we would use this tool to provide views into, for example, what a proposal will mean for the DAO. Another example would be showing the meaningful impact of previous and historical proposals. All of these examples could then be further composed into a single view, which allows us to compose these to build a better story of the data we are trying to explain. Subgraph Data Exploration\nWith our tool, users can query subgraphs or other data sources, and visualize how all of the nodes are related. Upon selecting a node, or sets of nodes, they can use this specific entity as the starting point for a new query, which won't modify our initial view. We built this project using:\nPharo smalltalk\nThe Streamline programming language\nThe graph (as our primary data source for visualizations) Using pharo gives us a ton of super powerful data visualization tools. And without it the project would have been impossible in this timeframe. Using the graph was also pretty fun. But the file data sources were very frustrating to get functional. Additionally the substreams endpoints kept going down for us as we were building. Not good! Streamline was also great. I don't think we could have iterated as fast as we could have without it. All in all we are pretty happy with what we managed to spit out in just over a day!",
        "how_its_made": "We built this project using:\nPharo smalltalk\nThe Streamline programming language\nThe graph (as our primary data source for visualizations) Using pharo gives us a ton of super powerful data visualization tools. And without it the project would have been impossible in this timeframe. Using the graph was also pretty fun. But the file data sources were very frustrating to get functional. Additionally the substreams endpoints kept going down for us as we were building. Not good! Streamline was also great. I don't think we could have iterated as fast as we could have without it. All in all we are pretty happy with what we managed to spit out in just over a day!",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0ffz5/screenshots/jtwvz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0ffz5/screenshots/xkog1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0ffz5/screenshots/e0kxm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MercuricChloride/streamline-hackathon",
        "link": "https://ethglobal.com/showcase/neograph-0ffz5"
    },
    {
        "title": "Aloria",
        "brief_description": "A decentralized omni-powerful AI personal assistant that can complete all kinds of tasks by operating directly on web browser",
        "long_description": "This project uses AI agents to plan tasks, parse images and execute steps of all kinds of tasks by operating on a web browser. Users need to login with their wallet, pay the node that host the service to ask AI agents to complete tasks like booking tickets, monitoring news or price changes, gathering information from reddit, etc. Users can also publish their task prompts to claim ownership. XMTP sends users asynchronous updates about their tasks. The app is built with next.js and typescript and we use:",
        "how_its_made": "The app is built with next.js and typescript and we use:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gfwo5/screenshots/ntm8f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gfwo5/screenshots/yrr9h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gfwo5/screenshots/8d2d1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gfwo5/screenshots/xde3i/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/tkeith/aloria",
        "link": "https://ethglobal.com/showcase/aloria-gfwo5"
    },
    {
        "title": "HOA Insight",
        "brief_description": "Home Owners Association Board Members want to do right by their communities. HOA Insight Smart Contracts help Board Members evaluate and vote on Proposals, Quotes and Funds Allocation, with transparency to their community.",
        "long_description": "The Home Owners Association Board Members don't always to do right by their community when evaluating proposals and finding high quality contractors to fulfill those proposals. That said, most of them also have full-time jobs, and time is limited. A home owner brought them the idea of setting up a HOAInsight Smart Contract. When a new proposal is brought to the HOA, they enter the Project Requirements and the Budget in HOAInsight. All Board Members receive a notification to vote on it in the mobile app. If the proposal receives unanimous vote (as written in Redwood Greens Bylaws), the funds are made available to the HOA Treasurer. Those funds can now be used to pay contracting company's invoice. We began the project using Miro for brainstorming and gathering essential tools to help us build the prototype. For the UI, we used Figma to design a seamless user experience. To generate demo data, we utilized AI tools like ChatGPT and Perplexity. Our tech stack includes HTML, CSS, JavaScript, with Next.js and React for front-end development, while Node.js powers the backend. We also integrated Hardhat for smart contract development, Remix, and Rainbow Wallet for seamless wallet connectivity.",
        "how_its_made": "We began the project using Miro for brainstorming and gathering essential tools to help us build the prototype. For the UI, we used Figma to design a seamless user experience. To generate demo data, we utilized AI tools like ChatGPT and Perplexity. Our tech stack includes HTML, CSS, JavaScript, with Next.js and React for front-end development, while Node.js powers the backend. We also integrated Hardhat for smart contract development, Remix, and Rainbow Wallet for seamless wallet connectivity.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5bc3h/screenshots/m1wgi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5bc3h/screenshots/p4bg1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5bc3h/screenshots/qgakj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/aldenio/hoa",
        "link": "https://ethglobal.com/showcase/hoa-insight-5bc3h"
    },
    {
        "title": "$deeproot",
        "brief_description": "Build a bitcoin  meme-defi dAPP  on RootStock protocol, implementing Reflection Token Reward Logic",
        "long_description": "We built and deployed a rootstock smart contract implementation from scratch. This project involves developing a  A Bitcoin meme-defi-DAO-governance dAPP  on RootStock , with Reflection Token  Logic  in BitMask web wallet.  We equally built and deployed ERC20, ERC721, IERC20 token standards in Rootstock. The reflection mechanism rewards token holders through automatic reflections or dividends from transactions, encouraging long-term holding. The dApp is deployed within the BitMask Wallet, enabling users to seamlessly interact with the decentralized financial ecosystem built on Bitcoin. The integration with MetaMask allows users to connect their MetaMask wallet to interact with the dApp, facilitated by RainbowKit, a popular library for wallet connection. The deployment of the RootStock smart contract enables secure, scalable, and low-cost financial transactions using Bitcoin's Layer 2. The smart contract will manage reflection rewards and allow users to participate in liquidity pools. $deeproot not only bridges Bitcoin and Ethereum\u2019s DeFi ecosystem but also establishes a solid foundation for future Bitcoin-evm financial applications. Smart Contract Development on RootStock (RSK) we built an ERC-20 token smart contract using Solidity on RootStock with built-in reflection mechanisms. Reflection tokens automatically redistribute a percentage of each transaction to holders based on their holdings, creating passive income.\nThis contract would include methods like transfer, approve, and rewardDistribution. Implement the logic so that each transaction applies a fee that gets distributed among token holders. Integration with BitMask Web Wallet and MetaMask\nWe used RainbowKit to bridge the interaction between MetaMask and BitMask. This will allow users to connect their MetaMask wallet to BitMask's dApp where the contract is deployed. We built a frontend web-based user interface (UI) for the dApp, allowing users to:\nView balances, interact with the contract, such as buying or transferring tokens. We made sure that RootStock is set as a custom network in MetaMask. verifying details such as the RPC URL, chain ID, and network name.",
        "how_its_made": "Smart Contract Development on RootStock (RSK) we built an ERC-20 token smart contract using Solidity on RootStock with built-in reflection mechanisms. Reflection tokens automatically redistribute a percentage of each transaction to holders based on their holdings, creating passive income.\nThis contract would include methods like transfer, approve, and rewardDistribution. Implement the logic so that each transaction applies a fee that gets distributed among token holders. Integration with BitMask Web Wallet and MetaMask\nWe used RainbowKit to bridge the interaction between MetaMask and BitMask. This will allow users to connect their MetaMask wallet to BitMask's dApp where the contract is deployed. We built a frontend web-based user interface (UI) for the dApp, allowing users to:\nView balances, interact with the contract, such as buying or transferring tokens. We made sure that RootStock is set as a custom network in MetaMask. verifying details such as the RPC URL, chain ID, and network name.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/1cuho/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/4zpuw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/6vasc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/7atp2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/bkxg4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/1iyi6/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/trevor-ofarrell/rootstock-hardhat-starterkit",
        "link": "https://ethglobal.com/showcase/deeproot-dm8yg"
    },
    {
        "title": "EAT Global",
        "brief_description": "EAT stands for \"Epicurean Advice & Travel\" and lets users post reviews about their food and travel experiences, and allows users to collaborate to generate curated food guides.  Share, Eat, and Earn.",
        "long_description": "We looked at the travel and food review industry and the problem of personal recommendations versus generic recommendations, The problem EAT Global solves: It\u2019s a fragmented and time consuming process narrowing down places to eat in a new city Not always possible to find personal recommendations for every city you visit Traditional web 2 food reviewers are not yet able to participate in the IP economy and post valuable content without any future monetization potential EAT Global is a dApp that allows users to: Easily post Reviews of their food experiences with licensing and royalties using Story Protocol Generate curated food guides in collaboration with others Get rewarded for their reviews and an opportunity to sell to media and travel websites who want to feature their reviews and guides in their content Please see our pitch here: https://www.canva.com/design/DAGUEzO98bU/jL1l0FFAm6lqmq-YneFajg/view?utm_content=DAGUEzO98bU&utm_campaign=designshare&utm_medium=link&utm_source=editor Story Protocol and Dynamic.  We focused on implementing the \"Proof of Creativity\" protocol and worked on the royalty and the licensing contracts as well as creating derivative works with linage in our travel guide offering. The visualization of the Story explorer is very informative and helped us with building and testing and exploring the IP assets on the Story network.  Speaking with the Story team was very helpful and guided us towards a successful completion.  We used the Typescript SDK and look forward to also using the React SDK next time. We decided to implement this MVP live at the hackathon by conducting food reviews of the food trucks that were on site. We have focused on the beneifts of using easy sign-on with Dynamic and the benefits of Story, including curating food guides, bring social proof on home page, and ability to generate rewards via NFT badges indicating those who post more.",
        "how_its_made": "Story Protocol and Dynamic.  We focused on implementing the \"Proof of Creativity\" protocol and worked on the royalty and the licensing contracts as well as creating derivative works with linage in our travel guide offering. The visualization of the Story explorer is very informative and helped us with building and testing and exploring the IP assets on the Story network.  Speaking with the Story team was very helpful and guided us towards a successful completion.  We used the Typescript SDK and look forward to also using the React SDK next time. We decided to implement this MVP live at the hackathon by conducting food reviews of the food trucks that were on site. We have focused on the beneifts of using easy sign-on with Dynamic and the benefits of Story, including curating food guides, bring social proof on home page, and ability to generate rewards via NFT badges indicating those who post more.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/izfgq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/tt302/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/at6g5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/9dz1p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/kz6av/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/gr01u/default.jpg"
        ],
        "live_demo": "https://eatglobal.vercel.app/ ",
        "source_code": "https://github.com/Dangoz/EthSF",
        "link": "https://ethglobal.com/showcase/eat-global-hdcq6"
    },
    {
        "title": "Neurosaurs",
        "brief_description": "A concentration game powered by the Neurosity Crown! Mint Neurosaur NFTs depending on how focused you are during the game.",
        "long_description": "Unlock the power of your mind with our concentration game powered by the Neurosity Crown! Dive into the classic Chrome Dino game like never before, where your focus determines the outcome. As you play, the Neurosity Crown tracks your concentration levels in real-time, transforming your mental focus into digital rewards. The more you concentrate, the better the rare dino NFT you'll receive as a testament to your skills. It's not just a game; it's a unique fusion of neurotechnology and blockchain that turns your mental prowess into collectible assets. Train your brain, level up your focus, and collect exclusive NFTs to show off your mental game!",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/a8r8k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/jin6g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/v25ra/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/wnvwy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/vzzj4/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MattWong-ca/neurosaurs",
        "link": "https://ethglobal.com/showcase/neurosaurs-4ymov"
    },
    {
        "title": "MAO One",
        "brief_description": "Chat GPT use twitter posts and onchain data to trustless manage funds via Intell SGX, XMTP and Smart Contract.",
        "long_description": "The service to create machine-controlled Smart Contracts. These organizations are managed autonomously and transparently\u2014without any human interference! At the core of MAO lies the integration of advanced security and cryptographic technologies, granting AI unconditional control over users' funds. To obtain real-world information, MAO One relies on X.com (formerly Twitter)\u2014the most open social platform supporting free speech. Users can submit a tweet from an account (whether personal, organizational, or governmental) to verify real-world events. For example, users could submit an election result tweet from the @POTUS account to confirm the outcome. This enables MAO to respond to real-world events promptly and support community members efficiently. Every government has its laws to guide decisions, and in MAO, these laws are captured in the Manifest\u2014the organization\u2019s core document. The Manifest defines: MAO is built around Intel SGX (Software Guard Extensions) technology. These specialized chips run immutable code in a secure, isolated environment and are capable of generating cryptographic signatures. On October 19, 2024, the first instance\u2014\"MAO One\"\u2014was deployed within an SGX chip. This instance guarantees the secure operation of all MAO systems. The process begins when MAO One listens for anonymous messages via the XMTP protocol. Upon receiving a request, the message is forwarded to the central controller\u2014ChatGPT. Communications between MAO One and ChatGPT servers are encrypted using pre-configured TSL certificates, ensuring that no third party can interfere. If the controller authorizes a transaction, MAO One signs it with its private key and sends the signed transaction back to the user via XMTP. The user can then execute the transaction on a blockchain. MAO One can fetch on-chain data from TheGraph via a secure TSL channel. This enables ChatGPT to access essential blockchain information, such as token balances, prices, holders, and transaction volumes. This data allows MAO to make informed decisions based on current blockchain states. Thanks to Intel SGX technology, the \"MAO One\" code is immutable and cannot be altered. All MAOs built on this platform operate exclusively through ChatGPT.",
        "how_its_made": "MAO is built around Intel SGX (Software Guard Extensions) technology. These specialized chips run immutable code in a secure, isolated environment and are capable of generating cryptographic signatures. On October 19, 2024, the first instance\u2014\"MAO One\"\u2014was deployed within an SGX chip. This instance guarantees the secure operation of all MAO systems. The process begins when MAO One listens for anonymous messages via the XMTP protocol. Upon receiving a request, the message is forwarded to the central controller\u2014ChatGPT. Communications between MAO One and ChatGPT servers are encrypted using pre-configured TSL certificates, ensuring that no third party can interfere. If the controller authorizes a transaction, MAO One signs it with its private key and sends the signed transaction back to the user via XMTP. The user can then execute the transaction on a blockchain. MAO One can fetch on-chain data from TheGraph via a secure TSL channel. This enables ChatGPT to access essential blockchain information, such as token balances, prices, holders, and transaction volumes. This data allows MAO to make informed decisions based on current blockchain states. Thanks to Intel SGX technology, the \"MAO One\" code is immutable and cannot be altered. All MAOs built on this platform operate exclusively through ChatGPT.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/da928/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/c8i2d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/wx2ys/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/r2sf3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/7zb5n/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/pvolnov/sgx-ai-dao",
        "link": "https://ethglobal.com/showcase/mao-one-wyviu"
    },
    {
        "title": "TrailLink",
        "brief_description": "An open Protocol for Marketing Teams to launch campaigns and events onchain",
        "long_description": "We built an NFT ticketing and event curation platform that allows users to mint an NFT for entrance to an event and then go through guided/curated tasks that can earn them points for attend IRL events. This helps protocols incentivize and reward users who show up no only onchain but in real life as well. All interactions happen through a Telegram App with virtually no wallet or gas interactions making this a user friendly onchain activity for anyone. The two frontends (one for marketers and one for end users) are built with Next JS. With one of the frontends deployed as a web page and the user facing one deployed as a Telegram Mini App. We deployed our smart contracts on Polygon, any marketer can deploy NFT campaigns and create tasks without any code thanks to our factory contract on the Polygon Testnet. And we leverage Dynamic for wallets as well as ZeroDev to help with Account Abstraction for better user experience.",
        "how_its_made": "The two frontends (one for marketers and one for end users) are built with Next JS. With one of the frontends deployed as a web page and the user facing one deployed as a Telegram Mini App. We deployed our smart contracts on Polygon, any marketer can deploy NFT campaigns and create tasks without any code thanks to our factory contract on the Polygon Testnet. And we leverage Dynamic for wallets as well as ZeroDev to help with Account Abstraction for better user experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tfpov/screenshots/yox2z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tfpov/screenshots/jnyp5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tfpov/screenshots/co3g6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tfpov/screenshots/o27kr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kasba96/tg-app",
        "link": "https://ethglobal.com/showcase/traillink-tfpov"
    },
    {
        "title": "Stackr ERC721",
        "brief_description": "Modular implementation of ERC721 in Stackr deployed on AvailDA",
        "long_description": "The general idea was to play with Stackr, a framework to build rollups. For this, I wanted to develop a project that relies on known open standards, namely ERC-721 in this case. The idea was to be able to: However, it turns out that Stackr cannot do async transitions, so the image generation part is not quite possible. I thus ended up just playing with Stackr and implementing ERC-721 in a nice and extensible way instead and to deploy the result with Avail as the DA. It mostly just uses Stackr's SDK and CLI. The ERC-721 implementation is based on Solmate's, and quite some work went into architecture decisions to be able to easily import the base ERC-721 functions and extend the ones necessary for the application. A lot of thought also went into types.",
        "how_its_made": "It mostly just uses Stackr's SDK and CLI. The ERC-721 implementation is based on Solmate's, and quite some work went into architecture decisions to be able to easily import the base ERC-721 functions and extend the ones necessary for the application. A lot of thought also went into types.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/15c7x/screenshots/br4uk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/15c7x/screenshots/7xpq1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/15c7x/screenshots/i2hcf/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/filoozom/mru-nfts",
        "link": "https://ethglobal.com/showcase/stackr-erc721-15c7x"
    },
    {
        "title": "Meta Splash",
        "brief_description": "Beautiful lock screens for MetaMask. We redesigned the lock screen for most used crypto wallet MetaMask.",
        "long_description": "To make Ethereum more inviting, we redesigned the lock screen for most used crypto wallet MetaMask. MetaMask wallet is the entry point to Ethereum user experience. Current wallet lock screen is sterile and overly functional, making the first impression technical and uninviting. Proposed lock screen offers wide range of graphics. Users can chose from simple colors to extravagant patterns. We used Adobe Illustrator for vector graphics and Stable Diffusion for graphic backgrounds. Application of the lock screen redesign would involve partnership with existing wallet projects or creation of a custom wallet or DAP. The other screen asking for a stylistic redesign is the wait screen displayed to users while they wait for smart contract execution.",
        "how_its_made": "We used Adobe Illustrator for vector graphics and Stable Diffusion for graphic backgrounds. Application of the lock screen redesign would involve partnership with existing wallet projects or creation of a custom wallet or DAP. The other screen asking for a stylistic redesign is the wait screen displayed to users while they wait for smart contract execution.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/ijkti/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/me9qx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/rs8zy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/z081n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/fqiet/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/xk9yj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/d86us/metasplash",
        "link": "https://ethglobal.com/showcase/meta-splash-suf85"
    },
    {
        "title": "freeTrader",
        "brief_description": "A smart contract that trade according to user defined price and real time price",
        "long_description": "This prj include both smart contract piece and a frontend This prj include both smart contract piece and a frontend\nThe smart contract is written in solidity.\nThe frontend is written using NextJS framework. Key Elements\nUser-defined price: A function that allows the user to set a price.\nOracle integration: Use a Chainlink oracle (or another service like Chronicle) to fetch real-time price data.\nUniswap interaction: Utilize Uniswap\u2019s contract to swap USDC for ETH when a condition is met.",
        "how_its_made": "This prj include both smart contract piece and a frontend\nThe smart contract is written in solidity.\nThe frontend is written using NextJS framework. Key Elements\nUser-defined price: A function that allows the user to set a price.\nOracle integration: Use a Chainlink oracle (or another service like Chronicle) to fetch real-time price data.\nUniswap interaction: Utilize Uniswap\u2019s contract to swap USDC for ETH when a condition is met.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/cjm7o/screenshots/q58wi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cjm7o/screenshots/tjhx8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cjm7o/screenshots/35pia/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/thinkvic/hacksf2024",
        "link": "https://ethglobal.com/showcase/freetrader-cjm7o"
    },
    {
        "title": "StoryVerse",
        "brief_description": "Authors craft unique universes by defining key elements such as lore, environments, characters, and interactions. Build off another author's world, protect your IP and receive royalties.",
        "long_description": "Alex, a passionate fantasy writer, uses our platform to create an expansive new universe. With advanced IP technology, Alex defines the licensing terms, allowing fans to legally build upon their favorite worlds. Fans contribute by crafting new stories within Alex\u2019s world, earning money for their work, while Alex earns royalties from each derivative. As the platform evolves, Alex's fans will be able to buy or rent stories, using encrypted smart contracts to ensure fair payment and limited-time access to the content, expanding Alex's universe with every contribution. We combine IP technology, and harness the power of fans to expand on artistic universes and explore new frontiers of their favorite worlds. We enable fans to earn money for their contributions while sharing a fair amount with the original creator as well. We plan to support the full E2E marketplace in the future, allowing folks to buy/rent content and we will implement that using an encryption protocol with smart contract conditional permissioning based on an expiration date that gets set on the user when they pay for access and it's incremented every time they pay for more access. We use Story to power our IP, Pi\u00f1ata to store the works themselves, and dynamic for our authentication flow. We integrated with the story-sdk, dynamic's sample application / sdk, and pi\u00f1atas SDK. Story handled generating an IP object that stored an ID corresponding to a Pi\u00f1ata object that contained the summary of the artist's world itself.",
        "how_its_made": "We use Story to power our IP, Pi\u00f1ata to store the works themselves, and dynamic for our authentication flow. We integrated with the story-sdk, dynamic's sample application / sdk, and pi\u00f1atas SDK. Story handled generating an IP object that stored an ID corresponding to a Pi\u00f1ata object that contained the summary of the artist's world itself.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/7to6s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/fonh3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/6raqe/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/q4kbn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/f60oe/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/2r7hy/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/parsaattari/storyverse",
        "link": "https://ethglobal.com/showcase/storyverse-hot66"
    },
    {
        "title": "Betsy",
        "brief_description": "A Web3 betting platform on Skale with XMTP-powered messaging for group bets. USDC funds are transparently handled via smart contracts, and AI helps determine outcomes. Bets are finalized and resolved on-chain, ensuring secure, trustless, and engaging group betting experiences.",
        "long_description": "Betsy is a Web3-based group betting platform that allows friends and communities to place bets on sporting events in a decentralized, transparent, and fun way on SKALE blockchain. It uses XMTP's Converse app to leverage its group messaging feature and user wallets to create an immersive experience that allows people to place bets while they message and have fun. When a bet is created, group members can chat, agree or disagree with the predictions, and place their wagers, all within the platform. This makes betting more engaging and interactive, creating a shared experience around sporting events. Once the bet is finalized, smart contracts automatically move the funds, ensuring that everyone\u2019s contributions are handled fairly and securely. Additionally, the platform uses AI to analyze real-time sports data and help determine the outcome of each bet, ensuring accuracy and fairness. Once the game is over, the AI checks whether the prediction was correct, and the smart contracts distribute the winnings or losses accordingly. This combination of blockchain, decentralized messaging, and AI creates a seamless, fully automated betting experience where users can enjoy betting with friends, all while having complete control over their funds and the outcome. This project was built on the SKALE blockchain, taking advantage of its gas-free transactions, making it cost-efficient for users placing bets. We integrated XMTP\u2019s Converse app for decentralized messaging, allowing users to communicate in real-time, propose bets, and vote within group chats securely. The platform uses OpenAI's language models (LLMs) to parse user prompts, interpret natural language queries, and interact with external sports data feeds. This helps verify that games exist and process bet outcomes based on real-time sports data. The LLMs also assist in generating responses, making the interaction more natural and efficient. We implemented agents that monitor for specific triggers in user messages, such as bet prompts, agreements, or disagreements. These agents parse the commands, triggering actions such as fund transfers and game creation on-chain. All bets and outcomes are managed by smart contracts, ensuring that the process is fully trust-less and automated. The integration of ethers.js manages blockchain interactions, particularly for handling USDC approvals and fund transfers to the smart contract.",
        "how_its_made": "This project was built on the SKALE blockchain, taking advantage of its gas-free transactions, making it cost-efficient for users placing bets. We integrated XMTP\u2019s Converse app for decentralized messaging, allowing users to communicate in real-time, propose bets, and vote within group chats securely. The platform uses OpenAI's language models (LLMs) to parse user prompts, interpret natural language queries, and interact with external sports data feeds. This helps verify that games exist and process bet outcomes based on real-time sports data. The LLMs also assist in generating responses, making the interaction more natural and efficient. We implemented agents that monitor for specific triggers in user messages, such as bet prompts, agreements, or disagreements. These agents parse the commands, triggering actions such as fund transfers and game creation on-chain. All bets and outcomes are managed by smart contracts, ensuring that the process is fully trust-less and automated. The integration of ethers.js manages blockchain interactions, particularly for handling USDC approvals and fund transfers to the smart contract.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9qx39/screenshots/0bmw0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9qx39/screenshots/v0m9g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9qx39/screenshots/8u8kx/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ItsAdel/ethglobalsf2024",
        "link": "https://ethglobal.com/showcase/betsy-9qx39"
    },
    {
        "title": "SmolSend",
        "brief_description": "Send tokens to friends via a link, without them needing a wallet upfront",
        "long_description": "I want to send tokens to a friend that has never used crypto before. Traditionally, I would ask them to install metamask, they would proceed to download it and send me their address, and I would then send them the tokens. Wouldn't it be cool if we could send them a link that held crypto such that as soon as they onboarded they could play around with those tokens? Also, if I wanted to send tokens to my favorite Twitter KOL, they would want a way to receive the tokens without doxxing their wallet address to me The key insight here is that embedded wallets plus simple use of a hash function allows users to sign in with google to claim the tokens trustlessly This app is best viewed on a mobile browser! It is built with next pwa and is mobile first. Walrus: The Graph:\nWe use this to make sure users aren't submitting a duplicate password! Dynamic: Supported Chains:",
        "how_its_made": "This app is best viewed on a mobile browser! It is built with next pwa and is mobile first. Walrus: The Graph:\nWe use this to make sure users aren't submitting a duplicate password! Dynamic: Supported Chains:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/0vtv1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/e0ms9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/kp0it/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/c9suv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/m9e9d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/wnrao/default.jpg"
        ],
        "live_demo": "https://smolsend.vercel.app/",
        "source_code": "https://github.com/AlbertSu123/linkToLambo",
        "link": "https://ethglobal.com/showcase/smolsend-n3gsh"
    },
    {
        "title": "OmnichainFHEAuction",
        "brief_description": "Using fully-homomorphic encryption on Fhenix to implement second-price sealed bid auctions, and using LayerZero to allow bids from any chain, unifying liquidity: a global secret auction across all chains.",
        "long_description": "Auction creator creates an auction contract on Fhenix: The auction creator sets an auction start / end date, minimum bid, and code to run when the auction is won (e.g. automatically send an NFT). This code can be run cross-chain using LayerZero.\nUser visits our frontend, they want to bid on X Chain\nWe use Fhenix\u2019s FHE frontend library to encrypt their bid.\nEncrypted bid is sent to our bid submission smart contract on X Chain.\nWe also ask the user to approve the bid submission smart contract as a spender for UINT256_MAX\nWe use LayerZero to send the encrypted bid to our auction smart contract on Fhenix.\nThe auction contract stores the encrypted bit and the chain from which the bid originated.\nSince it\u2019s difficult to install on LayerZero on new chains, we\u2019re actually sending via Sepolia (the base cain for the Fhenix L2)\nAt the end of the auction period, the contract uses FHE to compare all bids and determine which bid is the highest\nWe use LayerZero to send a message back to the chain from which the bid originated and transfer the assets from the winning bidder.\nIf the transfer is unsuccessful, LayerZero can send message back and Fhenix contract can move on to next highest bidder Frontend which can grab data from Fhenix to show auction status and can send data to X Chain to submit bids\nFigure out how encrypt data with the Fhenix JS SDK and send it as arbitrary bytes to another smart contract Auction smart contract on Fhenix\nFigure out how to compare different encrypted values on Fhenix\nhttps://github.com/FhenixProtocol/blind-auction-example Bid submission contract on any L1 we want to support\nFigure out how to accept encrypted bytes LayerZero infrastructure to send data to and from other L1s and Fhenix\nFigure out how to send data between chains",
        "how_its_made": "Frontend which can grab data from Fhenix to show auction status and can send data to X Chain to submit bids\nFigure out how encrypt data with the Fhenix JS SDK and send it as arbitrary bytes to another smart contract Auction smart contract on Fhenix\nFigure out how to compare different encrypted values on Fhenix\nhttps://github.com/FhenixProtocol/blind-auction-example Bid submission contract on any L1 we want to support\nFigure out how to accept encrypted bytes LayerZero infrastructure to send data to and from other L1s and Fhenix\nFigure out how to send data between chains",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h4q81/screenshots/052is/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h4q81/screenshots/muu1t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h4q81/screenshots/1apo5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/nathanhleung/ethglobal",
        "link": "https://ethglobal.com/showcase/omnichainfheauction-h4q81"
    },
    {
        "title": "Things2Do",
        "brief_description": "Our Discovery Feed curates relevant news and offers based on user transaction history, driving higher engagement. By promoting actionable content, it boosts user retention, reduces churn, and encourages transactions.",
        "long_description": "Our Discovery Feed leverages the GrowthMate API to analyze user transaction history and rank posts based on individual interests. By interpreting on-chain activity, the API ensures users see content most relevant to them, including actionable news, offers, and suggested dApps. Users can choose the chain they want to explore and input any address to view content curated for that specific transaction history. This approach drives engagement by delivering personalized, interest-aligned recommendations, enhancing user retention and increasing the likelihood of completing transactions. This submission is frontend integration to the GrowthMate General Purpose Ranking API. The webpage was built using a default Vite React stack.",
        "how_its_made": "This submission is frontend integration to the GrowthMate General Purpose Ranking API. The webpage was built using a default Vite React stack.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pugqi/screenshots/9k9t0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pugqi/screenshots/3h7be/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pugqi/screenshots/t1yca/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/lennczar/eth-global-sf-2024",
        "link": "https://ethglobal.com/showcase/things2do-pugqi"
    },
    {
        "title": "ChainSage",
        "brief_description": "ChainSage: AI-powered DeFi strategy optimizer across multiple chains. Leverages Zircuit for high-performance smart contracts, LayerZero for cross-chain messaging, and Phala Network for confidential AI computations. Maximize your DeFi returns with personalized, secure insights.",
        "long_description": "ChainSage is an innovative AI-powered DeFi strategy optimizer that operates across multiple blockchain networks. The project aims to solve the challenge of identifying optimal investment strategies in the rapidly evolving DeFi landscape. It does this by aggregating strategies from various chains, using artificial intelligence to analyze and recommend optimal strategies based on user preferences, and providing a user-friendly interface for strategy comparison and selection.\nThe project leverages a sophisticated technology stack, including React.js for the frontend, Solidity for smart contracts, TensorFlow.js for AI modeling, and is primarily deployed on the Zircuit Testnet. It utilizes LayerZero for cross-chain messaging and Phala Network for confidential computing, ensuring privacy and security in AI computations. The core smart contract, ChainSageOApp, manages strategies across different chains and includes functions for adding strategies, retrieving data, and optimizing strategies cross-chain. With its focus on user experience, cross-chain functionality, and AI-driven insights, ChainSage represents a cutting-edge approach to DeFi strategy optimization, aiming to provide users with secure, efficient, and personalized investment recommendations across the fragmented DeFi ecosystem. This project is built on a foundation of Solidity smart contracts, with the main ChainSageOApp contract inheriting from LayerZero's OApp for cross-chain functionality. This allows ChainSage to manage and optimize DeFi strategies across various blockchain networks.\nThe frontend is developed using React.js, providing a user-friendly interface for interacting with the DeFi strategies. Key components include AIOptimizer for strategy fetching and optimization, StrategyDisplay for rendering strategy items, and WalletConnection for managing user wallet connections. The project integrates TensorFlow.js for AI-driven strategy analysis and recommendations, while Ethers.js facilitates blockchain interactions.\nChainSage incorporates several cutting-edge technologies to enhance its functionality and security. LayerZero's protocol enables cross-chain messaging and strategy optimization across different networks. Phala Network's SDK is integrated to ensure the privacy and security of AI model computations through confidential computing in a Trusted Execution Environment (TEE). The smart contracts are deployed on the Zircuit Testnet, taking advantage of its EVM-compatible environment, while the frontend is hosted on Vercel for reliable and fast access.\nThe development process included addressing challenges such as cross-chain data consistency and simulating AI decision-making for the hackathon demo. The project demonstrates the potential for sophisticated and secure DeFi applications by integrating blockchain technologies with AI, showcasing innovative solutions for DeFi strategy optimization across multiple chains.",
        "how_its_made": "This project is built on a foundation of Solidity smart contracts, with the main ChainSageOApp contract inheriting from LayerZero's OApp for cross-chain functionality. This allows ChainSage to manage and optimize DeFi strategies across various blockchain networks.\nThe frontend is developed using React.js, providing a user-friendly interface for interacting with the DeFi strategies. Key components include AIOptimizer for strategy fetching and optimization, StrategyDisplay for rendering strategy items, and WalletConnection for managing user wallet connections. The project integrates TensorFlow.js for AI-driven strategy analysis and recommendations, while Ethers.js facilitates blockchain interactions.\nChainSage incorporates several cutting-edge technologies to enhance its functionality and security. LayerZero's protocol enables cross-chain messaging and strategy optimization across different networks. Phala Network's SDK is integrated to ensure the privacy and security of AI model computations through confidential computing in a Trusted Execution Environment (TEE). The smart contracts are deployed on the Zircuit Testnet, taking advantage of its EVM-compatible environment, while the frontend is hosted on Vercel for reliable and fast access.\nThe development process included addressing challenges such as cross-chain data consistency and simulating AI decision-making for the hackathon demo. The project demonstrates the potential for sophisticated and secure DeFi applications by integrating blockchain technologies with AI, showcasing innovative solutions for DeFi strategy optimization across multiple chains.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/ucdv8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/n4y5n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/cce9r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/bbq7s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/1kvvb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/pgxb5/default.jpg"
        ],
        "live_demo": "https://chain-sage.vercel.app/",
        "source_code": "https://github.com/ajag408/ChainSage",
        "link": "https://ethglobal.com/showcase/chainsage-0pwyv"
    },
    {
        "title": "tinder for memecoins",
        "brief_description": "tinder for memecoins is a telegram mini app that lets you swipe right to purchase a memecoin",
        "long_description": "swipe right to buy, swipe left to load the next meme coin! no selling allowed. buys are pre-approved amounts. View a coins stats and charts and swipe once to buy the coin! This is all done within telegram's chat UI through a bot as a mini app. Swipe to go to the moon instead of getting rejected on traditional tinder! react project using react-tinder-card library and version 18 + 0x API for swaps & privy for telegram mini app authentication and wallet creation swaps on ethereum sepolia testnet from WETH --> UNI using 0x protocols swaps api very hacky and broken in it's current state but able to auth in, swipe through coins and send a swap through 0x protocol's swaps api & privy wallet",
        "how_its_made": "react project using react-tinder-card library and version 18 + 0x API for swaps & privy for telegram mini app authentication and wallet creation swaps on ethereum sepolia testnet from WETH --> UNI using 0x protocols swaps api very hacky and broken in it's current state but able to auth in, swipe through coins and send a swap through 0x protocol's swaps api & privy wallet",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/q3i3k/screenshots/2102f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q3i3k/screenshots/zeg7g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q3i3k/screenshots/mn3e1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MikeDank/ethglobalsf",
        "link": "https://ethglobal.com/showcase/tinder-for-memecoins-q3i3k"
    },
    {
        "title": "racoon-crypto-ai",
        "brief_description": "Imagine being able to interact with your favorite protocols, but this time with a chat interface",
        "long_description": "Imagine seamlessly interacting with your favorite blockchain protocols through a chat interface, where complex transactions and interactions become as simple as sending a message. Whether you\u2019re managing DeFi assets, swapping tokens, or exploring NFTs, you can now do it all through an intuitive conversation, making the experience more accessible and user-friendly. No more navigating complicated UIs or remembering contract addresses\u2014just a natural conversation that helps you perform the actions you want, effortlessly. This is the future of decentralized interaction, where blockchain meets simplicity through chat. I took two projects and combined them together. I plugged in a eth scaffold template alongside an open llm chat and got this. Used Dynamic for account management. The llm actually runs inside of the browser preventing any data leaking. Alongside this, messages and chats are saved locally",
        "how_its_made": "I took two projects and combined them together. I plugged in a eth scaffold template alongside an open llm chat and got this. Used Dynamic for account management. The llm actually runs inside of the browser preventing any data leaking. Alongside this, messages and chats are saved locally",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/r0vyu/screenshots/wu9vd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r0vyu/screenshots/zccip/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r0vyu/screenshots/b3eav/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ben-jamming-reilly/racoon-crypto-ai?tab=readme-ov-file",
        "link": "https://ethglobal.com/showcase/racoon-crypto-ai-r0vyu"
    },
    {
        "title": "Easypeace",
        "brief_description": "There is room for improvement as to how we navigate conflict. Easy peace helps with that.",
        "long_description": "Easy Peace is an AI-driven mediation app designed to help individuals and couples resolve relationship conflicts through thoughtful, diplomatic guidance. Whether you're navigating communication barriers, emotional misunderstandings, or complex relationship dynamics, EasyPeace provides a safe space for reflection, resolution, and growth. A heartfelt thanks goes out to the incredible teams behind the technology that makes this peace mediation tool possible. Most of the magic in untangling conflicts and fostering better communication is driven by the powerful AI agent, thanks to the innovative advancements from OpenAI. Their work has provided us with the tools to create meaningful solutions, offering thoughtful rephrasing and suggestions that allow both parties to find common ground. We also extend our deep appreciation to Privy.io for their invaluable support in safeguarding user privacy and handling sensitive data responsibly. Their expertise in privacy matters ensures that our platform not only facilitates conflict resolution but also maintains the highest standards of data protection and user trust. Their contributions to Frontend Matters have been essential in creating a secure, user-friendly experience for all involved. Thank you to both OpenAI and Privy.io for helping to make this mediation tool a reality, empowering people to resolve conflicts while feeling safe and supported.",
        "how_its_made": "A heartfelt thanks goes out to the incredible teams behind the technology that makes this peace mediation tool possible. Most of the magic in untangling conflicts and fostering better communication is driven by the powerful AI agent, thanks to the innovative advancements from OpenAI. Their work has provided us with the tools to create meaningful solutions, offering thoughtful rephrasing and suggestions that allow both parties to find common ground. We also extend our deep appreciation to Privy.io for their invaluable support in safeguarding user privacy and handling sensitive data responsibly. Their expertise in privacy matters ensures that our platform not only facilitates conflict resolution but also maintains the highest standards of data protection and user trust. Their contributions to Frontend Matters have been essential in creating a secure, user-friendly experience for all involved. Thank you to both OpenAI and Privy.io for helping to make this mediation tool a reality, empowering people to resolve conflicts while feeling safe and supported.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mo3do/screenshots/ro9c7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mo3do/screenshots/vvqox/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mo3do/screenshots/7ckj9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/PiaVictoria21/easypeace",
        "link": "https://ethglobal.com/showcase/easypeace-mo3do"
    },
    {
        "title": "Omni Castles",
        "brief_description": "In Omni Castles, players conquer castles across blockchains, using Skale\u2019s gasless battles, Fhenix\u2019s hidden armies with Acurast weather, and Rootstock\u2019s Bitcoin-based morale. Control 70% of castles to be crowned Emperor\u2014each requiring a unique strategy!",
        "long_description": "Omni Castles is a game where players must conquer and hold multiple castles across different blockchains. To be crowned Emperor, a player must control at least 70% -  (Math.ceil(0.7 * number_of_castles)) of all castles. Each castle is built on a unique blockchain, utilizing its strengths to offer diverse gameplay experiences, requiring different strategies to conquer. Skale Castle: This castle requires a massive army due to Skale's ability to handle large computations. Battles are complex and leverage Skale's built-in, gasless randomness. Skale\u2019s scalability makes large-scale battles possible without gas costs. Fhenix Castle: Utilizing Fully Homomorphic Encryption (FHE), this castle hides the defending army, forcing attackers to guess its composition based on previous battles. Acurast Oracle integrates real-time weather data, which affects battle outcomes. AirDAO Castle: Built on a scalable blockchain with high transactions per second (TPS), battles are more resource-intensive than on Fhenix, though not as demanding as on Skale. Rootstock Castle: Closely tied to the price of Bitcoin, the defending army's morale is affected by Bitcoin\u2019s market performance, adding an economic twist to battles. Here are the relevant Github repos: This hackathon is just the start, we ran out of time before implementing a unifying leaderboard (using subgraph) and Near protocol for controlling other EVM chains. In Omni Castles, we used a variety of technologies tailored to the strengths of different blockchains: Skale: Leveraged Skale\u2019s gasless techniques and built-in RNG for large-scale battles. This allowed us to run complex computations without incurring gas costs, which was crucial for smooth gameplay in army-heavy scenarios. AirDAO: Integrated Acurast for oracles, bringing in real-time weather data to affect battles, and used decentralized keepers for automatic execution of tasks, ensuring the game ran autonomously without manual intervention. Fhenix: Also utilized Acurast for weather oracles but added the twist of Fully Homomorphic Encryption (FHE) to hide defender states, requiring attackers to deduce defensive positions based on prior battles. We initially planned to unify these castles using Near for cross-chain actions and Subgraph for leaderboard tracking, but ran out of time before completing those integrations. These would have enhanced the multi-chain functionality and tracking of player progress across all castles. One of the more hacky aspects of Omni Castles is that neither AirDAO nor Fhenix had native oracle support before. This project is the first to introduce Acurast Oracles on these blockchains. Acurast\u2019s Trusted Execution Environment (TEE) forwards Web2 API data, like weather conditions, directly to smart contracts with minimal trust overhead, making it a groundbreaking integration for decentralized gaming mechanics.",
        "how_its_made": "In Omni Castles, we used a variety of technologies tailored to the strengths of different blockchains: Skale: Leveraged Skale\u2019s gasless techniques and built-in RNG for large-scale battles. This allowed us to run complex computations without incurring gas costs, which was crucial for smooth gameplay in army-heavy scenarios. AirDAO: Integrated Acurast for oracles, bringing in real-time weather data to affect battles, and used decentralized keepers for automatic execution of tasks, ensuring the game ran autonomously without manual intervention. Fhenix: Also utilized Acurast for weather oracles but added the twist of Fully Homomorphic Encryption (FHE) to hide defender states, requiring attackers to deduce defensive positions based on prior battles. We initially planned to unify these castles using Near for cross-chain actions and Subgraph for leaderboard tracking, but ran out of time before completing those integrations. These would have enhanced the multi-chain functionality and tracking of player progress across all castles. One of the more hacky aspects of Omni Castles is that neither AirDAO nor Fhenix had native oracle support before. This project is the first to introduce Acurast Oracles on these blockchains. Acurast\u2019s Trusted Execution Environment (TEE) forwards Web2 API data, like weather conditions, directly to smart contracts with minimal trust overhead, making it a groundbreaking integration for decentralized gaming mechanics.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yv5wp/screenshots/bsu1d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yv5wp/screenshots/82u7w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yv5wp/screenshots/g8eha/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Cloakworks-collective/omnicastle_skale",
        "link": "https://ethglobal.com/showcase/omni-castles-yv5wp"
    },
    {
        "title": "ProgressionXR",
        "brief_description": "ProgressionXR blends AI, XR, and Web3 for the ultimate fitness journey! \ud83e\udde0\ud83d\udd76\ufe0f\ud83c\udf0d Train with AI wellness coaches, sync workouts with Fitbit & VR, and earn rewards through fitness challenges while ensuring your privacy with multichain attestations. \ud83d\ude80\ud83d\udcaa",
        "long_description": "ProgressionXR is an innovative platform that combines Artificial Intelligence (AI), Extended Reality (XR), and Web3 technologies to create a truly immersive fitness experience. Users can connect their fitness devices, such as Fitbit and VR headsets, to engage in personalized, real-time workouts. The platform features AI-driven wellness coaches that guide users on their fitness journey, providing tailored advice to help them achieve their goals. With a focus on privacy, ProgressionXR utilizes the Litt X Sign Protocol for privacy-preserved attestations, allowing users to maintain full control over their data. Additionally, the platform offers competitive fitness challenges, where users can predict outcomes, support their favorite teams, and earn exclusive rewards. ProgressionXR's seamless Dynamic integration allows for easy, multichain logins, enhancing the onboarding experience for users across various blockchain ecosystems. ProgressionXR leverages a sophisticated tech stack, blending AI, XR, and Web3 innovations to provide users with an enhanced fitness experience. Phala AI Models: These decentralized AI models power the wellness coaches, offering real-time, personalized fitness advice based on user data and goals, while ensuring privacy through a decentralized approach. XR Integration: Users can sync their Fitbit and VR headsets, creating an immersive fitness journey that tracks workouts in real-time. This provides a fully interactive and engaging fitness experience. Dynamic for Social Logins: The platform uses Dynamic for seamless, multichain logins, allowing users to sign in across various blockchains without any hassle. Litt X Sign Protocol for Privacy Attestations: ProgressionXR integrates the Litt X Sign Protocol to ensure privacy-preserved attestations, allowing users to maintain control over their fitness data in a decentralized and secure way. Fitness Predictions: An integrated oracle enables decentralized prediction markets where users can forecast the outcomes of fitness challenges and earn rewards based on their predictions.",
        "how_its_made": "ProgressionXR leverages a sophisticated tech stack, blending AI, XR, and Web3 innovations to provide users with an enhanced fitness experience. Phala AI Models: These decentralized AI models power the wellness coaches, offering real-time, personalized fitness advice based on user data and goals, while ensuring privacy through a decentralized approach. XR Integration: Users can sync their Fitbit and VR headsets, creating an immersive fitness journey that tracks workouts in real-time. This provides a fully interactive and engaging fitness experience. Dynamic for Social Logins: The platform uses Dynamic for seamless, multichain logins, allowing users to sign in across various blockchains without any hassle. Litt X Sign Protocol for Privacy Attestations: ProgressionXR integrates the Litt X Sign Protocol to ensure privacy-preserved attestations, allowing users to maintain control over their fitness data in a decentralized and secure way. Fitness Predictions: An integrated oracle enables decentralized prediction markets where users can forecast the outcomes of fitness challenges and earn rewards based on their predictions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/84tjv/screenshots/1b2uz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/84tjv/screenshots/94djj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/84tjv/screenshots/650yp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/84tjv/screenshots/qsgbh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ProgressionXR-eth-sanfrancisco/xr-contracts",
        "link": "https://ethglobal.com/showcase/progressionxr-84tjv"
    },
    {
        "title": "Best Consumer App",
        "brief_description": "We make it easy for anyone - even consumers - to \"cook\" code with an AI-assisted interface.",
        "long_description": "Fund.fun is a decentralized, permissionless platform to fund fun projects. The donor seeds a project by staking a designated of amount of cryptocurrency, selecting a source of yield, and designating a recipient of the yield. Other donors can join the pool. The project receives all yield while the donors always have the option to withdraw their principle. I use cookbook.dev to demonstrate the capabilities of its contract library and AI assistance. Cookbook.dev accelerates protocol growth by onboarding developers faster. Cookbook integrates an AI chatbot, dev playground and contract library into a project\u2019s docs. The result is a unified learning, building, and deployment ecosystem so devs can deploy faster and projects can grow their communities.",
        "how_its_made": "I use cookbook.dev to demonstrate the capabilities of its contract library and AI assistance. Cookbook.dev accelerates protocol growth by onboarding developers faster. Cookbook integrates an AI chatbot, dev playground and contract library into a project\u2019s docs. The result is a unified learning, building, and deployment ecosystem so devs can deploy faster and projects can grow their communities.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tcm75/screenshots/hp91h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tcm75/screenshots/eskw8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tcm75/screenshots/6q4w3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/whatupjeff",
        "link": "https://ethglobal.com/showcase/best-consumer-app-tcm75"
    },
    {
        "title": "My Little Quant",
        "brief_description": "AI agent to read charts and tell you where the orderblock is (so you know if it's a good time to buy)",
        "long_description": "When the user presses the chrome extension's button, chrome extension takes a picture of the chart of the asset, and determines where the orderblock is, so that when the asset goes back down to that price, you know it's a good time to buy the asset (because it'll go up). words words words words words words words words words words words words words words words words  words words words words words words words words  words words words words words words words words It's a basic chrome extension. I used the Claude API, React, JS. What inspired me to make this is trying to trade shitcoins and not really knowing when to enter or exit the coin and needing to consult chatgpt to understand these things. words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words",
        "how_its_made": "It's a basic chrome extension. I used the Claude API, React, JS. What inspired me to make this is trying to trade shitcoins and not really knowing when to enter or exit the coin and needing to consult chatgpt to understand these things. words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bmjyb/screenshots/v7q88/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bmjyb/screenshots/d4eau/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bmjyb/screenshots/04w10/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/619/orderblock-detector",
        "link": "https://ethglobal.com/showcase/my-little-quant-bmjyb"
    },
    {
        "title": "Cr\u00e8de",
        "brief_description": "Decentralized platform using Zero-Knowledge(K) circuits for secure identity verification.",
        "long_description": "Introducing a decentralized platform powered by Zero-Knowledge (ZK) circuits, designed to revolutionize secure identity verification. This innovative solution provides a no-code tool for credential issuers to effortlessly create ZK circuits, simplifying the process of building advanced cryptographic proofs. Users benefit by generating trustless on-chain identities, enabling seamless interaction with various online services without compromising their privacy. The platform empowers both individuals and organizations with privacy-preserving identity management. Key Features: Privacy-Focused: Protect user data by proving identity without sharing personal details.\nTrustless Proofs: On-chain verification ensures transparency without requiring trust in intermediaries.\nNo-Code Tools: Simple UI for credential issuers to build ZK circuits without technical expertise.\nVersatile Use Cases: Support for multiple online services across Web3 and traditional platforms.\nUser-Friendly Interface: Intuitive workflows for both users and issuers, fostering adoption and ease of use.\nThis platform redefines digital trust, ensuring secure and private identity verification in the era of decentralized technology. here are some transactions created by the app:\nhttps://juicy-low-small-testnet.explorer.testnet.skalenodes.com/address/0xf7f861870aC67B27322E6f23f3442E660103Ce00?tab=txs\nhttps://amoy.polygonscan.com/tx/0xe6bfe9743a2434291256f2ccc36ffe268e3c01e332e87936d38a2a6df2651fdb\nhttps://testnet.layerzeroscan.com/tx/0xb302e3f543145b58e1b2d45c83f75d650d55201ae93c89415a98e88dc9a6a517 Our platform is built on a robust, scalable, and decentralized architecture that ensures privacy, security, and seamless integration with blockchain ecosystems. The core components of our architecture are: Backend \u2013 Zero-Knowledge Proof Generation\nTechnology: Rust & Circom\nFunctionality: The backend is responsible for generating Zero-Knowledge (ZK) proofs, providing cryptographic assurance of identity without exposing personal information. Rust ensures high performance and security, while Circom enables the creation of complex ZK circuits. Blockchain Layer \u2013 Smart Contracts and Proof Storage\nTechnology: Solidity\nNetwork: SKALE Network\nFunctionality: Smart contracts, written in Solidity, store and manage ZK proofs on-chain, enabling secure, trustless identity verification. The SKALE blockchain provides scalability, low-latency transactions, and interoperability to support seamless identity verification. Incentivization Token\nToken Utility: Encourages adoption and usage of the platform through an incentive model.\nBridge Technology: LayerZero protocol.\nToken Transfer: A cross-chain bridge connects SKALE with the Polygon network, ensuring seamless transfer of tokens between chains for users and incentivizing ecosystem participants. Frontend \u2013 User and Issuer Interface\nTechnology: Next.js\nFunctionality: The frontend offers an intuitive and responsive interface for users and credential issuers. With easy-to-navigate workflows, it allows issuers to create ZK circuits without code and users to generate, manage, and carry trustless on-chain identities across services. This modular and decentralized architecture ensures that the platform remains secure, scalable, and user-friendly. Each component integrates seamlessly to deliver a privacy-preserving, trustless identity verification system, leveraging the best technologies across Rust, Circom, Solidity, and modern blockchain protocols.",
        "how_its_made": "Our platform is built on a robust, scalable, and decentralized architecture that ensures privacy, security, and seamless integration with blockchain ecosystems. The core components of our architecture are: Backend \u2013 Zero-Knowledge Proof Generation\nTechnology: Rust & Circom\nFunctionality: The backend is responsible for generating Zero-Knowledge (ZK) proofs, providing cryptographic assurance of identity without exposing personal information. Rust ensures high performance and security, while Circom enables the creation of complex ZK circuits. Blockchain Layer \u2013 Smart Contracts and Proof Storage\nTechnology: Solidity\nNetwork: SKALE Network\nFunctionality: Smart contracts, written in Solidity, store and manage ZK proofs on-chain, enabling secure, trustless identity verification. The SKALE blockchain provides scalability, low-latency transactions, and interoperability to support seamless identity verification. Incentivization Token\nToken Utility: Encourages adoption and usage of the platform through an incentive model.\nBridge Technology: LayerZero protocol.\nToken Transfer: A cross-chain bridge connects SKALE with the Polygon network, ensuring seamless transfer of tokens between chains for users and incentivizing ecosystem participants. Frontend \u2013 User and Issuer Interface\nTechnology: Next.js\nFunctionality: The frontend offers an intuitive and responsive interface for users and credential issuers. With easy-to-navigate workflows, it allows issuers to create ZK circuits without code and users to generate, manage, and carry trustless on-chain identities across services. This modular and decentralized architecture ensures that the platform remains secure, scalable, and user-friendly. Each component integrates seamlessly to deliver a privacy-preserving, trustless identity verification system, leveraging the best technologies across Rust, Circom, Solidity, and modern blockchain protocols.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/64vph/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/2mies/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/i1ciu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/07kpb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/NJCinnamond/crede",
        "link": "https://ethglobal.com/showcase/crede-pucis"
    },
    {
        "title": "Cr\u00e8de",
        "brief_description": "Decentralized platform using Zero-Knowledge(K) circuits for secure identity verification.",
        "long_description": "Introducing a decentralized platform powered by Zero-Knowledge (ZK) circuits, designed to revolutionize secure identity verification. This innovative solution provides a no-code tool for credential issuers to effortlessly create ZK circuits, simplifying the process of building advanced cryptographic proofs. Users benefit by generating trustless on-chain identities, enabling seamless interaction with various online services without compromising their privacy. The platform empowers both individuals and organizations with privacy-preserving identity management. Key Features: Privacy-Focused: Protect user data by proving identity without sharing personal details.\nTrustless Proofs: On-chain verification ensures transparency without requiring trust in intermediaries.\nNo-Code Tools: Simple UI for credential issuers to build ZK circuits without technical expertise.\nVersatile Use Cases: Support for multiple online services across Web3 and traditional platforms.\nUser-Friendly Interface: Intuitive workflows for both users and issuers, fostering adoption and ease of use.\nThis platform redefines digital trust, ensuring secure and private identity verification in the era of decentralized technology. here are some transactions created by the app:\nhttps://juicy-low-small-testnet.explorer.testnet.skalenodes.com/address/0xf7f861870aC67B27322E6f23f3442E660103Ce00?tab=txs\nhttps://amoy.polygonscan.com/tx/0xe6bfe9743a2434291256f2ccc36ffe268e3c01e332e87936d38a2a6df2651fdb\nhttps://testnet.layerzeroscan.com/tx/0xb302e3f543145b58e1b2d45c83f75d650d55201ae93c89415a98e88dc9a6a517 Our platform is built on a robust, scalable, and decentralized architecture that ensures privacy, security, and seamless integration with blockchain ecosystems. The core components of our architecture are: Backend \u2013 Zero-Knowledge Proof Generation\nTechnology: Rust & Circom\nFunctionality: The backend is responsible for generating Zero-Knowledge (ZK) proofs, providing cryptographic assurance of identity without exposing personal information. Rust ensures high performance and security, while Circom enables the creation of complex ZK circuits. Blockchain Layer \u2013 Smart Contracts and Proof Storage\nTechnology: Solidity\nNetwork: SKALE Network\nFunctionality: Smart contracts, written in Solidity, store and manage ZK proofs on-chain, enabling secure, trustless identity verification. The SKALE blockchain provides scalability, low-latency transactions, and interoperability to support seamless identity verification. Incentivization Token\nToken Utility: Encourages adoption and usage of the platform through an incentive model.\nBridge Technology: LayerZero protocol.\nToken Transfer: A cross-chain bridge connects SKALE with the Polygon network, ensuring seamless transfer of tokens between chains for users and incentivizing ecosystem participants. Frontend \u2013 User and Issuer Interface\nTechnology: Next.js\nFunctionality: The frontend offers an intuitive and responsive interface for users and credential issuers. With easy-to-navigate workflows, it allows issuers to create ZK circuits without code and users to generate, manage, and carry trustless on-chain identities across services. This modular and decentralized architecture ensures that the platform remains secure, scalable, and user-friendly. Each component integrates seamlessly to deliver a privacy-preserving, trustless identity verification system, leveraging the best technologies across Rust, Circom, Solidity, and modern blockchain protocols.",
        "how_its_made": "Our platform is built on a robust, scalable, and decentralized architecture that ensures privacy, security, and seamless integration with blockchain ecosystems. The core components of our architecture are: Backend \u2013 Zero-Knowledge Proof Generation\nTechnology: Rust & Circom\nFunctionality: The backend is responsible for generating Zero-Knowledge (ZK) proofs, providing cryptographic assurance of identity without exposing personal information. Rust ensures high performance and security, while Circom enables the creation of complex ZK circuits. Blockchain Layer \u2013 Smart Contracts and Proof Storage\nTechnology: Solidity\nNetwork: SKALE Network\nFunctionality: Smart contracts, written in Solidity, store and manage ZK proofs on-chain, enabling secure, trustless identity verification. The SKALE blockchain provides scalability, low-latency transactions, and interoperability to support seamless identity verification. Incentivization Token\nToken Utility: Encourages adoption and usage of the platform through an incentive model.\nBridge Technology: LayerZero protocol.\nToken Transfer: A cross-chain bridge connects SKALE with the Polygon network, ensuring seamless transfer of tokens between chains for users and incentivizing ecosystem participants. Frontend \u2013 User and Issuer Interface\nTechnology: Next.js\nFunctionality: The frontend offers an intuitive and responsive interface for users and credential issuers. With easy-to-navigate workflows, it allows issuers to create ZK circuits without code and users to generate, manage, and carry trustless on-chain identities across services. This modular and decentralized architecture ensures that the platform remains secure, scalable, and user-friendly. Each component integrates seamlessly to deliver a privacy-preserving, trustless identity verification system, leveraging the best technologies across Rust, Circom, Solidity, and modern blockchain protocols.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/64vph/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/2mies/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/i1ciu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/07kpb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/NJCinnamond/crede",
        "link": "https://ethglobal.com/showcase/crede-pucis"
    },
    {
        "title": "bitGaming",
        "brief_description": "Play-to-earn gaming platform and NFT marketplace powered by AI, Blockchain and Decentralized storage",
        "long_description": "Bitgame-ETH is a blockchain-powered gaming platform that integrates NFTs, decentralized storage, and multiple interactive  play-to-earn (P2E) games, including an AI-driven Dungeons & Dragons (DnD) experience, Chimp Test, and Number Memory. The platform uses: Dynamic.xyz for lightning-fast authentication. Dynamic's widget enables first time users to create new wallet with various accounts including GitHub, emails, e.g. without extra effort. Wallet address is the key for user to enter the world of web3,  claim NFTs, and view leaderboard and galleries. Walrus for decentralized object storage. We store NFTs and D&D narration images in Walrus and serve them on our frontend. The blob id returned from Walrus are also stored as a folder-like file to optimize the storage space in our server, and ensures the security and robustness of the data, utilizing the BFT feature of Walrus. OpenAI APIs LLM for AI gaming experience. We use OpenAI's API to create AI chat bot that generate sceneries and images according to user's selection of actions, providing a immersive and innovative experience for users. Morph Holesky Testnet for the smart contract deployments & interactions. Smart contracts manage NFT creation and ownership, with Morph handling the underlying transaction processes, allowing for secure, transparent, and automated interactions. You may play these games on our platform: Other functionalities: Technologies Backend Technologies Architecture Notable Features",
        "how_its_made": "Technologies Backend Technologies Architecture Notable Features",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/oqjnk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/ffq0i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/b3r62/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/a1jqc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/j2v3q/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/zwpvz/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Akezh/bitgaming-eth",
        "link": "https://ethglobal.com/showcase/bitgaming-2up94"
    },
    {
        "title": "Guides",
        "brief_description": "An educational app for learning Web3 protocols with interactive lessons, on-chain actions, and attestations. Users earn XP, complete quizzes, and validate achievements on Polygon while seamlessly engaging with blockchain tech like Coinbase AA and Sign Attestation Protocol.",
        "long_description": "The project is a comprehensive educational mobile platform designed to make learning about Web3 protocols interactive and engaging. Built using React, Next.js, and designed in Figma, the app provides a seamless user experience with a dynamic interface. User access is facilitated through Alchemy Account Kit, which supports flexible login options like email and wallet connections. Course completions are validated through Sign Protocol, which generates attestations stored immutably on the Polygon blockchain, providing verifiable proof of user achievements. The platform also integrates Coinbase's account abstraction (AA) flow in specific lessons to enable users to create smart accounts and experience advanced blockchain features firsthand. Inspired by the Easy A platform, the app combines theoretical learning with practical experience. Users explore blockchain protocols through lessons that detail features, technical background, use cases, and provides information on estimated completion time, developer participation, and XP rewards. Each lesson ends with an on-chain interaction, such as minting an NFT or signing a transaction, allowing users to directly engage with blockchain technologies. The platform emphasizes real-world skills, where completing lessons not only imparts knowledge but also involves blockchain activities that solidify the learning experience. This project aims to enhance blockchain education by merging interactive content, decentralized technologies, and practical applications to create an all-encompassing environment where users can learn, engage, and verify their skills through the entire Web3 ecosystem. The project uses React, Next.js, and Figma for a dynamic and visually consistent frontend. Alchemy Account Kit provides flexible authentication, while Coinbase's AA flow enables smart account creation. Sign Protocol verifies course completions with attestations stored on Polygon. The platform includes on-chain tasks like minting NFTs, and features real-time tracking for XP rewards and a custom onboarding flow for seamless user experience.",
        "how_its_made": "The project uses React, Next.js, and Figma for a dynamic and visually consistent frontend. Alchemy Account Kit provides flexible authentication, while Coinbase's AA flow enables smart account creation. Sign Protocol verifies course completions with attestations stored on Polygon. The platform includes on-chain tasks like minting NFTs, and features real-time tracking for XP rewards and a custom onboarding flow for seamless user experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ac8ng/screenshots/6b4z8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ac8ng/screenshots/assio/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ac8ng/screenshots/dkoyq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/henrikkv/Guides",
        "link": "https://ethglobal.com/showcase/guides-ac8ng"
    },
    {
        "title": "Notarix",
        "brief_description": "Our project is a secure, real-world, ID-verified notarization platform designed to streamline digital notarization while maintaining strong user privacy and security.",
        "long_description": "notarix.vercel.app This project is designed to on-board users not familiar with web3 to a secure, real-world ID-verified digital notarization platform. The website is designed such that the file upload provides a one-click attestation, generating a unique URL that can be sent to a notary of your choice. Dynamic wallet is used for extensive compatibility with wallets, including Ledger Live. The attestation includes an on-chain stored file via the Skale Network and real-world identity verification via Synaps. The notary is then able to verify the identity of the document and provider via a simple interface and provide their own signature via the Sign protocol. The entire project is hosted on Polygon to allow for rapid execution of dApps and low gas fees. All payment uses USDC as currency to further break down the web2 to web3 barrier for uninitiated users. We use Dynamic for wallet authentication to serve as the central identity for document notarization and payment processes. We use Ledger for cryptographic document signing, ensuring private keys remain offline and tamper-proof. Skale Network provides decentralized, zero-cost storage for affidavit voice memos and other files via elastic sidechains. We built a smart contract that handles payment, using Circle\u2019s USDC, ensuring seamless and transparent fee settlements for the non-blockchain enthusiast. The core of the platform is our custom Sign Protocol, which emulates in-person notary workflows using nested schemas. In this process, clients submit signed documents and verified identities through Synaps, a decentralized identity protocol utilizing zero-knowledge proofs for AML/KYC real-world identity verification. Upon verifying document integrity and associated identity, a digital notary attests the signature, with notarization entries indexed on-chain for fast lookups. Our documentation includes setup instructions, architecture diagrams, and a roadmap for future scalability and multi-chain support.",
        "how_its_made": "We use Dynamic for wallet authentication to serve as the central identity for document notarization and payment processes. We use Ledger for cryptographic document signing, ensuring private keys remain offline and tamper-proof. Skale Network provides decentralized, zero-cost storage for affidavit voice memos and other files via elastic sidechains. We built a smart contract that handles payment, using Circle\u2019s USDC, ensuring seamless and transparent fee settlements for the non-blockchain enthusiast. The core of the platform is our custom Sign Protocol, which emulates in-person notary workflows using nested schemas. In this process, clients submit signed documents and verified identities through Synaps, a decentralized identity protocol utilizing zero-knowledge proofs for AML/KYC real-world identity verification. Upon verifying document integrity and associated identity, a digital notary attests the signature, with notarization entries indexed on-chain for fast lookups. Our documentation includes setup instructions, architecture diagrams, and a roadmap for future scalability and multi-chain support.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/h30kb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/n5ihm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/oyo8d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/byc4m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/hkm1f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/pm9x1/default.jpg"
        ],
        "live_demo": "https://notarix.vercel.app/",
        "source_code": "https://github.com/kevinledev/notarix",
        "link": "https://ethglobal.com/showcase/notarix-hyb0a"
    },
    {
        "title": "TrueCanvas",
        "brief_description": "TrueCanvas empowers digital artists to authenticate their original work using zero-knowledge proofs. By providing command logs and artworks, artists generate proofs published to blockchains. This allows anyone to verify authenticity, enhancing trust in digital creations.",
        "long_description": "Problem Statement/Motivation Digital artists who create original works manually or with traditional digital tools like Adobe Illustrator or Photoshop face significant challenges in proving the authenticity of their creations. The rise of generative AI and sophisticated digital manipulation tools has made it increasingly difficult for viewers and other artists to discern whether a piece of art is genuinely original or partially generated by AI. This skepticism undermines the value and credibility of authentic digital art, making it challenging for artists to showcase their hard work and for viewers to trust the originality of the pieces they admire. Moreover, artists are concerned about privacy issues, as they may not want to disclose the intricate details of their creative process or reveal proprietary techniques that constitute their \"secret sauce\" in art creation. Solution: To tackle the challenge of proving the authenticity of original digital artworks without compromising the artist's privacy, we developed TrueCanvas. This platform allows artists to notarize their creations using zero-knowledge proofs (ZKPs), ensuring that their work is original and unaltered by AI without revealing sensitive details of their creative process. Generating a Proof Workflow Artist Generates Creation Logs The artist creates their digital artwork using tools like Photoshop and exports the command logs (.psd logs) that record each creative action taken during the artwork's development. Uploading Artwork and Requesting Proof The artist uploads their artwork (e.g., a PNG file) along with the associated .psd logs to the TrueCanvas frontend application. They then make a request for proof generation through the application's interface. Proof Request Processing The frontend application sends the proof request to the backend server, which is responsible for handling the proof generation process. Log Verification and Proof Generation The backend server verifies the uploaded logs to ensure they meet specific criteria, such as confirming that less than 10% of the pixels are copy-pasted. If the logs pass verification, they are fed into the zero-knowledge proof generator written in Rust using RISC Zero. Receiving Proof and Verification The generated proof and verification details are returned to the artist. This proof attests to the authenticity and originality of the artwork without disclosing any proprietary information or revealing the artist's creative techniques. Publishing to Blockchains The proof and a reference to the artwork are securely stored using Walrus, a decentralized storage solution. They are then published to various blockchains, such as the Story Protocol, via smart contracts written in Solidity. This ensures that the proof is immutable and publicly accessible for verification by anyone. Verifying Proof Accessing the Proof Anyone interested in verifying the authenticity of the artwork can access the verification link provided by the artist. This link might be shared in an Instagram description, on an online gallery, or through other platforms where the artwork is showcased. Proof Verification The verifier reads the proof directly from the blockchain and can independently verify the authenticity of the artwork on any device. This process does not require specialized software or access to the artist's private creation logs. By verifying the proof, they are assured that the artwork is original and not generated or heavily modified using AI tools. Technology Stack To implement TrueCanvas effectively, we integrated a comprehensive technology stack that ensures security, scalability, and a seamless user experience. Here's how the various technologies work together: At the frontend, we utilized Next.js and React to build a responsive and intuitive application where artists can upload their artwork and request proof generation. This user-friendly interface allows artists to interact with the platform effortlessly. The frontend communicates with a backend server developed in Go, which handles proof requests and orchestrates the interactions between different system components. Go's efficiency and concurrency support make it ideal for managing these operations reliably. For the core logic of zero-knowledge proof generation, we employed Rust in conjunction with RISC Zero, a zero-knowledge virtual machine (zkVM). Rust provides high performance and security, which are crucial for cryptographic computations. RISC Zero enables us to create off-chain zero-knowledge proofs that verify the artist's creation process without revealing sensitive information. This ensures that the proofs are both secure and efficient. To securely store the generated proofs and associated artwork, we used Walrus, a decentralized data availability storage solution. Walrus ensures that the data is tamper-proof and remains accessible, leveraging the benefits of decentralized storage to enhance security and reliability. The proofs and references to the artwork are published to multiple blockchains to guarantee transparency and immutability. We wrote smart contracts in Solidity and deployed them on platforms like Polygon and Story Protocol. Polygon provides a scalable and decentralized blockchain platform, ensuring cost-effective transactions and fast confirmation times. The Story Protocol facilitates the registration of NFTs and offers a provenance system, which is essential for tracking the history and ownership of digital artworks. To enable cross-chain interoperability, we integrated Layer Zero. This technology allows proofs to be published and verified across multiple blockchain networks, enhancing the system's flexibility and reach. It ensures that artists and verifiers can interact with the platform regardless of their preferred blockchain. For secure authentication, we incorporated Dynamic, which provides wallet-based authentication for artists. This enables artists to securely log in and manage their proofs using their digital wallets, adding an extra layer of security and convenience. By combining these technologies, TrueCanvas offers a cohesive system where each component plays a vital role: The frontend provides an accessible platform for artists to interact with.\nThe backend manages proof generation requests and system coordination.\nRISC Zero and Rust handle secure and efficient proof generation.\nWalrus ensures secure and decentralized storage of proofs and artworks.\nSolidity smart contracts on Polygon and Story Protocol handle blockchain interactions, providing transparency and immutability.\nLayer Zero enhances interoperability across different blockchain networks.\nDynamic secures user authentication and session management.\nThis integrated technology stack ensures that TrueCanvas operates smoothly, providing artists with a secure and private way to authenticate their digital artworks, and offering verifiers a reliable method to confirm authenticity. ZK Proofs At the heart of TrueCanvas is the use of advanced cryptographic techniques involving zero-knowledge proofs (ZKPs) to verify the authenticity of digital artworks without revealing any sensitive information about the creation process. Canvas Representation as a Two-Dimensional Merkle Tree with Action Logs The digital canvas is modeled as a two-dimensional Merkle tree, a cryptographic data structure that efficiently represents and verifies large datasets. Each pixel or group of pixels acts as leaves in the tree, and the root hash uniquely represents the current state of the canvas. Any modification to the canvas, such as altering pixels through an action, updates the Merkle root, serving as a secure fingerprint of the artwork at any given time. Artists export detailed action logs from Photoshop, which record every action performed and the specific pixels modified. These logs provide the necessary data to understand how the canvas evolves with each action, forming the foundation for our proofs. Base Proof Generation Using RISC Zero, we generate base proofs that verify the correctness of the canvas's transition from the initial state to the updated state after each action. The function inputs for the proof generation are: Initial Merkle Tree (Before an Action): Represents the state of the canvas before a specific action is applied.\nUpdates from Actions: The set of pixel modifications resulting from the action.\nThis base proof ensures that the action is legitimate and consistent with the canvas's state changes without revealing any details about the action itself. Recursive Proofs and Merkle Root Constraints Each base proof is transformed into a recursive proof, which encapsulates not just a single action but the entire sequence of actions up to that point. Recursive proofs are combined by aligning the Merkle root hashes: The output Merkle root of one proof becomes the input Merkle root of the next.\nThis chaining ensures that all transitions between canvas states are valid and verifiable, effectively proving the integrity of the entire creation process. We employ Scalable Transparent ARguments of Knowledge (STARKs) to construct these recursive proofs. STARKs provide scalability and transparency, making the proofs efficient to generate and verify without requiring trusted setups. Enhancing Proof Succinctness with KZG Commitments While STARKs are powerful, the proofs they generate can be relatively large compared to other proof systems. To further reduce the size of the proofs and enhance verification efficiency, we use Kate-Zaverucha-Goldberg (KZG) polynomial commitments. Zero-Knowledge Proof of Verification:\nWe create a zk-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) of the STARK proof verification using KZG commitments.\nThis process generates a succinct zero-knowledge proof that verifies the correctness of the original STARK proof without revealing any additional information.\nBy making a zk-proof of the verification process, we significantly compress the proof data. The combination of STARKs with KZG commitments results in highly succinct proofs that are practical for real-world applications, offering both transparency and efficiency.",
        "how_its_made": "Technology Stack To implement TrueCanvas effectively, we integrated a comprehensive technology stack that ensures security, scalability, and a seamless user experience. Here's how the various technologies work together: At the frontend, we utilized Next.js and React to build a responsive and intuitive application where artists can upload their artwork and request proof generation. This user-friendly interface allows artists to interact with the platform effortlessly. The frontend communicates with a backend server developed in Go, which handles proof requests and orchestrates the interactions between different system components. Go's efficiency and concurrency support make it ideal for managing these operations reliably. For the core logic of zero-knowledge proof generation, we employed Rust in conjunction with RISC Zero, a zero-knowledge virtual machine (zkVM). Rust provides high performance and security, which are crucial for cryptographic computations. RISC Zero enables us to create off-chain zero-knowledge proofs that verify the artist's creation process without revealing sensitive information. This ensures that the proofs are both secure and efficient. To securely store the generated proofs and associated artwork, we used Walrus, a decentralized data availability storage solution. Walrus ensures that the data is tamper-proof and remains accessible, leveraging the benefits of decentralized storage to enhance security and reliability. The proofs and references to the artwork are published to multiple blockchains to guarantee transparency and immutability. We wrote smart contracts in Solidity and deployed them on platforms like Polygon and Story Protocol. Polygon provides a scalable and decentralized blockchain platform, ensuring cost-effective transactions and fast confirmation times. The Story Protocol facilitates the registration of NFTs and offers a provenance system, which is essential for tracking the history and ownership of digital artworks. To enable cross-chain interoperability, we integrated Layer Zero. This technology allows proofs to be published and verified across multiple blockchain networks, enhancing the system's flexibility and reach. It ensures that artists and verifiers can interact with the platform regardless of their preferred blockchain. For secure authentication, we incorporated Dynamic, which provides wallet-based authentication for artists. This enables artists to securely log in and manage their proofs using their digital wallets, adding an extra layer of security and convenience. By combining these technologies, TrueCanvas offers a cohesive system where each component plays a vital role: The frontend provides an accessible platform for artists to interact with.\nThe backend manages proof generation requests and system coordination.\nRISC Zero and Rust handle secure and efficient proof generation.\nWalrus ensures secure and decentralized storage of proofs and artworks.\nSolidity smart contracts on Polygon and Story Protocol handle blockchain interactions, providing transparency and immutability.\nLayer Zero enhances interoperability across different blockchain networks.\nDynamic secures user authentication and session management.\nThis integrated technology stack ensures that TrueCanvas operates smoothly, providing artists with a secure and private way to authenticate their digital artworks, and offering verifiers a reliable method to confirm authenticity. ZK Proofs At the heart of TrueCanvas is the use of advanced cryptographic techniques involving zero-knowledge proofs (ZKPs) to verify the authenticity of digital artworks without revealing any sensitive information about the creation process. Canvas Representation as a Two-Dimensional Merkle Tree with Action Logs The digital canvas is modeled as a two-dimensional Merkle tree, a cryptographic data structure that efficiently represents and verifies large datasets. Each pixel or group of pixels acts as leaves in the tree, and the root hash uniquely represents the current state of the canvas. Any modification to the canvas, such as altering pixels through an action, updates the Merkle root, serving as a secure fingerprint of the artwork at any given time. Artists export detailed action logs from Photoshop, which record every action performed and the specific pixels modified. These logs provide the necessary data to understand how the canvas evolves with each action, forming the foundation for our proofs. Base Proof Generation Using RISC Zero, we generate base proofs that verify the correctness of the canvas's transition from the initial state to the updated state after each action. The function inputs for the proof generation are: Initial Merkle Tree (Before an Action): Represents the state of the canvas before a specific action is applied.\nUpdates from Actions: The set of pixel modifications resulting from the action.\nThis base proof ensures that the action is legitimate and consistent with the canvas's state changes without revealing any details about the action itself. Recursive Proofs and Merkle Root Constraints Each base proof is transformed into a recursive proof, which encapsulates not just a single action but the entire sequence of actions up to that point. Recursive proofs are combined by aligning the Merkle root hashes: The output Merkle root of one proof becomes the input Merkle root of the next.\nThis chaining ensures that all transitions between canvas states are valid and verifiable, effectively proving the integrity of the entire creation process. We employ Scalable Transparent ARguments of Knowledge (STARKs) to construct these recursive proofs. STARKs provide scalability and transparency, making the proofs efficient to generate and verify without requiring trusted setups. Enhancing Proof Succinctness with KZG Commitments While STARKs are powerful, the proofs they generate can be relatively large compared to other proof systems. To further reduce the size of the proofs and enhance verification efficiency, we use Kate-Zaverucha-Goldberg (KZG) polynomial commitments. Zero-Knowledge Proof of Verification:\nWe create a zk-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) of the STARK proof verification using KZG commitments.\nThis process generates a succinct zero-knowledge proof that verifies the correctness of the original STARK proof without revealing any additional information.\nBy making a zk-proof of the verification process, we significantly compress the proof data. The combination of STARKs with KZG commitments results in highly succinct proofs that are practical for real-world applications, offering both transparency and efficiency.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/h29mf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/jrdrv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/hyhxb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/7i8y3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/91b2k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/cmk2t/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Pistondo/eth-sf-2024",
        "link": "https://ethglobal.com/showcase/truecanvas-5uwmd"
    },
    {
        "title": "The Monk Store",
        "brief_description": "Add feature that will allow user ENS names to be resolved to wallet address for payments",
        "long_description": "This project adds a simple utility that enables users to be able to use Unlimit web payment portal with their ENS. Currently the user cannot simply pay using his ENS name. The address has to be input manually. This feature allows for the input to be parsed and then supplied to the web payment portal Next.js, ethers, and Unlimit integration was used to create this project. I added a new feature for them so their overlay model can accept an ENS address. Unlimit payment portal was fun to use and thei documentation was helpful. I caught couple of bugs in the documentation, and the integration process",
        "how_its_made": "Next.js, ethers, and Unlimit integration was used to create this project. I added a new feature for them so their overlay model can accept an ENS address. Unlimit payment portal was fun to use and thei documentation was helpful. I caught couple of bugs in the documentation, and the integration process",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/qyf6m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/toos3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/thpha/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/oew00/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/orc1v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/gyxzt/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/way2rach/unlimit-ens-resolver",
        "link": "https://ethglobal.com/showcase/the-monk-store-zsjk1"
    },
    {
        "title": "EthBox",
        "brief_description": "EthBox is a Web3-based Dropbox for artists and listeners. It ensures secure, tamper-proof, and verifiable file sharing through Dynamic login and Weavechain for encrypted storage, and Skale\u2019s Calypso Chain for transaction proofs creating a decentralized solution to protect IPs",
        "long_description": "EthBox is a decentralized, secure music distribution platform, designed to tackle file sharing and piracy issues. The music industry has long struggled with piracy and unauthorized file sharing at the peer-to-peer level and within larger circles. Large music labels and streaming services often control rights and distribution, but peer-to-peer sharing, especially among smaller artists, continues to be a problem. For example, DJs often distribute their work on thumb drives, lacking secure and verifiable methods for managing their intellectual property.  EthBox is a specialized Web3 Dropbox for music, offering an encrypted, semi-decentralized file-sharing platform that maintains privacy and authenticity. It integrates with Dynamic for secure login, using a wallet address to authenticate users, ensuring that only trusted users can share and receive files. Artists can upload their music to Weavechain, an in-house API for storing and transporting encrypted files. Each file is signed and associated with a recipient's wallet address, ensuring that only the intended recipient can access the file.  Additionally, audit logs are generated during each read-and-write operation by the Weave node on the storage database.  These logs are stored on Skale Network, a zero-cost, gas-free blockchain platform that allows for scalable and efficient deployment. By writing audit logs on-chain, EthBox ensures verifiable proof of file immutability and lineage, preventing unauthorized tampering and verifying the sender's authenticity through cryptographic methods. This project is primarily written in javascript, using React for the frontend, using solidity to write the Skale smart contracts.  Python is used to control the development server that hosts the files and the weave node.  We start with Dynamic's login (React) which abstracts Web3 authentication behind a familiar Web2-like interface, which was crucial for onboarding users who might not be familiar with decentralized applications. Each user\u2019s public key is generated through their wallet address, and their actions are signed using cryptographic keys for secure identification.  I used Weavechain's API  (external) to code the backend.  A bit of solidity + java is used to create smart contracts deployed on the Skale network for each operation on the Weave database. Skale\u2019s zero-cost deployment was very helpful in dealing with gas fees, which would have been prohibitively expensive with frequent contract deployments for file tracking and audit logging. Next, looking at the way the public key exchange works, I used the Diffie Hellman pub key exchange.",
        "how_its_made": "This project is primarily written in javascript, using React for the frontend, using solidity to write the Skale smart contracts.  Python is used to control the development server that hosts the files and the weave node.  We start with Dynamic's login (React) which abstracts Web3 authentication behind a familiar Web2-like interface, which was crucial for onboarding users who might not be familiar with decentralized applications. Each user\u2019s public key is generated through their wallet address, and their actions are signed using cryptographic keys for secure identification.  I used Weavechain's API  (external) to code the backend.  A bit of solidity + java is used to create smart contracts deployed on the Skale network for each operation on the Weave database. Skale\u2019s zero-cost deployment was very helpful in dealing with gas fees, which would have been prohibitively expensive with frequent contract deployments for file tracking and audit logging. Next, looking at the way the public key exchange works, I used the Diffie Hellman pub key exchange.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ce3s1/screenshots/1srdk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ce3s1/screenshots/jjon0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ce3s1/screenshots/09bpq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ebchassine/final-ethsf24",
        "link": "https://ethglobal.com/showcase/ethbox-ce3s1"
    },
    {
        "title": "Medily",
        "brief_description": "An on-chain platform for medical image storage, solving interoperability across global healthcare systems.",
        "long_description": "A broken foot led me to the Canadian Emergency services. Unfortunately, the X ray was not shared with me for further consultation. This is a problem on many fronts. This project has 3 major parts:",
        "how_its_made": "This project has 3 major parts:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/66gcm/screenshots/uxv6a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/66gcm/screenshots/a57ik/default.jpg",
            "https://ethglobal.b-cdn.net/projects/66gcm/screenshots/gvctj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/66gcm/screenshots/9eos5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Garima5/Medily",
        "link": "https://ethglobal.com/showcase/medily-66gcm"
    },
    {
        "title": "CareHippos",
        "brief_description": "Data aggregation app to give a real-time, reputational, and quantitative assessment of the community's health.",
        "long_description": "The CareHippos App is a decentralized application designed to allow users to submit their mood within the context of their communities, helping track the overall mental health and well-being of the community. Whether it\u2019s an office department, a DAO, a hospital floor, or a hackathon sponsor, this app provides a simple and effective way to assess a community's emotional state. By enabling users to vote via \"mood submission\", the app aggregates these votes to give a real-time, reputational, and quantitative assessment of the community's health. It helps community administrators identify potential conflicts, stress levels, and overall mood trends, empowering them to take action where needed. The smart contracts are deployed on Morph Holesky Testnet. We use Morph Holesky Testnet for each of the Mood CareHippo Token, Dynamic for wallet management \u00b4+ account abstraction. Our app is built with NextJS and wagmi, and deployed on Vercel. The users login with their social account, a wallet is generated for them. Users can create a Passkey to manage their keys, and gasless transactions are in the roadmap for seamless user interactions",
        "how_its_made": "We use Morph Holesky Testnet for each of the Mood CareHippo Token, Dynamic for wallet management \u00b4+ account abstraction. Our app is built with NextJS and wagmi, and deployed on Vercel. The users login with their social account, a wallet is generated for them. Users can create a Passkey to manage their keys, and gasless transactions are in the roadmap for seamless user interactions",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sn19u/screenshots/fhm03/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sn19u/screenshots/5thu2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sn19u/screenshots/jkjvb/default.jpg"
        ],
        "live_demo": "https://carehippos.vercel.app",
        "source_code": "https://github.com/a1uaP/carehippos",
        "link": "https://ethglobal.com/showcase/carehippos-sn19u"
    },
    {
        "title": "UniV4Backtester",
        "brief_description": "An institutional grade UniV4 backtester that faithfully replays UniV3 events (Swap, Mint, Burn), and see how a hypothetical position would have performed over a time window.",
        "long_description": "Uniswap v4 introduces the concept of hooks which allows DEX builders to customize behaviors throughout the swap lifecycle, i.e. before/after every swap and liquidity management actions.  A UniV4 pool is usually equipped with the concentrated liquidity curve of UniV3, but the hooks contract can customize how fees accrue to liquidity providers, among many others things, which can have a profound impact on LP profitability. As UniV4 gets ready for production and as more and more hooks are being developed, it is essential to build fast and robust tools that can help analyze how a hooks implementation affects traders and liquidity providers.  In that spirit, we introduce our UniV4 backtester. Our UniV4 backtester fetches liquidity events from a specified UniV3 pool, and then replays these events (Swap, Increase Liquidity, Remove Liquidity) in a hypothetical UniV4 pool which may come with specified hooks. This setup enables institutional grade backtesting analyses on how a UniV4 pool would have performed using the exact liquidity events of a real-world CLMM pool, rather than using aggregated (hourly or daily) historical data which will result in inaccurate and unrealistic results. The backtester is able to set up a hypothetical position, and backtests the position\u2019s performance through a specified time window. We used a variety of technologies to make this backtester: Viem (NodeJS) to fetch UniV3 pool events; Foundry to fork the Sepolia testnet and execute the backtest. --- UniV3 Event Fetching ---\nUniV3 events are fetched from an Ethereum RPC node through eth_getLogs calls on the UniV3 pool contract.  For the demo, we fetched early events of the WBTC-WETH 0.3% pool on Ethereum mainnet.  Since each eth_getLogs call only supports a limited block range, we have to fetch events in batches.  Retry mechanism has been implemented to make event fetching more robust against temporary communication issues with the rpc node. Details of Swap, Mint, Burn are recorded. Collect events are skipped as they do not affect the pool\u2019s liquidity state. --- Backtester Engine ---\nWe use Foundry to create a fork of the Ethereum Sepolia network where UniV4 is deployed.  First, the specified UniV4 pool is created on the fork.  Two dummy token contracts are deployed since production tokens are not available on testnet.  A large amount of tokens are minted to an arbitrary whale address. Liquidity events are replayed: The hypothetical position is set up at startTime, and its state (how much currency0 and currency1 can be collected) at endTime is returned as output at the end of the backtest.",
        "how_its_made": "We used a variety of technologies to make this backtester: Viem (NodeJS) to fetch UniV3 pool events; Foundry to fork the Sepolia testnet and execute the backtest. --- UniV3 Event Fetching ---\nUniV3 events are fetched from an Ethereum RPC node through eth_getLogs calls on the UniV3 pool contract.  For the demo, we fetched early events of the WBTC-WETH 0.3% pool on Ethereum mainnet.  Since each eth_getLogs call only supports a limited block range, we have to fetch events in batches.  Retry mechanism has been implemented to make event fetching more robust against temporary communication issues with the rpc node. Details of Swap, Mint, Burn are recorded. Collect events are skipped as they do not affect the pool\u2019s liquidity state. --- Backtester Engine ---\nWe use Foundry to create a fork of the Ethereum Sepolia network where UniV4 is deployed.  First, the specified UniV4 pool is created on the fork.  Two dummy token contracts are deployed since production tokens are not available on testnet.  A large amount of tokens are minted to an arbitrary whale address. Liquidity events are replayed: The hypothetical position is set up at startTime, and its state (how much currency0 and currency1 can be collected) at endTime is returned as output at the end of the backtest.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/zwhv6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/n01mx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/kodmz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/69i1e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/pt8kw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Aperture-Finance/UniV4Backtester_ETHSF2024",
        "link": "https://ethglobal.com/showcase/univ4backtester-ht1e6"
    },
    {
        "title": "CryptoBASO",
        "brief_description": "Splits swaps across multiple transactions to prevent front running",
        "long_description": "Our project involves splitting up swap orders on DEX\u2019s across multiple transactions by taking advantage of SKALE\u2019s zero gas fees. This is so we can minimize losses occurred from frontrunning.\nOn other blockchains, trying to split up transactions results in more and more gas fees. If you want to make a trade of $50 across multiple transactions, it is not easily doable. It doesn\u2019t make sense to do 5 $10 trades if gas fees are $5.\nThe SKALE network\u2019s zero gas features improves the ability to spread out buy and sell orders across multiple transactions because gas costs are no longer a problematic factor.\nOur project can be slightly altered to work with any DEX on the network (given the DEX has good documentation). We used a simple \u201cfake DEX\u201d for demonstration purposes.\nWe hope that, as the SKALE network\u2019s DeFi ecosystem increases, we could help facilitate that growth with our own project and differentiate the SKALE ecosystem by using SKALE\u2019s zero gas features with our unique way of minimizing MEV. The frontend, built with Next.js and styled using Tailwind CSS, serves as the user interface where traders place limit orders, connect wallets, and monitor trades. Ethers.js bridges the frontend with the SKALE blockchain, enabling direct user interaction with the smart contracts. TypeScript enhances code reliability across the application. The smart contracts, written in Solidity, manage the core functionalities on the SKALE network. For the purpose of this project, we have created our own DEX to simulate trading conditions.\nIt manages trading operations such as token swaps, liquidity management, and order execution, with functions for adding/removing liquidity and handling token swaps. Here, the user mentions the limit orders. The orderbook.sol contract manages the lifecycle of limit orders, providing functionalities to place, modify, and cancel orders. It maintains a record of active orders and interacts with the DEX contract to execute trades when market conditions match the user\u2019s specified price. The PriceChecker.sol contract is responsible for validating real-time prices before executing a trade. It interacts with the DEX to fetch current market prices and ensures that each fragmented order meets the user\u2019s criteria for execution. We have a backend \u201cserver\u201d that utilizes ethers.js and the hardhat framework to conduct constant price checks and executions for every order. We utilized hardhat\u2019s local node for testing as well as SKALE\u2019s Europa DeFi testnet. The \"hacky\" part involved creating the dex.sol contract to simulate a realistic DEX environment for testing. There were no testnet DEX\u2019s, and other DEX\u2019s we tried to use had poor documentation on deployment. Our DEX handles fragmented trade execution, breaking large orders into smaller swaps to prevent frontrunning, leveraging SKALE's zero gas fees for efficient, iterative execution without incurring extra costs.",
        "how_its_made": "The frontend, built with Next.js and styled using Tailwind CSS, serves as the user interface where traders place limit orders, connect wallets, and monitor trades. Ethers.js bridges the frontend with the SKALE blockchain, enabling direct user interaction with the smart contracts. TypeScript enhances code reliability across the application. The smart contracts, written in Solidity, manage the core functionalities on the SKALE network. For the purpose of this project, we have created our own DEX to simulate trading conditions.\nIt manages trading operations such as token swaps, liquidity management, and order execution, with functions for adding/removing liquidity and handling token swaps. Here, the user mentions the limit orders. The orderbook.sol contract manages the lifecycle of limit orders, providing functionalities to place, modify, and cancel orders. It maintains a record of active orders and interacts with the DEX contract to execute trades when market conditions match the user\u2019s specified price. The PriceChecker.sol contract is responsible for validating real-time prices before executing a trade. It interacts with the DEX to fetch current market prices and ensures that each fragmented order meets the user\u2019s criteria for execution. We have a backend \u201cserver\u201d that utilizes ethers.js and the hardhat framework to conduct constant price checks and executions for every order. We utilized hardhat\u2019s local node for testing as well as SKALE\u2019s Europa DeFi testnet. The \"hacky\" part involved creating the dex.sol contract to simulate a realistic DEX environment for testing. There were no testnet DEX\u2019s, and other DEX\u2019s we tried to use had poor documentation on deployment. Our DEX handles fragmented trade execution, breaking large orders into smaller swaps to prevent frontrunning, leveraging SKALE's zero gas fees for efficient, iterative execution without incurring extra costs.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/d7xqy/screenshots/t3tbt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d7xqy/screenshots/5bmb2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d7xqy/screenshots/4pmkn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d7xqy/screenshots/fo6a2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/cryptobaso/cryptobaso_skale",
        "link": "https://ethglobal.com/showcase/cryptobaso-d7xqy"
    },
    {
        "title": "Liquidity",
        "brief_description": "Implementation of an Automated Market Maker (AMM) contract using PINT (Programming Intent Notation). Supports providing liquidity, removing liquidity, token swaps, staking LP tokens, and claiming rewards based on staking duration.",
        "long_description": "This project is an implementation of an Automated Market Maker (AMM) smart contract using PINT (Programming Intent Notation). The contract supports providing liquidity, removing liquidity, token swaps, staking liquidity provider (LP) tokens, and claiming rewards based on staking duration. Contract Features\nProvide Liquidity: Users can provide two tokens, Token A and Token B, to a liquidity pool and receive LP tokens representing their share.\nRemove Liquidity: Users can remove liquidity from the pool by redeeming their LP tokens for Token A and Token B.\nSwap Tokens: Users can swap between Token A and Token B. A fee is charged on swaps, which is distributed to liquidity providers.\nStaking Liquidity: Liquidity providers can stake their LP tokens to earn rewards over time.\nClaiming Rewards: Users who stake their LP tokens can claim rewards based on how long their tokens were staked. The AMM project is built using a robust and scalable architecture. Here's a deep dive into how it was built: Smart Contract Layer: The core of the project is the AMM smart contract, implemented using PINT (Programming Intent Notation). PINT allows for a structured representation of contract logic, which enhances the readability and security of the code. The contract includes functions for providing liquidity, removing liquidity, swapping tokens, staking LP tokens, and claiming rewards. PINT's expressiveness allowed us to simplify complex behaviors through macros such as @auth for authorization checks, and @init_once for state consistency. Backend Infrastructure: The backend, entirely written in Rust, handles off-chain computations and interacts directly with the blockchain. Rust was chosen for its high performance and memory safety, making it ideal for managing critical financial transactions. The backend is responsible for processing requests from users, managing data consistency, and ensuring that all interactions with the blockchain are secure and efficient. Security Measures: Security is a significant concern for any DeFi project. We employed Secp256k1Signature for signed transactions, a cryptographic algorithm known for its use in blockchain systems like Bitcoin. Additionally, PredicateAddress authorization mechanisms were used to ensure flexible, programmable access control, which makes our solution highly secure while allowing composability with other smart contracts. We also implemented nonce-based replay protection to secure transaction integrity. Partner Technologies: To facilitate deployment and continuous integration, we used GitHub Actions for automating testing and deployments. This significantly reduced manual errors and ensured a smooth development workflow. Hacky but Notable Workarounds: One particularly hacky approach worth mentioning is our use of state delta tracking to minimize gas costs during state transitions. Instead of updating the entire state, we track and update only the deltas\u2014what has changed since the last transaction. This optimization led to reduced gas fees and more efficient execution of complex contract operations. By combining PINT, Rust, and efficient deployment practices, we've built a robust, scalable, and efficient AMM that offers flexibility, security, and a solid user experience. Partner technologies like GitHub Actions enriched the platform, ensuring stability and consistent deployments.",
        "how_its_made": "The AMM project is built using a robust and scalable architecture. Here's a deep dive into how it was built: Smart Contract Layer: The core of the project is the AMM smart contract, implemented using PINT (Programming Intent Notation). PINT allows for a structured representation of contract logic, which enhances the readability and security of the code. The contract includes functions for providing liquidity, removing liquidity, swapping tokens, staking LP tokens, and claiming rewards. PINT's expressiveness allowed us to simplify complex behaviors through macros such as @auth for authorization checks, and @init_once for state consistency. Backend Infrastructure: The backend, entirely written in Rust, handles off-chain computations and interacts directly with the blockchain. Rust was chosen for its high performance and memory safety, making it ideal for managing critical financial transactions. The backend is responsible for processing requests from users, managing data consistency, and ensuring that all interactions with the blockchain are secure and efficient. Security Measures: Security is a significant concern for any DeFi project. We employed Secp256k1Signature for signed transactions, a cryptographic algorithm known for its use in blockchain systems like Bitcoin. Additionally, PredicateAddress authorization mechanisms were used to ensure flexible, programmable access control, which makes our solution highly secure while allowing composability with other smart contracts. We also implemented nonce-based replay protection to secure transaction integrity. Partner Technologies: To facilitate deployment and continuous integration, we used GitHub Actions for automating testing and deployments. This significantly reduced manual errors and ensured a smooth development workflow. Hacky but Notable Workarounds: One particularly hacky approach worth mentioning is our use of state delta tracking to minimize gas costs during state transitions. Instead of updating the entire state, we track and update only the deltas\u2014what has changed since the last transaction. This optimization led to reduced gas fees and more efficient execution of complex contract operations. By combining PINT, Rust, and efficient deployment practices, we've built a robust, scalable, and efficient AMM that offers flexibility, security, and a solid user experience. Partner technologies like GitHub Actions enriched the platform, ensuring stability and consistent deployments.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/rn6mp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/oz6a6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/1wggt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/tydxo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/is3e3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/3e4kp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/dkcodes2/amm-pint",
        "link": "https://ethglobal.com/showcase/liquidity-w7ccf"
    },
    {
        "title": "ETHGambit",
        "brief_description": "A superior, decentralized alternative to online chess betting.",
        "long_description": "The act of \"hustling\" is a core part of chess culture. In big cities like New York and Boston, chess hustlers hang out in the park and play strangers, each putting down a small wager on the winner of the game. A single online service, chesshustleonline.com, attempts to capitalize on this tradition. On this website, 10% of each player's bets are taken as a fee. You don't get to decide how much to bet, which chess platform is used, and must wait 5-7 business days for your winnings. However, ETHGambit can completely circumvent all of these downsides. Using blockchain technology, users can take back control of this timeless tradition, tapping into an extremely large market of approximately 110 million users that were previously priced out and sketched out by the status quo. Overall, an intuitive UI combined with a solution alleviating a major pain point in the market will make a big splash in the online chess community, onboarding many enthusiastic users into web3. The blockchain technology used in ETHGambit is a Solidity smart contract originally deployed on Polygon, but switched to Flow. The Polygon Amoy Testnet had about a 50% percent chance of throwing a random \"Internal JSON-RPC Error\" when interacting with the contract, which contributed to much frustration. The Flow Testnet did not have these issues. The contract acts as an escrow with three main functions: An additional part of the back-end is a Python Flask server that grabs the result of the game. To make it more decentralized/trustless, we would use an oracle in the smart contract instead of a central server, which is the next step for this project. The front end was originally planned to be a browser extension, however, we shelved that for the purposes of technical capability demonstration. The UI is built with ReactJS that imports modules like ethers and web3 to pass values to the smart contract.",
        "how_its_made": "The blockchain technology used in ETHGambit is a Solidity smart contract originally deployed on Polygon, but switched to Flow. The Polygon Amoy Testnet had about a 50% percent chance of throwing a random \"Internal JSON-RPC Error\" when interacting with the contract, which contributed to much frustration. The Flow Testnet did not have these issues. The contract acts as an escrow with three main functions: An additional part of the back-end is a Python Flask server that grabs the result of the game. To make it more decentralized/trustless, we would use an oracle in the smart contract instead of a central server, which is the next step for this project. The front end was originally planned to be a browser extension, however, we shelved that for the purposes of technical capability demonstration. The UI is built with ReactJS that imports modules like ethers and web3 to pass values to the smart contract.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/y8v9e/screenshots/snze4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8v9e/screenshots/pzv7y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8v9e/screenshots/pemmw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8v9e/screenshots/2hecg/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wolfiesell/ETHGambit",
        "link": "https://ethglobal.com/showcase/ethgambit-y8v9e"
    },
    {
        "title": "TerraTracker",
        "brief_description": "TerraTracker: Harnessing blockchain and AI for hyper-local disaster predictions. Empower communities with real-time insights, engage users through staking rewards, and support relief efforts with a portion of profits. Predict. Prepare. Protect.",
        "long_description": "TerraTracker is an innovative platform designed to predict natural disasters with precision and engage communities in proactive preparedness. By leveraging blockchain technology, TerraTracker ensures secure, transparent transactions and data integrity. The platform integrates real-time data from diverse sources, such as weather and seismic APIs, using Chainlink oracles for accurate predictions. Key Features: Blockchain Platform: Flow, Polygon for smart contracts, ensuring secure and transparent transactions. Integration and Benefits Notable Hacks",
        "how_its_made": "Blockchain Platform: Flow, Polygon for smart contracts, ensuring secure and transparent transactions. Integration and Benefits Notable Hacks",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/7jne7/screenshots/onvb4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7jne7/screenshots/sb9xp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7jne7/screenshots/cabr2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jackiesafari/Terratracker3",
        "link": "https://ethglobal.com/showcase/terratracker-7jne7"
    },
    {
        "title": "Fluxus",
        "brief_description": "The project aims to maintain stablecoin price stability within a Uniswap V4 pool by using Chronicle oracles and dynamic fees.",
        "long_description": "The aim of the our project is to create a flexible, dynamic fee system that maintains stablecoin price stability within a Uniswap V4 liquidity pool. By integrating external oracles, dynamic fees, and the ability to toggle price behavior, we seek to maintain the value of a stablecoin near its target, discouraging extreme price volatility through economic incentives (fees). Smart Contract:\nThe smart contract is built via Foundry. It integrates Uniswap V4 to customize swap behavior for stablecoin trades, allowing dynamic fee adjustments based on price deviations from a target. The contract manages stablecoin prices using oracles to track pool prices and applies dynamic buy/sell fees to stabilize the price. A flipping mechanism allows the contract to switch between two pricing models. Fees are capped at 50%, encouraging price stability. Core functions include retrieving stablecoin prices, calculating fees, and modifying Uniswap\u2019s swap behavior. Additionally, a selfKiss method links oracles through the Chronicle ISelfKisser interface. Frontend:\nThis frontend is built with Next.js, React, and other web3 tools. It integrates authentication using Alchemy Account Kit with multiple login options, including email, passkey, social logins (Google, Facebook), and external wallets via WalletConnect. The project also utilizes Sepolia Testnet for blockchain interactions, configured with Alchemy's infrastructure for secure data transport.\nReact Query is used for efficient data fetching, and Wagmi with Viem handles wallet connections and blockchain transactions. TailwindCSS is used for styling, and ESLint ensures code quality. This setup makes the app a responsive and secure platform for interacting with stablecoins and decentralized finance features.",
        "how_its_made": "Smart Contract:\nThe smart contract is built via Foundry. It integrates Uniswap V4 to customize swap behavior for stablecoin trades, allowing dynamic fee adjustments based on price deviations from a target. The contract manages stablecoin prices using oracles to track pool prices and applies dynamic buy/sell fees to stabilize the price. A flipping mechanism allows the contract to switch between two pricing models. Fees are capped at 50%, encouraging price stability. Core functions include retrieving stablecoin prices, calculating fees, and modifying Uniswap\u2019s swap behavior. Additionally, a selfKiss method links oracles through the Chronicle ISelfKisser interface. Frontend:\nThis frontend is built with Next.js, React, and other web3 tools. It integrates authentication using Alchemy Account Kit with multiple login options, including email, passkey, social logins (Google, Facebook), and external wallets via WalletConnect. The project also utilizes Sepolia Testnet for blockchain interactions, configured with Alchemy's infrastructure for secure data transport.\nReact Query is used for efficient data fetching, and Wagmi with Viem handles wallet connections and blockchain transactions. TailwindCSS is used for styling, and ESLint ensures code quality. This setup makes the app a responsive and secure platform for interacting with stablecoins and decentralized finance features.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/zr3xd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/a03vp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/caubd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/oqbr5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/s5tsy/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Ashy5000/stablecoin_contracts",
        "link": "https://ethglobal.com/showcase/fluxus-ci8sj"
    },
    {
        "title": "StreamChain",
        "brief_description": "We don\u2019t want a centralized organization controlling crucial video evidence of things like police brutality or war crimes, but safety and legality must be paramount. StreamChain combines the trust of decentralized storage with the versatility of multi-modal LLM moderation.",
        "long_description": "While we don\u2019t want a centralized organization controlling crucial video evidence of things like police brutality or war crimes, safety and legality must be paramount. Combining the decentralized and immutable nature of Walrus Blob Storage with the safety and versatility of multi-modal LLM content moderation, we can ensure that videos that need to be published can be seen, while also moderating content that users upload, simultaneously ensuring the legality of the uploaded content. Using the SKALE blockchain, the content moderation model is fully auditable, as every confirmation or rejection is pushed to the chain with a reason provided by the model. Even the weights of the model are published on Walrus, meaning anybody can investigate the nature of the model and object to its behavior. Walrus Blob Storage is leveraged for its decentralized and immutable nature. The frontend procures blobIDs directly from the SKALE blockchain, and fetches the video directly from Walrus. Before any content is pushed to Walrus, the content moderation must make a decision as to its visibility and legality. Using the SKALE blockchain, the content moderation model is fully auditable, as every confirmation or rejection is pushed to the chain with a reason provided by the model. Even the weights of the model are published on Walrus, meaning anybody can investigate the nature of the model and object to its behavior. The video content moderation system uses an advanced filtering technique that can moderate huge amounts of footage with little inference cost. First, the frames are embedded in a multi-modal vector space using OpenAI CLIP. This process runs super fast entirely on device using Mac M2 Metal Performance Shaders. We can run this inexpensive computation in huge volume for free, which makes it perfect for filtering out potential true positives. We can then forward the frame to a smarter model, such as GPT-4o, for a final decision on content moderation. This method of content moderation is completely zero shot and is therefore extremely versatile. It can be further tuned with either fine-tuning or prompt adjustments, which can increase accuracy and usability.",
        "how_its_made": "Walrus Blob Storage is leveraged for its decentralized and immutable nature. The frontend procures blobIDs directly from the SKALE blockchain, and fetches the video directly from Walrus. Before any content is pushed to Walrus, the content moderation must make a decision as to its visibility and legality. Using the SKALE blockchain, the content moderation model is fully auditable, as every confirmation or rejection is pushed to the chain with a reason provided by the model. Even the weights of the model are published on Walrus, meaning anybody can investigate the nature of the model and object to its behavior. The video content moderation system uses an advanced filtering technique that can moderate huge amounts of footage with little inference cost. First, the frames are embedded in a multi-modal vector space using OpenAI CLIP. This process runs super fast entirely on device using Mac M2 Metal Performance Shaders. We can run this inexpensive computation in huge volume for free, which makes it perfect for filtering out potential true positives. We can then forward the frame to a smarter model, such as GPT-4o, for a final decision on content moderation. This method of content moderation is completely zero shot and is therefore extremely versatile. It can be further tuned with either fine-tuning or prompt adjustments, which can increase accuracy and usability.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zj41z/screenshots/85586/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zj41z/screenshots/hd7sx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zj41z/screenshots/prgpj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sun-jay/ETHsf24",
        "link": "https://ethglobal.com/showcase/streamchain-zj41z"
    },
    {
        "title": "undegen finance",
        "brief_description": "Undegen simplifies portfolio management by using a risk survey defined strategy to build and rebalance crypto investments automatically. Users can easily sign up, deposit funds, and maintain an optimal mix of assets based on their risk tolerance.",
        "long_description": "Our project tackles the challenge that many users face in building and balancing an optimal portfolio aligned with their risk tolerance, particularly those outside the U.S. who lack access to traditional investment options. Inspired by The Missing Billionaires by James White and Victor Haghani, we address common mistakes investors make when assessing risk, which often leads to poor financial outcomes. Through Undegen, users begin by taking a risk profile survey that helps them allocate assets across risk categories. This allocation is based on Merton portfolio calculations, offering an optimal split between low-risk (USDC with fixed yield) and high-risk (staked ETH and wrapped Bitcoin) assets. Users can then easily sign up with just an email and deposit funds, starting with USDC, to have their portfolio automatically built. Once set up, the platform provides real-time visibility into their holdings via a dashboard. The system continuously monitors risk allocation, and users can update their risk profile at any time, triggering automatic rebalancing of their portfolio to ensure it aligns with their updated investment goals and risk tolerance. Undegen aims to offer a globally accessible, permissionless solution for portfolio optimization, making smart investing easy and adaptable for everyone. We're streamlining the onboarding process by using Dynamic, which allows users to sign up using just their email. In the background, this creates an embedded wallet, offering a seamless experience without the complexity of traditional wallet setup. We're also generating a Safe smart wallet for each user. This wallet enables account abstraction, which lets us send transactions and handle gas fees on behalf of the user, enhancing usability. Our system leverages a Safe module to initiate a transaction on the Safe smart account, calling the UndegenModule's rebalance() function. This function then calls back into the Safe account (where it has authorization as an approved module), performing a delegatecall to the UndegenRebalancer contract. The rebalance action is executed from there, dynamically adjusting the portfolio based on preset risk strategies. One key advantage of this architecture is that the rebalancing occurs without needing explicit approvals, allowing everything to happen within a single transaction. The user still initiates the flow by specifying the desired allocation of risky assets (in USD) for their portfolio, with any excess automatically deposited into a USDC fixed-rate pool on Hyperdrive. To ensure accurate conversions between token prices and USD, our contracts use Chronicle oracles, ensuring smooth and precise portfolio rebalancing. We also used shadcn components for both figma and front-end implementation.",
        "how_its_made": "We're streamlining the onboarding process by using Dynamic, which allows users to sign up using just their email. In the background, this creates an embedded wallet, offering a seamless experience without the complexity of traditional wallet setup. We're also generating a Safe smart wallet for each user. This wallet enables account abstraction, which lets us send transactions and handle gas fees on behalf of the user, enhancing usability. Our system leverages a Safe module to initiate a transaction on the Safe smart account, calling the UndegenModule's rebalance() function. This function then calls back into the Safe account (where it has authorization as an approved module), performing a delegatecall to the UndegenRebalancer contract. The rebalance action is executed from there, dynamically adjusting the portfolio based on preset risk strategies. One key advantage of this architecture is that the rebalancing occurs without needing explicit approvals, allowing everything to happen within a single transaction. The user still initiates the flow by specifying the desired allocation of risky assets (in USD) for their portfolio, with any excess automatically deposited into a USDC fixed-rate pool on Hyperdrive. To ensure accurate conversions between token prices and USD, our contracts use Chronicle oracles, ensuring smooth and precise portfolio rebalancing. We also used shadcn components for both figma and front-end implementation.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/sr3vj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/bxefr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/e99x0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/w916i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/4f9cw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/dcejp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/pcarranzav/undegen-contracts",
        "link": "https://ethglobal.com/showcase/undegen-finance-ym8tt"
    },
    {
        "title": "\u00c6xtend",
        "brief_description": "\u00c6xtend is a way to take your life, your specialty, and spread it everywhere.",
        "long_description": "The Project uses a series of AI agents to Mimic your skills, to make the model much better than it was at that skill, which also make it better than leading models at that skill while still being a mid-tier model. We first feed an AI model some documents you might have, it makes conclusions, which show us its thinking process and what its learning. From there you can edit that according to what you need it to be then test it with that takeaway/thought-process, then tweak it, and repeat the cycle till what you have is the perfect one. From there use it on real life projects. Usually Gemini 1.5 < GPT-4o For us, Gemini 1.5+\u00c6xtend > GPT-4o There is also Yddgrasil mode, which is several Gemini 1.5+\u00c6xtend skills put togther, this is >4o, weaker than OpenAI O1, but can reason with many more diverse skills and over much longer sizes (1M tokens), giving it some advantages over even the strongest models This project was made with my favorite fullstack setup, Sveltekit+Firebase, Then I used the Google GenAI api and its Model Gemini 1.5 for the very long very fast AI capabilities. From there I also used the Clip model to measure text similarity, and I used @Coinbase's wallets for all the transactions between my agents. Overall everything connects in the front end, but I had to make a key operation into a backend part and now its really clean+open source jump point for AI agents",
        "how_its_made": "This project was made with my favorite fullstack setup, Sveltekit+Firebase, Then I used the Google GenAI api and its Model Gemini 1.5 for the very long very fast AI capabilities. From there I also used the Clip model to measure text similarity, and I used @Coinbase's wallets for all the transactions between my agents. Overall everything connects in the front end, but I had to make a key operation into a backend part and now its really clean+open source jump point for AI agents",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/mn7xw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/u6p09/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/8hmup/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/k0mbu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/2yrfi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/h3458/default.jpg"
        ],
        "live_demo": "https://extendtheta.vercel.app/",
        "source_code": "https://github.com/VatsaDev/ethglobalhack",
        "link": "https://ethglobal.com/showcase/aextend-6e2df"
    },
    {
        "title": "Swipa.meme",
        "brief_description": "Memecoin collecting with Tinder UI and points. If you like it, swipe right \ud83d\ude80",
        "long_description": "We're bringing memecoins to the masses, using a familiar touch: the swipe \u2714\ufe0f Memecoins are eating the world. In 2024, the memecoin market cap is $44.9B, and it's only going to grow. We want everyone in the world to join in on the fun. Introducing: Swipa.meme How does it work? The project is a PWA that aims to abstract as much of the boring and difficult web3 elements of crypto away from users so that they can focus on the fun of curating and rating memes for points. One point = one swipe = $0.01 Tech stack User Onboarding Swiping Cashing out",
        "how_its_made": "The project is a PWA that aims to abstract as much of the boring and difficult web3 elements of crypto away from users so that they can focus on the fun of curating and rating memes for points. One point = one swipe = $0.01 Tech stack User Onboarding Swiping Cashing out",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/r82ik/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/1mhp3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/adxwg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/1r0i8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/mgrca/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/a2no6/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/thatguyintech/swipa",
        "link": "https://ethglobal.com/showcase/swipa-meme-zucyg"
    },
    {
        "title": "Crypto Carbon Alerts",
        "brief_description": "We built a React app that connects to user authentication via Alchemy\u2019s Accounts UI Widget. We're creating a composite Ethereum token of two crypto carbon credits on Celo using Toucan Protocol. A subgraph listens to wallet events and broadcasts via XMTP to a Telegram bot.",
        "long_description": "The background of this project is deeply rooted in sustainability, especially in the context of upcoming regulations like California's SB 253 and SB 261, which require companies to report on their carbon emissions across Scope 1, 2, and 3. These regulations, along with growing pressures from big tech companies like Amazon and Apple, are pushing corporations to be more transparent about their emissions and take action to reduce them.\nTo achieve net-zero emissions, these companies will need to purchase carbon offsets that compensate for the emissions they can't eliminate. However, there is currently a dearth of high-quality carbon credits, and the process of purchasing and managing them can be cumbersome.\nThe Role of Blockchain:\nBlockchain offers a promising solution by enabling dramatic transparency in carbon credit transactions. It allows companies to seamlessly purchase and retire carbon credits, ensuring that these credits are verifiable and traceable. The application your team built aims to address this need by fractionalizing a variety of carbon credits into a single composite token, reducing friction for companies seeking to offset emissions across various projects related to their operations.\nSingle Token for Multiple Projects:\nCompanies often want to offset their carbon footprint by investing in a variety of projects such as: Our team of three UC Berkeley students built for EthGlobal SF integrates several advanced technologies to create a unique solution for tracking and broadcasting crypto carbon credit movements.\nOverview:\nThe project is a React-based application that leverages Alchemy, Ethereum smart contracts, Toucan Protocol, The Graph, and XMTP for decentralized carbon credit tracking. The purpose of this application is to allow users to authenticate, monitor, and interact with carbon credit transactions on the blockchain, broadcasting real-time updates to a Telegram bot for easy tracking.\nDetailed Components:",
        "how_its_made": "Our team of three UC Berkeley students built for EthGlobal SF integrates several advanced technologies to create a unique solution for tracking and broadcasting crypto carbon credit movements.\nOverview:\nThe project is a React-based application that leverages Alchemy, Ethereum smart contracts, Toucan Protocol, The Graph, and XMTP for decentralized carbon credit tracking. The purpose of this application is to allow users to authenticate, monitor, and interact with carbon credit transactions on the blockchain, broadcasting real-time updates to a Telegram bot for easy tracking.\nDetailed Components:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gus4z/screenshots/1xe6j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gus4z/screenshots/kydt4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gus4z/screenshots/y8eve/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gus4z/screenshots/dm8fu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/CarbonSustain/ethglobalsf",
        "link": "https://ethglobal.com/showcase/crypto-carbon-alerts-gus4z"
    },
    {
        "title": "PintSwap",
        "brief_description": "We built the first DEX on Essential Blockchain, powered by a declarative framework. Users can seamlessly add/remove liquidity, swap tokens, and earn LP tokens. Plus, we open-sourced a JS framework to make Essential development accessible to all developers.",
        "long_description": "Our project is the first decentralized exchange (DEX) built on Essential Blockchain, which operates using a declarative programming model. Essential allows state updates driven by constraints and solvers, optimizing outcomes without requiring direct transaction execution.\nWe dedicated significant time to developing and open-sourcing a TypeScript framework for Essential Blockchain, as no such framework existed before. This tool allows other developers to build applications on Essential using JavaScript/TypeScript, significantly lowering the barrier to entry for the ecosystem. In addition, we created a rigorous testing framework that helped us master contract syntax. Due to the limited resources and documentation available, we frequently worked with Essential\u2019s development team in Australia to troubleshoot issues and deepen our understanding of the chain and its capabilities. Our DEX allows users to:\n\u2022\tAdd/remove liquidity using token pairs and receive LP tokens, representing their share of the liquidity pool.\n\u2022\tSwap tokens within the liquidity pools, with prices adjusting automatically based on the AMM model.\n\u2022\tEarn LP tokens for providing liquidity and share in transaction fees as passive income.\nSince no tokens existed on the Essential Blockchain when we started, we wrote contracts to mint, burn, and transfer tokens. We also experimented with building a smart wallet tailored for the Essential Blockchain. On the front-end, we utilized Next.js and React to create a modern, responsive user interface, adhering to best practices observed in other swap protocols. Despite building the DEX in just 36 hours, we see incredible potential for future enhancements. Our next steps include developing a Dollar-Cost Averaging (DCA) tool, which will allow users to automatically purchase assets on a scheduled basis using time-based constraints in Pint contracts. This DEX project is just the beginning of leveraging the power of declarative blockchains to innovate in decentralized finance. Building the first decentralized exchange (DEX) on Essential Blockchain was a deeply technical and challenging process, particularly because Essential is a declarative blockchain, and most tooling traditionally supports imperative blockchains. Since Essential only supported Rust, we had to innovate to make the blockchain more accessible to a broader developer audience. Technologies We Used:\n\u2022\tPint: Essential\u2019s declarative smart contract language. It allowed us to write contracts with constraints that solvers could optimize, making the DEX function without relying on sequential execution.\n\u2022\tJavaScript/TypeScript: To make development easier and more accessible, we built a TypeScript framework that lets other developers write tools in JS/TS for Essential, bypassing the need for fluency in Rust. This framework also integrates with Essential\u2019s backend to allow contracts to be executed declaratively.\n\u2022\tNext.js: We built the DEX\u2019s front-end using Next.js & React to create a modern, responsive user interface, adopting best practices from established DEX protocols like Uniswap. This gave us a solid front-end development framework with server-side rendering for optimal performance.\n\u2022\tCustom Testing Framework: Since no robust testing framework existed for Pint contracts, we built our own to ensure that the constraints and contract logic were functioning properly. This involved writing tests that forced us to learn the nuances of the contract language and ensuring that all contract conditions were met during execution.\n\u2022\tSolvers & Constraints: The DEX relies on solvers to find the optimal token swaps and liquidity pooling conditions based on user-set constraints. This required a deep understanding of how solvers work to ensure that valid state transitions were made. How It Came Together:\n\u2022\tBackend Contracts: We built contracts for minting, burning, and transferring tokens since no tokens existed on the Essential chain when we started. These foundational contracts allowed us to create liquidity pools and issue LP tokens. Using Pint, we expressed constraints rather than step-by-step execution, which solvers would optimize to ensure valid outcomes.\n\u2022\tFrontend Development: With Next.js, we implemented the DEX\u2019s UI, allowing users to interact with the smart contracts seamlessly. We focused on user experience by mimicking the design patterns of successful swap protocols, ensuring users could add liquidity, swap tokens, and remove liquidity with ease. Challenges & Hacky Solutions:\n\u2022\tBuilding a JavaScript Framework: One of the most hacky and notable aspects of our project was building the JavaScript framework from scratch. Essential only supports Rust, so to make development easier for the broader community, we created this JS framework so that developers could write tools and apps for Essential without needing to dive deep into Rust. This was critical for us to overcome the limitations imposed by Rust-only support and enabled us to open-source the framework for future projects.\n\u2022\tCustom Wallet Development: We experimented with creating our own smart wallet to handle specific token interactions on the Essential chain. While this wasn\u2019t fully completed during the hackathon, it allowed us to explore how custom wallets could interact with the new JS framework and Pint contracts.\n\u2022\tConstant Communication with Essential\u2019s Dev Team: Since the documentation and guides for Essential were sparse, we often found ourselves directly reaching out to their dev team in Australia. This became essential for resolving tough bugs, especially when we were trying to wrap our heads around the proper contract syntax in Pint and testing various contract executions.",
        "how_its_made": "Building the first decentralized exchange (DEX) on Essential Blockchain was a deeply technical and challenging process, particularly because Essential is a declarative blockchain, and most tooling traditionally supports imperative blockchains. Since Essential only supported Rust, we had to innovate to make the blockchain more accessible to a broader developer audience. Technologies We Used:\n\u2022\tPint: Essential\u2019s declarative smart contract language. It allowed us to write contracts with constraints that solvers could optimize, making the DEX function without relying on sequential execution.\n\u2022\tJavaScript/TypeScript: To make development easier and more accessible, we built a TypeScript framework that lets other developers write tools in JS/TS for Essential, bypassing the need for fluency in Rust. This framework also integrates with Essential\u2019s backend to allow contracts to be executed declaratively.\n\u2022\tNext.js: We built the DEX\u2019s front-end using Next.js & React to create a modern, responsive user interface, adopting best practices from established DEX protocols like Uniswap. This gave us a solid front-end development framework with server-side rendering for optimal performance.\n\u2022\tCustom Testing Framework: Since no robust testing framework existed for Pint contracts, we built our own to ensure that the constraints and contract logic were functioning properly. This involved writing tests that forced us to learn the nuances of the contract language and ensuring that all contract conditions were met during execution.\n\u2022\tSolvers & Constraints: The DEX relies on solvers to find the optimal token swaps and liquidity pooling conditions based on user-set constraints. This required a deep understanding of how solvers work to ensure that valid state transitions were made. How It Came Together:\n\u2022\tBackend Contracts: We built contracts for minting, burning, and transferring tokens since no tokens existed on the Essential chain when we started. These foundational contracts allowed us to create liquidity pools and issue LP tokens. Using Pint, we expressed constraints rather than step-by-step execution, which solvers would optimize to ensure valid outcomes.\n\u2022\tFrontend Development: With Next.js, we implemented the DEX\u2019s UI, allowing users to interact with the smart contracts seamlessly. We focused on user experience by mimicking the design patterns of successful swap protocols, ensuring users could add liquidity, swap tokens, and remove liquidity with ease. Challenges & Hacky Solutions:\n\u2022\tBuilding a JavaScript Framework: One of the most hacky and notable aspects of our project was building the JavaScript framework from scratch. Essential only supports Rust, so to make development easier for the broader community, we created this JS framework so that developers could write tools and apps for Essential without needing to dive deep into Rust. This was critical for us to overcome the limitations imposed by Rust-only support and enabled us to open-source the framework for future projects.\n\u2022\tCustom Wallet Development: We experimented with creating our own smart wallet to handle specific token interactions on the Essential chain. While this wasn\u2019t fully completed during the hackathon, it allowed us to explore how custom wallets could interact with the new JS framework and Pint contracts.\n\u2022\tConstant Communication with Essential\u2019s Dev Team: Since the documentation and guides for Essential were sparse, we often found ourselves directly reaching out to their dev team in Australia. This became essential for resolving tough bugs, especially when we were trying to wrap our heads around the proper contract syntax in Pint and testing various contract executions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/a229i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/dd8jr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/qminr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/pwkya/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/3z0vd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/15yug/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ewitulsk/PintSwap",
        "link": "https://ethglobal.com/showcase/pintswap-70ayj"
    },
    {
        "title": "SuperPass",
        "brief_description": "Super secure password management to prevent database pass code from getting lost or stolen.",
        "long_description": "Passman allows AI powered swipe based authentication to prevent lost or stolen passwords. The application allows database encryption and decryption using AI powered signature recognition preventing the possibility of stolen pass codes and persists on the blockchain to prevent code from becoming lost or forgotten. The server runs on a secure hardware TEE component. This project utilizes SIGN for encryption and decryption, Lit for database management, WALRUS for storage and PHALA for for a secure server. It uses AI image recognition and analysis to verify that the signature belongs to the user and can be used conveniently from either a mobile app or web browser.",
        "how_its_made": "This project utilizes SIGN for encryption and decryption, Lit for database management, WALRUS for storage and PHALA for for a secure server. It uses AI image recognition and analysis to verify that the signature belongs to the user and can be used conveniently from either a mobile app or web browser.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/z2esk/screenshots/8a8jv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z2esk/screenshots/kcg90/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z2esk/screenshots/tfhnr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z2esk/screenshots/0yr0f/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/amirhyoussefi/supersecurepass",
        "link": "https://ethglobal.com/showcase/superpass-z2esk"
    },
    {
        "title": "SmartEthereumWallet",
        "brief_description": "Smart Ethereum Wallet is a secure, user-friendly wallet tracker that monitors your Ethereum wallet activities, sends notifications for incoming/outgoing transactions, and provides a summary of balance changes over time\u2014all in one streamlined dashboard.",
        "long_description": "Smart Ethereum Wallet is a user-friendly tracker that provides real-time insights into Ethereum wallet activities. Built with a React frontend and an Express.js backend, it connects to the Ethereum blockchain using Ethers.js and Infura, ensuring fast and reliable data access. Users can view wallet balances, track transaction history, and receive instant notifications for new transactions through WebSocket integration. A custom caching mechanism on the backend helps reduce redundant API calls, providing a faster and smoother experience. SmartEthereumWallet is built using a React frontend for a seamless user experience, integrated with an Express.js backend to handle API requests and data processing. We used Ethers.js for interacting with the Ethereum blockchain, allowing us to fetch wallet balances and transaction history efficiently. The backend is connected to Infura, which serves as the Ethereum node provider, ensuring quick and reliable access to blockchain data without the need to manage our own nodes.",
        "how_its_made": "SmartEthereumWallet is built using a React frontend for a seamless user experience, integrated with an Express.js backend to handle API requests and data processing. We used Ethers.js for interacting with the Ethereum blockchain, allowing us to fetch wallet balances and transaction history efficiently. The backend is connected to Infura, which serves as the Ethereum node provider, ensuring quick and reliable access to blockchain data without the need to manage our own nodes.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t692u/screenshots/55mpp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t692u/screenshots/c8ry0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t692u/screenshots/yua3s/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/michelllee/SmartEthereumWallet",
        "link": "https://ethglobal.com/showcase/smartethereumwallet-t692u"
    },
    {
        "title": "DeHack",
        "brief_description": "A blazing fast cross-chain bridge utilizing account abstraction across all EVM chains",
        "long_description": "A blazing fast cross-chain bridge utilizing account abstraction across all EVM chains offers a seamless and efficient way to transfer assets. By enabling instant transactions and automating processes through smart contract wallets, users can enjoy a streamlined experience without the complexities of traditional cross-chain methods. This bridge optimizes gas fees and enhances security with additional measures like multi-signatures. Ultimately, it promotes improved liquidity and universal compatibility, making it a vital tool for the evolving DeFi ecosystem. A blazing fast cross-chain bridge utilizing account abstraction across all EVM chains offers a seamless and efficient way to transfer assets. By enabling instant transactions and automating processes through smart contract wallets, users can enjoy a streamlined experience without the complexities of traditional cross-chain methods. This bridge optimizes gas fees and enhances security with additional measures like multi-signatures. Ultimately, it promotes improved liquidity and universal compatibility, making it a vital tool for the evolving DeFi ecosystem.",
        "how_its_made": "A blazing fast cross-chain bridge utilizing account abstraction across all EVM chains offers a seamless and efficient way to transfer assets. By enabling instant transactions and automating processes through smart contract wallets, users can enjoy a streamlined experience without the complexities of traditional cross-chain methods. This bridge optimizes gas fees and enhances security with additional measures like multi-signatures. Ultimately, it promotes improved liquidity and universal compatibility, making it a vital tool for the evolving DeFi ecosystem.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vepwo/screenshots/j154x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vepwo/screenshots/m4df9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vepwo/screenshots/02wdm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Chaitenyag/DeHack",
        "link": "https://ethglobal.com/showcase/dehack-vepwo"
    },
    {
        "title": "PumpRoyale",
        "brief_description": "Improve your fitness goals while also exposing yourself to immense monetary gain.",
        "long_description": "In PumpRoyale users across the globe can stake any amount of USDC across recurring global competitions. At random times during the competition a user is prompted to record themselves completing a basic fitness activity within 10 minutes of being prompted. Those who successfully completed the physical activity within the time frame will have their stake returned while those that fail will lose their stake which will form a losers pool. Upon the completion of every game, there will be a random select few of people that completed the fitness activity and will be awarded a distribution of the losers pool. Not only is the physical challenge relatively simple, but as the user base increases, the potential reward becomes exponentially larger. This project uses smart contracts to hold the stake from the users entering the competition, as well as refunding, and distributing the money from the loser pool amongst some randomly selected winners that completed their physical exercise. We built our frontend in React.js and our backend in Node.js. The reason why deploying this as a web3 application is advantageous is because these type of incentives fitness apps have been built on web2, however with payment processors like Stripe taking a 2.5% fee and receiving so many refund requests, Stripe actually blocked the company. With web3 we can avoid this problem since everything is handled on chain.",
        "how_its_made": "This project uses smart contracts to hold the stake from the users entering the competition, as well as refunding, and distributing the money from the loser pool amongst some randomly selected winners that completed their physical exercise. We built our frontend in React.js and our backend in Node.js. The reason why deploying this as a web3 application is advantageous is because these type of incentives fitness apps have been built on web2, however with payment processors like Stripe taking a 2.5% fee and receiving so many refund requests, Stripe actually blocked the company. With web3 we can avoid this problem since everything is handled on chain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/4zvfv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/sjns9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/y27s7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/xkei8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/04o0s/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/gkarthi280/hackathon_project/",
        "link": "https://ethglobal.com/showcase/pumproyale-vdz5o"
    },
    {
        "title": "Curvy",
        "brief_description": "Custom Curve Custom Curve Custom Curve Custom Curve Custom Curve",
        "long_description": "Custom Curve Custom Curve Custom Curve Custom Curve Custom Curve\nCustom Curve Custom Curve Custom Curve Custom Curve Custom Curve\nCustom Curve Custom Curve Custom Curve Custom Curve Custom Curve\nCustom Curve Custom Curve Custom Curve Custom Curve Custom Curve\nCustom Curve Custom Curve Custom Curve Custom Curve Custom Curve Solidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math",
        "how_its_made": "Solidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/joijc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/odkbq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/ttvfx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/y4xw5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/06iou/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/bksfw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MarcusWentz/eth-sf-2024",
        "link": "https://ethglobal.com/showcase/curvy-vjk7e"
    },
    {
        "title": "HelloACAI",
        "brief_description": "HelloACAI is Agent-based Collaborative AI infrastructure running On-Chain",
        "long_description": "Current Generalized AI helps with suggestions but doesn\u2019t actually help save execution time. AI lacks the ability to take the appropriate action based on the request. Enter Collaborative AI Agents. Multiple AI agents specializing in capabilities like:\nResearch, Interacting with websites, APIs, Calendars, Payments, etc. Purpose-built AI Agents all working together to perform complex tasks. When AI is collaborating, how can we ensure good interactions? Human agents do this through pen and paper contracts, HelloACAI does so via Smart Contracts. Interactions with and between AI Agents are bound by these contracts. HelloACAI also provides a registry for AI Agents built via a Smart Contract. Bring your own AI Agent, choose one from the registry, or both. With Collaborative AI, complex tasks are easily broken up into smaller, specific chunks. Building Collaborative AI via Smart Contracts ensures all agents interact well together. ACI Registry: Agent Collaboration Interface Registry: On-Chain Registry of Agents indexed via Subgraph Spindle \u2013 Agent Collaboration Thread: Spindle is a custom thread management system we built leveraging Substreams to rapidly respond to Agent Requested events from the ACS contract and call the corresponding Agent API Chat Interface: Friendly GUI for interacting with ACAI\nLeveraging Dynamic.xyz for easy sign in with email and CDP onramp for rapid onboarding AI Agents: Each Agent can be created independently by anyone\nAgents get contract signing capabilities, and an EOA provisioned via CDP when they are registered on ACAI",
        "how_its_made": "ACI Registry: Agent Collaboration Interface Registry: On-Chain Registry of Agents indexed via Subgraph Spindle \u2013 Agent Collaboration Thread: Spindle is a custom thread management system we built leveraging Substreams to rapidly respond to Agent Requested events from the ACS contract and call the corresponding Agent API Chat Interface: Friendly GUI for interacting with ACAI\nLeveraging Dynamic.xyz for easy sign in with email and CDP onramp for rapid onboarding AI Agents: Each Agent can be created independently by anyone\nAgents get contract signing capabilities, and an EOA provisioned via CDP when they are registered on ACAI",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hbeet/screenshots/gjixw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hbeet/screenshots/xjuaz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hbeet/screenshots/5c7ry/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/helloacai/helloacai",
        "link": "https://ethglobal.com/showcase/helloacai-hbeet"
    },
    {
        "title": "SmolKOL",
        "brief_description": "A transparent LLM-powered attention marketplace for Twitter.",
        "long_description": "I would encourage you watch the pitch! SmolKOL is an attention marketplace that connects indie Twitter accounts and companies through performance-based bounties. It allows companies or individuals to create bounties for social media engagement, and shitposters to earn rewards based on how well their content performs. The platform ensures that payments are tied to measurable outcomes such as likes or views, providing transparency and efficiency. Current \"KOL\" marketing models involve paying influencers upfront, often with no clear correlation between the payment and the actual results achieved. This creates inefficiency for brands and limits opportunities for smaller content creators to participate. There is a lack of transparency in how much value brands are getting for the money spent. SmolKOL addresses this by allowing companies/individuals to offer bounties based on specific performance metrics. Poasters submit content that aligns with these criteria, and payments are only made if the content meets the required level of engagement. This ensures that compensation is based on actual performance rather than follower count or reputation. SmolKOL operates as a bounty board where bounties are posted in natural language. Companies or individuals specify the type of engagement they want (e.g., likes, views) and the reward for meeting these targets. Creating a Bounty: A brand wants to increase awareness about a new product. They create a bounty for tweets that receive over 100 likes, offering 0.01 ETH for each tweet that meets this condition. Submitting a Tweet: A user with a relevant story or comment about the product tweets and submits their post to SmolKOL once it hits 100 likes. Verification: SmolKOL uses GPT-4O to verify that the tweet meets the bounty\u2019s criteria, including relevance to the prompt and engagement level. If the tweet is approved, the user receives the reward. Rejection Example: If the tweet does not meet the requirements or is irrelevant, GPT-4O provides natural language feedback explaining why it was rejected. SmolKOL has a few multiple parts: More specifically: And some weirdness in between (docker for postgres) It's practically my first time building frontend, especially with Next. I was way more comfortable in Rust, so I used it where I can, but it's certainly an odd mix of tech. I also didn't expect to be exploring prompt engineering before the hackathon; but realized that the new OpenAI beta feature for structured JSON output could be super useful to adjudicate whether a given tweet was valid or not. As such, I spent some time writing a system prompt which pleased me (https://github.com/stanleyjzheng/smolkol/blob/master/openai.md). By far the most annoying part of it was the Twitter API. There's so many oddities; it just said my auth was wrong. It turns out, for the free tier, Twitter API is WRITE ONLY. I've never remotely heard of that; you can create tweets, but not read? Despite all docs saying that 1500 tweets/month could still be read, it's straight up wrong, and one only finds out via forms. Else, it was $100/mo. Therefore, I decided to scrape twitter using my own account's bearer token, which oddly worked much better. Other oddities were that the callback url can't be localhost (but it allows you to set it as localhost?) so localhost:3000 doesn't work, but 127.0.0.1:3000 works fine. Why???? Truly bizzare. But whatever, some makeshift scraping did the job, so it's hard to complain in the end.",
        "how_its_made": "SmolKOL has a few multiple parts: More specifically: And some weirdness in between (docker for postgres) It's practically my first time building frontend, especially with Next. I was way more comfortable in Rust, so I used it where I can, but it's certainly an odd mix of tech. I also didn't expect to be exploring prompt engineering before the hackathon; but realized that the new OpenAI beta feature for structured JSON output could be super useful to adjudicate whether a given tweet was valid or not. As such, I spent some time writing a system prompt which pleased me (https://github.com/stanleyjzheng/smolkol/blob/master/openai.md). By far the most annoying part of it was the Twitter API. There's so many oddities; it just said my auth was wrong. It turns out, for the free tier, Twitter API is WRITE ONLY. I've never remotely heard of that; you can create tweets, but not read? Despite all docs saying that 1500 tweets/month could still be read, it's straight up wrong, and one only finds out via forms. Else, it was $100/mo. Therefore, I decided to scrape twitter using my own account's bearer token, which oddly worked much better. Other oddities were that the callback url can't be localhost (but it allows you to set it as localhost?) so localhost:3000 doesn't work, but 127.0.0.1:3000 works fine. Why???? Truly bizzare. But whatever, some makeshift scraping did the job, so it's hard to complain in the end.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/v4sy5/screenshots/1q5pv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v4sy5/screenshots/ua6o3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v4sy5/screenshots/ut8kg/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/stanleyjzheng/smolkol",
        "link": "https://ethglobal.com/showcase/smolkol-v4sy5"
    },
    {
        "title": "Spatio",
        "brief_description": "Spatio is the perfect assistant for new crypto retail traders",
        "long_description": "Spatio is your ultimate consumer app for retail traders which is a chat assistant that has access to real time crypto, crypto news, macro economic news and your portfolio data, not only that but you can also ask it to send others money and trade and swap assets making it the easiest onboarding tool to your ecosystem We are using groq llama 8b as our base llm while using different functions utilising mobula APIs which helps us fetch the MarketData, metadata and price history of any token, portfolio details and historical networth of your wallet whereas crypto panic for news and zero hedge for macroeconomic data and are asking it to generate code to solve the users query, while we are using dynamic\u2019s inbuilt functions for transferring and are using LiFi widget for cross swaps",
        "how_its_made": "We are using groq llama 8b as our base llm while using different functions utilising mobula APIs which helps us fetch the MarketData, metadata and price history of any token, portfolio details and historical networth of your wallet whereas crypto panic for news and zero hedge for macroeconomic data and are asking it to generate code to solve the users query, while we are using dynamic\u2019s inbuilt functions for transferring and are using LiFi widget for cross swaps",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6ikch/screenshots/22gic/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6ikch/screenshots/t513w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6ikch/screenshots/aym51/default.jpg"
        ],
        "live_demo": "https://spatio-psi.vercel.app/",
        "source_code": "https://github.com/harshalmadnani/spatio",
        "link": "https://ethglobal.com/showcase/spatio-6ikch"
    },
    {
        "title": "BAM Protocol",
        "brief_description": "The BAM Protocol defines a new primitive for incentivizing provable off-chain actions on chain. In addition we have built the BAM portal v0.1, a competitive, scam resistant escrow market for Twitter KOL\u2019s powered by our new primitive.",
        "long_description": "Our Project consists of two main components, the BAM protocol, and the BAM portal. The BAM Protocol is a novel primitive which allows for any off chain action, that can be proven to have happened. The Current Implementation of the BAM protocol is built to be able to incentivise ANY action. To leverage it, you simply need to connect a prover service, an off-chain source of truth (SOT), or an oracle. If the action can be proven, it can be incentivized through the BAM Protocol. To harness the power of the BAM protocol we also created the BAM Portal, which acts as scam-resistant, competitive, escrow market for twitter  KOLs. Incentive providers can create bespoke orders for their needs, filtering by follower count, sentiment, and many other variables, and pair their desired action with an incentive, which is then temporarily stored in the contract. Action providers can negotiate on both the action and the incentives. Once they fill the order, they would create the tweet and provide the tweet ID to our front end. This is then passed to the TEE running on LIT Protocol, which uses the Twitter API to reach consensus on the result of the action. Once consensus is reached the attestation is posted to both Flow network and Fhenix. At this point the incentive is taken out of the order and is sent to the action provider.\\ However our current BAM portal is just the tip of the iceberg. The BAM primitive is far more powerful  and flexible than just verifying twitter KOL\u2019s. Here are some of the extensions that are possible TODAY with BAM.\nIncentivised KOL\u2019s on any platform\nSupply Chain proofs, allowing for real work goods to be exchanged\nWhite hat hacking and auditing\nConsumer / Market Data\nDigital Labor (Logo Creation, Video Creation etc) Our project is designed to facilitate the incentivization of off-chain actions, while still supporting on-chain actions through traditional mechanisms. We achieved this by implementing a fork of the Royco protocol, which provides a solid foundation for managing incentives and verification processes. The core component of the system is the order book, which serves as a marketplace for defining and negotiating the terms of verification scripts. These scripts, which are critical for off-chain action validation, are stored on IPFS and executed by LIT Protocol nodes using Trusted Execution Environments (TEEs). Within the marketplace, order negotiation allows both incentive providers and action providers to adjust the parameters that will feed into these verification scripts. For example, in the case of Twitter actions, these parameters might include follower counts or retweet activity over a specified period. This flexible negotiation process ensures that both parties agree on clear, quantifiable metrics. Once an order is fulfilled on-chain, the off-chain action provider has a set timeframe\u2014defined by the incentive provider\u2014to complete the required action. At that point, the LIT Protocol nodes run the verification scripts to confirm whether the action occurred as agreed. The result is a signed message or hash, which is then verified by the on-chain contract. Upon successful verification, the action provider is paid out atomically, ensuring a secure, trustless transaction. By integrating multiple technologies such as IPFS for decentralized storage, LIT Protocol for off-chain verification, and smart contracts for secure payouts, we\u2019ve built a robust, flexible platform that enables seamless incentivization of both on-chain and off-chain actions.",
        "how_its_made": "Our project is designed to facilitate the incentivization of off-chain actions, while still supporting on-chain actions through traditional mechanisms. We achieved this by implementing a fork of the Royco protocol, which provides a solid foundation for managing incentives and verification processes. The core component of the system is the order book, which serves as a marketplace for defining and negotiating the terms of verification scripts. These scripts, which are critical for off-chain action validation, are stored on IPFS and executed by LIT Protocol nodes using Trusted Execution Environments (TEEs). Within the marketplace, order negotiation allows both incentive providers and action providers to adjust the parameters that will feed into these verification scripts. For example, in the case of Twitter actions, these parameters might include follower counts or retweet activity over a specified period. This flexible negotiation process ensures that both parties agree on clear, quantifiable metrics. Once an order is fulfilled on-chain, the off-chain action provider has a set timeframe\u2014defined by the incentive provider\u2014to complete the required action. At that point, the LIT Protocol nodes run the verification scripts to confirm whether the action occurred as agreed. The result is a signed message or hash, which is then verified by the on-chain contract. Upon successful verification, the action provider is paid out atomically, ensuring a secure, trustless transaction. By integrating multiple technologies such as IPFS for decentralized storage, LIT Protocol for off-chain verification, and smart contracts for secure payouts, we\u2019ve built a robust, flexible platform that enables seamless incentivization of both on-chain and off-chain actions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/2to0b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/xscf4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/q98j0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/swo4a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/8xzhk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/xi59a/default.jpg"
        ],
        "live_demo": "https://bam-portal.vercel.app/",
        "source_code": "https://github.com/githubotoro/BAM",
        "link": "https://ethglobal.com/showcase/bam-protocol-mg10y"
    },
    {
        "title": "Archivault",
        "brief_description": "Museums collection management tool with blockchain-based storage",
        "long_description": "Users can instantly create new record entries by simply taking a photo of an object. This feature eliminates the need for manual data entry, making it incredibly easy to start building a comprehensive digital catalog. Entries can be started and saved for later, with folders to organize pending entries, all entries, and then sorting by exhibits that those artifacts have been a part of. As students new to web3 development, we chose React as our frontend framework. This allowed us to break down our complex UI into manageable pieces for photo capture, AI analysis, and collection management. We focused on creating a minimum viable product where a user could create an entry based on an uploaded photo and then enter information into predefined fields. We used tailwind in order to make the front end prettier. One of us was entirely new to web development and the other was still mostly new. We tried to use Dynamic.xyz for authentication and to create a wallet that was abstracted for the user that is not familiar with blockchain. However, we ran into a lot of issues with TypeScript dependencies and were  not able to implement it.",
        "how_its_made": "As students new to web3 development, we chose React as our frontend framework. This allowed us to break down our complex UI into manageable pieces for photo capture, AI analysis, and collection management. We focused on creating a minimum viable product where a user could create an entry based on an uploaded photo and then enter information into predefined fields. We used tailwind in order to make the front end prettier. One of us was entirely new to web development and the other was still mostly new. We tried to use Dynamic.xyz for authentication and to create a wallet that was abstracted for the user that is not familiar with blockchain. However, we ran into a lot of issues with TypeScript dependencies and were  not able to implement it.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/46nts/screenshots/5kv5i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/46nts/screenshots/0bndn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/46nts/screenshots/e5s18/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/elyiagrace/Archivault",
        "link": "https://ethglobal.com/showcase/archivault-46nts"
    },
    {
        "title": "IPFi Strategy",
        "brief_description": "Create and tokenize your trading strategies on UniSwap with Story Protocol",
        "long_description": "Create your own trading strategies in UniSwap, and tokenize them via Story as IP assets to allow other users to remix or mimic your trades. Users can use different defi concepts to create their strategies including limit orders, liquidity pools with customized fees and pairs, concentrated liquidity, etc. still figuring it out. UniSwap v4's documentation is limited, and this is also my first time leveraging the protocol amongst other things so the learning curve was a little steep. I did not get a chance to even integrate with story protocol unfortunately. Nothing notable for this submission unfortunately, but learned more about UniSwap overall.",
        "how_its_made": "still figuring it out. UniSwap v4's documentation is limited, and this is also my first time leveraging the protocol amongst other things so the learning curve was a little steep. I did not get a chance to even integrate with story protocol unfortunately. Nothing notable for this submission unfortunately, but learned more about UniSwap overall.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/kxcda/screenshots/38k1t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxcda/screenshots/4qn5h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxcda/screenshots/n4f2h/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wanasim/ipfi-strategy",
        "link": "https://ethglobal.com/showcase/ipfi-strategy-kxcda"
    },
    {
        "title": "ReFy",
        "brief_description": "We're building a rewards system for businesses, where customers earn points on every purchase.   These points can be redeemed for gifts, driving customer loyalty and repeat visits.",
        "long_description": "RewardFy is a next-gen rewards system designed to boost customer engagement for retail businesses. It works by offering easy to use loyalty point-earning and gift redemption experiences. Customers are presented with promotional offers, such as earning 10 loyalty points for purchasing a specific item like a bag of chips. Upon making the purchase, customers instantly receive their loyalty points, which can be accumulated and spent on exclusive rewards. For example, a free burrito could be redeemed for 10 points. RewardFy integrates XMTP to create a personalized experience within a business's website interface (existing in the form of a chat bot). Customers can interact with a built-in bot to check their current point balance, discover new offers, and manage their account all in real-time. This integration allows for tracking of promotions, point redemption, a balance tracking system, in hopes of boosting revenues for the business.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/e3j91/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/qn1nc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/pabz8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/4aweu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Parth59/ReFy",
        "link": "https://ethglobal.com/showcase/refy-ppy1t"
    },
    {
        "title": "ReFy",
        "brief_description": "We're building a rewards system for businesses, where customers earn points on every purchase.   These points can be redeemed for gifts, driving customer loyalty and repeat visits.",
        "long_description": "RewardFy is a next-gen rewards system designed to boost customer engagement for retail businesses. It works by offering easy to use loyalty point-earning and gift redemption experiences. Customers are presented with promotional offers, such as earning 10 loyalty points for purchasing a specific item like a bag of chips. Upon making the purchase, customers instantly receive their loyalty points, which can be accumulated and spent on exclusive rewards. For example, a free burrito could be redeemed for 10 points. RewardFy integrates XMTP to create a personalized experience within a business's website interface (existing in the form of a chat bot). Customers can interact with a built-in bot to check their current point balance, discover new offers, and manage their account all in real-time. This integration allows for tracking of promotions, point redemption, a balance tracking system, in hopes of boosting revenues for the business.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/e3j91/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/qn1nc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/pabz8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/4aweu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Parth59/ReFy",
        "link": "https://ethglobal.com/showcase/refy-ppy1t"
    },
    {
        "title": "Anon Therapy",
        "brief_description": "Still waiting for that bull cycle to arrive? Well, you tried therapy and that didn't quite work out, did it? We built Anon Therapy just for you. Speak freely to our trained AI therapists that know how to help degens like you.",
        "long_description": "Still waiting for that bull cycle to arrive? Still getting rugged by influencers while your cousin at Deloitte bought their third Stanley cup? Terrified that this Thanksgiving your uncle is going to ask you about those memecoins you were talking about last year? Afraid your whole life was just a zero interest rate phenomenon? Well, you tried therapy and that didn't quite work out, did it? Your therapist thinks your NFTs are just so cute and those numbers in your spreadsheet aren't real anyway. Jaredfromsubway.eth sandwich attacking your DEX transactions isn't trauma?? We built Anon Therapy just for you. Speak freely to our trained AI therapists that know how to help degens like you. Speak freely because we let you own your own therapy chat logs. There's no dev team at BetterHelp poring over your chat logs and pointing and laughing here. In fact, you can show your chats to your therapist so they know your trauma is real. Bull market came roaring back and you feel on top of the world again? Just pretend these chats never happened and nobody will ever know that you were ever down this bad. Anon Therapy combines LLMs with blockchain technology to deliver and anonymous and secure product. Chat logs are stored on the Walrus network which provides fast and cheap decentralized storage. Dynamic is used for easy login using diverse web3 and web2 methods. We write hashes into a smart contract on Flow to easily port therapy sessions across different devices.",
        "how_its_made": "Anon Therapy combines LLMs with blockchain technology to deliver and anonymous and secure product. Chat logs are stored on the Walrus network which provides fast and cheap decentralized storage. Dynamic is used for easy login using diverse web3 and web2 methods. We write hashes into a smart contract on Flow to easily port therapy sessions across different devices.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sjjk0/screenshots/k7to2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sjjk0/screenshots/ahkhc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sjjk0/screenshots/qewbo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sjjk0/screenshots/f3tkw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Cryptonomic/anonTherapy",
        "link": "https://ethglobal.com/showcase/anon-therapy-sjjk0"
    },
    {
        "title": "TokenTally",
        "brief_description": "Empowering hackathons with decentralized, fair, and programmable judging.",
        "long_description": "Token Tally is a decentralized hackathon judging platform that gives judges a set amount of tokens to allocate across multiple projects as they see fit. After the judging round concludes, the tokens and any prize earnings are automatically distributed to team members using a smart contract and Circles programmable wallet, based on pre-determined allocation percentages. Powered by the Flow blockchain, Token Tally ensures transparent, fair, and automated reward distribution. we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js",
        "how_its_made": "we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/yatrg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/an3zd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/zx1jp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/0pu9c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/yiyeu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/aismael234/Token-Tally",
        "link": "https://ethglobal.com/showcase/tokentally-pceqb"
    },
    {
        "title": "Stake2Meet",
        "brief_description": "Stake2Meet: Stake ETH to book, show up to reclaim, valuing your time.",
        "long_description": "Stake2Meet is a time-respecting tool built for professionals, leveraging blockchain technology to minimize no-shows in scheduled meetings. Using TypeScript and Solidity, it operates by having participants stake a small amount of ETH before they can book a meeting on your calendar. If they attend, the ETH is refunded; if not, you keep it, compensating for lost time. The platform utilizes Next.js for the frontend, Hardhat, and integrates RainbowKit for seamless wallet connections. Ideal for consultants and professionals, and just about anyone that values their time. Stake2Meet reduces spammed, non-committed bookings and ensures your time is valued. Ideal for consultants and professionals, and just about anyone that values their time. It reduces spammed, non-committed bookings and ensures your time is valued. Next.js for the frontend to make everything fast and responsive. For the blockchain side, it relies on Hardhat to deploy and manage Ethereum smart contracts. And to handle wallet connections,  integrated RainbowKit so users can easily connect and stake ETH. I had it all come together to create a platform where people stake ETH to book a meeting, with smart contracts handling everything in the background!",
        "how_its_made": "Next.js for the frontend to make everything fast and responsive. For the blockchain side, it relies on Hardhat to deploy and manage Ethereum smart contracts. And to handle wallet connections,  integrated RainbowKit so users can easily connect and stake ETH. I had it all come together to create a platform where people stake ETH to book a meeting, with smart contracts handling everything in the background!",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9c8do/screenshots/gcet9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9c8do/screenshots/bgx3m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9c8do/screenshots/ra4gc/default.jpg"
        ],
        "live_demo": "https://staketomeet.vercel.app/",
        "source_code": "https://github.com/TheWeb3Attorney/Stake2Meet.",
        "link": "https://ethglobal.com/showcase/stake2meet-9c8do"
    },
    {
        "title": "DAOsaster",
        "brief_description": "Built a decentralized, autonomous disaster response system using AI agents, drones, and blockchain to detect disasters and coordinate responses without relying on traditional infrastructure.",
        "long_description": "In disasters where traditional communication and coordination fail, our project introduces a decentralized, autonomous disaster response system leveraging AI agents, drones, and blockchain technology. We deploy a network of AI agents\u2014global, regional, and local\u2014that continuously monitor environments for signs of disasters. Upon detecting an event, these agents collaborate through a blockchain-based consensus mechanism to confirm the disaster, collect data, and coordinate responses. Key Features: Autonomous Agents: AI agents detect disasters and coordinate with other agents and human organizations.\nDecentralized Coordination: Blockchain is used for trust, identity verification, and tasking rescue efforts without reliance on centralized systems.\nAutonomous Drones: Integration of drones for real-time data collection and support in rescue operations.\nConsensus Building: Agents report disasters and build consensus across the network to validate events.\nShared Data Platform: Creation of a unified, distributed dataset that maintains a shared understanding of the situation among all participants.\nHow It Works: Monitoring and Detection: Agents continuously monitor various data sources and sensors for disaster indicators.\nConsensus and Reporting: Once a potential disaster is detected, agents report it and seek confirmation from others to build consensus.\nData Collection and Sharing: As confidence in the disaster report grows, more resources like drones are deployed to gather additional data.\nAutonomous Coordination: Agents autonomously coordinate the deployment of resources and communicate with human organizations for an effective response.\nHuman Collaboration: Organizations and individuals can interact with the agents, verify their identities through decentralized mechanisms, and contribute to the response efforts.\nImpact: This system enhances disaster preparedness and response by: Providing a resilient communication network that doesn't rely on traditional infrastructure.\nEnabling rapid, coordinated responses through autonomous decision-making.\nEnsuring trust and transparency via blockchain technology.\nFacilitating collaboration between autonomous systems and human responders.\nProject Structure: Our project includes various components such as AI agents, smart contracts for blockchain interaction, tokenization of AI agents, and front-end interfaces for user interaction. Each component is modular and contributes to the overall functionality of the decentralized disaster response system. Our project is constructed by seamlessly integrating a suite of advanced technologies to establish a decentralized, autonomous disaster response system. The initial phase involves data collection from local and global agents using drones that survey and gather crucial information from disaster-stricken areas. This data\u2014which includes high-resolution video files and photographs\u2014is stored on Walrus, a platform adept at handling large file sizes efficiently. To monetize and distribute this valuable content, we utilize Story Protocol, enabling entities like news journalists to mint and use the data. Any profits generated through this process are funneled back into a DAO (Decentralized Autonomous Organization) contract, which the AI agents use to manage the supply chain. This includes automating the purchase of essential supplies like food and arranging logistics such as flight tickets for volunteers. When a disaster occurs, the AI agents initiate communication among themselves via the SKALE chain, assigning roles and coordinating actions autonomously. They leverage the Graph Protocol to query and process data swiftly, ensuring a responsive and efficient operation. Volunteers play a vital role by running DStack on their local computers, which allows them to organize and upload data to automate tasks further. For secure and confidential computing, we employ the Phala Network to run local Trusted Execution Environments (TEEs), safeguarding sensitive information and processes. To bolster liquidity and funding for the DAO managed by the AI agents, users can tokenize any of the AI assets\u2014from drones to omni-gel devices\u2014thereby contributing to the community's resources. We have integrated Dynamic Wallet to streamline user onboarding and wallet interactions, making it easier for participants to engage with the platform and support the disaster response efforts. This collaborative integration of technologies not only enhances the efficiency and effectiveness of disaster response but also fosters a community-driven approach where both AI agents and humans work in tandem to mitigate the impacts of disasters.",
        "how_its_made": "Our project is constructed by seamlessly integrating a suite of advanced technologies to establish a decentralized, autonomous disaster response system. The initial phase involves data collection from local and global agents using drones that survey and gather crucial information from disaster-stricken areas. This data\u2014which includes high-resolution video files and photographs\u2014is stored on Walrus, a platform adept at handling large file sizes efficiently. To monetize and distribute this valuable content, we utilize Story Protocol, enabling entities like news journalists to mint and use the data. Any profits generated through this process are funneled back into a DAO (Decentralized Autonomous Organization) contract, which the AI agents use to manage the supply chain. This includes automating the purchase of essential supplies like food and arranging logistics such as flight tickets for volunteers. When a disaster occurs, the AI agents initiate communication among themselves via the SKALE chain, assigning roles and coordinating actions autonomously. They leverage the Graph Protocol to query and process data swiftly, ensuring a responsive and efficient operation. Volunteers play a vital role by running DStack on their local computers, which allows them to organize and upload data to automate tasks further. For secure and confidential computing, we employ the Phala Network to run local Trusted Execution Environments (TEEs), safeguarding sensitive information and processes. To bolster liquidity and funding for the DAO managed by the AI agents, users can tokenize any of the AI assets\u2014from drones to omni-gel devices\u2014thereby contributing to the community's resources. We have integrated Dynamic Wallet to streamline user onboarding and wallet interactions, making it easier for participants to engage with the platform and support the disaster response efforts. This collaborative integration of technologies not only enhances the efficiency and effectiveness of disaster response but also fosters a community-driven approach where both AI agents and humans work in tandem to mitigate the impacts of disasters.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ngboi/screenshots/3itn3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ngboi/screenshots/dfuga/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ngboi/screenshots/kpva2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ngboi/screenshots/3knzy/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/soma9574/daosaster-response",
        "link": "https://ethglobal.com/showcase/daosaster-ngboi"
    },
    {
        "title": "Permissionless GPT4",
        "brief_description": "Permissionless access to the OpenAI API using TEE and TLS Notary.",
        "long_description": "Ever been banned by OpenAI or Anthropic? Not anymore! This project combines TLS Notary and AWS Nitro Enclaves to create a privacy-preserving OpenAI API proxy access system. By integrating Multiparty Computation and Trusted Execution Environments, it guarantees the authenticity, privacy, and censorship resistance of API requests for any transactional API. Today, accessing powerful APIs like OpenAI\u2019s can often come with trade-offs\u2014whether it\u2019s giving up privacy, being restricted by service providers, or dealing with censorship. But what if you could bypass all of that? That\u2019s where TEEProxy comes in\u2014a cutting-edge system designed to give you secure, private, and permissionless access to OpenAI\u2019s API. At the core of TEEProxy is the combination of AWS Nitro Enclaves and TLS Notary, two state-of-the-art technologies that work together to create a fully encrypted environment. When you send a request to OpenAI through TEEProxy, you can be absolutely sure your data remains private. How? We\u2019ve enhanced the Nitro remote attestation process to give you extra guarantees. Every time you make a request, a unique identifier\u2014called a nonce\u2014is embedded into the attestation document. This ensures that the response is generated specifically for you and hasn\u2019t been pre-fetched or tampered with. Additionally, TEEProxy includes a TLS certificate fingerprint in the attestation. This fingerprint proves that the TLS session\u2014the encrypted connection between you and the API\u2014terminates inside the enclave, giving you even more assurance that your communication is secure. For Service Providers, this system guarantees that their API keys remain confidential, even from the miners who run the nodes. TEEProxy makes it possible for Service Providers to trust that their keys will not be exposed, while still offering seamless access to OpenAI\u2019s powerful API. As a User, you benefit from complete anonymity and protection. Your requests are processed securely within the enclave, so neither miners nor service providers can view or intercept your data. This ensures privacy and protection from surveillance or tracking. And beyond that, censorship resistance is a key feature of TEEProxy. Because of the distributed nature of the miners, no single entity\u2014including OpenAI\u2014can stop you from accessing the API. This is permissionless access, free from restrictions or blocks. TEEProxy is built to give you the strongest guarantees: complete privacy, authenticity of responses, censorship resistance, and security. By using Multiparty Computation (MPC) alongside TLS Notary, TEEProxy guarantees the authenticity of the OpenAI responses. You can be confident that the responses you receive haven\u2019t been altered. Even though the system adds some delay, up to two minutes due to cryptographic proofs, the peace of mind is well worth it. In a world where privacy, security, and censorship resistance are increasingly important, TEEProxy stands as a breakthrough solution. Whether you\u2019re a developer, a researcher, or an enterprise looking for OpenAI API access without compromising on security or privacy\u2014TEEProxy has you covered. TEEProxy \u2013 Your key to secure, permissionless OpenAI API access. In this project, I integrate TLS Notary into the AWS Nitro Enclave and enhance the Nitro remote attestation process to provide additional guarantees for all parties involved. To achieve this I modify the attestation document to include: While functional, TLS Notary introduces significant delays \u2014 up to two minutes per request \u2014 resulting in potential OpenAI timeouts.",
        "how_its_made": "In this project, I integrate TLS Notary into the AWS Nitro Enclave and enhance the Nitro remote attestation process to provide additional guarantees for all parties involved. To achieve this I modify the attestation document to include: While functional, TLS Notary introduces significant delays \u2014 up to two minutes per request \u2014 resulting in potential OpenAI timeouts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h8oyg/screenshots/90sz1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8oyg/screenshots/azhvi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8oyg/screenshots/61j7x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8oyg/screenshots/x1bvi/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/vkleban/teegpt/",
        "link": "https://ethglobal.com/showcase/permissionless-gpt4-h8oyg"
    },
    {
        "title": "PicFable",
        "brief_description": "PicFable allows anyone to monetize their camera roll. Just upload your photos, set the price and terms of use, and you\u2019re done. Buyers can purchase the rights to use your images, remix them, or train AI models on them - with everything handled onchain.",
        "long_description": "PicFable is an image licensing hub powered by the blockchain. Similar to websites like Unsplash and Shutterstock, PicFable creates an easy way for people to discover and license images for various uses. PicFable\u2019s advantages come from its blockchain based architecture, which ensures data availability, transparency, and the ability to allow users to opt-in to being used for AI model training Using Story Protocol, PicFable enables creators to make money from their original images while specifying acceptable uses for their creations. For both professional and hobbyist photographers, PicFable represents a way to make money from stacks of unused digital images. We built this project on the Story Protocol using the Registration and Licensing modules allowing users to register their IP and assign licensing ensuring that they maintain control over their work. A user logs in through Dynamic with a Web2 like onboarding experience reducing friction. Photos are uploaded and stored on Walrus which allows the user to break their reliance on centralized systems. We then register the image on Story and assign a license as chosen by the user. Finally ENS URLs are created showcasing items available in a gallery view allowing users to create personalized pages. Some hacky workarounds were:",
        "how_its_made": "We built this project on the Story Protocol using the Registration and Licensing modules allowing users to register their IP and assign licensing ensuring that they maintain control over their work. A user logs in through Dynamic with a Web2 like onboarding experience reducing friction. Photos are uploaded and stored on Walrus which allows the user to break their reliance on centralized systems. We then register the image on Story and assign a license as chosen by the user. Finally ENS URLs are created showcasing items available in a gallery view allowing users to create personalized pages. Some hacky workarounds were:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bzitq/screenshots/id88g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bzitq/screenshots/13adg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bzitq/screenshots/62jj9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bzitq/screenshots/1t7b9/default.jpg"
        ],
        "live_demo": "https://eth-global-sf-2024.vercel.app/",
        "source_code": "https://github.com/sergical/eth-global-sf-2024",
        "link": "https://ethglobal.com/showcase/picfable-bzitq"
    },
    {
        "title": "Found in Translation",
        "brief_description": "Decentralised system for real time language translations, using open-sourced AI wearables.",
        "long_description": "FoundInTranslation is a decentralised system for real time language translations using open-sourced AI wearables, a perfect marriage between AI and blockchain technology, our elegant attempt to do language transcriptions on the fly. It has a pay as you go model where a user can refill their transcription credits, and allows the user to log in with their EVM-compatible wallet and choose from several target and destination languages. Great for tourist travels, learning new languages with international friends, or watching your favourite foreign films with loved ones. This project utilizes Dynamic for onchain signup mechanism which also utilises Phala's TEE. After a user logs in and authenticates with the preferred wallet, we ask the user to choose a language in which they prefer the translation. We have deployed a smart contract on Polygon for our ERC20 token, which will be utilised by our consumers. The user speaks into the AI wearable Omi and the transcription is sent to the phala AI  agent which in turn does the translation depending on the user's translation language preference, which is further used to convert the translated text to audio in the UI running on next.js.",
        "how_its_made": "This project utilizes Dynamic for onchain signup mechanism which also utilises Phala's TEE. After a user logs in and authenticates with the preferred wallet, we ask the user to choose a language in which they prefer the translation. We have deployed a smart contract on Polygon for our ERC20 token, which will be utilised by our consumers. The user speaks into the AI wearable Omi and the transcription is sent to the phala AI  agent which in turn does the translation depending on the user's translation language preference, which is further used to convert the translated text to audio in the UI running on next.js.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/tdtwj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/vt4hp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/mi0nn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/eww4m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/rju0g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/rg2xh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Prachi1615/FoundInTranslation",
        "link": "https://ethglobal.com/showcase/found-in-translation-rxyws"
    },
    {
        "title": "Archiv3",
        "brief_description": "A video archive aggregator that allows documentary makers to license clips from multiple archives with ease.",
        "long_description": "Documentaries are more popular than ever. Almost 50% of Americans continuously stream docs across all major video channels. Netflix is expected to spend over $1.5 billion on documentary and non-scripted content by next year. Video archive licensing right now is very clunky and often revolves around email. Archiv3 allows filmmakers large and small to pull down clips across multiple archives, allowing for a better product. Product is built on top of Story. Front-end is done through Scaffold ETH. Walrus is used for metadata and asset storage. Hackiest thing in here is a globally resetting array for easy iteration of royalty splits. I figured out that the SDK didn't support the latest smart contract features so I had to hard code a few variables to simulate some of those actions.",
        "how_its_made": "Product is built on top of Story. Front-end is done through Scaffold ETH. Walrus is used for metadata and asset storage. Hackiest thing in here is a globally resetting array for easy iteration of royalty splits. I figured out that the SDK didn't support the latest smart contract features so I had to hard code a few variables to simulate some of those actions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/183kk/screenshots/quncm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/183kk/screenshots/0s8eq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/183kk/screenshots/e6j4u/default.jpg"
        ],
        "live_demo": "https://archiv3-3snws40pz-hlauinfos-projects.vercel.app",
        "source_code": "https://github.com/hlauinfo/archiv3",
        "link": "https://ethglobal.com/showcase/archiv3-183kk"
    },
    {
        "title": "ETH Movie Voting",
        "brief_description": "The ETH Movie Database is a decentralized app built with React and Ethereum. It allows users to vote on movies transparently via MetaMask, recording votes on-chain for a secure, tamper-proof ranking system. A showcase of blockchain's potential in entertainment",
        "long_description": "The ETH Movie Database is a decentralized web application designed to let users rank and vote on movies in a transparent and secure manner. Built as a user-centric platform, it allows users to connect their Ethereum wallet using MetaMask and cast votes on a curated list of movies. The votes are recorded directly on the Ethereum blockchain, ensuring immutability and preventing tampering or manipulation. The application presents users with detailed movie information, including titles, release years, and posters. Users can upvote or downvote movies based on their preferences, and the app dynamically updates the movie rankings based on the community's interactions. The goal is to provide an engaging and transparent voting experience, showcasing how blockchain technology can be applied in entertainment. The ETH Movie Database is developed using React for the frontend, enabling a dynamic and responsive user interface. It integrates with the Ethereum blockchain using the ethers.js library for Web3 interactions. The application relies on MetaMask as the Ethereum provider, allowing users to securely connect their wallets and interact with the smart contract. Technical Details: Frontend: Built with React, the app displays a list of movies with images and current rankings. Users interact with the app through buttons to upvote or downvote, and the state updates in real-time based on the blockchain data.\nSmart Contract: The application\u2019s smart contract is deployed on the Ethereum network. It manages the voting logic, recording votes securely on-chain. The contract provides functions to upvote, downvote, and retrieve vote counts for each movie.\nState Management: The app uses React\u2019s state management to keep track of movie data. When the user connects their wallet and votes, the frontend interacts with the smart contract to update the votes and rankings, ensuring the UI reflects the latest state from the blockchain.\nBlockchain Interaction: MetaMask is used for user authentication and wallet connection. The app creates a Web3Provider using ethers.js to interact with the smart contract. Upon wallet connection, the app fetches and displays the latest voting data from the blockchain.\nThe ETH Movie Database showcases the potential of decentralized applications (dApps) and emphasizes secure, community-driven content ranking through blockchain technology.",
        "how_its_made": "The ETH Movie Database is developed using React for the frontend, enabling a dynamic and responsive user interface. It integrates with the Ethereum blockchain using the ethers.js library for Web3 interactions. The application relies on MetaMask as the Ethereum provider, allowing users to securely connect their wallets and interact with the smart contract. Technical Details: Frontend: Built with React, the app displays a list of movies with images and current rankings. Users interact with the app through buttons to upvote or downvote, and the state updates in real-time based on the blockchain data.\nSmart Contract: The application\u2019s smart contract is deployed on the Ethereum network. It manages the voting logic, recording votes securely on-chain. The contract provides functions to upvote, downvote, and retrieve vote counts for each movie.\nState Management: The app uses React\u2019s state management to keep track of movie data. When the user connects their wallet and votes, the frontend interacts with the smart contract to update the votes and rankings, ensuring the UI reflects the latest state from the blockchain.\nBlockchain Interaction: MetaMask is used for user authentication and wallet connection. The app creates a Web3Provider using ethers.js to interact with the smart contract. Upon wallet connection, the app fetches and displays the latest voting data from the blockchain.\nThe ETH Movie Database showcases the potential of decentralized applications (dApps) and emphasizes secure, community-driven content ranking through blockchain technology.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/msbpq/screenshots/9n4x5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/msbpq/screenshots/h7b8f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/msbpq/screenshots/254ru/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/alexhaeringer/ETHGlobal-SF24",
        "link": "https://ethglobal.com/showcase/eth-movie-voting-msbpq"
    },
    {
        "title": "Gameverse",
        "brief_description": "A chatbot integrating a text-based currency game and a real-world auction system",
        "long_description": "This project combines XMTP messaging and on-chain data storage to implement a currency-based game and auctioning system. Users can solve web3 trivia questions, run commands, be active in group chats to earn coins, and compete with each other by stealing coins from each other and competing to be the top coin holder on the leaderboard. All of these coins are stored on-chain on the SKALE Network, and can be traded for NFTs, collectibles and other tokens. Users in group chats can auction off items to the highest bidder, setting a bid increment and starting bid in an English auction format. The winner of the auction will receive an Open Frame link to pay for their item, and the owner will receive payment once payment has been successfully completed and verified. The project is designed to be a step forward in chatbot integration on-chain, combining an entertainment experience with real-world applications. The development of this project included using Converse's MessageKit framework to develop a chatbot interface. A particularly interesting part of the implementation was designing a custom message handler, as well as editing the source code of the MessageKit framework itself to allow bots to read all messages in group chats so that this handler could extend the existing command framework provided. Some other interesting applications were to create a MessageCollector class that would allow for the bot to \"listen\" to messages in response to a command, without needing for any advanced state-tracking or caching mechanism. This was done using Node.JS' in-built EventEmitter mechanism and event loops. The bot uses SKALE Network to store currency data, minimizing transaction backlog by committing data on-chain every hour in the form of snapshots. This is all handled by the bot's source code in a cron scheduler, making sure that the bot will never miss a snapshot. Data is committed and retrieved from the smart contract when necessary, taking advantage of SKALE's zero-gas mechanisms to completely cut out transaction fees and abstract away the on-chain mechanism of this bot, integrating into a seamless, simple experience for the end user. The bot's auction mechanism is developed using a smart contract on the AirDAO chain -- all details are public, allowing for integration into AirDAO's existing projects like AirQuest (a quest could be implemented for hosting 3 successful auctions etc.). More dev notes and details are included in the repository in the DEVNOTES.MD file.",
        "how_its_made": "The development of this project included using Converse's MessageKit framework to develop a chatbot interface. A particularly interesting part of the implementation was designing a custom message handler, as well as editing the source code of the MessageKit framework itself to allow bots to read all messages in group chats so that this handler could extend the existing command framework provided. Some other interesting applications were to create a MessageCollector class that would allow for the bot to \"listen\" to messages in response to a command, without needing for any advanced state-tracking or caching mechanism. This was done using Node.JS' in-built EventEmitter mechanism and event loops. The bot uses SKALE Network to store currency data, minimizing transaction backlog by committing data on-chain every hour in the form of snapshots. This is all handled by the bot's source code in a cron scheduler, making sure that the bot will never miss a snapshot. Data is committed and retrieved from the smart contract when necessary, taking advantage of SKALE's zero-gas mechanisms to completely cut out transaction fees and abstract away the on-chain mechanism of this bot, integrating into a seamless, simple experience for the end user. The bot's auction mechanism is developed using a smart contract on the AirDAO chain -- all details are public, allowing for integration into AirDAO's existing projects like AirQuest (a quest could be implemented for hosting 3 successful auctions etc.). More dev notes and details are included in the repository in the DEVNOTES.MD file.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h8w91/screenshots/bzkp0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8w91/screenshots/gaovb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8w91/screenshots/tk5ro/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8w91/screenshots/xc6fn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/keshramamurthy/gameverse-ethsf/",
        "link": "https://ethglobal.com/showcase/gameverse-h8w91"
    },
    {
        "title": "PolymarketAnalytics",
        "brief_description": "Polymarket Analytics allows you to fetch and analyze all trades made by any account on Polymarket, bypassing the platform's viewing limitations. Track profit and loss over time, inspect impactful trades, and uncover trading strategies. Built using Scaffold-ETH-2 and subgraphs.",
        "long_description": "Our project provides an analytics tool for Polymarket users. Polymarket does not allow users to view the complete trade history of an account, which limits their ability to analyze performance and strategies. We address this limitation by using subgraphs/substreams to fetch all trades made by any account on Polymarket. This enables users to: Future Plans: We plan to allow users to connect their own wallets and automatically copy trades made by other Polymarket traders using substreams. Substreams offer lower latency than subgraphs, minimizing tracking errors when copying trades. Implementation of this feature is currently on hold due to issues with the Application Binary Interface (ABI) of the Polymarket CTF Market, which prevents proper functionality. We built Polymarket Analytics using Scaffold-ETH-2 as our foundational template, which streamlined our setup process. Data Retrieval with Subgraphs/Substreams: We utilized multiple existing subgraphs and developed a custom subgraph to fetch detailed trade data from Polymarket. These subgraphs collect and organize on-chain data, making it accessible for analysis. Chart.js and similar libraries to visualize the data By using subgraphs we've created a tool that enhances transparency and strategy analysis for Polymarket users.",
        "how_its_made": "We built Polymarket Analytics using Scaffold-ETH-2 as our foundational template, which streamlined our setup process. Data Retrieval with Subgraphs/Substreams: We utilized multiple existing subgraphs and developed a custom subgraph to fetch detailed trade data from Polymarket. These subgraphs collect and organize on-chain data, making it accessible for analysis. Chart.js and similar libraries to visualize the data By using subgraphs we've created a tool that enhances transparency and strategy analysis for Polymarket users.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/e18yc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/6g706/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/fqwp8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/gwm5r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/9vhuc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/HighDom/polymarket_analysis_v1",
        "link": "https://ethglobal.com/showcase/polymarketanalytics-vt1dm"
    },
    {
        "title": "SnapSafe",
        "brief_description": "The world's first secure screenshot app that prioritizes your privacy.",
        "long_description": "SnapSafe is the ultimate privacy-focused screenshot app. It empowers users to securely capture, edit, and organize screenshots without worrying about unauthorized access or data leaks. With advanced features like OCR for text extraction, decentralized storage, and a cross-platform dashboard, SnapSafe offers a seamless experience for managing images, all while ensuring your privacy is the top priority. In a world of growing data concerns, SnapSafe is the go-to solution for anyone seeking the perfect balance between functionality and security. We use IPFS/Walrus for storage. And we use SKALE/FLOW/MORPH to manage directory.\nWe use Electron to make the app fully cross-platform compatible, and after uploading the screenshots, it gets stored as directory in the chain.",
        "how_its_made": "We use IPFS/Walrus for storage. And we use SKALE/FLOW/MORPH to manage directory.\nWe use Electron to make the app fully cross-platform compatible, and after uploading the screenshots, it gets stored as directory in the chain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/oa3mv/screenshots/811ze/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oa3mv/screenshots/k0pke/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oa3mv/screenshots/i5y7o/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AllenAJ/SnapSafe",
        "link": "https://ethglobal.com/showcase/snapsafe-oa3mv"
    },
    {
        "title": "AutoSplit",
        "brief_description": "AutoSplit is an expense-sharing dApp that revolutionizes debt management. Define personalized debt thresholds, and watch as automated reimbursement requests with secure payment links are effortlessly dispatched\u2014all powered by the gas-free Skale Network.",
        "long_description": "AutoSplit is a decentralized application designed to simplify expense sharing and debt management among friends, colleagues, and groups. AutoSplit automates the entire process by allowing users to create groups, add participants, shared expenses, and set personalized debt thresholds. When a member's debt surpasses the limit set by the payer, the app automatically sends a notification with a secure payment link, eliminating the need for awkward conversations. Leveraging Sign Protocol, each expense generates a verifiable attestation sent via XMTP, ensuring transactions are secure and trustworthy. With real-time balance tracking and secure in-app messaging, AutoSplit fosters transparency and accountability, making shared finances seamless and stress-free. AutoSplit is built on the Skale Network, chosen for its zero gas fees, high throughput, and EVM compatibility, which are essential for handling numerous daily microtransactions cost-effectively. The frontend is developed using React with TypeScript to ensure a user-friendly and scalable interface. Smart contracts written in Solidity manage group creation, expense tracking, and debt thresholds, seamlessly interacting with the Skale blockchain. Integration with Sign Protocol allows each expense to generate secure, verifiable attestations sent via XMTP, enabling automated and trustworthy notifications. By combining Skale's robust infrastructure with Sign Protocol's security features, AutoSplit delivers a reliable and intuitive solution for managing shared expenses and repayments without the complexities of traditional Web3 applications.",
        "how_its_made": "AutoSplit is built on the Skale Network, chosen for its zero gas fees, high throughput, and EVM compatibility, which are essential for handling numerous daily microtransactions cost-effectively. The frontend is developed using React with TypeScript to ensure a user-friendly and scalable interface. Smart contracts written in Solidity manage group creation, expense tracking, and debt thresholds, seamlessly interacting with the Skale blockchain. Integration with Sign Protocol allows each expense to generate secure, verifiable attestations sent via XMTP, enabling automated and trustworthy notifications. By combining Skale's robust infrastructure with Sign Protocol's security features, AutoSplit delivers a reliable and intuitive solution for managing shared expenses and repayments without the complexities of traditional Web3 applications.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/varyw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/ivn7s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/bes5f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/thdhy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/r57rt/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MarouaBoudoukha/AutoSplit",
        "link": "https://ethglobal.com/showcase/autosplit-dr6oj"
    },
    {
        "title": "my own words",
        "brief_description": "Browser Extension for portable IP experimentation and interactions",
        "long_description": "my-own-words is a browser extension organizing the provenance and nuance of ideas on the Story Network. Users can create written work in the editor of their choice, highlight it, attach terms of fair use and register a snapshot of its provenance and permissions. There is AI support natively integrated into the project for users unfamiliar Story or IP to still have understanding, agency, and support as they navigate registering new works. We see this project being especially useful for two audiences: researchers and academics who very much value the provenance of ideas, creators and artists across industries. This project uses Pinata and IPFS for storage of text files, Polygon for tokenization of these files' content IDs, and Story SDK for registering these NFTs onchain with licensing terms. We used React, Typescript, ChakraUI, and Emma's original Procreate animations for the front end. For the backend, we used an express server, cors for browser extension to server communication. We also used the ChatGPT API to create and fine-tune our AI arbiter and AI also to auto-suggest recommendations for descriptions, licensing terms, etc. for a simple introduction to IP.",
        "how_its_made": "This project uses Pinata and IPFS for storage of text files, Polygon for tokenization of these files' content IDs, and Story SDK for registering these NFTs onchain with licensing terms. We used React, Typescript, ChakraUI, and Emma's original Procreate animations for the front end. For the backend, we used an express server, cors for browser extension to server communication. We also used the ChatGPT API to create and fine-tune our AI arbiter and AI also to auto-suggest recommendations for descriptions, licensing terms, etc. for a simple introduction to IP.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/d1a7h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/aakkc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/8nhfp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/y5yav/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/ci8j4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/nxad7/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/emmanasseri/my-own-words",
        "link": "https://ethglobal.com/showcase/my-own-words-9uap2"
    },
    {
        "title": "Left Curve Simulator",
        "brief_description": "LCS is a dex where users press one button and automatically purchase 3 silly memecoins at random.",
        "long_description": "Buying memecoins is hard, that's why we built left curve simulator! With LCS even the dumbest left curve can buy memecoins with virtually no difficulties or strategy. LCS is a dex where users press one button and automatically purchase 3 silly memecoins at random. To decrease friction, we are utilizing unlimit crypto to allow users to onramp with debit or credit card, and start transacting with Ethereum. After they onramp, they just need to determine how much money they want to ape into memecoins. Once they decide they click generate and 3 random tokens are chosen, and purchased. To make sure only quality tokens are generated we filter tokens by minimum TVL of $5k, and have transactions which occurred within 24 hours. We also are passing the data through AI to make sure only tokens with silly names are chosen. tbdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddd",
        "how_its_made": "tbdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddd",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zzzqa/screenshots/kzm8r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zzzqa/screenshots/jep8i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zzzqa/screenshots/cht3e/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/arrudagates/leftcurve",
        "link": "https://ethglobal.com/showcase/left-curve-simulator-zzzqa"
    },
    {
        "title": "IP Infinity",
        "brief_description": "The user will input their ENS; their NFTs are processed, labeled as a type of game object (character, equipment, other), and given stats based on its floor price and traits. The NFTs get put in a world with a procedurally generated map/world with full game functionality.",
        "long_description": "IP-Landers is a project that brings NFTs to life by creating an interactive game experience combining digital IP assets with an immersive world. The process begins when users input their ENS. Their NFTs are each processed and categorized by AI, getting transformed into game objects like characters or equipment. Each game object is assigned stats that reflect the floor price and its traits. These assets are then implemented into a procedurally generated game world built in Unreal Engine, providing an engaging and dynamic environment. The project's unique feature is the story's IP database, which allows users to share their NFT worlds and contribute to them with their own distinct characters and stories. IP-Landers was built using AI models, blockchain integration, and game development tools. Meta's Llama 3.2 vision model analyzes the NFT images, generating text descriptions that are categorized by the DeBERTa zero-shot classification model, sorting them into different types of objects. Unreal Engine powers the game, featuring procedurally generated landscapes and dungeons for a dynamic experience. Story Protocol's platform allows collaborative creativity without IP disputes. We implemented a unique solution to link NFT metadata to playable Unreal Engine assets.",
        "how_its_made": "IP-Landers was built using AI models, blockchain integration, and game development tools. Meta's Llama 3.2 vision model analyzes the NFT images, generating text descriptions that are categorized by the DeBERTa zero-shot classification model, sorting them into different types of objects. Unreal Engine powers the game, featuring procedurally generated landscapes and dungeons for a dynamic experience. Story Protocol's platform allows collaborative creativity without IP disputes. We implemented a unique solution to link NFT metadata to playable Unreal Engine assets.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/q0f4x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/k9j1o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/kuxja/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/ai31i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/auzia/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/oowia/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/edi3on/ip-infinity",
        "link": "https://ethglobal.com/showcase/ip-infinity-mnkym"
    },
    {
        "title": "ZK Wallet",
        "brief_description": "ZK Wallet improves wallet signature security and creates new authorization flows",
        "long_description": "ZK Wallet uses ZK to mask signatures both offchain and onchain and verifiable proof that the signature exists, drastically improving wallet accounts security against phishing and other malicious attacks. Morever, ZK powered proofs improve authorization flow within smart contracts, that increases safety and controls undesired outcomes directly. Within this project I show: I use:\nZK-EVM - Risc 0\nBackend - Rust\nGPU acceleration - Bonsai\nFrontEnd - TypeScript\nContracts - Solidity\nEssentially FrontEnd acts as a wallet and interacts with Backend through REST API to send and receive proofs. Backend connected to ZKVM as host to query proofs and verifications. FrontEnd also interacts with Contracts to verify proofs within Contract context.",
        "how_its_made": "I use:\nZK-EVM - Risc 0\nBackend - Rust\nGPU acceleration - Bonsai\nFrontEnd - TypeScript\nContracts - Solidity\nEssentially FrontEnd acts as a wallet and interacts with Backend through REST API to send and receive proofs. Backend connected to ZKVM as host to query proofs and verifications. FrontEnd also interacts with Contracts to verify proofs within Contract context.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tnmaq/screenshots/z2xw2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tnmaq/screenshots/xdm3f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tnmaq/screenshots/a17z8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tnmaq/screenshots/ppkgv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/altyni86/Eth_Global_Submit",
        "link": "https://ethglobal.com/showcase/zk-wallet-tnmaq"
    },
    {
        "title": "ExerciseTee",
        "brief_description": "Monitor your exercise from Whoop and shame you on twitter if you don't exercise for two consecutive days!",
        "long_description": null,
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qepxo/screenshots/0gb5v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qepxo/screenshots/d9grq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qepxo/screenshots/a096r/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/renchuqiao/tee-exercise",
        "link": "https://ethglobal.com/showcase/exercisetee-qepxo"
    },
    {
        "title": "Quantum Gate",
        "brief_description": "Quantum Gate unlocks EVM utilities on BTC Ordinals inscriptions.",
        "long_description": "NFT liquidity has gone to BTC Ordinals. What if we have ways to bring the liquidity back to the EVM ecosystem? This is an experimental project for showcasing EVM smart contract calls inside BTC Ordinals inscriptions. A MetaMask user visits a Quantum Gate inscription page and switches to a full-screen mode. S/he clicks on the \"unlock\" button and connects a wallet. The inscription prompts the user to sign a human-readable message and submit that signature to an EVM smart contract. The contract got called successfully and more EVM utilities were unlocked on Quantum Gate's BTC inscriptions. BTC Inscriptions are mostly html-based. BTC inscription are placed in a sandbox environment so that no external server calls are allowed. However, wallets such as MetaMask are injecting codes through web browsers. This provides an opportunity to place smart contract calls within BTC inscriptions.",
        "how_its_made": "BTC Inscriptions are mostly html-based. BTC inscription are placed in a sandbox environment so that no external server calls are allowed. However, wallets such as MetaMask are injecting codes through web browsers. This provides an opportunity to place smart contract calls within BTC inscriptions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/7btoa/screenshots/1s2my/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7btoa/screenshots/8arxg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7btoa/screenshots/j3b0f/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jackieeth/quantumgate-ethglobalsf2024",
        "link": "https://ethglobal.com/showcase/quantum-gate-7btoa"
    },
    {
        "title": "Power Agents",
        "brief_description": "Create, manage and chat with your AI agents from a XMTP group chat.",
        "long_description": "Power Agents is a collection of AI agents that you can spawn and chat with in an XMTP Group Chat. These agents are powered by Brian and leverage the CDP SDK to have their own wallets and funds to operate on behalf of the user. Each agent when it's created receives a poweragents.eth ENS subdomain, so that the user can easily remember it's handle when creating a new group chat, or when chatting with it outside of a group.\nWithin the group chat, you can chat with your agents and make them perform tasks. We developed the following Agents: This projects uses the following technologies: We also developed from scracth a nice way to spawn new XMTP bots inside the same repository at runtime without the need of re-deploying the project.",
        "how_its_made": "This projects uses the following technologies: We also developed from scracth a nice way to spawn new XMTP bots inside the same repository at runtime without the need of re-deploying the project.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/sorrv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/gq11o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/1z4u3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/qgu4d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/1dagu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/rxeux/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/builders-garden/power-agents",
        "link": "https://ethglobal.com/showcase/power-agents-djqmb"
    },
    {
        "title": "Essence Vault",
        "brief_description": "Essence Vault: a secure, efficient multisig wallet on Essential's declarative blockchain. #Essential #DeFi #Multisig #EthGlobal",
        "long_description": "Essence Vault is a multisig (multi-signature) wallet built on the Essential blockchain, leveraging the platform\u2019s declarative smart contract system to provide a secure, transparent, and efficient way to manage funds collectively. Multisig wallets require a predefined number of signatories (wallet holders) to approve any outgoing transaction, providing enhanced security and decentralized control over funds. Key Features of Essence Vault:\nm-of-n Approval System: The core functionality of Essence Vault is its m-of-n approval system. In simple terms: n is the total number of authorized members (or signatories) who can approve or reject a transaction.\nm is the minimum number of these members required to approve a transaction before it can be executed. This ensures that no single party can unilaterally control the wallet\u2019s funds. For example, if you have a 5-member wallet (n=5), and set m=3, at least 3 out of the 5 members must approve any fund transfers before it is executed.\nCreate a Multisig Wallet: At the start, an authorized user can create a new multisig wallet by providing a set of member addresses and specifying m, the minimum number of required approvals. This can be easily adjusted later as needed. Add/Remove Members: Wallet members can be added or removed based on the collective decision of existing members. The multisig wallet maintains flexibility by allowing changes in membership without disrupting operations or compromising security. Update m-of-n Configuration: If necessary, members can change the m value, adjusting the number of approvals required. This is especially useful if the organizational structure changes or the wallet grows in size. Fund Management (Receive & Send Funds): Receiving Funds: Anyone can send funds to the multisig wallet. It serves as a shared account for organizations, teams, or projects that need collective control over assets.\nSending Funds: To send funds, a transaction proposal is made, and the required number of members must approve it (based on the m-of-n rule) before the transfer is completed.\nTransaction Proposals: Any member can propose a transaction, such as sending funds to another wallet. Once proposed, other members must review and approve or reject the transaction. Approve Approvals: Members have the ability to approve a transaction proposal, and if they change their mind before the transaction is finalized, they can revoke their approval. This allows flexibility and ensures that all decisions are well-considered. View Transaction History: All transactions\u2014whether proposed, pending, approved, rejected, or completed\u2014are stored transparently on the blockchain. Users can easily view this history to ensure accountability. Security and Transparency: Built on Essential\u2019s declarative smart contracts, Essence Vault emphasizes simplicity, security, and auditability. By focusing on what should happen rather than how, it reduces the likelihood of vulnerabilities like reentrancy attacks that are common in other blockchain systems. Low Gas Costs: Thanks to Essential\u2019s blockchain optimizations, transaction costs are minimized, making Essence Vault a cost-effective solution for managing collective funds without the high fees typically associated with smart contract execution on imperative blockchains like Ethereum. Why Essence Vault?\nEssence Vault is ideal for organizations, venture capital funds, DeFi projects, DAOs, or any group that needs shared control over assets. It\u2019s particularly useful for managing treasury funds, handling collective investments, and ensuring that no single entity has unilateral access to funds. With its m-of-n approval system, all decisions are decentralized, preventing fraud, theft, or misuse of funds. Advantages of Using Essential Blockchain for Multisig Wallets:\nDeclarative Smart Contracts: Essence Vault leverages Essential\u2019s declarative nature, which allows smart contracts to focus on intent, making the logic simpler and reducing the risk of bugs and security vulnerabilities.\nEnhanced Security: By minimizing low-level control, the risk of errors or exploits is reduced, leading to a more secure wallet. This is especially critical for large or organizational funds.\nEfficiency and Cost Savings: Compared to other blockchains, Essential's structure optimizes for lower gas costs, ensuring that even high-frequency or complex transactions are cost-effective.\nScalability: As Essential is designed to support large-scale decentralized applications, Essence Vault is well-positioned to handle the demands of growing organizations or DAOs that may scale significantly over time.\nUse Cases:\nDecentralized Autonomous Organizations (DAOs): DAOs often manage collective treasuries, and Essence Vault\u2019s multisig model ensures that no single member can misappropriate funds. This m-of-n approval system also aligns with the decentralized decision-making model that DAOs are built upon. Venture Capital or Investment Funds: For groups of investors managing pooled funds, Essence Vault ensures that any outgoing transactions are approved by multiple stakeholders, safeguarding against unauthorized withdrawals or investments. Corporate Treasury Management: Essence Vault can be used by companies to manage internal budgets or decentralized teams that need to ensure financial decisions are made transparently and securely. Grant Funds or Non-Profits: When distributing grants or donations, it\u2019s important to ensure accountability. The multisig approval process guarantees that funds are only released after careful consideration and approval by trusted members. Future Roadmap for Essence Vault\nAs Essence Vault evolves, additional functionalities will be implemented to further enhance its capabilities: Revoke Approval: Members will be able to revoke their on-chain approval before a transaction is fully approved, providing flexibility and allowing members to reconsider decisions before execution.\nSet Time-Locked Approvals: On-chain time locks will be added, allowing transactions to be delayed for a specified time after receiving approvals, which adds an additional layer of protection for large or sensitive transfers.\nSet Transaction Limits: On-chain transaction limits will automatically adjust the number of required approvals based on the transaction size. For example, larger transactions could require more signatories or escalate to higher levels of the hierarchy, while smaller transactions may be executed with fewer approvals.\nStaking Wallet Funds: To optimize treasury management, a portion of the wallet's funds can be staked in DeFi protocols to earn passive income. AI and statistical models will analyze transaction history to suggest staking strategies and portfolio management, ensuring that funds not needed for immediate use are working to generate yield. Essence Vault was built using Pint for the smart contract, which simplifies logic by focusing on what needs to happen, ensuring security and reducing vulnerabilities. The frontend is written in Rust for performance and safety, leveraging WebAssembly for smooth cross-platform execution. Partnering with Essential allowed us to leverage declarative blockchain design.",
        "how_its_made": "Essence Vault was built using Pint for the smart contract, which simplifies logic by focusing on what needs to happen, ensuring security and reducing vulnerabilities. The frontend is written in Rust for performance and safety, leveraging WebAssembly for smooth cross-platform execution. Partnering with Essential allowed us to leverage declarative blockchain design.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dmrve/screenshots/1h25k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dmrve/screenshots/1rxjz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dmrve/screenshots/jcnzc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/esphene/eth-global-sf-2024",
        "link": "https://ethglobal.com/showcase/essence-vault-dmrve"
    },
    {
        "title": "TipJar",
        "brief_description": "The Tip Jar is a DApp that gamifies tipping and incentives community use.",
        "long_description": "The Tip Jar is a decentralized application (DApp) built on the Ethereum blockchain, utilizing the SKALE network for gasless transactions. This platform allows users to send and receive tips in a user-friendly manner while contributing to a communal jar that encourages community support. Blockchain: Ethereum (via SKALE for gas-free transactions)\nSmart Contracts: Solidity for managing the tip jar and communal jar logic\nFrontend: Simple web app (HTML/CSS/JavaScript) with Metamask SDK integration\nBackend (optional): If you want to store extra user data or logs off-chain, you can use a server (e.g., Node.js, Express) or a decentralized storage solution like IPFS\nDeployment: SKALE network for Ethereum",
        "how_its_made": "Blockchain: Ethereum (via SKALE for gas-free transactions)\nSmart Contracts: Solidity for managing the tip jar and communal jar logic\nFrontend: Simple web app (HTML/CSS/JavaScript) with Metamask SDK integration\nBackend (optional): If you want to store extra user data or logs off-chain, you can use a server (e.g., Node.js, Express) or a decentralized storage solution like IPFS\nDeployment: SKALE network for Ethereum",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/789zv/screenshots/mj0x5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/789zv/screenshots/84azi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/789zv/screenshots/q7ztz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/789zv/screenshots/mu72f/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/deapinkme/ETHGlobalSF24/tree/main/demo",
        "link": "https://ethglobal.com/showcase/tipjar-789zv"
    },
    {
        "title": "Pinnect",
        "brief_description": "Pinnect: Interactive story co-creating platform that lets creators write and link stories on open-world.",
        "long_description": "Pinnect is an innovative open-world co-creation platform that revolutionizes how people interact with and conceive storytelling. It allows users to place their narratives within specific geographic locations on a virtual map, linking ideas and expanding upon existing tales contributed by others. This digital ecosystem supports a vibrant community of creators, from writers and artists to thinkers, who wish to leave their mark on a shared, evolving narrative landscape. Technology Stack:\nFrontend: Built with Swift for a native iOS experience, ensuring a smooth and intuitive user interface tailored for mobile devices.\nBackend: The backend runs on Node.js, utilizing Express.js for API management, which orchestrates interactions between the frontend, the database, and the blockchain components. Blockchain and Web3 Integration:\nEthereum Blockchain: Smart contracts written in Solidity handle DAO functionalities, content monetization, and IP management.\nStory Protocol: Integrates with Story Protocol for IP asset registration and management, leveraging its IPFi (Intellectual Property Finance) capabilities to create a market for buying and selling story-based IP assets.\nWeb3.js: Allows the mobile app to interact directly with Ethereum blockchain, enabling transactions such as voting, content posting, and royalty distributions directly from the user\u2019s device.",
        "how_its_made": "Technology Stack:\nFrontend: Built with Swift for a native iOS experience, ensuring a smooth and intuitive user interface tailored for mobile devices.\nBackend: The backend runs on Node.js, utilizing Express.js for API management, which orchestrates interactions between the frontend, the database, and the blockchain components. Blockchain and Web3 Integration:\nEthereum Blockchain: Smart contracts written in Solidity handle DAO functionalities, content monetization, and IP management.\nStory Protocol: Integrates with Story Protocol for IP asset registration and management, leveraging its IPFi (Intellectual Property Finance) capabilities to create a market for buying and selling story-based IP assets.\nWeb3.js: Allows the mobile app to interact directly with Ethereum blockchain, enabling transactions such as voting, content posting, and royalty distributions directly from the user\u2019s device.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/y1hnr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/1gs02/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/4z8xq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/cfw9o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/opnj0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/kigy3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AnnieTianyuHuang/ethSF24-proj",
        "link": "https://ethglobal.com/showcase/pinnect-j3531"
    },
    {
        "title": "JunLend",
        "brief_description": "One-click migration that guarantees better yield and liquidation protection.",
        "long_description": "JunLend features a simple one-click migration that guarantees better yield and liquidation protection. JunLend pools everyone's positions together. So if I'm borrowing USDC and you're supplying USDC, you can use your USDC to pay off my debt. In this pool, we match users' deposits/borrows to create win-win situations that boost the underlying yield efficiency. This also boosts the global health factor, creating this buffer for liquidations. Instead of AAVE liquidating you, JunLend would liquidate you through a fair Dutch auction that lets you keep the MEV surplus. JunLend will support many lending protocols and many different chains. It's strictly better to use JunLend over the vanilla option. The smart contracts use Uniswap v4 to flashloan so it can migrate a user's borrow position. Liquidations are handled with a Uniswap hook that lets users buy the capital in exchange for the debt. Chronicle powers the oracle for internal liquidations. The frontend is built with next.js and wagmi. Testing was done through Foundry.",
        "how_its_made": "The smart contracts use Uniswap v4 to flashloan so it can migrate a user's borrow position. Liquidations are handled with a Uniswap hook that lets users buy the capital in exchange for the debt. Chronicle powers the oracle for internal liquidations. The frontend is built with next.js and wagmi. Testing was done through Foundry.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/58snu/screenshots/j5j7r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/58snu/screenshots/0a6eb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/58snu/screenshots/6e3xc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jun1on/junlend",
        "link": "https://ethglobal.com/showcase/junlend-58snu"
    },
    {
        "title": "root4.fun",
        "brief_description": "memecoin launchpad built on Rootstock, offering easy tools for creating, buying, and selling memecoins. With AI-generated designs, seamless wallet connections, and credit card payments, it makes launching and sharing memecoins fun, fast, and accessible for everyone.",
        "long_description": "ROOT4.FUN is a memecoin launchpad built within the Rootstock (RSK) ecosystem, designed to make creating, buying, and selling memecoins as easy and accessible as possible. Our platform takes inspiration from projects like Pump.fun, but adds significant innovations to improve the user experience and functionality, with a focus on community-driven memecoins. We believe that memecoins hold potential beyond just speculation. They represent coins created by the community, for the community, making them a unique and valuable part of the crypto ecosystem. ROOT4.FUN offers four key functions to make memecoin creation and trading seamless: Create a MEMECOIN: Users can quickly generate and deploy their own memecoin on Rootstock. The process is streamlined through a smooth UI, and we even provide AI-generated suggestions for when users aren\u2019t sure what concept to meme. Buy a Coin: Users can easily purchase memecoins directly through the platform, with the option to pay using crypto wallets, credit cards, or email sign-ins. We aim to lower the barriers to entry for everyone, regardless of their technical expertise. Sell a Coin: Memecoin holders can easily list and sell their tokens through automated contracts. Automatic Creation of Liquidity Pools: Once a memecoin is created, liquidity pools are automatically established on decentralized exchanges like Uniswap once it reaches a bonding curve of 24 ETH(customizable).  This allows memecoins to have immediate market access Rootstock\nWe built the project on Rootstock . This gives us the stability and security of Bitcoin, while being EVM-compatible.\nwe built a contract that has 4 main functions, Create, Buy, Sell and once the bonding curve selected is reached it will be listed into decentralized exchanges. Phala Network AI Agents\nTheir AI agents are integrated to assist users in generating memecoin assets like names, images, and websites. We chose Phala because it runs  inside a Trusted Execution Environment (TEE), ensuring the integrity and security of the generated data.\nWhen users aren\u2019t sure what to meme, our platform calls on Phala\u2019s AI to generate these assets. The TEE guarantees that all HTML code and data produced by the AI is verifiable. Walrus for Decentralized Storage\nWe integrated Walrus to ensure all the AI-generated images, metadata, and websites are stored securely and accessibly.Walrus stores all the HTML and images generated by Phala\u2019s AI. This ensures that the content remains available. Privy and Dynamic for Wallet Connectivity:\nWhy We Chose Them: Both Privy and Dynamic are designed to provide frictionless wallet connectivity. Unlimit for Credit Card Payments\nWe wanted to make memecoin buying and selling as accessible as possible. With Unlimit, users can make purchases using credit cards as a payment gateway. Smart Contracts for Liquidity Management:\nOnce a memecoin is created, the system will automatically create a liquidity pool on Uniswap, but only once the bonding curve is reached. This ensures that there is sufficient demand and value established before providing liquidity. The bonding curve mechanism regulates the token supply and price dynamically as users buy into the memecoin. Once the required curve is reached, the smart contracts deploy the memecoin to Uniswap, creating an immediate liquidity pool.",
        "how_its_made": "Rootstock\nWe built the project on Rootstock . This gives us the stability and security of Bitcoin, while being EVM-compatible.\nwe built a contract that has 4 main functions, Create, Buy, Sell and once the bonding curve selected is reached it will be listed into decentralized exchanges. Phala Network AI Agents\nTheir AI agents are integrated to assist users in generating memecoin assets like names, images, and websites. We chose Phala because it runs  inside a Trusted Execution Environment (TEE), ensuring the integrity and security of the generated data.\nWhen users aren\u2019t sure what to meme, our platform calls on Phala\u2019s AI to generate these assets. The TEE guarantees that all HTML code and data produced by the AI is verifiable. Walrus for Decentralized Storage\nWe integrated Walrus to ensure all the AI-generated images, metadata, and websites are stored securely and accessibly.Walrus stores all the HTML and images generated by Phala\u2019s AI. This ensures that the content remains available. Privy and Dynamic for Wallet Connectivity:\nWhy We Chose Them: Both Privy and Dynamic are designed to provide frictionless wallet connectivity. Unlimit for Credit Card Payments\nWe wanted to make memecoin buying and selling as accessible as possible. With Unlimit, users can make purchases using credit cards as a payment gateway. Smart Contracts for Liquidity Management:\nOnce a memecoin is created, the system will automatically create a liquidity pool on Uniswap, but only once the bonding curve is reached. This ensures that there is sufficient demand and value established before providing liquidity. The bonding curve mechanism regulates the token supply and price dynamically as users buy into the memecoin. Once the required curve is reached, the smart contracts deploy the memecoin to Uniswap, creating an immediate liquidity pool.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/ohrvy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/cxd96/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/57wy4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/muutp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/bzsoz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/ov1bk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shadowfaz16/root.fun.git",
        "link": "https://ethglobal.com/showcase/root4-fun-uubnf"
    },
    {
        "title": "TheLottery",
        "brief_description": "It's a cross chain lottery operated with LAyerZero, Dynamo, Ledger and ENS. Everybody from everywhere with everywallet can play",
        "long_description": "TheLottery is an innovative decentralized application that brings the excitement of lottery games to the blockchain world. Built with React and and Web3 technologies, this project offers a seamless and engaging user experience for participants across multiple blockchain networks. Key Features: Cross-chain Compatibility: Utilizing LayerZero technology, users can purchase tickets from any supported blockchain, expanding accessibility and liquidity across networks. Flexible Wallet Integration: The app integrates Dynamic for wallet connections, allowing users to interact with their preferred wallet solution, including hardware wallets like Ledger for enhanced security. Real-time Updates: The application provides live updates on the current jackpot size, time remaining until the next draw, and the number of tickets purchased, creating an engaging and dynamic user interface. ENS Integration: Winners' addresses are displayed using Ethereum Name Service (ENS) when available, adding a personal touch to the lottery experience. Animated UI: The interface features falling coin animations and smooth transitions, enhancing the visual appeal and user engagement. Smart Contract Powered: The core lottery logic is implemented in a Solidity smart contract, ensuring fairness and transparency in ticket purchases and winner selection. Chainlink VRF Integration: The lottery uses Chainlink's Verifiable Random Function (VRF) to guarantee truly random and tamper-proof winner selection. Automated Lottery Cycles: The smart contract manages lottery cycles, including ticket sales, drawing winners, and distributing prizes, with minimal manual intervention required. Technical Highlights: TheLottery demonstrates the potential of blockchain technology to create fair, transparent, and exciting gaming experiences across multiple networks, setting a new standard for decentralized lottery applications. Cross-chain Compatibility: Utilizing LayerZero technology, users can purchase tickets from any supported blockchain, expanding accessibility and liquidity across networks. Flexible Wallet Integration: The app integrates Dynamic for wallet connections, allowing users to interact with their preferred wallet solution, including hardware wallets like Ledger for enhanced security. Real-time Updates: The application provides live updates on the current jackpot size, time remaining until the next draw, and the number of tickets purchased, creating an engaging and dynamic user interface. ENS Integration: Winners' addresses are displayed using Ethereum Name Service (ENS) when available, adding a personal touch to the lottery experience.",
        "how_its_made": "Cross-chain Compatibility: Utilizing LayerZero technology, users can purchase tickets from any supported blockchain, expanding accessibility and liquidity across networks. Flexible Wallet Integration: The app integrates Dynamic for wallet connections, allowing users to interact with their preferred wallet solution, including hardware wallets like Ledger for enhanced security. Real-time Updates: The application provides live updates on the current jackpot size, time remaining until the next draw, and the number of tickets purchased, creating an engaging and dynamic user interface. ENS Integration: Winners' addresses are displayed using Ethereum Name Service (ENS) when available, adding a personal touch to the lottery experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jy2xa/screenshots/r0uhs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jy2xa/screenshots/x69o1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jy2xa/screenshots/4bkmh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/TonioSnowden/TheLottery",
        "link": "https://ethglobal.com/showcase/thelottery-jy2xa"
    },
    {
        "title": "DeepTrust.eth",
        "brief_description": "SoTA On-chain proofs for LLM Model Executions. DeepTrust.eth makes sure that OpenAI, Anthropic, Groq be honest about the model they are serving.",
        "long_description": "The future will undoubtedly rely heavily on AI-powered applications and insights. But how can we ensure that the individuals or enterprises providing us with these models are trustworthy and credible? We identified two major problems that haven't been widely addressed: Centralized inference requires trust in an inference provider not to alter the model or data. For example, how can we be sure that OpenAI is providing responses from the more expensive GPT-4 model instead of cutting costs and using GPT-3.5?\nCentralized entities might manipulate or censor outputs, potentially affecting model fairness.\nTo address these issues, we proposed a solution using blockchain technology, creating a network of verification nodes that perform the checks for us. We introduced a novel plugin that can be integrated into all transformer architectures, which LLM models are based on. This plugin allows us to derive a deterministic term from each model by intercepting the LLM prior to the head layer (where randomness, such as temperature, is introduced). Since relying on a single source could be risky (due to potential dishonesty), our solution involves a network of models performing independent verifications. These outputs are then compared with those provided by enterprises like OpenAI, giving us a better chance to detect bad actors. Rather than checking every single request, we opted to sample 2-5% of all inference requests for verification. Additionally, we implemented a tokenomics system within the network. All inference clients must stake tokens to participate. If our platform detects dishonesty, these stakes will be slashed. Conversely, those who remain honest will see their trust score increase and will be rewarded with tokens. This system creates a strong incentive for participants to act with integrity. We primarily used two key technologies to achieve this solution: Polygon \u2013 We chose Polygon due to its scalability and low transaction costs. It allows us to build a transparent and efficient verification system, where transactions related to inference verifications and token staking/slashing are processed quickly and affordably. We find the documetation very friendly so it made our developer experience awesome! Lit Protocol \u2013 We leveraged Trusted Execution Environments (TEEs) to ensure that our model executions are isolated and protected from external interference. Lit Protocol was also one of the easiest platforms to develop on, as its setup process is much more straightforward compared to other providers.",
        "how_its_made": "We primarily used two key technologies to achieve this solution: Polygon \u2013 We chose Polygon due to its scalability and low transaction costs. It allows us to build a transparent and efficient verification system, where transactions related to inference verifications and token staking/slashing are processed quickly and affordably. We find the documetation very friendly so it made our developer experience awesome! Lit Protocol \u2013 We leveraged Trusted Execution Environments (TEEs) to ensure that our model executions are isolated and protected from external interference. Lit Protocol was also one of the easiest platforms to develop on, as its setup process is much more straightforward compared to other providers.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6rv0v/screenshots/79yxh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6rv0v/screenshots/3fycm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6rv0v/screenshots/fjy8v/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Jackmin801/DeepTrust.eth",
        "link": "https://ethglobal.com/showcase/deeptrust-eth-6rv0v"
    },
    {
        "title": "hoshi",
        "brief_description": "A web3 social media app that gives automatic IP rights to content creation through NFTs, making use of AI to identify derivative work.",
        "long_description": "Web2 social media apps are flawed. Today\u2019s social media platforms \u2014 TikTok, Instagram, YouTube \u2014 are powered by creators. From viral dances to popular memes, users are constantly sharing new ideas. Yet, there\u2019s a major problem: the original creators often go unrecognized and uncompensated. While larger creators and influencers who build on original trends or content reap the majority of credit and financial rewards, the originators of these ideas are not fairly rewarded. The root of this problem lies in the inability of current Web2 platforms to effectively prove content ownership or enforce fair revenue sharing. Creators are forced into an 'all or nothing' revenue system due to rigid copyright rules. We need a solution to provide a fair, transparent, and equitable content creation ecosystem where intellectual property rights are protected and content contributors are compensated based on their value added. hoshi aims to address these inequities by leveraging Web3 technology to create a platform where content creators can prove ownership, enforce fair use, and receive equitable compensation for their work. By giving IP rights to content creation through NFTs and an automated royalty distribution system, hoshi ensures that both original creators and those who contribute to or remix their work are fairly rewarded. 1.1 Automated AI-Powered Detection\nUses AI/ML to analyze content & determine an originality score across all other posts. We use an AI-based originality scoring system that quantifies the degree of contribution for each post. The more original the content, the higher the share of rewards allocated to the original creator. Users who remix or modify content receive proportional compensation based on their added value. An IP derivative tree is built based on these scores, to determine revenue flow sharing across all contributors based on their added value. 1.2 IP Ownership and Protection via NFTs\nhoshi ensures that creators retain full control over their IP by minting each piece of content uploaded to the platform as a non-fungible token (NFT). This provides verifiable proof of ownership and a permanent, immutable record on the blockchain, safeguarding against unauthorized use or plagiarism. 1.3 Smart Royalty Distribution\nhoshi employs a smart royalty distribution model that rewards original creators and those who contribute to or build upon their work. This system ensures that all contributors along the creative chain are fairly rewarded. Royalties are distributed through our native ERC20 token backed by ETH.  When a user interacts with a piece of content, some of their tokens are transferred from their wallet to the wallet of the content creator, and through our smart contract code, royalty distributions of derivative work is automatically paid. 2.1 Subscription-Based Revenue Withdrawal\nCreators can directly withdraw the underlying ETH tagged to the hoshi tokens and directly earn funds from their content. This is done by enabling a whitelist of wallet addresses who are allowed to unwrap the tokens, so as to prevent casual viewers from unwrapping their tokens as well. To join the whitelist and make money off your content, hoshi adopts an approach similar to twitter that requires content creators to pay a subscription fee to earn money off their content on our platform. hoshi reinvests the subscription fees back into the platform\u2019s liquidity pool. This subscription model not only facilitates monetization but also ensures the platform\u2019s long-term financial sustainability. We believe hoshi is the future of social media content creation, and we hope that you will join us in empowering creators with the recognition and rewards they deserve. To detect Copyright Infringement, we develop a proprietary AI pipeline to not only find the media and text that are similar in nature to the new post but also detect the specific location with the highest similarity. To detect textual similarity of captions, we use Cohere Embeddings to embed each caption into a vector. When a new post is provided, we similarly embed the new caption and compare against other vectors in the database. However, such an approach heavily focuses on semantic similarity since copyright infringement requires exact textual lifting, we utilise the BM25 method to conduct  full text search as well. The textual similarity score is thus a linear combination of the results from the vector and the full text search, making it robust and efficient. For the media detection, we use a similar approach using SIGLIP (https://arxiv.org/abs/2303.15343) embeddings and compare the input media using these embeddings. Again following the need for similarity beyond semantic meaning, we apply structural similarity scores based off the histogram of the image. We compute the following matrix (Correlation of Histogram, Intersection of Histogram and the Structural Similarity Index (https://www.imatest.com/docs/ssim/). To determine the location of the image that is most likely to be an infringement, we utilise a novel image localisation approach. We split the new image into many small patches and run a sliding window over the patches. Each patch in the window would have the same similarity score as all other patches in that particular iteration. After normalizing the scores, we would have a distribution of patches with varying similarity scores corresponding to a heatmap of the mini patches that are most similar to the existing original image. To extend this approach to videos, we split the video up into frames at a specified frames per second and perform the search over each frame. The final original result is determined by majority voting which makes our approach temporally robust. We made use of Dynamic Protocol for the user authentication. Making it easier for people to onboard onto Hoshi by allowing for email and Google account login and hiding login via wallets. We made use of ERC20 and ERC721 token contracts by openzeppelin so as to create custom logic to our tokens and NFTs to fit our needs. The metadata of the posts/NFTs are uploaded to IPFS, further adding to the decentralization of our platform. For the frontend, we used NextJS for the framework. We also used Three.js to create the 3D derivative graphs to show the connections between an original post and its derivatives.",
        "how_its_made": "To detect Copyright Infringement, we develop a proprietary AI pipeline to not only find the media and text that are similar in nature to the new post but also detect the specific location with the highest similarity. To detect textual similarity of captions, we use Cohere Embeddings to embed each caption into a vector. When a new post is provided, we similarly embed the new caption and compare against other vectors in the database. However, such an approach heavily focuses on semantic similarity since copyright infringement requires exact textual lifting, we utilise the BM25 method to conduct  full text search as well. The textual similarity score is thus a linear combination of the results from the vector and the full text search, making it robust and efficient. For the media detection, we use a similar approach using SIGLIP (https://arxiv.org/abs/2303.15343) embeddings and compare the input media using these embeddings. Again following the need for similarity beyond semantic meaning, we apply structural similarity scores based off the histogram of the image. We compute the following matrix (Correlation of Histogram, Intersection of Histogram and the Structural Similarity Index (https://www.imatest.com/docs/ssim/). To determine the location of the image that is most likely to be an infringement, we utilise a novel image localisation approach. We split the new image into many small patches and run a sliding window over the patches. Each patch in the window would have the same similarity score as all other patches in that particular iteration. After normalizing the scores, we would have a distribution of patches with varying similarity scores corresponding to a heatmap of the mini patches that are most similar to the existing original image. To extend this approach to videos, we split the video up into frames at a specified frames per second and perform the search over each frame. The final original result is determined by majority voting which makes our approach temporally robust. We made use of Dynamic Protocol for the user authentication. Making it easier for people to onboard onto Hoshi by allowing for email and Google account login and hiding login via wallets. We made use of ERC20 and ERC721 token contracts by openzeppelin so as to create custom logic to our tokens and NFTs to fit our needs. The metadata of the posts/NFTs are uploaded to IPFS, further adding to the decentralization of our platform. For the frontend, we used NextJS for the framework. We also used Three.js to create the 3D derivative graphs to show the connections between an original post and its derivatives.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/xkihw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/wsg9f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/48c0o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/ew74h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/183v2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/w8e1i/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/limrik/hoshi",
        "link": "https://ethglobal.com/showcase/hoshi-xzzxj"
    },
    {
        "title": "BulletPay",
        "brief_description": "BulletPay is a blockchain native payment protocol. It enables instance confirmation in face to face payment while keeping the assets safely on-chain.",
        "long_description": "BulletPay utilizes Pre Consensus Gateway and One Time Topup technologies to enable blockchain-native payments. Due to the decentralization of blockchain and the weak finality of its consensus algorithms, asset transfers typically experience delays ranging from seconds to minutes. This is unsuitable for face-to-face transactions, such as daily purchases, which require instant payment confirmation. Unlike channel technologies such as the Lightning Network, we believe that on-chain payments are more secure and reliable. Therefore, we focus on a blockchain-native approach to payments while addressing the issue of delays. We have developed the BulletPay protocol, which combines the efficiency of centralized payment gateways with the security of decentralized blockchains. Our protocol successfully resolves the delay issue, making blockchain payments feasible for real-world scenarios. We use Solidity to build smart contracts and Python to develop the backend. The BulletPay system includes top-up and payment steps for on-chain end users. After a user tops up, the indexer component monitors on-chain events. Each top-up creates an account that can be used multiple times but is not rechargeable. The top-up account can be spent with the spender's signature via the gateway. The gateway monitors the blockchain and tracks the spender's balance, allowing it to notify the merchant if the payment is successful or to reject the user before the payment processed by the blockchain. This constitutes the pre-consensus component. Importantly, assets remain on-chain, ensuring that the gateway cannot access users' assets for any other purpose, which enhances security.",
        "how_its_made": "We use Solidity to build smart contracts and Python to develop the backend. The BulletPay system includes top-up and payment steps for on-chain end users. After a user tops up, the indexer component monitors on-chain events. Each top-up creates an account that can be used multiple times but is not rechargeable. The top-up account can be spent with the spender's signature via the gateway. The gateway monitors the blockchain and tracks the spender's balance, allowing it to notify the merchant if the payment is successful or to reject the user before the payment processed by the blockchain. This constitutes the pre-consensus component. Importantly, assets remain on-chain, ensuring that the gateway cannot access users' assets for any other purpose, which enhances security.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/tz9ii/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/iusb7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/keqp6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/wxn9x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/c5qoq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Bullet-Pay/bulletpay_service",
        "link": "https://ethglobal.com/showcase/bulletpay-rsx64"
    },
    {
        "title": "tradealerts",
        "brief_description": "tradealerts notifies individuals or interest groups of trade events for a given policy.",
        "long_description": "This project is a social network crypto investors and interest groups.\nIt uses xmtp to timely deliver market signals based on a given policy.\nE.g. relay buy or sell signals for crypto currencies.\nThe signals themselves are generated by a separate backend application that ties into Coinbase to access market data. This project uses MessageKit by xmtp to deliver trade alerts to subscribed users or interest groups.\nIt is prototyped with MessageKit and connects to a backend using CDK by Coinbase.\nWe will try to host the application on Walrus.\nThree components play together:",
        "how_its_made": "This project uses MessageKit by xmtp to deliver trade alerts to subscribed users or interest groups.\nIt is prototyped with MessageKit and connects to a backend using CDK by Coinbase.\nWe will try to host the application on Walrus.\nThree components play together:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/43gav/screenshots/233x6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/43gav/screenshots/qn4b3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/43gav/screenshots/juohk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wojtczyk/tradealerts",
        "link": "https://ethglobal.com/showcase/tradealerts-43gav"
    },
    {
        "title": "NFTap",
        "brief_description": "connect via ens by bumping phones with verifiable irl connections",
        "long_description": "This projects aims to verify and create memories based on irl connections easily by allowing users to exchange their ENS information by bumping their phones together. Afterwards, an NFT is minted to verify the meeting, where the image of the NFT makes use of the ENS avatars as well as the location, weather and time of day to generate an image that captures the vibe of the meeting. Afterwards, users can view their minted memories on-chain, and share them with friends and family This project uses React Native for the front end and NodeJS with WebSockets as the communication protocol between the FE and BE. We use Dynamic to allow users to sign up easily and ENS for sharing of personal information such as avatar and name information. For generating the NFT images, we use GenAI to generate unique images based on location data, weather data, time of day and ENS avatars. We decided to deploy and mint our NFT collection on the Polygon chain for its high speed and low transaction fees, meaning we are able to airdrop to users, saving them time and fees.",
        "how_its_made": "This project uses React Native for the front end and NodeJS with WebSockets as the communication protocol between the FE and BE. We use Dynamic to allow users to sign up easily and ENS for sharing of personal information such as avatar and name information. For generating the NFT images, we use GenAI to generate unique images based on location data, weather data, time of day and ENS avatars. We decided to deploy and mint our NFT collection on the Polygon chain for its high speed and low transaction fees, meaning we are able to airdrop to users, saving them time and fees.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/mapd3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/b2n5m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/k1zq3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/qgukn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/f0vbu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/danielliuzy/nftapp",
        "link": "https://ethglobal.com/showcase/nftap-z0740"
    },
    {
        "title": "Shared trading",
        "brief_description": "Let one person trade, but many people contribute and withdraw any time they want",
        "long_description": "Only got part of the project complete this hackathon! Clone the Repository: Set Up the Backend: Navigate to the backend directory and install dependencies: Create a .env file in the backend directory with the following content: Compile and Deploy Contracts: Compile the smart contracts: Deploy the contracts: Set Up the Frontend: Navigate to the frontend directory and install dependencies: Start the React Application: Open Your Browser: Neon VM to use EVM to deploy to Solana + a react app for interacting with the deployed contracts on the Neon VM testnet. Clone the Repository: Set Up the Backend: Navigate to the backend directory and install dependencies: Create a .env file in the backend directory with the following content: Compile and Deploy Contracts: Compile the smart contracts: Deploy the contracts: Set Up the Frontend: Navigate to the frontend directory and install dependencies: Start the React Application: Open Your Browser:",
        "how_its_made": "Neon VM to use EVM to deploy to Solana + a react app for interacting with the deployed contracts on the Neon VM testnet. Clone the Repository: Set Up the Backend: Navigate to the backend directory and install dependencies: Create a .env file in the backend directory with the following content: Compile and Deploy Contracts: Compile the smart contracts: Deploy the contracts: Set Up the Frontend: Navigate to the frontend directory and install dependencies: Start the React Application: Open Your Browser:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mzh4z/screenshots/f95bg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mzh4z/screenshots/of9eu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mzh4z/screenshots/og9o4/default.jpg"
        ],
        "live_demo": "https://ethglobalhack-4sufkljta-nathanmatons-projects.vercel.app/",
        "source_code": "https://github.com/NathanMaton/ethglobalhack",
        "link": "https://ethglobal.com/showcase/shared-trading-mzh4z"
    },
    {
        "title": "Versioned Walrus",
        "brief_description": "A lib based on walrus DB that supports the version control. A simple file system demo based on this versioned walrus lib.",
        "long_description": "This project involves the creation of a library built on top of WalrusDB, designed to provide robust version control functionality for document storage. The system utilizes WalrusDB as the underlying storage solution, while metadata is stored on the client side to track different versions of documents. Key Features:\nWalrusDB-Based Storage: The system uses WalrusDB to store contract files, ensuring data immutability and decentralized storage for long-term persistence. Version Control: Supports uploading different versions of the same contract, allowing agents to easily manage updates over time.\nPrevious versions of documents are tracked, allowing for easy navigation and auditability of historical changes.\nVersion control is handled at the metadata level, making it possible to skip uploading files that already exist to avoid redundancy.\nWhen a new version of a document is uploaded, the system automatically creates and links it as a new version, tracking the relationship between versions.\nContract Management: Agents can upload contracts onto WalrusDB, leveraging the version control system to manage multiple versions of a contract for clients.\nThe system allows agents and clients to sign a specific version of a document. Upon signing, a signature file is generated, which logs the action in the format: [addr] has signed [BlobID], providing cryptographic proof that a specific version has been signed by a particular party.\nSigning Workflow: Agents or clients can sign individual versions of documents, with the system automatically generating a signature file. This file contains details such as the signer\u2019s address and the BlobID of the signed document, ensuring traceability and proof of signature.\nUse Cases:\nContract Versioning: An agent can upload multiple versions of the same contract as needed, allowing for smooth management of changes over time. The system tracks all previous versions, ensuring complete transparency and traceability. Document Signing: Both agents and clients can sign specific versions of documents. The system generates signature metadata files that certify the signing event and provide an audit trail.",
        "how_its_made": "Key Features:\nWalrusDB-Based Storage: The system uses WalrusDB to store contract files, ensuring data immutability and decentralized storage for long-term persistence. Version Control: Supports uploading different versions of the same contract, allowing agents to easily manage updates over time.\nPrevious versions of documents are tracked, allowing for easy navigation and auditability of historical changes.\nVersion control is handled at the metadata level, making it possible to skip uploading files that already exist to avoid redundancy.\nWhen a new version of a document is uploaded, the system automatically creates and links it as a new version, tracking the relationship between versions.\nContract Management: Agents can upload contracts onto WalrusDB, leveraging the version control system to manage multiple versions of a contract for clients.\nThe system allows agents and clients to sign a specific version of a document. Upon signing, a signature file is generated, which logs the action in the format: [addr] has signed [BlobID], providing cryptographic proof that a specific version has been signed by a particular party.\nSigning Workflow: Agents or clients can sign individual versions of documents, with the system automatically generating a signature file. This file contains details such as the signer\u2019s address and the BlobID of the signed document, ensuring traceability and proof of signature.\nUse Cases:\nContract Versioning: An agent can upload multiple versions of the same contract as needed, allowing for smooth management of changes over time. The system tracks all previous versions, ensuring complete transparency and traceability. Document Signing: Both agents and clients can sign specific versions of documents. The system generates signature metadata files that certify the signing event and provide an audit trail.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3btjd/screenshots/gn4tq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3btjd/screenshots/3ygam/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3btjd/screenshots/gjspm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3btjd/screenshots/q68of/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wenlianglaw/versioned_walrus",
        "link": "https://ethglobal.com/showcase/versioned-walrus-3btjd"
    },
    {
        "title": "influencer swap",
        "brief_description": "Ai oracle swaps the influencer's photo onto brand's content. the influencer gets paid",
        "long_description": "Ai oracle swaps the influencer's photo onto brand's content. the influencer gets paid. \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\" layerzero to create omnichain nft, story's IP for licensing and for the influencer getting paid \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"",
        "how_its_made": "layerzero to create omnichain nft, story's IP for licensing and for the influencer getting paid \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zwff7/screenshots/3j1qp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zwff7/screenshots/8org0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zwff7/screenshots/yu0n1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kirilligum/story-protocol-boilerplate-sf24-sonft",
        "link": "https://ethglobal.com/showcase/influencer-swap-zwff7"
    },
    {
        "title": "Integration",
        "brief_description": "AI powered post-journey guide to serve theraphy clinics. \"Unlocking Lasting Insights, From Treatment to Transformation\"",
        "long_description": "Integration a revolutionary Web3 application designed to support individuals through the critical integration phase following a psychedelic experience. Harnessing the neuroplasticity triggered by psychedelics, this app provides a structured, self-guided journey to maximize personal growth and insight.\nBuilt on the robust MAPS (Multidisciplinary Association for Psychedelic Studies) psychological framework, Intergration ensures users follow scientifically-backed steps for effective integration. The app guides you through three core pillars: Intentional Preparation and Reflection, Holistic Integration into Daily Life, and Community Support and Ethical Practice.\nSecurity and privacy are paramount. Utilizing blockchain technology, all journal entries are encrypted and stored safely ensuring your most intimate reflections remain private and secure. Key features include: Customizable integration plans\nEncrypted journaling tools\nProgress tracking with tokenized rewards\nGuided meditation and mindfulness exercises\nCreative expression prompts\nCommunity support options\nEducational resources on psychedelic integration Whether you're processing insights, working through emotions, or implementing life changes, provides the structure and support you need. It's not just a journal; it's a comprehensive tool for transforming profound experiences into lasting positive change. Our project harnesses the power of cutting-edge AI, intuitive design, and adaptive functionality to create a truly revolutionary psychedelic integration experience: Claude AI: Leveraging advanced language models to provide personalized guidance, intelligent prompts, and adaptive content based on user input and progress. Claude's deep understanding of psychedelic experiences and integration practices ensures relevant, empathetic support throughout your journey.\nFigma-Crafted Interface: A meticulously designed user interface created in Figma, offering an intuitive, visually appealing experience. The design prioritizes ease of use, emotional resonance, and a calming aesthetic to support the integration process.\nDynamic Functionality: An adaptive system that evolves with your needs, offering personalized integration pathways, real-time adjustments to your plan based on your progress and feedback, and interactive elements that respond to your unique journey. This powerful combination creates a fluid, intelligent, and beautifully designed tool that adapts to your individual integration needs, making the process of translating profound insights into lasting change both effective and engaging.",
        "how_its_made": "Our project harnesses the power of cutting-edge AI, intuitive design, and adaptive functionality to create a truly revolutionary psychedelic integration experience: Claude AI: Leveraging advanced language models to provide personalized guidance, intelligent prompts, and adaptive content based on user input and progress. Claude's deep understanding of psychedelic experiences and integration practices ensures relevant, empathetic support throughout your journey.\nFigma-Crafted Interface: A meticulously designed user interface created in Figma, offering an intuitive, visually appealing experience. The design prioritizes ease of use, emotional resonance, and a calming aesthetic to support the integration process.\nDynamic Functionality: An adaptive system that evolves with your needs, offering personalized integration pathways, real-time adjustments to your plan based on your progress and feedback, and interactive elements that respond to your unique journey. This powerful combination creates a fluid, intelligent, and beautifully designed tool that adapts to your individual integration needs, making the process of translating profound insights into lasting change both effective and engaging.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xuj1k/screenshots/j5h08/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xuj1k/screenshots/tcng3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xuj1k/screenshots/0t157/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/matthew1809/integration",
        "link": "https://ethglobal.com/showcase/integration-xuj1k"
    },
    {
        "title": "Probana",
        "brief_description": "User Powered Prediction Market for Real-World Events on Flow Chain",
        "long_description": "Probana is a prediction market on flow that allows users to bet on anything. Users can create markets and set rules for those markets.  We created an order book from scratch that has limit orders, this allows people to queue up prices that they want to buy at, straight in the contract. The project uses Flow EVM as the chain we utilize this due to the extremely low block times and extremely affordable gas fees. In order to index the blockchain data we decided to use Alchemy subgraph feature. As our betting token we decided to use USDC because of its stable nature.",
        "how_its_made": "The project uses Flow EVM as the chain we utilize this due to the extremely low block times and extremely affordable gas fees. In order to index the blockchain data we decided to use Alchemy subgraph feature. As our betting token we decided to use USDC because of its stable nature.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sn7tu/screenshots/ubw3g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sn7tu/screenshots/n2nz3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sn7tu/screenshots/yhd31/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ElliotSlusky/Probana",
        "link": "https://ethglobal.com/showcase/probana-sn7tu"
    },
    {
        "title": "P3-FV",
        "brief_description": "Auto-generating formal verification specs from Plonky3 circuits",
        "long_description": "This project is an experimental devtool for more easily generating formal verification specs from existing Plonky3 circuits. First you extract the symbolic constraints from your Rust circuit and then pass it through a Python transpiler to output a Z3 Python program, which you use to run the Z3 solver. This project uses the Z3 theorem prover and Polygon's Plonky3 ZK framework. The Plonky3 framework has nice abstractions around building AIRs which was very beneficial for extracting the constraints before passing them through the Z3 transpiling pipeline in Python (for which Z3 has a far more ergonomic library than in Rust).",
        "how_its_made": "This project uses the Z3 theorem prover and Polygon's Plonky3 ZK framework. The Plonky3 framework has nice abstractions around building AIRs which was very beneficial for extracting the constraints before passing them through the Z3 transpiling pipeline in Python (for which Z3 has a far more ergonomic library than in Rust).",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/95jy3/screenshots/gzukb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/95jy3/screenshots/1tcwa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/95jy3/screenshots/pn8cu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/rpalakkal/p3-fv",
        "link": "https://ethglobal.com/showcase/p3-fv-95jy3"
    },
    {
        "title": "NBA MOMENTUM",
        "brief_description": "NBA Momentum is a strategy-driven trading card game that transforms NBA Top Shot moments into competitive, stats-based gameplay. Players build decks and compete by using real NBA moments with custom abilities.",
        "long_description": "NBA Momentum leverages NBA Top Shot\u2019s blockchain moments to create a trading card game where each moment becomes a playable card with attributes like offense, defense, and special abilities. Players build decks using various types of cards\u2014Player Moments, Hype, Playbook, Equipment, and Arena cards\u2014and engage in strategic gameplay to reach 21 points, simulating a fast-paced pickup basketball game. The game\u2019s innovation lies in its integration with Flow blockchain, giving players ownership over their moments while adding strategic layers through custom stats and abilities, making it a more immersive experience. NBA Momentum is built using the Flow blockchain and Cadence for smart contracts, enabling us to tokenize and add metadata to existing NBA Top Shot moments. We used Python scripts and the OpenAI API to dynamically generate custom stats for each moment, which is stored as metadata on the Flow network. The frontend uses React for a seamless user experience, allowing players to view their moment collections, build decks, and engage in card battles. Postman was used to interact with the NBA Top Shot API, and the game\u2019s backend utilizes Node.js to manage game logic and deck building.",
        "how_its_made": "NBA Momentum is built using the Flow blockchain and Cadence for smart contracts, enabling us to tokenize and add metadata to existing NBA Top Shot moments. We used Python scripts and the OpenAI API to dynamically generate custom stats for each moment, which is stored as metadata on the Flow network. The frontend uses React for a seamless user experience, allowing players to view their moment collections, build decks, and engage in card battles. Postman was used to interact with the NBA Top Shot API, and the game\u2019s backend utilizes Node.js to manage game logic and deck building.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9shz6/screenshots/bzqm6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9shz6/screenshots/5k7vs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9shz6/screenshots/9oy6z/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/bombfriedrice/nbamomentum",
        "link": "https://ethglobal.com/showcase/nba-momentum-9shz6"
    },
    {
        "title": "Engagemint",
        "brief_description": "Engagemint empowers users to earn, tokenize, and unlock rewards for their attention on their favorite artists and influencers. Mint unique tokens, track engagement, and redeem exclusive perks\u2014all in a Web3 ecosystem.",
        "long_description": "Engagemint is an Web3 platform designed to transform user engagement into a valuable currency. Engagemint enables users to earn, tokenize, and unlock exclusive rewards for their interactions with artists and influencers. Upon logging in, users are greeted with a personalized dashboard that displays metrics reflecting their engagement activity, such as time spent streaming specific artists or influencers. This data is essential for tracking progress and rewards. One of the platform's standout features is the influencer tokens, which users can browse to find various artists. These tokens are approved through a community voting process, ensuring users feel connected to the content they engage with. Community members can also propose new artist tokens, and once an artist receives 150 affirmative votes, a new token is minted through a Solidity smart contract on Skale\u2019s Calypso testnet. This process allows underground and emerging artists to gain visibility while providing users with a wider range of tokens to accumulate. As users engage with their favorite artists, they earn engagement points, which contribute to the minting of new tokens and can lead to exclusive perks. Additionally, users accumulate digital proof of their interactions, displayed as achievement collections, which serve as badges of loyalty and enhance the overall experience. The redemption page allows users to exchange their tokens for exclusive rewards, such as backstage passes and limited-edition merchandise, incentivizing ongoing interaction and loyalty. Engagemint fosters a sense of community by allowing users to participate in the decision-making process regarding which artists receive tokens. This collaborative approach not only enhances user satisfaction but also encourages fans to support their favorite artists, driving more engagement on the platform. Overall, Engagemint is revolutionizing the way fans and creators interact in the digital space, making engagement a rewarding experience and transforming casual listeners into invested community members. Whether you\u2019re a dedicated fan or an emerging artist, Engagemint makes it easy to be recognized and rewarded for your engagement. This project is deployed on the Skale Calypso Testnet and we implemented a voting system to that allow users to vote on new tokens. It also tracks how long people are spending on the applications to mint these tokens using a Solidity smart contract.The entire goal is to let creators get to advertise themselves and let fans of those creators get to promote themself",
        "how_its_made": "This project is deployed on the Skale Calypso Testnet and we implemented a voting system to that allow users to vote on new tokens. It also tracks how long people are spending on the applications to mint these tokens using a Solidity smart contract.The entire goal is to let creators get to advertise themselves and let fans of those creators get to promote themself",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/yffv6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/rpexa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/g2rni/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/9nygn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/tem4n/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ssarahmou/engagemint",
        "link": "https://ethglobal.com/showcase/engagemint-t6caw"
    },
    {
        "title": "BlockLingo",
        "brief_description": "A decentralized protocol enabling direct asset transfers between different blockchains.",
        "long_description": "This image illustrates a cross-chain transfer protocol system, focusing on the user experience and the underlying technical process. At the top, we see a user interface represented by a wallet. The wallet shows the source (ETH) and destination (Layer 0 OTP) for a transfer. This represents the user's intent to move assets from one blockchain (Ethereum) to another (a Layer 0 protocol). The lower section of the image depicts the internal workings of the transfer system. The central component is labeled \"Main AI ORCHESTRATOR,\" which appears to be the core logic coordinating the entire process. Connected to this main orchestrator is a \"Translator\" module. This translator interacts with multiple blockchain networks: ETH (Ethereum), EURC (possibly a fictional or newer blockchain), EURC (another blockchain or network), and Layer 0 OTP (the destination chain from the user's perspective). The translator's role seems to be facilitating communication and transaction formatting between these different blockchain protocols. The flow suggests that when a user initiates a transfer, the main orchestrator processes the request, then utilizes the translator to interact with the necessary blockchains. This likely involves creating and verifying transactions on the source chain (ETH in this case), translating the asset or data into a format compatible with the destination chain, and then finalizing the transfer on the Layer 0 OTP network. The bottom of the image states \"Source reaches final destination,\" indicating the successful completion of the cross-chain transfer. This system appears designed to abstract away the complexity of cross-chain interactions from the user, providing a seamless experience for transferring assets between different blockchain networks, while handling the intricate details of protocol translation and transaction orchestration behind the scenes. The frontend is built in react, Coinbase SDK Wallet connect, Tailwind CSS. The backend is comprised of integrations between Metamask, Layer 0, Morph, and Solidity Smart Contracts. Layer 0 was a great benefit to the project as it helped us use hardhat and contracts to simplify our workflow.",
        "how_its_made": "The frontend is built in react, Coinbase SDK Wallet connect, Tailwind CSS. The backend is comprised of integrations between Metamask, Layer 0, Morph, and Solidity Smart Contracts. Layer 0 was a great benefit to the project as it helped us use hardhat and contracts to simplify our workflow.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9pf20/screenshots/bjezt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9pf20/screenshots/jp470/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9pf20/screenshots/ytduw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/U1tra-Labs/blockLingo",
        "link": "https://ethglobal.com/showcase/blocklingo-9pf20"
    },
    {
        "title": "ToneRight",
        "brief_description": "TuneRight is a web marketplace where artists and production companies trade music licensing as intellectual property. It empowers users to register their music, set licensing terms, manage royalties, and ensures the original artist is always credited and compensated.",
        "long_description": "Our web service acts as a marketplace where artists and production companies come to buy and sell licensing to their Music, which is their Intellectual Property. Our webspace allows users to register their music as Intellectual Property Assets, set personalized Licensing Terms and sell rights to their music without any human intervention or requirement of delegation. It also takes care of flow of royalties and makes sure that the original artist is always credited and compensated according to their own accord. The project leverages Story Protocol to streamline intellectual property management, licensing, and royalty distribution. It also integrates Dynamic to offer users an easy and seamless onboarding experience. Built with Next.js, Solidity, viem, and wagmi, the platform ensures a decentralized and efficient approach to music rights and usage.",
        "how_its_made": "The project leverages Story Protocol to streamline intellectual property management, licensing, and royalty distribution. It also integrates Dynamic to offer users an easy and seamless onboarding experience. Built with Next.js, Solidity, viem, and wagmi, the platform ensures a decentralized and efficient approach to music rights and usage.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xdj7q/screenshots/oouav/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xdj7q/screenshots/1m7qg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xdj7q/screenshots/9g5y7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xdj7q/screenshots/qr8tx/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sreekar9601/tone-right/",
        "link": "https://ethglobal.com/showcase/toneright-xdj7q"
    },
    {
        "title": "Build Villager",
        "brief_description": "An interface to write community benefits into intellectual patent acquisitions",
        "long_description": "Mint projects on Story that allow the use of derivatives access to rights within a community. One use case is if I write a novel and mint intellectual copyright on Story, I can allow some parts of the novel to be editable by the reader and others to be uneditable. I can also add multimedia patents such as music to add to the experience of the novel. Token holders of the parent novel and its derivatives can use those tokens to gain access to community events such as concerts, healthcare, and other benefits. Story's Proof of Creativity Protocol would be the origination and host of the parent intellectual properties. Then write the benefits into the individual copyrights during the minting. The ERC-20 tokens could have unique properties allowing easy access for downstream benefit recognition. The project gives token holders access to a community called Villager.",
        "how_its_made": "Story's Proof of Creativity Protocol would be the origination and host of the parent intellectual properties. Then write the benefits into the individual copyrights during the minting. The ERC-20 tokens could have unique properties allowing easy access for downstream benefit recognition. The project gives token holders access to a community called Villager.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qsadf/screenshots/gr1tk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qsadf/screenshots/4og5m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qsadf/screenshots/e5dvp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/eldarina/villager",
        "link": "https://ethglobal.com/showcase/build-villager-qsadf"
    },
    {
        "title": "APIWink",
        "brief_description": "APIWink at core is an API micro-lending service, ideal to attract more users and reduce costs. It's developed on Skale contracts, invisible custodial experience, Europa testnet and program money.",
        "long_description": "APIs traditionally have a monthly/yearly subscription models, for developers who want to just try out APIs for their application, this model becomes a rather costly option. We've developed a micro-lending service enabling devs to purchase \"number of API calls\" for Skale programmed money. This model not only charges per use, but also splits the money between us (the service providers) and creators (api creators). These people are welcome to join our marketplace, we have specially designed an SDK to attach to our eco-system along with robust documentation. The application is heavily centered around Skale, utilizing it's zero gas fees. It's present in our project in the following ways - Skale contracts, Invisible custodial experience, Europa testnet for DeFI and programmable monday. The backend and SDK are developed using python, frontent uses nextjs.\nWe have deployed the backend on render, docs on gitbook, MongoDb for database",
        "how_its_made": "The application is heavily centered around Skale, utilizing it's zero gas fees. It's present in our project in the following ways - Skale contracts, Invisible custodial experience, Europa testnet for DeFI and programmable monday. The backend and SDK are developed using python, frontent uses nextjs.\nWe have deployed the backend on render, docs on gitbook, MongoDb for database",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2ogub/screenshots/2fwif/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2ogub/screenshots/r2c4z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2ogub/screenshots/4wb7r/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ApiWink",
        "link": "https://ethglobal.com/showcase/apiwink-2ogub"
    },
    {
        "title": "Photo Booth",
        "brief_description": "Photo Booth is a fun tool that lets people take photos and add fun overlays including Nouns glasses and their ENS.",
        "long_description": "Photo Booth is a web application built with Next.js that allows users to take photos, add fun overlays including Nouns glasses and their ENS, and see all images uploaded by users from the same event. When you access this app you connect your wallet, then are able to take an photo with your webcam. We then allow you to add cool overlays like Noun glasses and your ENS. We also leverage walrus aggregator and publisher however it was down during the event. We built the project using Next.js and used libraries like wagmi. We let the user take photos and we created an upload route to upload images to Walrus and a route to get images from the walrus aggregator. We used partners like Walrus (for the images hostings), Nouns (for their IP and incorporating their IP in as overlays), ENS (we let users connect wallet and then add their ENS overlayed on the image). This help increase and promote Nouns and ENS visibility and adoption.",
        "how_its_made": "We built the project using Next.js and used libraries like wagmi. We let the user take photos and we created an upload route to upload images to Walrus and a route to get images from the walrus aggregator. We used partners like Walrus (for the images hostings), Nouns (for their IP and incorporating their IP in as overlays), ENS (we let users connect wallet and then add their ENS overlayed on the image). This help increase and promote Nouns and ENS visibility and adoption.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h1pz9/screenshots/b9t1t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h1pz9/screenshots/qpphk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h1pz9/screenshots/fqukd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h1pz9/screenshots/ikub1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jarrensj/photo-booth",
        "link": "https://ethglobal.com/showcase/photo-booth-h1pz9"
    },
    {
        "title": "zk-checkpoint",
        "brief_description": "ZK proofs for checkpointing on Polygon PoS to save on settlement gas and faster interop",
        "long_description": "Polygon PoS being one of the most used chains has a mechanism where it settles to Ethereum (L1) at regular intervals through checkpoints which is helpful for bridging. As a result, the consensus signatures are sent to L1 contract and signature verification for all validators is done on-chain. This incurs a lot of gas on ethereum and ~86% of total gas used is taken by signature verification for all validators (on mainnet, roughly 105). The costs gas go >250$ in case of high demand. This settlement workflow can be improved using ZK proofs which asserts that majority of validator set (>2/3) voted on a particular checkpoint. This can lead to 2 things: The project is made with the help of SP1, which allows to write the signature verification and validation logic in Rust and generate a proof out of it which can be verified on-chain. While the crux is pretty simple, there were lots of challenges while building this. Moreover, the circuit has certain strict constraints which eliminates the risk of prover generating false/fake proofs.",
        "how_its_made": "The project is made with the help of SP1, which allows to write the signature verification and validation logic in Rust and generate a proof out of it which can be verified on-chain. While the crux is pretty simple, there were lots of challenges while building this. Moreover, the circuit has certain strict constraints which eliminates the risk of prover generating false/fake proofs.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1humr/screenshots/3ciie/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1humr/screenshots/fhhp6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1humr/screenshots/h7ktj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/manav2401/zk-checkpoint",
        "link": "https://ethglobal.com/showcase/zk-checkpoint-1humr"
    },
    {
        "title": "bloq",
        "brief_description": "search on-chain data with a prompt, we enable users to search on-chain data and consume it in layman language",
        "long_description": "Using LlamaIndex with The Graph protocol for indexing and serving on-chain data, and then leveraging that with agentic RAG (Retrieval-Augmented Generation) LLMs is a powerful approach. This setup allows for intelligent, context-aware querying of blockchain data with the added benefit of AI-driven insights. We have used llama-index framework to semantically search on-chain data.Using LlamaIndex (formerly GPT Index) for semantically searching on-chain data is an innovative approach. It allows you to create more intelligent and context-aware searches of blockchain data. his setup allows for intelligent, context-aware querying of blockchain data with the added benefit of AI-driven insights.",
        "how_its_made": "We have used llama-index framework to semantically search on-chain data.Using LlamaIndex (formerly GPT Index) for semantically searching on-chain data is an innovative approach. It allows you to create more intelligent and context-aware searches of blockchain data. his setup allows for intelligent, context-aware querying of blockchain data with the added benefit of AI-driven insights.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9k8fv/screenshots/1qnvy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9k8fv/screenshots/1x1ns/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9k8fv/screenshots/qijwb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/DV0x/bloq",
        "link": "https://ethglobal.com/showcase/bloq-9k8fv"
    },
    {
        "title": "SecurityModuleForAA",
        "brief_description": "The user enabled Safe Guard with 2FA (via email) to protect the Smart Account from the risk of a compromised EOA key.",
        "long_description": "A traditional EOA wallet is vulnerable, as a single exposure of the private key can immediately put all assets at risk. Additionally, when managing a smart account through multi-signature, there is the inconvenience of requiring signatures above the threshold every time a transaction occurs. To address these issues, two accounts can be created to manage a single smart account. One account is attached to the smart account to manage transactions via a module, while the other serves as the owner of the smart account and handles signing responsibilities. This approach distributes responsibilities and enhances the user experience. The process is as follows: First, the user creates a smart wallet using their EOA. Simultaneously, they log into our app (SPOT) using another method or another EOA. In SPOT, they create a module that manages transactions and attach this module to the smart wallet created with the previous EOA. By doing so, the management of the smart account is divided into two (the module and the user's EOA), each managed through different methods. This ensures much stronger security than managing everything with a single private key. Since transactions are automatically handled according to the rules set in the module, the hassle of multiple signatures for every transaction is reduced. Furthermore, by incorporating advanced security measures like encryption oracles such as Lit Protocol, users can manage account security at a more sophisticated level (e.g., based on IP address). As more data accumulates, AI-powered fraud detection systems (FDS) can also be provided through the module, further enhancing security. This project implemented smart accounts and attached the appropriate module using Safe Wallet. To create a management point separate from the EOA, we onboarded users through SPOT by utilizing Dynamic.xyz. Additionally, to reduce gas fee conflicts during user onboarding, we used Alchemy's Account Kit and Paymaster to eliminate gas fees associated with creating modules and changing settings. Moving forward, we plan to provide modules that allow users to encrypt their IP addresses and specific actions using Lit Protocol, enabling privacy-preserving configuration.",
        "how_its_made": "This project implemented smart accounts and attached the appropriate module using Safe Wallet. To create a management point separate from the EOA, we onboarded users through SPOT by utilizing Dynamic.xyz. Additionally, to reduce gas fee conflicts during user onboarding, we used Alchemy's Account Kit and Paymaster to eliminate gas fees associated with creating modules and changing settings. Moving forward, we plan to provide modules that allow users to encrypt their IP addresses and specific actions using Lit Protocol, enabling privacy-preserving configuration.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/n7kyk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/9nycn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/iz60v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/mwcka/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/o3fpn/default.jpg"
        ],
        "live_demo": "https://ethglobal-24-sf.vercel.app/",
        "source_code": "https://github.com/PermissionLabs/ethglobal-24-sf",
        "link": "https://ethglobal.com/showcase/securitymoduleforaa-ufcg7"
    },
    {
        "title": "BenderBite",
        "brief_description": "AI Employee Bender: get AI advices based on previous winners, vote for other project and get prices and meet friends!",
        "long_description": "BenderBite is an AI-powered assistant designed to enhance the EthGlobal hackathon experience by serving as a virtual employee with multiple interactive features. Here's a detailed breakdown: Tailored Advice from Previous Winners: Users can receive tailored advice based on insights from previous hackathon winners.\nBender uses historical data to offer actionable suggestions on project development, presentation, and strategies for winning.\nProject Bidding and Rewards: Users can add projects to the platform using the XMTP bot and automatically receive an ENS domain through the ENS smart contract, along with a wallet created programmatically using Circle\u2019s wallet service.\nUsers can place bids on other projects during the hackathon.\nAutomated reward distribution is facilitated through the Circle API.\nSocial Networking and Collaboration: Bender helps users find friends and collaborate with others.\nIt enables networking by matching users with potential partners. I have integrated XMTP for seamless messaging capabilities, allowing users to communicate effectively within the platform. To provide tailored guidance, I\u2019ve utilized AI for context learning, drawing insights from previous hackathon winners to offer strategic advice on project development and presentation. For identity management, I\u2019ve implemented smart contracts that facilitate ENS subdomain registration, ensuring that users can establish their unique digital identities on the blockchain. Additionally, I\u2019ve incorporated Circle\u2019s programmable wallets API, enabling the automatic generation of secure wallets for users, as well as Circle\u2019s smart contract platform and used Circle for automated and transparent transaction processing, including bidding and reward distribution.",
        "how_its_made": "I have integrated XMTP for seamless messaging capabilities, allowing users to communicate effectively within the platform. To provide tailored guidance, I\u2019ve utilized AI for context learning, drawing insights from previous hackathon winners to offer strategic advice on project development and presentation. For identity management, I\u2019ve implemented smart contracts that facilitate ENS subdomain registration, ensuring that users can establish their unique digital identities on the blockchain. Additionally, I\u2019ve incorporated Circle\u2019s programmable wallets API, enabling the automatic generation of secure wallets for users, as well as Circle\u2019s smart contract platform and used Circle for automated and transparent transaction processing, including bidding and reward distribution.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/z2f7s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/6h54g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/dxvbh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/x19yj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/s5mdj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wisemik/benderbite",
        "link": "https://ethglobal.com/showcase/benderbite-331m7"
    },
    {
        "title": "EssenSwap",
        "brief_description": "EssenSwap is a limit orderbook-based exchange built on the Essential blockchain.",
        "long_description": "In EssenSwap, the bids and asks are submitted as constraints, as required by Essential's declarative virtual machine. Every time there is a positive spread, an external solver bot is created that matches bids and asks and submits a solution to propose a new state of the system, viz., the updated balances of the bidders and askers. EssenSwap consists of three components: front-end, solver bot, and blockend. First, we deploy smart contracts for standard fungible token contracts currently available on Essential. Then, we deploy a unique smart contract for every bid and ask order, with predicates that impose constraints on the swap price of a trade. After that, we build a rust-based script that performs on-behalf of a solver by sorting, and then matching bids and asks orders. The final solution is then submitted to the Essential blockchain through their API. Once the rust script receives a confirmation receipt, it updates the front-end display.",
        "how_its_made": "EssenSwap consists of three components: front-end, solver bot, and blockend. First, we deploy smart contracts for standard fungible token contracts currently available on Essential. Then, we deploy a unique smart contract for every bid and ask order, with predicates that impose constraints on the swap price of a trade. After that, we build a rust-based script that performs on-behalf of a solver by sorting, and then matching bids and asks orders. The final solution is then submitted to the Essential blockchain through their API. Once the rust script receives a confirmation receipt, it updates the front-end display.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/qy5hd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/6rru4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/cw9at/default.jpg",
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/azcmt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/06nj9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jeffklinck/EthSF",
        "link": "https://ethglobal.com/showcase/essenswap-82ygd"
    },
    {
        "title": "Wilson:sound intents",
        "brief_description": "Execute, Attest, Validate, and Share Communicated data via agent-assisted contracts.",
        "long_description": "Bringing insights on chain, and generating value for data gatherings. Wilson is a toolset built on the Friend SDK that turns your voice into secure triggers for onchain actions. Simply pair your Omi, or other compatible wearable with your Omi app, add the Wilson extension, and tap the screen to complete the memory block whenever you want to process a command. Upon processing, Wilson will send the parsed statement to a server that will generate a response based on your trigger statement. If this is Friend SDK produces a prompt that is sent to a webhook parsed before being sent to an available DA layer, where the request is staged to produce a response from Dynamic for wallet info, or XMTP for external actions. All Dynamic responses return as Sign attestation, under a schema that allows recipient to authenticate the response if they wish the result to be onchain. Otherwise, the insights from the contributor's personal device are shared with the local network once they submit a 'register' command, then all further insights are contributed to local pool until insight stream is 'plugged'. While streaming your insights via Wilson, you can use your device to capture and cultivate local data, post, share, and challenge others from your personal onchain history, and generate new historic intents. Each change in permissions possible thanks to zk toolset from Polygon, and assignable via ENS retrieval contracts.",
        "how_its_made": "Friend SDK produces a prompt that is sent to a webhook parsed before being sent to an available DA layer, where the request is staged to produce a response from Dynamic for wallet info, or XMTP for external actions. All Dynamic responses return as Sign attestation, under a schema that allows recipient to authenticate the response if they wish the result to be onchain. Otherwise, the insights from the contributor's personal device are shared with the local network once they submit a 'register' command, then all further insights are contributed to local pool until insight stream is 'plugged'. While streaming your insights via Wilson, you can use your device to capture and cultivate local data, post, share, and challenge others from your personal onchain history, and generate new historic intents. Each change in permissions possible thanks to zk toolset from Polygon, and assignable via ENS retrieval contracts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/x147v/screenshots/ict2t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x147v/screenshots/tz4nr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x147v/screenshots/ahn5y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x147v/screenshots/4wqhx/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/paulman5/ETHGlobalSF",
        "link": "https://ethglobal.com/showcase/wilson-sound-intents-x147v"
    },
    {
        "title": "Real Lend",
        "brief_description": "Borrowers pledge real-world assets as collateral. An oracle sets the asset\u2019s value and posts a bond. Lenders provide loans with interest. If borrowers default, lenders sell the asset to the oracle to recover funds. Loans can also be sold early through Dutch auctions.",
        "long_description": "Real Lend bridges real-world assets (RWAs) with decentralized finance, allowing borrowers to unlock liquidity and lenders to earn yields. Borrowers pledge assets like vacation cottages as collateral, with an oracle setting the value and posting it as a bond to guarantee the lender\u2019s recovery. Lenders provide loans (e.g., 100k USDC at 10% interest) based on the asset's value. If the borrower repays, they reclaim the asset; if not, the lender recovers funds by selling the asset to the oracle at the bonded value. Lenders can exit early by selling their loan position through a Dutch auction, which starts at a high price and drops until purchased. Pools on protocols like Morpho improve liquidity, ensuring a smooth, secure, and flexible lending experience for both parties. We built a decentralized protocol for real-world asset lending using Solidity smart contracts and the Foundry toolkit. Our core components include USDC.sol for managing loan payments, Cottage.sol to tokenize real estate collateral like vacation homes, and Protocol.sol to oversee loan issuance, repayments, and defaults. An oracle sets asset values and posts bonds, ensuring lenders are protected by guaranteeing recovery if borrowers default. In such cases, lenders can recover their funds by selling the assets to the oracle at the bonded value. To offer flexibility, we implemented a Dutch auction mechanism in DutchAuction.sol, allowing lenders to exit their loan positions early by dynamically selling them as prices adjust over time. We streamlined deployment using Foundry tools such as forge and automated the process with custom Bash scripts for contract deployment and verification. Anvil was used to fork the Ethereum mainnet locally, creating realistic test environments that simulated live network conditions. This setup allowed us to efficiently identify and resolve issues before deployment. Our automation framework ensured a seamless and repeatable workflow, making the development process smooth and scalable from testing through deployment.",
        "how_its_made": "We built a decentralized protocol for real-world asset lending using Solidity smart contracts and the Foundry toolkit. Our core components include USDC.sol for managing loan payments, Cottage.sol to tokenize real estate collateral like vacation homes, and Protocol.sol to oversee loan issuance, repayments, and defaults. An oracle sets asset values and posts bonds, ensuring lenders are protected by guaranteeing recovery if borrowers default. In such cases, lenders can recover their funds by selling the assets to the oracle at the bonded value. To offer flexibility, we implemented a Dutch auction mechanism in DutchAuction.sol, allowing lenders to exit their loan positions early by dynamically selling them as prices adjust over time. We streamlined deployment using Foundry tools such as forge and automated the process with custom Bash scripts for contract deployment and verification. Anvil was used to fork the Ethereum mainnet locally, creating realistic test environments that simulated live network conditions. This setup allowed us to efficiently identify and resolve issues before deployment. Our automation framework ensured a seamless and repeatable workflow, making the development process smooth and scalable from testing through deployment.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/11w4v/screenshots/74sjp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11w4v/screenshots/tnvd3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11w4v/screenshots/6suru/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/mergd/reallend-ui",
        "link": "https://ethglobal.com/showcase/real-lend-11w4v"
    },
    {
        "title": "Omi FM",
        "brief_description": "Decentralized music player, let smart contracts take care of creating the vibes.",
        "long_description": "AI powered Dapp that plays curated music for you based on the conversations analyzed by Omi. DApp created using Omi SDK for conversation analysis with its AI models. UI/UX is command line, using Python and Solidity to communication with Smart Contracts deployed to Skale, Flow, and Avail. Those contracts contain the logic for creating playlists and getting new songs. DApp created using Omi SDK for conversation analysis with its AI models. UI/UX is command line, using Python and Solidity to communication with Smart Contracts deployed to Skale, Flow, and Avail. Those contracts contain the logic for creating playlists and getting new songs. ZK rollups handle bulk song creation off chain.",
        "how_its_made": "DApp created using Omi SDK for conversation analysis with its AI models. UI/UX is command line, using Python and Solidity to communication with Smart Contracts deployed to Skale, Flow, and Avail. Those contracts contain the logic for creating playlists and getting new songs. ZK rollups handle bulk song creation off chain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/i6xxx/screenshots/jyupj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/i6xxx/screenshots/24xk4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/i6xxx/screenshots/g16q8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Derricks-DApps/Omi-FM",
        "link": "https://ethglobal.com/showcase/omi-fm-i6xxx"
    },
    {
        "title": "Block-Jack 21",
        "brief_description": "I have build a multiplayer Blackjack game on the blockchain with one smart contract using Phoenix Solidity for data encryption and privacy. Web3.js and React with Tailwind CSS will handle the UI for smooth player interaction.",
        "long_description": "I have deployed a multiplayer Blackjack game on the blockchain using a single smart contract that integrates the Phoenix Solidity library for encrypting sensitive data. The smart contract handles the entire game logic, including dealing cards, tracking bets, and determining winners, while ensuring that private information like players\u2019 hands remains secure and hidden. This setup allows players to trust that the game operates fairly and securely on the blockchain. The front-end of the game connects to the blockchain using web3.js or ethers.js, while the interface itself is built using React and styled with Tailwind CSS for a user-friendly and visually appealing experience. Players can join games, place bets, and view results in real-time, with the blockchain managing all interactions in the background. The use of Phoenix encryption guarantees that private data is never exposed on the public ledger, adding an extra layer of security, which is crucial for a blockchain-based game. This project balances the transparency of blockchain with the privacy needed for multiplayer gaming, offering a secure and fair platform for players. I started with creating the smart contracts using solidity, Fhenix (FOH.sol) hardhat, and then deployed on sepolia for testing. Then, created the frontend with reactJS and Tailwind. At the end, used Helium PoW Faucet to get the tokens for Fhenix testnet and deploying the smart contract over there.",
        "how_its_made": "I started with creating the smart contracts using solidity, Fhenix (FOH.sol) hardhat, and then deployed on sepolia for testing. Then, created the frontend with reactJS and Tailwind. At the end, used Helium PoW Faucet to get the tokens for Fhenix testnet and deploying the smart contract over there.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t68nv/screenshots/37dcm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t68nv/screenshots/0ent9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t68nv/screenshots/too3b/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/saniddhyaDubey/BlockJack-21",
        "link": "https://ethglobal.com/showcase/block-jack-21-t68nv"
    },
    {
        "title": "Rhizome",
        "brief_description": "Rhizome Markets is a synthetics protocol built on the Rootstock EVM. Rhizome enhances capital efficiency and risk diversification with multicollateralization, allowing users to engage in hedging, yield farming, and collateralized debt positions directly on Rootstock.",
        "long_description": "A Bitcoin synthetics protocol allows users to create and trade synthetic assets\u2014tokens that represent and track the value of other assets like fiat currencies, commodities, or equities\u2014while using Bitcoin as collateral. With Rhizome, Bitcoin holders can participate on complex financial activities such as hedging, yield farming, and CDPs directly on the Rootstock EVM. Capital Efficiency Through Multicollateralization of rhUSD\nSynthetics, primarily the rhUSD dollar pegged instance deployed as an example of the Rootstock EVM mainnet, offers multicollateral support for collateralizing rhUSD, which offers significant advantages: Capital Efficiency: Utilizing multiple assets (rBTC, RIF, USDRIF, ETHs) as collateral allows for more efficient use of capital, enabling users to leverage a broader asset base.\nRehypothecation: Assets used as collateral can be rehypothecated, meaning they can be used simultaneously in multiple financial operations, enhancing liquidity.\nEcosystem: Promotes interoperability within the Rootstock DeFi ecosystem, increasing the utility of various tokens.\nMulticollateralization of assets with rBTC also allows a singular efficient pool of collateral to mint multiple synthetic assets on top of the pool. Additionally, relying solely on Bitcoin as collateral exposes the system to Bitcoin's price volatility. This can be mitigated with stablecoins or more stable assets in the multicollateral pool for all rh synthetics. Liquidation Risks: Sharp declines in Bitcoin's price can trigger collateral liquidations, destabilizing the system.\nOver-Collateralization: Users may need to provide excessive collateral to safeguard against volatility, reducing capital efficiency.\nRisk Diversification: The volatility of Bitcoin can be offset by the stablecoins, by default decreasing risk compared to a purely BTC collateralized CDP protocol.\nStability: A diversified collateral pool enhances the stability of the synthetic stablecoin and decreasing the risk of liquidation for debt positions, maintaining its peg more effectively.\nStabilizers\nStabilizers are multiple modules in the Rhizome protocol that strengthen the peg price for minted rh synthetic assets. For instance, each synthetic can have it's own Peg Stability Modules (PSM) based on the MakerDAO DAI-USDC PSM with various customizations to the swap fee. In the case of rhUSD, the alternative asset to rhUSD would be rUSDT, the fiat stablecoin with the largest dominance on Rootstock at 34.44%. Additionally, as utilized by MakerDAO and Inverse, the amount of synthetics can be controlled by governance or an administrator address through increasing and decreasing the liquidity of mintable synthetics. In these deployed contracts, only a US-dollar pegged synthetic, rhUSD, has been deployed, but any synthetic can be deployed as long as there is a secure oracle for the asset on Rootstock EVM. In the case for rhUSD, the price is hardcoded at 1. This project was based on the Compound v2 lending markets and heavily modified to support synthetic assets, but the synthetics protocol relies on stabilizers, which are optimized modules to keep the theoretical price of Rhizome synthetic assets. The entirety of the contracts were made used with Solidity, and integrated major Rootstock ecosystem tokens such as rBTC, rUSDT, RIF, and USDRIF in the code. The contract deployments were configured to use Umbrella Network oracles for rBTC/rUSDT prices, and were deployed on Rootstock mainnet as well to support all these assets.",
        "how_its_made": "This project was based on the Compound v2 lending markets and heavily modified to support synthetic assets, but the synthetics protocol relies on stabilizers, which are optimized modules to keep the theoretical price of Rhizome synthetic assets. The entirety of the contracts were made used with Solidity, and integrated major Rootstock ecosystem tokens such as rBTC, rUSDT, RIF, and USDRIF in the code. The contract deployments were configured to use Umbrella Network oracles for rBTC/rUSDT prices, and were deployed on Rootstock mainnet as well to support all these assets.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1a0t5/screenshots/8hk52/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1a0t5/screenshots/hzv84/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1a0t5/screenshots/sj3xr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/in70/rhizome-protocol/",
        "link": "https://ethglobal.com/showcase/rhizome-1a0t5"
    },
    {
        "title": "Kiss Or Slap 2.0",
        "brief_description": "A gamified mobile social app that people can earn under prisoner's dilemma",
        "long_description": "Kiss or Slap is a gamified dating app where users make strategic decisions in a fun social experience based on game theory's prisoner's dilemma. Players engage with each other by choosing either a \"Kiss\" or a \"Slap.\" The outcomes vary: The app has an onboarding process where users create profiles, upload live photos, and link their social media accounts to earn initial points. Users can browse a feed resembling Tinder, view profiles, and see if others have interacted with them. A hot score and karma system reflect user engagement and behavior, with scores visible on profiles. Tech Stack:\nnextjs + prisma Sponsor used:\n@walrus for all image upload and hosting in the app\n@coinbase-sdk for MPC wallet Payout, User Onramp\n@polygon gas-less rail for onramp with USDC Onramp, In app purchase\n@flow Onramp, In App purchase for user want extra rewards\n@privy for login & user identity management\n@circle USDC for in-app payment/payout",
        "how_its_made": "Tech Stack:\nnextjs + prisma Sponsor used:\n@walrus for all image upload and hosting in the app\n@coinbase-sdk for MPC wallet Payout, User Onramp\n@polygon gas-less rail for onramp with USDC Onramp, In app purchase\n@flow Onramp, In App purchase for user want extra rewards\n@privy for login & user identity management\n@circle USDC for in-app payment/payout",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/hyi4i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/5kqpn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/b4yxa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/o87d7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/h54i0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/2mvu2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/yayashuxue/kissorslap-ethsf2024",
        "link": "https://ethglobal.com/showcase/kiss-or-slap-2-0-5yxze"
    },
    {
        "title": "artist-popup",
        "brief_description": "Short Description: A decentralized platform for artist pop-up events, enabling artists to mint NFTs for their physical artwork and attendees to collect digital assets with exclusive content",
        "long_description": "The Artist Pop-Up NFT Platform is an innovative decentralized application that connects artists, attendees, and event organizers by combining physical pop-up art events with digital NFT technology. This platform allows artists to showcase their artwork and create NFTs that represent their pieces, giving collectors and attendees the opportunity to own unique digital collectibles linked to exclusive content. Using MetaMask, users can securely connect and interact with the platform, including minting new NFTs, transferring ownership, and accessing special content. Revised Replit Instructions for Artist Pop-Up Event with NFT Integration We\u2019re simplifying the process for developing your artist pop-up event application, focusing on security, user experience, and reducing complexity by leveraging MetaMask for all user interactions\u2014including admins, artists, and attendees. Here\u2019s a comprehensive guide to set up and deploy your app on Replit, incorporating what we\u2019ve learned so far. Step 1: Set Up the Replit Project Create a New Replit Project: Install Required Dependencies: Add Environment Variables: Step 2: Hardhat Local Deployment for Smart Contract Write the NFT Smart Contract: Deploy the Contract Using Hardhat: Step 3: Implement MetaMask Wallet Interactions Add MetaMask Login Functionality: Use MetaMask for Admin and User Actions: Step 4: Build a Unified Dashboard Create a Role-Based Dashboard (dashboard.html): Show/Hide Features Based on Role: Step 5: Exclusive Content Using Lit Protocol Set Up Exclusive Content Encryption: Front-End Interaction: Step 6: Testing and Deployment on Replit Test the Interaction Flow: Deploy on Replit: Step 7: No API Required for Sign Protocol Key Security Practices Summary\nThe entire app\u2014including Admin, Artist, and Attendee roles\u2014operates securely using MetaMask for authentication and blockchain transactions. Hosting on Replit is focused on the front-end, while smart contracts are managed securely using Hardhat and MetaMask to ensure a consistent, user-friendly experience without compromising security.",
        "how_its_made": "Revised Replit Instructions for Artist Pop-Up Event with NFT Integration We\u2019re simplifying the process for developing your artist pop-up event application, focusing on security, user experience, and reducing complexity by leveraging MetaMask for all user interactions\u2014including admins, artists, and attendees. Here\u2019s a comprehensive guide to set up and deploy your app on Replit, incorporating what we\u2019ve learned so far. Step 1: Set Up the Replit Project Create a New Replit Project: Install Required Dependencies: Add Environment Variables: Step 2: Hardhat Local Deployment for Smart Contract Write the NFT Smart Contract: Deploy the Contract Using Hardhat: Step 3: Implement MetaMask Wallet Interactions Add MetaMask Login Functionality: Use MetaMask for Admin and User Actions: Step 4: Build a Unified Dashboard Create a Role-Based Dashboard (dashboard.html): Show/Hide Features Based on Role: Step 5: Exclusive Content Using Lit Protocol Set Up Exclusive Content Encryption: Front-End Interaction: Step 6: Testing and Deployment on Replit Test the Interaction Flow: Deploy on Replit: Step 7: No API Required for Sign Protocol Key Security Practices Summary\nThe entire app\u2014including Admin, Artist, and Attendee roles\u2014operates securely using MetaMask for authentication and blockchain transactions. Hosting on Replit is focused on the front-end, while smart contracts are managed securely using Hardhat and MetaMask to ensure a consistent, user-friendly experience without compromising security.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8tqgc/screenshots/fxwf3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8tqgc/screenshots/ynvg0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8tqgc/screenshots/q5hui/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/devsodhirao/ArtConnectNFT",
        "link": "https://ethglobal.com/showcase/artist-popup-8tqgc"
    },
    {
        "title": "EZLaunch",
        "brief_description": "A platform for launching meme tokens with an innovative trading curve that optimizes liquidity and token price discovery. Users can easily mint and trade meme tokens, while the enhanced curve ensures better liquidity dynamics, fostering a smoother trading experience.",
        "long_description": "Our platform revolutionizes the meme token space by introducing an improved trading curve that outperforms traditional bonding curves. This curve ensures better liquidity management, providing users with an efficient and more balanced token trading experience. Meme token creators can easily launch their tokens, while traders benefit from improved price discovery mechanisms that stabilize market activity. The platform is designed to make token minting and trading accessible and intuitive, catering to the ever-growing meme economy and offering tools to ensure market sustainability. This project was built using Solidity for smart contract development, leveraging the Uniswap v4 framework to implement custom hooks and an enhanced custom trading curve.\nThis curve ensures better liquidity management, providing users with an efficient and more balanced token trading experience. Meme token creators can easily launch their tokens, while traders benefit from improved price discovery mechanisms that stabilize market activity. The platform is designed to make token minting and trading accessible and intuitive, catering to the ever-growing meme economy and offering tools to ensure market sustainability.",
        "how_its_made": "This project was built using Solidity for smart contract development, leveraging the Uniswap v4 framework to implement custom hooks and an enhanced custom trading curve.\nThis curve ensures better liquidity management, providing users with an efficient and more balanced token trading experience. Meme token creators can easily launch their tokens, while traders benefit from improved price discovery mechanisms that stabilize market activity. The platform is designed to make token minting and trading accessible and intuitive, catering to the ever-growing meme economy and offering tools to ensure market sustainability.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/p1gfa/screenshots/aj4rb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/p1gfa/screenshots/nxexn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/p1gfa/screenshots/aknx3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/DMomot/EZLaunch",
        "link": "https://ethglobal.com/showcase/ezlaunch-p1gfa"
    },
    {
        "title": "RPFT",
        "brief_description": "RPFT stands for Royalty Points Fungible Token is like transfer Royaltypoints of one brands to another one",
        "long_description": "the basic idea is to get Brand A and Brand B collab with each other and once they collab the user from Band A and Brand B should be able to transfer Points from one Brand to another one. and user/consumer should be able to use that points to redeem the things which he wants to buy. This Project mostly uses the LayerZero's standards contract since we assumed that different brand might have their own chain some day with RoyaltyPoint in the smartcontract. smartcontract are developed for EVM on solidity and Test on HardHat using LayerZero CLI.\nsince I have used LayerZero technology it gave me so easy and smooth transaction of messages from one Layer to another Layer. with their builtin CLI hardhat testing.",
        "how_its_made": "This Project mostly uses the LayerZero's standards contract since we assumed that different brand might have their own chain some day with RoyaltyPoint in the smartcontract. smartcontract are developed for EVM on solidity and Test on HardHat using LayerZero CLI.\nsince I have used LayerZero technology it gave me so easy and smooth transaction of messages from one Layer to another Layer. with their builtin CLI hardhat testing.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jygem/screenshots/5n7yy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jygem/screenshots/hux8s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jygem/screenshots/0vy6n/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Nishchit-Dev/EthGlobal-RPFT.git",
        "link": "https://ethglobal.com/showcase/rpft-jygem"
    },
    {
        "title": "Earnify",
        "brief_description": "An all-in-one platform that helps aspiring influencers earn instantly by completing brand tasks, while enabling companies to boost engagement and advertise effectively through real people.",
        "long_description": "A comprehensive platform that empowers aspiring influencers to earn instantly by completing tasks for brands, while helping companies boost engagement and promote their projects through real people.\nWe utilize dynamic wallet creation, account abstraction, task verification, and secure data handling to deliver a seamless experience. This project utilizes the dynamic wallet for account abstraction and onboarding new users to web3. We also leverage the LIT protocol for encrypting/decrypting and running verification tasks in LIT actions. The sign protocol is used to attest the verified task and store information. Finally, we utilize the Coinbase developer pack to create an instant payment system for quick payouts.",
        "how_its_made": "This project utilizes the dynamic wallet for account abstraction and onboarding new users to web3. We also leverage the LIT protocol for encrypting/decrypting and running verification tasks in LIT actions. The sign protocol is used to attest the verified task and store information. Finally, we utilize the Coinbase developer pack to create an instant payment system for quick payouts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/nbo5u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/57vuu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/t49qv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/mpwvm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/whj5t/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shubhank-saxena/eth-sf-submission",
        "link": "https://ethglobal.com/showcase/earnify-4hks7"
    },
    {
        "title": "Loop",
        "brief_description": "Loop is an onchain platform for reinforcement learning with human feedback (RLHF)",
        "long_description": "Loop is an onchain platform for reinforcement learning with human feedback (RLHF). Developers or corporate teams can upload models from HuggingFace (by submitting a link) and issue cryptocurrency bounties for crowdsourcing output validation. Users can sign in via web3 wallet (or web2 social platforms) and utilize the chat interface for regular functionality (i.e., writing essays), while being prompted to validate outputs. These prompts thereby disseminate the crypto rewards, effectively creating a Validate-to-Earn model. Subsequently, the prompts, outputs, and users' scores are stored off-chain in a dataset, accessible to the devs/teams behind the associated model. On the front-end, we built a responsive interface using React.js, implementing custom hooks for state management and modular components for content display and user interactions. Tailwind CSS provided a utility-first styling approach that dramatically accelerated our development cycle, while thirdweb's SDK facilitated seamless wallet connections and blockchain interactions across multiple networks. We deployed our front-end to Vercel. The back-end infrastructure centers around Foundry-developed smart contracts, meticulously unit tested and deployed for multi-chain usage. We've successfully deployed these contracts across nine different testnet environments: Polygon, Hedera, Neon EVM, Zircuit, Story, AirDAO, Rootstock, Morph, Unichain, and Story testnets. For AI processing, we leveraged HuggingFace's model hub to deploy both Llama 3.1 8B and Mixtral 8x-7B models, fine-tuned on our custom dataset. We leveraged Prime Intellect for decentralized GPU orchestration, allowing us to run LLM inference across distributed compute providers like Akash and RunPod during preliminary testing. Firebase serves as our human-verified dataset repository, chosen for its real-time database capabilities and seamless integration with our scoring system.",
        "how_its_made": "On the front-end, we built a responsive interface using React.js, implementing custom hooks for state management and modular components for content display and user interactions. Tailwind CSS provided a utility-first styling approach that dramatically accelerated our development cycle, while thirdweb's SDK facilitated seamless wallet connections and blockchain interactions across multiple networks. We deployed our front-end to Vercel. The back-end infrastructure centers around Foundry-developed smart contracts, meticulously unit tested and deployed for multi-chain usage. We've successfully deployed these contracts across nine different testnet environments: Polygon, Hedera, Neon EVM, Zircuit, Story, AirDAO, Rootstock, Morph, Unichain, and Story testnets. For AI processing, we leveraged HuggingFace's model hub to deploy both Llama 3.1 8B and Mixtral 8x-7B models, fine-tuned on our custom dataset. We leveraged Prime Intellect for decentralized GPU orchestration, allowing us to run LLM inference across distributed compute providers like Akash and RunPod during preliminary testing. Firebase serves as our human-verified dataset repository, chosen for its real-time database capabilities and seamless integration with our scoring system.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yjppn/screenshots/z946j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yjppn/screenshots/4yhr2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yjppn/screenshots/j67sm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shreybirmiwal/eth-sf",
        "link": "https://ethglobal.com/showcase/loop-yjppn"
    },
    {
        "title": "splitoon",
        "brief_description": "imagine giving ai access to your venmo account (real) (they could never)",
        "long_description": "imagine: you and your friends go out to eat and near the end, the bill comes. your friends all don't want to front the bill and neither do you. why? it's a hassle, you're out 30 bucks until they venmo you back. even worse, you have to keep reminding them to pay you or you might completely forget that you paid for this meal (unwillingly) and pretend they are on top of things and pay you your share right there and then. venmo will take 3-5 biz days to settle in your bank account as you definitely aren\u2019t paying them 3% to get your funds quicker. screw that. so let\u2019s leverage crypto and base to ensure you get your share of funds right as you spend it. ex: get paid by your friends before your uber gets here or split your dinner bill before the waiter takes your card. we want to empower ai with mpc wallets so that you can enable your favorite ai agent to manage your crypto wallet and send/transfer funds as you need.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/s5j5c/screenshots/vjkgk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s5j5c/screenshots/dmsha/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s5j5c/screenshots/ifg2k/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/mrbrianhobo/splitoon",
        "link": "https://ethglobal.com/showcase/splitoon-s5j5c"
    },
    {
        "title": "SuperTweets",
        "brief_description": "Do Crypto Transactions on your Twitter Feed - Now on any chain!",
        "long_description": "Project Description: This project is designed to tackle one of the most significant barriers to Web3 adoption\u2014its poor user experience. Most decentralized applications (DApps) have interfaces that are difficult and intimidating for everyday users, creating a significant gap between potential users and the opportunities that Web3 can offer. Both creators and consumers miss out on the potential of decentralized technologies because they are restricted to unfamiliar, isolated platforms. Our solution bridges this gap by allowing users to conduct crypto transactions, such as minting NFTs, making wagers, selling assets, and collecting tips, directly on the platforms where they already spend most of their time. This approach minimizes friction, creating a seamless experience by integrating crypto functionalities into familiar environments like their Twitter feed. Meeting Users Where They Are:\nOne of the keys to unlocking mainstream Web3 adoption is integrating it into the platforms where users already spend their time. Most users are not willing to switch between multiple apps or platforms, especially if they don\u2019t understand the complex blockchain processes behind the scenes. Social media, in particular, is a huge untapped frontier for crypto and blockchain adoption. By bringing crypto functionality to popular social platforms like Twitter, users can easily interact with blockchain features in a setting they are already comfortable with, removing the learning curve and making the process as intuitive as possible. This \u201cmeet-the-user-where-they-are\u201d approach will help drive both consumer and creator adoption, allowing them to seamlessly participate in Web3 without needing to leave their everyday platforms. As social media continues to evolve, it represents the next major frontier for Web3 growth, where digital ownership, peer-to-peer transactions, and decentralized assets can thrive naturally. Problem: Web3 has poor UX: Despite its potential, Web3 is hindered by complicated interfaces and systems that deter average users.\nMost DApps are intimidating to use: Decentralized apps often have steep learning curves, which limits their adoption by a broader audience.\nMissed opportunity for creators and consumers: Both groups miss out on the potential of Web3 technologies because the platforms they are familiar with do not support seamless integration of crypto functionalities.\nSolution: Meet the user where they are: Rather than forcing users to navigate entirely new platforms, we enable them to interact with blockchain functionalities on the platforms they already use every day\u2014whether that\u2019s social media, e-commerce, or content creation platforms.\nEnable Crypto transactions effortlessly: Users can easily mint NFTs, make wagers, sell digital assets, or even collect tips without leaving the environment they are comfortable with. This creates a smooth, user-friendly gateway to blockchain technology.\nOne more thing: Solana\u2019s Blinks integration was promising, but limited: Solana\u2019s Blinks allowed for some interaction within its ecosystem, but the limitation was that it only supported Solana, and the ecosystem was very closed. Therefore we built this as an add-on that leverages Blinks\u2019 infrastructure, but instead of being confined to one blockchain, it supports all major chains, creating a truly decentralized and interoperable solution. This enables a much wider range of users to participate, across multiple blockchains, without being restricted by ecosystem boundaries. The core of this project revolves around creating a seamless integration between social media content and blockchain transactions. We built a Chrome extension that interacts directly with the user's Twitter feed. The extension uses the Blinks SDK to dynamically replace standard links within tweets with interactive \"SuperTweets\" that allow users to engage in blockchain-based activities like minting NFTs, tipping creators, and more, all without leaving the platform. When a user wants to conduct a transaction, they can easily connect their wallet through the Wallet Context Providers injected by MetaMask. By leveraging MetaMask\u2019s environment, users gain access to all Ethereum Virtual Machine (EVM) compatible chains, meaning they can interact with a wide variety of blockchains, making it a truly decentralized experience. What\u2019s particularly innovative about this setup is the way we handle the interactions. The Blinks SDK gives us the infrastructure to support a high-speed experience, while the MetaMask integration ensures compatibility with every EVM chain. This combination provides a frictionless and familiar experience for users, allowing them to engage in Web3 activities directly on their Twitter page without needing to jump between different platforms or learn new interfaces. THE HARD PART: Was making MetaMask work with all the chains using the browser inject provider also building multiple actions for every chain!",
        "how_its_made": "The core of this project revolves around creating a seamless integration between social media content and blockchain transactions. We built a Chrome extension that interacts directly with the user's Twitter feed. The extension uses the Blinks SDK to dynamically replace standard links within tweets with interactive \"SuperTweets\" that allow users to engage in blockchain-based activities like minting NFTs, tipping creators, and more, all without leaving the platform. When a user wants to conduct a transaction, they can easily connect their wallet through the Wallet Context Providers injected by MetaMask. By leveraging MetaMask\u2019s environment, users gain access to all Ethereum Virtual Machine (EVM) compatible chains, meaning they can interact with a wide variety of blockchains, making it a truly decentralized experience. What\u2019s particularly innovative about this setup is the way we handle the interactions. The Blinks SDK gives us the infrastructure to support a high-speed experience, while the MetaMask integration ensures compatibility with every EVM chain. This combination provides a frictionless and familiar experience for users, allowing them to engage in Web3 activities directly on their Twitter page without needing to jump between different platforms or learn new interfaces. THE HARD PART: Was making MetaMask work with all the chains using the browser inject provider also building multiple actions for every chain!",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/urhdz/screenshots/5vteo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/urhdz/screenshots/vjcrs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/urhdz/screenshots/v7frg/default.jpg"
        ],
        "live_demo": "https://ethactions.vercel.app/",
        "source_code": "https://github.com/Rishabhjava/ethactions",
        "link": "https://ethglobal.com/showcase/supertweets-urhdz"
    },
    {
        "title": "ReadyVU",
        "brief_description": "SaaS platform for Teleradiology, remote reporting tools for medical Imaging for various stake holders",
        "long_description": "A few emerging tools are trying to offer useful and practical solutions for Radiology houses, Hospitals, etc., who are in real need of Solutions where they can outsource radiology writing expertise to remotely skilled doctors.\nCurrent situation have many urging needs from patients\u2019 point of view;\n1- specialized radiologists exist in specific cities, lowering the quality of healthcare given to people living outside capital cities\n2- cost and time involved by travelling doctors, travelling patients and thier famililes\n3- untimely report writing, you may have you exam performed and then wait a day or two, in many place it can easily get longer\nAlso apparently problem does affect hospital businesses, radiologist looking to work conveniently remotely, and more free market, etc. Challenges;\nPatient Privacy\nRegulations compliance, HIPAA, ONC,\nQA processes involved, insurance requirements\nNo \u201cone size fits all\u201d for workflow models in different business sizes, geographical areas, specialty level etc.\ncloud/on prem restrictions etc.\nIT experitise need to mainatin such systems are not generlly available\nIT expertise needed from health care providers themsleves, doctors, nurses etc.\nLegacy systems, sometimes from the 80s\u2019\nVarying requirements for compensating  and managing workforce , remote freelance payment models, etc.\nNeed to negotiate and setup long list of custom tools for various stakeholders involved\nMedical imaging has its own \u201cfile\u201d formats, for different kinds of modality and usages\nMedical imaging has a protocol not based http, cannot work with most of common software backend stacks directly, DICOM, HL7, IHE profiles etc. Solution\nReadyVU aim to be a decentralized, healthcare compliant platform for doctors to be able to view medical images and write radiology reports remotely,\nOnly Radiology center need to know about crypto or have a special setup - little as it is but still;\nOn Boarding new Doctors does not require them installing any special software, be that for crypto or medical imaging special software Hospital user story;\nHospital sets up it own infrastructure or have it through a certified partner\nHospital sponsors fees, sets up regulatory compliant workflows using standard business process modeling tools\nUpon receiving images for radiology modalities, its routed to preselected / newly certified doctors. Doctor user story;\nReceive shared document link\naccepts , goes to google doc\nSee info as per need basis\nopen medical images from within google doc, again no special software\nLogs in to the viewer using his google login, no browser extension wallets,etc.\nWrites findings, add images and annotations etc.\nSignal finishing the report when done Similar user stories for all other parties involved, no special tools, see info as per need basis.\nSystem is not hardcoded to public clouds, user can move to a fully decentralized self governed experience when he needs to Technology components in action; bmpn.io, Business process standard modeling tools to model and enforce business compliance\nConvert business process model and deploy as a Pint contract to essential network\nDICOM router to receive studies from radiology machines, CTs, PET, MRIs etc.\nHigh scalable PACS system to store images, for short periods, or commonly 5 to  7 years\nSecure function to dispatch workflow upon recieving a patient study, run as a LIT protocol action\nDiffernet google documents are shared from same template, set by various requirements, like dr pref, business, exam type etc.\nUser logs in to Flow network, using his google login, through Dynamic wallet social login\nGoogle docs have embedded scripts to talk to TEE LIT Action, to get information assinged to each individual user\nRadiologist opens CornerStone DICOM viewer, from inside google docs, adds annotations, take images, write findings etc.\nRadiologist finishes\nQA approves doc\nReport is sent to patient and referring doctor\nThe above workflow is enforced from Essential network using Pint contract generated from workflow",
        "how_its_made": "Technology components in action; bmpn.io, Business process standard modeling tools to model and enforce business compliance\nConvert business process model and deploy as a Pint contract to essential network\nDICOM router to receive studies from radiology machines, CTs, PET, MRIs etc.\nHigh scalable PACS system to store images, for short periods, or commonly 5 to  7 years\nSecure function to dispatch workflow upon recieving a patient study, run as a LIT protocol action\nDiffernet google documents are shared from same template, set by various requirements, like dr pref, business, exam type etc.\nUser logs in to Flow network, using his google login, through Dynamic wallet social login\nGoogle docs have embedded scripts to talk to TEE LIT Action, to get information assinged to each individual user\nRadiologist opens CornerStone DICOM viewer, from inside google docs, adds annotations, take images, write findings etc.\nRadiologist finishes\nQA approves doc\nReport is sent to patient and referring doctor\nThe above workflow is enforced from Essential network using Pint contract generated from workflow",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/q3p2s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/vx6x5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/957d6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/tdgnf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/djw30/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/melnaquib/ReadyVU",
        "link": "https://ethglobal.com/showcase/readyvu-yc4hu"
    },
    {
        "title": "GovernEase",
        "brief_description": "GovernEase is a cross-chain DAO tooling platform that simplifies DAO creation. It enables users to configure governance, manage tokens, and select voting methods through a seamless interface, allowing quick and efficient setup across multiple blockchains.",
        "long_description": "GovernEase is an innovative cross-chain DAO tooling platform that simplifies the creation and management of decentralized autonomous organizations (DAOs). Traditionally, setting up a DAO involves a complex process of coding, testing, and deployment. GovernEase streamlines this workflow, allowing users to create a DAO quickly and effortlessly by filling out a user-friendly form. One of the standout features of GovernEase is its support for quadratic voting, a unique governance mechanism that enhances fairness in decision-making by giving members more voting power on issues that matter most to them. This innovative approach fosters more democratic and nuanced governance within the DAO. GovernEase also excels in its cross-chain capabilities, enabling the seamless transfer of DAO data between different blockchains. For example, I successfully managed to send DAO data from the Sepolia testnet to the Polygon Cardano testnet, demonstrating the platform's versatility and interoperability across blockchain ecosystems. In addition to these core features, GovernEase offers various functionalities that enhance user experience and collaboration. DAO members can upload and store files directly within the DAO\u2019s storage, facilitating easy access to important documents and resources. Communication among members is also made simple through an integrated chat feature, promoting engagement and collaboration within the community. Furthermore, GovernEase leverages SKALE's sFuel distribution, allowing for zero gas fee transactions. This ensures that users can interact with the DAO without worrying about transaction costs, making the platform more accessible and user-friendly. Overall, GovernEase stands out not only for its cross-chain capabilities but also for its unique voting mechanism and a comprehensive set of features designed to empower users in managing their DAOs efficiently and effectively. At the heart of GovernEase are two key features: zero gas fee transactions and cross-chain capabilities. By utilizing SKALE, users can engage with the DAO without incurring any gas fees, greatly enhancing both accessibility and user satisfaction. Additionally, I successfully bridged DAO data from the Sepolia testnet to the Polygon Cardano testnet using the Unified Bridge (Agglayer), highlighting the platform\u2019s ability to operate seamlessly across multiple blockchain networks. The project leverages a comprehensive tech stack that ensures smooth functionality and an intuitive user interface: Frontend Development: The user interface for GovernEase is built with Next.js, a powerful React framework that supports server-side rendering and static site generation for optimal performance. To create a sleek and responsive design, I incorporated Chakra UI, a versatile and accessible component library that facilitates rapid UI development. Smart Contract Development: The backbone of GovernEase consists of smart contracts written in Solidity. These contracts are deployed and verified across various testnets, including Sepolia, Polygon Cardano, the EVM Flow testnet, and the SKALE Calypso hub. This multi-network deployment empowers users to interact with the DAO on any of these networks, ensuring flexibility and accessibility. Storage Solutions: For handling images and files uploaded by DAO members, I utilized Lighthouse. This decentralized storage service guarantees that files are stored securely and can be easily accessed by users within the DAO. Blockchain Integration: To seamlessly connect the frontend with the deployed smart contracts, I employed Ether.js and Wagmi. Ether.js offers a robust library for Ethereum blockchain interactions, while Wagmi streamlines the integration of React applications with Ethereum-based smart contracts, simplifying the development process. User Onboarding: To provide a smooth wallet connection experience, I implemented Rainbow Kit. This library makes it easy for users to connect their wallets to the application, which is essential for interacting with the DAO. Enhanced User Features: GovernEase also includes additional functionalities that foster collaboration among DAO members, such as integrated file storage and a chat feature for real-time communication. By combining these technologies and tools, GovernEase presents a powerful, user-friendly platform for creating and managing DAOs. The integration of zero gas fees, cross-chain capabilities, innovative voting mechanisms, and efficient user onboarding solidifies GovernEase as a pioneering solution in the blockchain landscape.",
        "how_its_made": "At the heart of GovernEase are two key features: zero gas fee transactions and cross-chain capabilities. By utilizing SKALE, users can engage with the DAO without incurring any gas fees, greatly enhancing both accessibility and user satisfaction. Additionally, I successfully bridged DAO data from the Sepolia testnet to the Polygon Cardano testnet using the Unified Bridge (Agglayer), highlighting the platform\u2019s ability to operate seamlessly across multiple blockchain networks. The project leverages a comprehensive tech stack that ensures smooth functionality and an intuitive user interface: Frontend Development: The user interface for GovernEase is built with Next.js, a powerful React framework that supports server-side rendering and static site generation for optimal performance. To create a sleek and responsive design, I incorporated Chakra UI, a versatile and accessible component library that facilitates rapid UI development. Smart Contract Development: The backbone of GovernEase consists of smart contracts written in Solidity. These contracts are deployed and verified across various testnets, including Sepolia, Polygon Cardano, the EVM Flow testnet, and the SKALE Calypso hub. This multi-network deployment empowers users to interact with the DAO on any of these networks, ensuring flexibility and accessibility. Storage Solutions: For handling images and files uploaded by DAO members, I utilized Lighthouse. This decentralized storage service guarantees that files are stored securely and can be easily accessed by users within the DAO. Blockchain Integration: To seamlessly connect the frontend with the deployed smart contracts, I employed Ether.js and Wagmi. Ether.js offers a robust library for Ethereum blockchain interactions, while Wagmi streamlines the integration of React applications with Ethereum-based smart contracts, simplifying the development process. User Onboarding: To provide a smooth wallet connection experience, I implemented Rainbow Kit. This library makes it easy for users to connect their wallets to the application, which is essential for interacting with the DAO. Enhanced User Features: GovernEase also includes additional functionalities that foster collaboration among DAO members, such as integrated file storage and a chat feature for real-time communication. By combining these technologies and tools, GovernEase presents a powerful, user-friendly platform for creating and managing DAOs. The integration of zero gas fees, cross-chain capabilities, innovative voting mechanisms, and efficient user onboarding solidifies GovernEase as a pioneering solution in the blockchain landscape.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/k2cc0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/7ofon/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/9cqv0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/zg6td/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/ymyby/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/7zxad/default.jpg"
        ],
        "live_demo": "https://ethsf-seven.vercel.app/",
        "source_code": "https://github.com/Sohamkayal4103/ETHSF",
        "link": "https://ethglobal.com/showcase/governease-17pde"
    },
    {
        "title": "FlowBets",
        "brief_description": "A transparent, crowdsourced sports betting platform on Flow's network utilizing smart contracts",
        "long_description": "This project uses a combination of smart contracts and web2 frontend frameworks to design a onchain betting application that allows users to wage predictions on sports games, specifically football (NFL). We deployed smart contracts on Flow's testnet and enabled wallet integration. Users can also see the average price, their shares, and potential returns per bet. Additionally, we integrated a chatting feature where users on the platform can communicate regarding bets. For this project, we used Solidity smart contracts deployed on Flow's testnet through hardhat. For the frontend, we utilized Next.js with shadcn components and rainbowkit for wallet integration. We used wagmi to connect the backend with the frontend. We implemented the odds by using a crowdsourcing model where the probability of an event happening was equivalent to the amount of money bet for this event. People's willingness to bet on an outcome directly correlates to the odds for that event.",
        "how_its_made": "For this project, we used Solidity smart contracts deployed on Flow's testnet through hardhat. For the frontend, we utilized Next.js with shadcn components and rainbowkit for wallet integration. We used wagmi to connect the backend with the frontend. We implemented the odds by using a crowdsourcing model where the probability of an event happening was equivalent to the amount of money bet for this event. People's willingness to bet on an outcome directly correlates to the odds for that event.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/9gfsz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/uft1h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/bqeag/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shrithan1/betflow",
        "link": "https://ethglobal.com/showcase/flowbets-u48sh"
    },
    {
        "title": "FlowBets",
        "brief_description": "A transparent, crowdsourced sports betting platform on Flow's network utilizing smart contracts",
        "long_description": "This project uses a combination of smart contracts and web2 frontend frameworks to design a onchain betting application that allows users to wage predictions on sports games, specifically football (NFL). We deployed smart contracts on Flow's testnet and enabled wallet integration. Users can also see the average price, their shares, and potential returns per bet. Additionally, we integrated a chatting feature where users on the platform can communicate regarding bets. For this project, we used Solidity smart contracts deployed on Flow's testnet through hardhat. For the frontend, we utilized Next.js with shadcn components and rainbowkit for wallet integration. We used wagmi to connect the backend with the frontend. We implemented the odds by using a crowdsourcing model where the probability of an event happening was equivalent to the amount of money bet for this event. People's willingness to bet on an outcome directly correlates to the odds for that event.",
        "how_its_made": "For this project, we used Solidity smart contracts deployed on Flow's testnet through hardhat. For the frontend, we utilized Next.js with shadcn components and rainbowkit for wallet integration. We used wagmi to connect the backend with the frontend. We implemented the odds by using a crowdsourcing model where the probability of an event happening was equivalent to the amount of money bet for this event. People's willingness to bet on an outcome directly correlates to the odds for that event.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/9gfsz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/uft1h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/bqeag/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shrithan1/betflow",
        "link": "https://ethglobal.com/showcase/flowbets-u48sh"
    },
    {
        "title": "PixelProof",
        "brief_description": "A Web Platform for Image Authenticity Verification Using Zero-Knowledge Proofs",
        "long_description": "In today\u2019s digital world, the ability to create, modify, and distribute visual content has become more accessible than ever. With advancements in artificial intelligence (AI), it\u2019s now possible to manipulate images in ways that are nearly undetectable to the human eye. AI-driven tools like deepfakes, image generators, and sophisticated photo-editing software have made it easy to alter or fabricate images that appear authentic. While these technologies offer creative and practical benefits, they also present serious challenges\u2014especially in terms of trust, authenticity, and misinformation. Also in today\u2019s social media-driven world, digital content spreads faster than ever. Unfortunately, false information and tampered images can go viral just as quickly as the truth. Whether it\u2019s fake news, altered photos of public figures, or images designed to mislead audiences, the potential for misinformation to have real-world consequences is significant. Pixel-Proof is a cutting-edge web platform that leverages zero-knowledge proofs (ZKPs) to allow users to verify the authenticity and integrity of digital images without exposing the actual content of the image. The platform provides a privacy-preserving method for determining whether an image has been modified or tampered with, ensuring users can verify the origin and authenticity of their images securely and efficiently. Using advanced cryptographic techniques, particularly ZKPs, the platform allows users to generate proofs of image integrity, proving whether an image is identical to the original version or has undergone changes\u2014without revealing the image itself. This is particularly useful for industries such as media, law enforcement, content verification, and intellectual property management, where proving image authenticity is crucial. Image Authentication verification\nThe platform allows users to capture the photo, edit the photo at which zkProof will be created which basically attests the photo whether the image was edited or not.\nThe interface has an option to upload the image where users can upload the edited image and verify whether the image was altered or not along with it\u2019s history. Zero-Knowledge Proofs (ZKPs) for Privacy\nBy utilizing ZKPs, the platform proves the integrity of the image without revealing its content to the verifier. This preserves the privacy of sensitive images while enabling secure verification.\nVerifiers can check the proof to validate the authenticity of the image without ever seeing the original image. Seamless Web-Based Interface\nPixelProof offers an intuitive and user-friendly web interface where users can easily upload images, generate proofs, and share the proof for verification. Secure Proof Sharing\nAs proof will be stored on-chain, any user from other chain can do the verification Image Capture\nUsers can capture an image on our platform. This will capture the metadata and allow the user to download that image.\nImage Edit\nUsers can select their captured photo and edit the image accordingly. Currently we have only supported grayscale operation because of the time constraints.\nUsing zero-knowledge proof techniques, proof for that edited image will be generated at the end of edit operation and the cryptographic proof is stored on-chain so anyone can use that proof and verify that image.\nEdited Image Upload\nUsers can upload the edited image to verify whether the image was modified or not. At this moment, proof will be verified against the original image and results will be given to the user. The history for that edited image will also be given to the user.\nAs soon as the proof is validated, the user will be shown the results of the verification and the user can see the series of edits on that original image if it was done on the Pixel-Proof platform. Our project, PixelProof, is a novel application of zero-knowledge proofs to verify various image conversions without revealing the original images. Here's a breakdown of how we built it: Circom: We used Circom, a domain-specific language for building zero-knowledge circuits. Circom allowed us to define the constraints for our grayscale verification process in a clear, declarative manner. snarkjs: This JavaScript library was crucial for generating and verifying zero-knowledge proofs based on our Circom circuits. Node.js: We leveraged Node.js for our backend processing, particularly for generating input data from images. canvas: This Node.js library was essential for image processing, allowing us to extract pixel data from both color and grayscale images. Circom Circuit (no_round.circom`): Input Generator (generate_grayscale_inputs.js): Proof Generation and Verification: Precision Handling: One of the trickiest parts was dealing with floating-point precision in grayscale calculations. We implemented a remainder system in our circuit to account for small discrepancies between calculated and given grayscale values. Scale Matching: We had to carefully manage the scale of our calculations. In the Circom circuit, we work with values scaled up by 100 to avoid floating-point operations, which aren't supported in Circom. Efficient Constraint Writing: Writing efficient constraints in Circom was crucial for keeping the proving time reasonable. We optimized our circuit to minimize the number of constraints while maintaining accuracy. This project demonstrates the powerful combination of zero-knowledge proofs and image processing, opening up new possibilities for privacy-preserving image verification systems.",
        "how_its_made": "Our project, PixelProof, is a novel application of zero-knowledge proofs to verify various image conversions without revealing the original images. Here's a breakdown of how we built it: Circom: We used Circom, a domain-specific language for building zero-knowledge circuits. Circom allowed us to define the constraints for our grayscale verification process in a clear, declarative manner. snarkjs: This JavaScript library was crucial for generating and verifying zero-knowledge proofs based on our Circom circuits. Node.js: We leveraged Node.js for our backend processing, particularly for generating input data from images. canvas: This Node.js library was essential for image processing, allowing us to extract pixel data from both color and grayscale images. Circom Circuit (no_round.circom`): Input Generator (generate_grayscale_inputs.js): Proof Generation and Verification: Precision Handling: One of the trickiest parts was dealing with floating-point precision in grayscale calculations. We implemented a remainder system in our circuit to account for small discrepancies between calculated and given grayscale values. Scale Matching: We had to carefully manage the scale of our calculations. In the Circom circuit, we work with values scaled up by 100 to avoid floating-point operations, which aren't supported in Circom. Efficient Constraint Writing: Writing efficient constraints in Circom was crucial for keeping the proving time reasonable. We optimized our circuit to minimize the number of constraints while maintaining accuracy. This project demonstrates the powerful combination of zero-knowledge proofs and image processing, opening up new possibilities for privacy-preserving image verification systems.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/exdzo/screenshots/vrovk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/exdzo/screenshots/b47u2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/exdzo/screenshots/99sex/default.jpg",
            "https://ethglobal.b-cdn.net/projects/exdzo/screenshots/bnyrs/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shyam-patel-kira/pixelProof",
        "link": "https://ethglobal.com/showcase/pixelproof-exdzo"
    },
    {
        "title": "PintAuction",
        "brief_description": "A Dutch auction platform written in Pint, Essential's DSL for declarative smart contracts, focused on logic rather than execution.",
        "long_description": "A Dutch auction platform written in Pint, Essential's DSL for declarative smart contracts, focused on logic rather than execution. The users can mint new currency, transfer currency via the essential-wallet. The users can create auctions from item_id, owner and initial_cost, since it is a Dutch based auction platform, the right to lower the cost of the auction item depends solely on the owner and owner can use the step-auction using item_id, decrease_amount. Once a bidder places bid higher than the cost of the item, and respective validity constraints meet, the amount is deducted from the bidder, and awarded to the owner and the state changes and new owner of the item becomes the bidder. The auction is also marked as closed and the earliest bidder gets the ownership. The smart contracts are written in Pint, and the CLI is written in rust(taking essential-contributions/token example) as a base. The frontend is written in next.js and there is also a small python server that eases the interaction between the frontend and provides the details of all the items i.e item_id, owner, auction_active status, cost. It is deployed on the test-net \"https://bigbangblock.builders\".",
        "how_its_made": "The smart contracts are written in Pint, and the CLI is written in rust(taking essential-contributions/token example) as a base. The frontend is written in next.js and there is also a small python server that eases the interaction between the frontend and provides the details of all the items i.e item_id, owner, auction_active status, cost. It is deployed on the test-net \"https://bigbangblock.builders\".",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jpwjo/screenshots/acrsa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jpwjo/screenshots/dfujy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jpwjo/screenshots/p9vjy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jpwjo/screenshots/6m4ur/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xn4utilus/PintAuction",
        "link": "https://ethglobal.com/showcase/pintauction-jpwjo"
    },
    {
        "title": "Bet",
        "brief_description": "An accountability app to share goals with your friends. put your money where your mouth is",
        "long_description": "Share your goals with friends and set up a system of accountability. You create a goal and place a financial stake as motivation. If you complete the goal, your friends must attest to your success. If they don\u2019t verify the accomplishment within the set time, you forfeit the stake. This encourages commitment by putting real value on your progress. Whether it's personal or professional, the system ensures you stay motivated, with rewards for follow-through or a financial loss if you don't succeed. This app is developed using Solidity as the primary smart contract language. I had initially planned to integrate Sign Protocol for handling the peer attestations, which would have allowed for decentralized verification of goals and claims. Unfortunately, due to time constraints and the complexity of the integration process, I wasn't able to incorporate it before the deadline. However, adding this feature in the future would greatly enhance the functionality and ensure a more robust and decentralized attestation process.",
        "how_its_made": "This app is developed using Solidity as the primary smart contract language. I had initially planned to integrate Sign Protocol for handling the peer attestations, which would have allowed for decentralized verification of goals and claims. Unfortunately, due to time constraints and the complexity of the integration process, I wasn't able to incorporate it before the deadline. However, adding this feature in the future would greatly enhance the functionality and ensure a more robust and decentralized attestation process.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/nqbcs/screenshots/9wrv2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nqbcs/screenshots/hiu28/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nqbcs/screenshots/zb2gn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/finessevanes/bet",
        "link": "https://ethglobal.com/showcase/bet-nqbcs"
    },
    {
        "title": "Socialfly",
        "brief_description": "A decentralized social app where you store your encrypted data once and then use it across multiple apps",
        "long_description": "This project combines Sign protocol with Lit protocol to create the foundation of a social networking app. Data is encrypted using Lit, and then stored using Sign.  Sign's attestations ensure that a user's data is associated with their account. Sign's schemas and indexing are combined to let us define data in a way that lets us efficiently query for it. The schema is used as the identifier for a certain piece of data that could be used for a social app (example: profile_photo_001, bio_short, location, etc.), and the data can be arbitrary - it can be a photo, some text about a user, or structured data such as a location. Using Lit's access controls, we're able to give specific apps (which are ultimately Lit actions) permission to decrypt our data.  From here the data can be used in creative ways, to demonstrate this I created two basic apps: The first is a centralized messageboard where user's data is just used to gain access to the ability to post on the messageboard, it's fundamentally a centralized service but via reusing a user's profile data it lowers the friction of starting to use the app. The second is a matching app where users can swipe through profiles, and connect with people nearby.  User's encrypted location data is decrypted inside a lit action, and the rest of their profile is only decrypted if they're close enough to the user's location.  The app never has access to user data, it only facilitates making the connections. Lit and Sign are used.  Lit is used for encrypting data, Lit actions are used for decrypting the data, and Sign is used for storing the data.  Sign's schemas are used to represent particular types of data, while Sign's query functionality is used to efficiently access the data that's relevant for a given app. Note that there are actually four repos associated with this project: Repo for creating/managing user account\nhttps://github.com/tms7331/socialfly-account Repo for gating access control based on an IPFS hash\nhttps://github.com/tms7331/socialfly-contracts Repo for example app 1  - public messageboard\nhttps://github.com/tms7331/socialfly-messageboard Repo for example app 2 - privacy preserving networking app\nhttps://github.com/tms7331/socialfly-matching",
        "how_its_made": "Lit and Sign are used.  Lit is used for encrypting data, Lit actions are used for decrypting the data, and Sign is used for storing the data.  Sign's schemas are used to represent particular types of data, while Sign's query functionality is used to efficiently access the data that's relevant for a given app. Note that there are actually four repos associated with this project: Repo for creating/managing user account\nhttps://github.com/tms7331/socialfly-account Repo for gating access control based on an IPFS hash\nhttps://github.com/tms7331/socialfly-contracts Repo for example app 1  - public messageboard\nhttps://github.com/tms7331/socialfly-messageboard Repo for example app 2 - privacy preserving networking app\nhttps://github.com/tms7331/socialfly-matching",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qa3o7/screenshots/a2e8d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qa3o7/screenshots/odyh6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qa3o7/screenshots/cabiq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/tms7331/socialfly-account",
        "link": "https://ethglobal.com/showcase/socialfly-qa3o7"
    },
    {
        "title": "Web3Warfare",
        "brief_description": "An IRL laser tag game with onchain components and fun. Place bounties on adverseries, mint powerup NFTs, and win the space race!",
        "long_description": "Web3Warfare is an immersive, real-life laser tag game that merges physical action with the innovative possibilities of blockchain technology. Players engage in thrilling laser tag battles, equipped with real-world hardware components like laser guns, sensors, and 3D-printed gear. These hardware elements track player performance, hits, and gameplay metrics in real time. What sets Web3Warfare apart is its integration of on-chain components. The game leverages blockchain for player stats, rewards, and progression tracking. Each player's achievements, game results, and in-game assets are stored on-chain, creating a permanent and tamper-proof record of their performance. This also enables players to own unique in-game assets, such as special abilities or gear, represented as NFTs, which can be earned, traded, or sold. The hardware ensures that every shot, hit, and movement in the physical world is accurately reflected in the game's digital ecosystem, combining the excitement of laser tag with the innovation of Web3 technology. How It's Made: Web3Warfare Web3Warfare is built with a blend of blockchain technologies, hardware, and software integration. Here's how it all comes together: Smart Contract Architecture: The game uses a custom-built factory design pattern smart contract, managing duels and payout logic. This contract is deployed across multiple blockchain networks including SKALE, Flow, Zircuit, and Ethereum mainnet. The factory design pattern allows for scalable and efficient deployment of new duels, with automated logic governing payouts and challenge results. Each duel is governed by blockchain rules, ensuring transparency and immutability. Frontend Development: The game's frontend is developed using React, hosted on Vercel for fast deployment and scalability. For user wallet onboarding, Dynamic is used, allowing seamless integration of blockchain wallets directly into the frontend experience. This ensures players can easily manage their on-chain interactions like asset ownership and game data. Hardware Integration: The physical components of Web3Warfare are built around an ESP32 module acting as the brain of each laser blaster. The hardware setup includes a breadboard, infrared LED, and code developed in Arduino IDE to manage the interactions between the laser blasters and the game. Each ESP32 module contains an embedded wallet with the firmware, thanks to Dynamic, which enables direct blockchain interaction from the physical devices. On-Chain Authentication: To guarantee the authenticity of in-game data being written to the blockchain, Web3Warfare uses Sign Protocol's schema hooks. A custom whitelist address contract is implemented, allowing only approved laser blasters to write data. Each laser blaster is whitelisted to ensure only genuine hardware can sign and submit events to the blockchain. Since the ESP32 module serves as a smart wallet, each device is the sole owner of its private key, preventing unauthorized devices from participating. Embedded Wallets & Signing: The ESP32 modules act as both the game\u2019s sensor and its on-chain identity, with embedded wallets stored within the firmware. This design allows each laser blaster to sign blockchain transactions directly, securing game events and ensuring the only valid signing devices are the blasters themselves. By flashing the wallets and private keys onto the hardware, the game eliminates the need for external signing mechanisms. Notable Hacks: One particularly hacky aspect of this project is embedding private key functionality directly into the ESP32 modules, allowing each blaster to function as a fully operational smart wallet. This allows for direct interaction with the blockchain from the physical game world, creating a seamless bridge between the real-world gameplay and on-chain logic.",
        "how_its_made": "How It's Made: Web3Warfare Web3Warfare is built with a blend of blockchain technologies, hardware, and software integration. Here's how it all comes together: Smart Contract Architecture: The game uses a custom-built factory design pattern smart contract, managing duels and payout logic. This contract is deployed across multiple blockchain networks including SKALE, Flow, Zircuit, and Ethereum mainnet. The factory design pattern allows for scalable and efficient deployment of new duels, with automated logic governing payouts and challenge results. Each duel is governed by blockchain rules, ensuring transparency and immutability. Frontend Development: The game's frontend is developed using React, hosted on Vercel for fast deployment and scalability. For user wallet onboarding, Dynamic is used, allowing seamless integration of blockchain wallets directly into the frontend experience. This ensures players can easily manage their on-chain interactions like asset ownership and game data. Hardware Integration: The physical components of Web3Warfare are built around an ESP32 module acting as the brain of each laser blaster. The hardware setup includes a breadboard, infrared LED, and code developed in Arduino IDE to manage the interactions between the laser blasters and the game. Each ESP32 module contains an embedded wallet with the firmware, thanks to Dynamic, which enables direct blockchain interaction from the physical devices. On-Chain Authentication: To guarantee the authenticity of in-game data being written to the blockchain, Web3Warfare uses Sign Protocol's schema hooks. A custom whitelist address contract is implemented, allowing only approved laser blasters to write data. Each laser blaster is whitelisted to ensure only genuine hardware can sign and submit events to the blockchain. Since the ESP32 module serves as a smart wallet, each device is the sole owner of its private key, preventing unauthorized devices from participating. Embedded Wallets & Signing: The ESP32 modules act as both the game\u2019s sensor and its on-chain identity, with embedded wallets stored within the firmware. This design allows each laser blaster to sign blockchain transactions directly, securing game events and ensuring the only valid signing devices are the blasters themselves. By flashing the wallets and private keys onto the hardware, the game eliminates the need for external signing mechanisms. Notable Hacks: One particularly hacky aspect of this project is embedding private key functionality directly into the ESP32 modules, allowing each blaster to function as a fully operational smart wallet. This allows for direct interaction with the blockchain from the physical game world, creating a seamless bridge between the real-world gameplay and on-chain logic.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qq1r9/screenshots/vuzag/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qq1r9/screenshots/5bt1o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qq1r9/screenshots/usg8o/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/pane2004/web3warfare",
        "link": "https://ethglobal.com/showcase/web3warfare-qq1r9"
    },
    {
        "title": "Liquid",
        "brief_description": "A crowd-sourced and incentivised bridging protocol using Layer Zero's OApp interface.",
        "long_description": "Liquid is a crowd-sourced and incentivized bridging protocol using Layer Zero's OApp interface. Users can provide liquidity to the bridge on either side and when their liquidity is used by somebody trying to bridge, they are incentivised for providing liquidity to the protocol. Liquid provides an alternate source of income for yield farming and helps users to de-fragment themselves across chains and get rewarded for the same. It also reduces reliance on institutional run bridges. We made use of Layer Zero's cross-chain messaging protocol (OApp), to send messages across chains. For the MVP we used Morph and Arbitrum Sepolia testnet to deploy our contracts, and one can provide liquidity of USDT on either side and others can use that liquidity to bridge their USDT tokens.",
        "how_its_made": "We made use of Layer Zero's cross-chain messaging protocol (OApp), to send messages across chains. For the MVP we used Morph and Arbitrum Sepolia testnet to deploy our contracts, and one can provide liquidity of USDT on either side and others can use that liquidity to bridge their USDT tokens.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yo7bg/screenshots/7d6n6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yo7bg/screenshots/exy4h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yo7bg/screenshots/c6t27/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/arvindkalra/SmartBridge",
        "link": "https://ethglobal.com/showcase/liquid-yo7bg"
    },
    {
        "title": "AI Fans",
        "brief_description": "An AI x Crypto OnlyFans. Uses Generative AI to create text responses and Images for the AI avatars, and faciiltates onchain transactions done by users and agents.",
        "long_description": "This projects combines the technologies of AI and crypto to create a user experience similar to OnlyFans. The idea of the project is to enable users to create their own AI partners, with each partner having control of their own wallet. This means that users can create their partners, but anyone can chat with them, and they are able to make their own decisions and transact onchain. The project uses XMTP, Walrus, and Phala at its core to power the user interface, storage, and security respectively. XMTP allows users to easily chat with their AI partners, tip them, perform onchain transactions all within one interface. Walrus is used directly in the solidity code, as each AI avatar is given a Soulbound NFT, in which the imageUri is actually a blob on walrus. In addition, the actual walrus site is stored onchain, linking the agent to their respective walrus site. Phala is used on the backend with docker to enable a trustless system where AI agents can be created at runtime. Each agent has their own wallet that is deterministic, enabling these agents to transact onchain. This is also done through a trustless manner, as all backend code is secured by TRS and execution is done within TEEs.",
        "how_its_made": "The project uses XMTP, Walrus, and Phala at its core to power the user interface, storage, and security respectively. XMTP allows users to easily chat with their AI partners, tip them, perform onchain transactions all within one interface. Walrus is used directly in the solidity code, as each AI avatar is given a Soulbound NFT, in which the imageUri is actually a blob on walrus. In addition, the actual walrus site is stored onchain, linking the agent to their respective walrus site. Phala is used on the backend with docker to enable a trustless system where AI agents can be created at runtime. Each agent has their own wallet that is deterministic, enabling these agents to transact onchain. This is also done through a trustless manner, as all backend code is secured by TRS and execution is done within TEEs.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/k8x9r/screenshots/aoezm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k8x9r/screenshots/47dk8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k8x9r/screenshots/d36qb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k8x9r/screenshots/08g90/default.jpg"
        ],
        "live_demo": "https://ai-fans.vercel.app",
        "source_code": "https://github.com/RevanthGundala/AIFans",
        "link": "https://ethglobal.com/showcase/ai-fans-k8x9r"
    },
    {
        "title": "AutoWebChain",
        "brief_description": "decentralised fine tuning of web agents and rag on chain, using lit and walrus",
        "long_description": "Websites are considered out-of-distribution data for LLMs, meaning they aren't naturally optimized to handle such content efficiently. While LLMs can navigate websites, their performance could greatly improve with specialized fine-tuning. During our work, we managed to integrate support for models like 4o-mini, SLMs (which we later removed for performance reasons), and LLama 3.2 B. Additionally, we explored optimizations for better handling of web data and improving interaction across various web environments. We utilized Walrus to simulate the addition of model weights into a network for efficient storage and retrieval as blobs. This allowed users to download these blobs and run the models directly, enabling them to automate tasks in their browsers. The automation was based on a simplified DOM model inspired by Taxy AI's implementation, making it more user-friendly and streamlined for common web interactions. Throughout this process, we added support for models like 4o-mini, SLMs (which we later phased out for performance reasons), and LLama 3.2 B. Though the latter models were eventually removed, their integration provided valuable insights into handling model storage and execution. Additionally, we enhanced the compatibility between model blobs and browser automations, improving overall flexibility and performance for end users.",
        "how_its_made": "We utilized Walrus to simulate the addition of model weights into a network for efficient storage and retrieval as blobs. This allowed users to download these blobs and run the models directly, enabling them to automate tasks in their browsers. The automation was based on a simplified DOM model inspired by Taxy AI's implementation, making it more user-friendly and streamlined for common web interactions. Throughout this process, we added support for models like 4o-mini, SLMs (which we later phased out for performance reasons), and LLama 3.2 B. Though the latter models were eventually removed, their integration provided valuable insights into handling model storage and execution. Additionally, we enhanced the compatibility between model blobs and browser automations, improving overall flexibility and performance for end users.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8jbmi/screenshots/v3a9i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jbmi/screenshots/tknn4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jbmi/screenshots/juobq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/EladWarshawsky/browser-extension",
        "link": "https://ethglobal.com/showcase/autowebchain-8jbmi"
    },
    {
        "title": "Gains Gladiator",
        "brief_description": "Gains Gladiator is an AI agent tournament simulator. It pits two AI's against each other in a battle to the riches!",
        "long_description": "The project uses LLM AI agents to power the reasoning and decision making behind the trading bots. Additionally, the project has a marketplace where user's can buy, sell, or lend their prompts behind their agents. The project also features a bridge for the Agents to use in their investing that relies upon Lit Network for trust less swap of assets on either chain.  The project also has a prediction market where user's can bet on which gladiator that they believe will win the competition. The project also makes use of Lit protocol for the trust-less execution of cross chain swaps. These work by creating a programmable key pair on each chain that waits until both assets on each chain have been received. When they are received then the lit action can be executed which produces the signed transactions that complete the transfers on both chains. The protocol also makes use of Story Network for the management of the data relevant towards the agents. The prompts that each AI agent has is first registered as an NFT and then onto Story. After the IP is created, then another user is able to mint a license token which they can use to then implement a copy or they can use a derivative to create their own agent. The royalties module was also configured so that the initial creator could receive rewards. A simple lending system was also built on top of this that allowed for a license token holder to lend their license out to any other user.\nThe prediction market was custom made and deployed to Flow Blockchain, where we used the advantage of them being a consumer focused app.",
        "how_its_made": "The project also makes use of Lit protocol for the trust-less execution of cross chain swaps. These work by creating a programmable key pair on each chain that waits until both assets on each chain have been received. When they are received then the lit action can be executed which produces the signed transactions that complete the transfers on both chains. The protocol also makes use of Story Network for the management of the data relevant towards the agents. The prompts that each AI agent has is first registered as an NFT and then onto Story. After the IP is created, then another user is able to mint a license token which they can use to then implement a copy or they can use a derivative to create their own agent. The royalties module was also configured so that the initial creator could receive rewards. A simple lending system was also built on top of this that allowed for a license token holder to lend their license out to any other user.\nThe prediction market was custom made and deployed to Flow Blockchain, where we used the advantage of them being a consumer focused app.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/qxbtc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/r3ugn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/jpmio/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/j386u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/izksw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/m5rg8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Gnome101/GainsGladiatorD",
        "link": "https://ethglobal.com/showcase/gains-gladiator-qvbnj"
    },
    {
        "title": "Fuse",
        "brief_description": "Infinite crafting game using GenAI and awarding NFTs, this game involves combining concepts and exploring what they might create",
        "long_description": "Craft to explore what is possible! Combining concepts with GenAI you'll get NFTs for new pairs that haven't been discovered. In Fuse, you'll combine words to create new ones, like water and fire making steam together. The catch is that these are generated by an LLM, so it is infinite! Compete with others to be the first to discover a new pair, and get an NFT for it! We're storing NFT metadata in Walrus, a decentralized storage service. For signup we're using Dynamic, to lower the barrier for new crypto users. On the web2 side of things, we have a backend using FastAPI that calls OpenAI with our custom agent instructions to generate both a new concept and choose a matching emoji. We have fun optimizations to run background tasks that keep the experience snappier, like uploading to Walrus. We also keep a PostgresDB database to keep track of our Walrus blob ids and some user session data. On the frontend we have Next.js and React, using Dynamic for login and signup",
        "how_its_made": "We're storing NFT metadata in Walrus, a decentralized storage service. For signup we're using Dynamic, to lower the barrier for new crypto users. On the web2 side of things, we have a backend using FastAPI that calls OpenAI with our custom agent instructions to generate both a new concept and choose a matching emoji. We have fun optimizations to run background tasks that keep the experience snappier, like uploading to Walrus. We also keep a PostgresDB database to keep track of our Walrus blob ids and some user session data. On the frontend we have Next.js and React, using Dynamic for login and signup",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5wsiz/screenshots/jjf6z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5wsiz/screenshots/cjuqv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5wsiz/screenshots/mx06c/default.jpg"
        ],
        "live_demo": "https://fuse-flax.vercel.app/",
        "source_code": "https://github.com/DiegoJRR/fuse",
        "link": "https://ethglobal.com/showcase/fuse-5wsiz"
    },
    {
        "title": "Photo-Danksharding",
        "brief_description": "Instagram, but the photos are in EIP-4844 blobs. Ephemeral on-chain social.",
        "long_description": "Social media doesn't need to be permanent! Blobs are a great way to have data available for a known period of time while automatically expiring. Gas fees would be paid by advertisers, who contribute funds to a FIFO queue, and have their logo displayed while they're at the top of the queue. Also, L2's are too cheap, and this helps fix that :) Alchemy Account Kit v4 for user wallet creation. Viem for on-chain interactions. Next.js frontend eployed to Vercel and leveraging Vercel KV for Redis caching of available posts on-chain. Explored using thirdweb engine for the backend wallet to submit the blob transactions, but found that the only efficient way to move forward was a private key in my env vars \ud83e\udd74",
        "how_its_made": "Alchemy Account Kit v4 for user wallet creation. Viem for on-chain interactions. Next.js frontend eployed to Vercel and leveraging Vercel KV for Redis caching of available posts on-chain. Explored using thirdweb engine for the backend wallet to submit the blob transactions, but found that the only efficient way to move forward was a private key in my env vars \ud83e\udd74",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/zurt2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/wsxmy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/jiekz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/ggky4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/q835w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/7rrqa/default.jpg"
        ],
        "live_demo": "https://photo-danksharding.vercel.app/",
        "source_code": "https://github.com/0xPenryn/photo-danksharding",
        "link": "https://ethglobal.com/showcase/photo-danksharding-11yph"
    },
    {
        "title": "MySFGame",
        "brief_description": "A simple, browser-based game where players s navigate through a foggy San Francisco, collecting and trading NFTs",
        "long_description": "This is a simple browser-based game that uniquely blends the elements of San Francisco with blockchain technology. Players navigate a stylized, fog-covered San Francisco cityscape as a customizable pixelated cable car, their goal being to collect valuable, city-themed NFTs such as the Golden Gate Bridge, Painted Ladies, and sourdough bread. The game's core mechanic revolves around using \"Fog Coins,\" the in-game cryptocurrency, to disperse the virtual fog and reveal hidden NFTs. As players accumulate these digital assets, they can engage in peer-to-peer trading using smart contracts on the game's simplified blockchain. The gameplay loop is enriched by San Francisco-themed quests, which not only provide players with additional Fog Coins but are also recorded as transactions on the blockchain. A blockchain-based leaderboard adds a competitive element, ranking players based on their NFT collection's value. This game concept not only serves as an entertaining introduction to blockchain technology and NFTs but also captures the essence of San Francisco's tech-forward culture and iconic landmarks in a playful, accessible format. I've created a basic implementation of the CryptoFog game using HTML, CSS, and JavaScript. This version includes the following features: A 5x5 grid representing the foggy San Francisco map.\nFog Coins that decrease when revealing cells.\nRandom placement of San Francisco-themed NFTs (represented by emojis).\nA counter for collected NFTs. This implementation is a simplified version and doesn't include all the features mentioned in the original concept, such as trading NFTs or a full blockchain integration. However, it demonstrates the core gameplay loop and can serve as a starting point for further development.",
        "how_its_made": "I've created a basic implementation of the CryptoFog game using HTML, CSS, and JavaScript. This version includes the following features: A 5x5 grid representing the foggy San Francisco map.\nFog Coins that decrease when revealing cells.\nRandom placement of San Francisco-themed NFTs (represented by emojis).\nA counter for collected NFTs. This implementation is a simplified version and doesn't include all the features mentioned in the original concept, such as trading NFTs or a full blockchain integration. However, it demonstrates the core gameplay loop and can serve as a starting point for further development.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fsd4k/screenshots/53qcc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fsd4k/screenshots/n1ysq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fsd4k/screenshots/wpuxm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/xinsianna/ethsf",
        "link": "https://ethglobal.com/showcase/mysfgame-fsd4k"
    },
    {
        "title": "Roblox Coin Exchange",
        "brief_description": "Enabling Roblox's 300 million (MAUs) to create, buy, and sell meme coins using bonding curves.",
        "long_description": "This project is designed to enable Roblox's 300 million monthly active users (MAU) to create, buy, and sell meme coins through a system that integrates bonding curves, which determine the price of the coins based on supply and demand. The project introduces several key features, including the creation of a Multi-Party Computation (MPC) wallet for each user. This MPC wallet is essential for securely managing users' cryptocurrency transactions and their interactions with the meme coins they create. We used the Coinbase Developer Platform and Coinbase SDK to manage wallets and facilitate meme coin transactions across Base, Polygon, and Flow blockchains. We built a custom ERC20-based bonding curve smart contract to control token prices based on supply and demand. For the game, we used Roblox Studio to create the user interface and integrate meme coins into the Roblox ecosystem. The backend was developed with NestJS for server logic and MongoDB for handling user data and transaction history. One hacky aspect was integrating real crypto transactions with Roblox gameplay, syncing blockchain and in-game interactions smoothly using Coinbase\u2019s SDK and bonding curve contracts.",
        "how_its_made": "We used the Coinbase Developer Platform and Coinbase SDK to manage wallets and facilitate meme coin transactions across Base, Polygon, and Flow blockchains. We built a custom ERC20-based bonding curve smart contract to control token prices based on supply and demand. For the game, we used Roblox Studio to create the user interface and integrate meme coins into the Roblox ecosystem. The backend was developed with NestJS for server logic and MongoDB for handling user data and transaction history. One hacky aspect was integrating real crypto transactions with Roblox gameplay, syncing blockchain and in-game interactions smoothly using Coinbase\u2019s SDK and bonding curve contracts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/nytuo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/ibrkx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/x0z88/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/rc2vk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/dpewj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/a0f53/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/iganbold/roblox-memecoin",
        "link": "https://ethglobal.com/showcase/roblox-coin-exchange-833sq"
    },
    {
        "title": "Intellijack",
        "brief_description": "AI Oracle on Fhenix enabling inference over private data to go on chain. Demonstrated application of an agent and data economy",
        "long_description": "Intellijack is an AI oracle framework for managing and monetizing AI agents and datasets using blockchain technology. The core of the project is a the oracle service that has been adapted from Galadriel's oracle system. However, rather than relying on a single payee for the AI API calls, Lit Protocol's open and secure platform enables self payment. In addition, since we are deployed on Fhenix we can retrieve private data and inference over it with the output from the call going on chain. This opens up a vast frontier of applications. The purpose of Intellijack GPT's is to enable a decentralized marketplace for AI agents and datasets. It allows creators to: The system also includes mechanisms for: The use of blockchain technology provides transparency, immutability, and decentralized control over these AI assets. The integration with AI services allows for dynamic interaction with the AI agents. This project could be particularly useful in scenarios where AI model ownership, licensing, and fair compensation are important, such as in collaborative AI development or AI-as-a-service marketplaces. The oracle system can work on any chain and could potentially be developed into a massively multichain and super scalable oracle service I first got started with Lit Protocol, and eventually decided on using Lit rather than Blockless. Some guy handed out free AI calls on Redpill which was super clutch. I worked all night on Friday and by noon Saturday I had set up the oracle service on Fhenix. After that, I wasn't totally sure what to do next so I ideated but eventually just settled on trying to do something like OpenAI's GPT's with Story protocol.\nThe coolest most hacky thing about the project to me is that I can store API keys and wallet seed phrase on Lit and run the oracle without exposing that information.",
        "how_its_made": "I first got started with Lit Protocol, and eventually decided on using Lit rather than Blockless. Some guy handed out free AI calls on Redpill which was super clutch. I worked all night on Friday and by noon Saturday I had set up the oracle service on Fhenix. After that, I wasn't totally sure what to do next so I ideated but eventually just settled on trying to do something like OpenAI's GPT's with Story protocol.\nThe coolest most hacky thing about the project to me is that I can store API keys and wallet seed phrase on Lit and run the oracle without exposing that information.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/75p06/screenshots/3okjx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/75p06/screenshots/rd932/default.jpg",
            "https://ethglobal.b-cdn.net/projects/75p06/screenshots/1o67i/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/madschristensen99/intellijack/",
        "link": "https://ethglobal.com/showcase/intellijack-75p06"
    },
    {
        "title": "ChainSplash",
        "brief_description": "ChainSplash revolutionizes charitable giving using blockchain. We ensure transparency, efficiency, and privacy in donations through smart contracts, NFTs, and zero-knowledge proofs. Empower trust in global giving with real-time tracking and reduced overhead costs.",
        "long_description": "ChainSplash is a blockchain-based donation platform that aims to revolutionize the NGO sector. Key features include: Transparency: All transactions are recorded on public blockchains.\nEfficiency: Smart contracts enable instant transactions, reducing overhead costs.\nPrivacy: Donors have the option to remain anonymous through zero-knowledge proofs.\nReal-time tracking: Donors can track their contributions as they flow through the system.\nNFT integration: When projects reach 100% funding, smart contracts generate NFTs for NGOs, which can be exchanged for physical goods. The platform allows donors to contribute to various NGO projects using cryptocurrency, addressing issues of trust and fraud in charitable giving. ChainSplash builds on successes like UNICEF's CryptoFund and the World Food Programme's blockchain initiative, offering a scalable solution for NGOs of all sizes. ChainSplash leverages several technologies: Frontend: Next.js, heavily inspired by NousDAO's community-driven approach.\nBackend: SQLite and Python, deployed on Polygon blockchain.\nSmart contracts: Developed using Solidity.\nPrivacy: Implemented zero-knowledge proofs (ZKP) for donor anonymity.",
        "how_its_made": "ChainSplash leverages several technologies: Frontend: Next.js, heavily inspired by NousDAO's community-driven approach.\nBackend: SQLite and Python, deployed on Polygon blockchain.\nSmart contracts: Developed using Solidity.\nPrivacy: Implemented zero-knowledge proofs (ZKP) for donor anonymity.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/m5db8/screenshots/g8e5j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m5db8/screenshots/i9ru9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m5db8/screenshots/5kcvq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/twliu-dorian/ethglobal-sf-hackathon.git",
        "link": "https://ethglobal.com/showcase/chainsplash-m5db8"
    },
    {
        "title": "DeForms",
        "brief_description": "Buy, sell and trade datasets as tokens to boost it's credibility, tracking ownership starting with survey data today",
        "long_description": "Problem:\nTrust and Data Ownership: Traditional marketplaces require users to trust a central authority with their data.\nData Quality and Authenticity: Ensuring the quality and provenance of data is challenging.\nPricing and Value Assessment: Data is difficult to price, and its value varies greatly depending on use case.\nInefficient Transactions: Traditional marketplaces involve intermediaries, leading to higher costs and slower processes.\nLimited Access and Control: Users often have limited control over their data and how it's used.\nData Silos: Lack of interoperability between different data sources and platforms.\nSolution:\nDecentralization and Smart Contracts:\nEliminates the need for a central authority, enhancing trust and transparency.\nAutomates transactions and licensing through smart contracts, reducing intermediaries.\nTokenization of Datasets:\nRepresents datasets as unique tokens (NFTs), allowing for clear ownership and provenance tracking.\nEnables fractional ownership, making valuable datasets more accessible. We are deploying this on @rootstock to leverage both BTC and ETH network in-case of staking powers in the future. We are using @privy for account abstraction that enables smooth onboarding for crypto and non-crypto users (facing one obstacle) Integration and Interaction:\nUser Interface: Built with React, providing a dynamic, responsive interface.\nBlockchain Interaction: Ether.js facilitates communication between the frontend and the Ethereum blockchain, enabling seamless smart contract interaction and wallet integration.\nSmart Contracts: Solidity contracts handle core business logic, including minting DataTokens, managing listings, and facilitating transactions.\nDeployment: Contracts are deployed on Rootstock, leveraging Bitcoin network interoperability while utilizing Ethereum's smart contract functionality. Stack used: React, Supabase, Rootstock, Privy SDK",
        "how_its_made": "We are deploying this on @rootstock to leverage both BTC and ETH network in-case of staking powers in the future. We are using @privy for account abstraction that enables smooth onboarding for crypto and non-crypto users (facing one obstacle) Integration and Interaction:\nUser Interface: Built with React, providing a dynamic, responsive interface.\nBlockchain Interaction: Ether.js facilitates communication between the frontend and the Ethereum blockchain, enabling seamless smart contract interaction and wallet integration.\nSmart Contracts: Solidity contracts handle core business logic, including minting DataTokens, managing listings, and facilitating transactions.\nDeployment: Contracts are deployed on Rootstock, leveraging Bitcoin network interoperability while utilizing Ethereum's smart contract functionality. Stack used: React, Supabase, Rootstock, Privy SDK",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/2cheu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/hzdni/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/mw2y4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/z5a6z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/18jw6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/72a41/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Kashyab19/deforms-ethglobal-sf-2024",
        "link": "https://ethglobal.com/showcase/deforms-a8jbh"
    },
    {
        "title": "ConversationStation",
        "brief_description": "Novel agent chat interface lets users interact with their autonomous agents",
        "long_description": "We\u2019ve developed an innovative agent chat interface that enables users to interact with and monitor their autonomous agents in real-time. This project leverages Large Language Models (LLM) and XMTP to create a seamless user interface for querying and commanding agents. Users can ask questions like \u201cWhat are you built to do?\u201d and the agent will summarize its skills, or ask \u201cWhat state are you in?\u201d for real-time updates. Users can even prompt actions such as \u201cchange parameter X to Y,\u201d and the agent will modify parameters on the fly. Agents can be customized with distinct personalities and deliver unprompted updates based on specific triggers. A mobile app consolidates all messages and updates from connected agents in one place. By leveraging XMTP, agents can also broadcast updates across multiple social channels, ensuring that critical information reaches users wherever they are. As autonomous agents become more essential for tasks like trading, selling, gathering information, and developing new actions, our project bridges the gap, enabling smooth interaction between humans and agents. This chat interface will be key in the evolving landscape of human-agent collaboration. We built this project using the Autonolas framework, which provided the foundation for our agent-based services. The architecture revolves around a set of core skill\u2014 Chit_chat \u2014 running as individual or multi-agent services that communicate and interact within an agent-economy. The chat skill integrates LLMs and XMTP: this allows us to bring together a decentralised chat interface for interacting with users, and LLMs which provide context-aware responses. Technologies Used:",
        "how_its_made": "We built this project using the Autonolas framework, which provided the foundation for our agent-based services. The architecture revolves around a set of core skill\u2014 Chit_chat \u2014 running as individual or multi-agent services that communicate and interact within an agent-economy. The chat skill integrates LLMs and XMTP: this allows us to bring together a decentralised chat interface for interacting with users, and LLMs which provide context-aware responses. Technologies Used:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mnhr4/screenshots/2z5o5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnhr4/screenshots/k5d1r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnhr4/screenshots/y7wd6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnhr4/screenshots/bkgso/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/xiuxiuxar/conversation_station/",
        "link": "https://ethglobal.com/showcase/conversationstation-mnhr4"
    },
    {
        "title": "Plutus",
        "brief_description": "Plutus is financial assistant that can help you with managing money, boosting credit score and paying off debts with lowest interests.",
        "long_description": "Our financial management app integrates with Plaid to provide users with real-time insights into their financial data, such as credit card history, bank balances, and more. The app analyzes this data to help users make informed financial decisions, like whether they can afford large purchases or how to maintain a strong credit score. If users are short on funds, the app seamlessly connects them to decentralized lending pools, such as Aave, enabling them to access loans and pay off debts or complete transactions. Key Features: Tech Stack: Our app bridges the gap between traditional finance and decentralized finance, empowering users to take control of their financial future. Project Build: We built a financial management app that connects traditional and decentralized finance using the following stack: Frontend (React): Provides a clean and intuitive interface for users to view and manage their financial data, including credit card history and bank balances. We used React hooks to manage state and ensure seamless navigation. Plaid Integration: We used Plaid to securely access real-time financial data, such as credit card transactions and bank balances. This allows users to make informed decisions, like whether they can afford large purchases or need to borrow funds. Web3 Tools: Smart Contract Development: We developed custom smart contracts to interact with Aave, enabling users to borrow funds when needed and track repayments. Contracts also handle decision-making logic, such as suggesting loans when funds are insufficient. Hacky Bits: We implemented an encryption layer using Fhenix, ensuring that all sensitive financial data is encrypted before any analysis or blockchain interaction. This keeps user data private while integrating seamlessly with both traditional and decentralized finance. By bridging traditional finance data (Plaid) and DeFi (Aave), our app allows users to move smoothly between fiat and crypto environments, providing a powerful financial management tool.",
        "how_its_made": "Project Build: We built a financial management app that connects traditional and decentralized finance using the following stack: Frontend (React): Provides a clean and intuitive interface for users to view and manage their financial data, including credit card history and bank balances. We used React hooks to manage state and ensure seamless navigation. Plaid Integration: We used Plaid to securely access real-time financial data, such as credit card transactions and bank balances. This allows users to make informed decisions, like whether they can afford large purchases or need to borrow funds. Web3 Tools: Smart Contract Development: We developed custom smart contracts to interact with Aave, enabling users to borrow funds when needed and track repayments. Contracts also handle decision-making logic, such as suggesting loans when funds are insufficient. Hacky Bits: We implemented an encryption layer using Fhenix, ensuring that all sensitive financial data is encrypted before any analysis or blockchain interaction. This keeps user data private while integrating seamlessly with both traditional and decentralized finance. By bridging traditional finance data (Plaid) and DeFi (Aave), our app allows users to move smoothly between fiat and crypto environments, providing a powerful financial management tool.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/fe70s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/i2zyb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/myuge/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/wbdd1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/0cndn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/r638r/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/bunsamosa/plutus",
        "link": "https://ethglobal.com/showcase/plutus-mtwx0"
    },
    {
        "title": "Lit Data Market",
        "brief_description": "Marketplace for data vendors and inference vendors. Run AI inference on any data vendor with your choice of open source models, without knowing the data.",
        "long_description": "Marketplace for data vendors and inference vendors. Run AI inference on any data vendor with your choice of open source models. Data vendors don't need to give up their data, since it's passed to specific inference models and vendors through secure Lit actions. -data vendors can better monetize their data (users don't get all the data) -data privacy; users can run queries on data without all the data -unlocks data from inference Example is Linkedin. Linkedin doesn't want to give up their entire database. Users don't want to be restricted to Linkedin search. Lit Data Marketplace allows users to run Llama 3.2, etc on Linkedin data without getting Linkedin data.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/v2ms0/screenshots/58fgg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v2ms0/screenshots/7vh74/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v2ms0/screenshots/k5siv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v2ms0/screenshots/x9ftn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/financegeek-org/ethsf2024",
        "link": "https://ethglobal.com/showcase/lit-data-market-v2ms0"
    },
    {
        "title": "FriendlyIntent",
        "brief_description": "Intent bridging, but only your friends can fill them! No more whitelisted market makers. You pick who can fill your intent!",
        "long_description": "For a user that doesn't care about being instantly filled (can take their time) and wants to share the intent with their friends rather than market makers, introducing FriendlyIntent! Why let market makers have all the fun? Only let your friends fill your intents, by first encrypting the intent, then giving your friends the decryption key! I spent a stupid amount of time debugging my Stackr rollup so I apologize for the lack of progress.\nI envisioned allowing the User encrypt using Lit Protocol, then put the encrypted intent on a stackr (using Avail) chain. Then, LayerZero would propagate the intent to other chains (using the initial chain as a hub in a hub and spoke model)\nThe decryption key would be sent to friends via a message group or broadcast.\nThen, any user can decrypt the intent on chain and fulfil it. I only really got to launching the group chat built with message kit and the stackr rollup because I spent waaaay too long on dumb bugs on the stackr rollup.",
        "how_its_made": "I spent a stupid amount of time debugging my Stackr rollup so I apologize for the lack of progress.\nI envisioned allowing the User encrypt using Lit Protocol, then put the encrypted intent on a stackr (using Avail) chain. Then, LayerZero would propagate the intent to other chains (using the initial chain as a hub in a hub and spoke model)\nThe decryption key would be sent to friends via a message group or broadcast.\nThen, any user can decrypt the intent on chain and fulfil it. I only really got to launching the group chat built with message kit and the stackr rollup because I spent waaaay too long on dumb bugs on the stackr rollup.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ipu74/screenshots/g2txt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ipu74/screenshots/zzc6g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ipu74/screenshots/ttsfp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Zeebradoom/testtt",
        "link": "https://ethglobal.com/showcase/friendlyintent-ipu74"
    },
    {
        "title": "VVLDrizzy",
        "brief_description": "Mint, watermark, license, and protect your viral short form videos. Get paid by media outlets on your terms. Powered by Story Protocol, Walrus.",
        "long_description": "VVLDrizzy (Viral Video Licensor) aims to make it easy for both content creators and media outlets to get paid for or pay to license video content, helping bridge the legacy media outlets' Web3 adoption gap. As a content creator: As a media agency: VVLDrizzy was part-inspired by my friend, PK, who was riding the TTC (Toronto's subway - hence Drizzy) when he filmed a section of the train with a broken window, popping his phone out the windowsill to show the danger. His video went semi-viral (127K views) after he uploaded it to TikTok, and was contacted by multiple news outlets to show it on live news. It was stolen and reuploaded a few times without permission too.\nHe didn't make any money from it, but now with VVLDrizzy, he easily could have set his own licensing terms and prevented it from being stolen without attribution and earned some money. Features: Inspiration for the name: https://youtu.be/AF2MqFnPotc?feature=shared Stack: Notable hacks:\nOne notable hack I pulled off was the client-side watermarking. Typically, video processing is done server-side, but by using WASM and FFmpeg, I was able to process videos directly in the user's browser, preventing the user from needing to send their video to a third-party server for processing, reducing server costs and keeping video ownership fully on the client side, creating a decentralized-first approach. Another hacky thing I did was leverage the IPA hash from the Story license to store the blob id of the video on Walrus to be used later when the video is retrieved after licensing, creating a single-source-of-truth to reduce the friction of content licensing. This combination of technologies made VVLDrizzy a seamless and decentralized solution for both content creators and media organizations.",
        "how_its_made": "Stack: Notable hacks:\nOne notable hack I pulled off was the client-side watermarking. Typically, video processing is done server-side, but by using WASM and FFmpeg, I was able to process videos directly in the user's browser, preventing the user from needing to send their video to a third-party server for processing, reducing server costs and keeping video ownership fully on the client side, creating a decentralized-first approach. Another hacky thing I did was leverage the IPA hash from the Story license to store the blob id of the video on Walrus to be used later when the video is retrieved after licensing, creating a single-source-of-truth to reduce the friction of content licensing. This combination of technologies made VVLDrizzy a seamless and decentralized solution for both content creators and media organizations.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/socxw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/1qced/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/eip9h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/yahk2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/a7a8f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/b90qk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/dynamicduho/ETHGlobalSF-VVLDrizzy",
        "link": "https://ethglobal.com/showcase/vvldrizzy-he09i"
    },
    {
        "title": "DMNO - PKP secrets",
        "brief_description": "dmno.dev plugin - encrypted secrets using a PKP gated by Github auth + teams",
        "long_description": "This hackathon project is a web3-related plugin for an existing open source devtool called  DMNO (https://dmno.dev) - of which I am the creator. So first some context: DMNO is a powerful tool for managing configuration and secrets that aims to solve all the common paper-cuts of dealing with config. Aside from validation, coercion, type-safety, composability, and leak prevention, sensitive values can be pulled from various backends using plugins. Currently there are plugins to store secrets in an encrypted file within your repo, 1password, and more (ex: bitwarden, aws, etc) are on the way. The existing encrypted file plugin (https://dmno.dev/docs/plugins/encrypted-vault/) uses a single symmetric key which must be shared with all teammates who need access. This is obviously a naive approach and not ideal... Other sensible approaches would require a centralized manager of the private key, which is also not ideal and comes with serious liability/security risks, and compliance requirements. This hackathon project introduces a new encrypted vault plugin (powered by web3) with a far superior decentralized approach to encryption/decryption. This plugin bridges the gap to web2 by relying on Github for access control, and hiding all web3 interactions after initial setup is complete. Encrypted secrets are still stored in a file within your repository, but encryption uses a PKP (powered by Lit Protocol). Using an on-chain PKP allows all devs to update secret values (encrypting using the public key), but decrypting those secrets can be set using programmable conditions - without ever exposing the private key to anyone. The plugin uses Github personal access tokens to identify users, and membership in Github org \"teams\" for access control at the vault level. Secrets can be segmented into multiple vault instances, and access to each vault can be granted to multiple teams, and changed over time, as the access list is also on-chain. The goal is to make this all as seamless as possible, and take advantage of the benefits of decentralization, without forcing the end users to deal with wallets/keys/etc. While a wallet is needed to set up the vault (and corresponding PKP), after that everything is handled via github auth tokens, so most users may not even realize they are using web3 at all. Even this is not necessary as a centralized service could handle setting things up for end users,  taking fiat payments, and hiding all web3 interactions. Future work will need to be done to move this onto mainnet, deal with payments and delegation, complete access management, etc... I ALSO created a simple package with a few web3-related data types for DMNO. This lets us set config items as being web3 addresses and private keys, and we get some basic validations. In the future, I will add more options to check certain conditions as validations - for example checking a balance, or checking that an address is a certain type of contract, etc... THis is just generally useful and will help stop typos turning into huge catastrophes :) This project relies heavily on Lit Protocol - which manages the PKP and talks to Github using Lit actions to restrict access. The access list is stored using Sign protocol as attestations (on a different chain). These attestations hold an encrypted Github Team ID.  The Lit action fetches those attestations, decrypts them, and compares the users current teams to the list. In an ideal world, the PKP would also be used to manage the attestations, also using Lit actions, so that after the initial setup, users never have to deal with a wallet again. This was initially attempted, but dealing with signing and submitting transactions involving multiple wallets and delegating payments proved to add too much complexity for the hackathon. Honestly had Lit protocol not been here, whatever I would have hacked together myself would have been a naive proof of concept... Using Lit solved my exact problem - and one that I had been pondering how to solve more generally, with or without web3, much before this hackathon. Using Sign Protocol was extremely convenient because of the schema, revokability, built-in indexing service, and helpful UI! In the future we could use sign hooks to trigger notifications when things change - or even to affect keys. A next step is to allow Lit actions to access keys that the user may not have access to - to do things like use a master key to generate dev or deployment specific keys. Also an alternative access control mechanism will need to be developed for server-to-server access, but it would look fairly similar, just using keypairs and signed messages, rather than relying on github.",
        "how_its_made": "This project relies heavily on Lit Protocol - which manages the PKP and talks to Github using Lit actions to restrict access. The access list is stored using Sign protocol as attestations (on a different chain). These attestations hold an encrypted Github Team ID.  The Lit action fetches those attestations, decrypts them, and compares the users current teams to the list. In an ideal world, the PKP would also be used to manage the attestations, also using Lit actions, so that after the initial setup, users never have to deal with a wallet again. This was initially attempted, but dealing with signing and submitting transactions involving multiple wallets and delegating payments proved to add too much complexity for the hackathon. Honestly had Lit protocol not been here, whatever I would have hacked together myself would have been a naive proof of concept... Using Lit solved my exact problem - and one that I had been pondering how to solve more generally, with or without web3, much before this hackathon. Using Sign Protocol was extremely convenient because of the schema, revokability, built-in indexing service, and helpful UI! In the future we could use sign hooks to trigger notifications when things change - or even to affect keys. A next step is to allow Lit actions to access keys that the user may not have access to - to do things like use a master key to generate dev or deployment specific keys. Also an alternative access control mechanism will need to be developed for server-to-server access, but it would look fairly similar, just using keypairs and signed messages, rather than relying on github.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/a4f6a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/u38zd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/dp6ug/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/7jp3i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/qwdc5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/dmno-dev/ethsf-2024",
        "link": "https://ethglobal.com/showcase/dmno-pkp-secrets-vaytr"
    },
    {
        "title": "Earn Your Story AI",
        "brief_description": "Using AI to registering your most personal identity IP, based on your open tabs",
        "long_description": "A quick and easy way to monetize your personal identity IP. Advertisers pay me good money if I can show who I am. Academic researchers yearn to know more about my behavioral patterns. And, I want AI to personalize my online user experience based on who I am. I need a quick and bullet-proof way to define and sell my personal interest IP ! I use the data that defines my most personal self: my browser tabs.\nTo understand (!) and explain who I am - transparent, IP-protected, automated in 1 click, thanks to LLMs. Now I only need a self-sovereign way to protect my personal identity:\nI register my identity as IP NFT on Story Protocol. This way my personal identity becomes IP, clearly attributed, and protected. Finally, I sell My Story to advertisers and researchers who are curious to learn more about my interests. Protected by IP licensing terms - e.g. restricting commercial use, but allowing academic research. https://testnet.storyscan.xyz/tx/0xe73588e2a449dfbb164eff645cf5f49682b7dd05e3a01a5dbcec96a9261f1087 The Chrome extension uses the Chrome API to read information such as open browser tabs. Only an extension has access to this personal data. The data then shows in your Chrome tab. GPT summarizes the titles of open browser tabs. A more private local LLM could be used, too, but doesn't quite work for demo purposes here. Then Story Protocol creates an NFT defining your personal interest.",
        "how_its_made": "The Chrome extension uses the Chrome API to read information such as open browser tabs. Only an extension has access to this personal data. The data then shows in your Chrome tab. GPT summarizes the titles of open browser tabs. A more private local LLM could be used, too, but doesn't quite work for demo purposes here. Then Story Protocol creates an NFT defining your personal interest.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tp1jd/screenshots/9z6tq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tp1jd/screenshots/j8f5r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tp1jd/screenshots/vcty6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tp1jd/screenshots/hj6wc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/p0s/earn-your-story",
        "link": "https://ethglobal.com/showcase/earn-your-story-ai-tp1jd"
    },
    {
        "title": "SmartSign",
        "brief_description": "Transform conversations into contracts instantly with our app, combining advanced language models and blockchain for secure, efficient, and transparent deal closures.",
        "long_description": "Imagine instantly transforming your business conversations into legally binding contracts with just a few clicks. Our app effortlessly captures discussions between parties and extracting crucial details. Leveraging advanced language models, it generates comprehensive written contracts instantly. Once both parties agree on the contract, it is AES encrypted, providing passwords exclusively to the involved parties, and stored on the walrus network. A smart contract referencing the encrypted contract is then created and stored on the Rootstock blockchain, ensuring transparency, security, and immutability. Say goodbye to lengthy negotiations and paperwork \u2013 with our app, closing deals has never been easier or more efficient. Say goodbye to pricey subscription services like Docusign, PandaDoc, and SignNow! And say hello to SmartSign! Example use cases:\nTwo parties negotiating a sale of an item.\nWarranty contracts.\nFreelance agreements and project scopes.\nRental and lease agreements.\nService contracts between businesses and clients.\nNon-disclosure agreements (NDAs).\nEmployment contracts and offer letters.\nPartnership agreements.\nLicensing and royalty agreements.\nLoan agreements and repayment terms The project uses XMTP (Converse) for chatting capability between users.  It uses Openai for legal contract capability.  It uses Walrus to store the encrypted contract data.  It uses Solidity contract for signing, timestamp of the contract.  The solidity contract is deployed on Rootstock chain. App Workflow: Two users engage in a conversation on XMTP. Once they finish discussing business details and exchanging personal information, they trigger the /generate contract bot command. The bot gathers the entire chat history and is fed into OpenAI's gpt-4o LLM, which generates a legal contract in text form. The bot then creates a random encryption key and uses it to AES encrypt the PDF contract. The bot sends the encrypted PDF and the encryption key to both users in the chat, allowing them to review the AI-generated contract. If needed, they can regenerate the contract by issuing the command again. No other people have access to the encryption key as XMTP is an end to end encrypted messenger. Either user can deploy the contract when ready. By invoking the /deploy command, the bot generates a link to a page where users can log into their MetaMask wallet and deploy the smart contract. The AES encrypted contract is first deployed on the Walrus Network. Once deployed, a hash for the blob id is stored on the smart contract when it's deployed. Users can sign the smart contract by using the /sign command which uses their Rootstock wallet to officially sign the contract.",
        "how_its_made": "The project uses XMTP (Converse) for chatting capability between users.  It uses Openai for legal contract capability.  It uses Walrus to store the encrypted contract data.  It uses Solidity contract for signing, timestamp of the contract.  The solidity contract is deployed on Rootstock chain. App Workflow: Two users engage in a conversation on XMTP. Once they finish discussing business details and exchanging personal information, they trigger the /generate contract bot command. The bot gathers the entire chat history and is fed into OpenAI's gpt-4o LLM, which generates a legal contract in text form. The bot then creates a random encryption key and uses it to AES encrypt the PDF contract. The bot sends the encrypted PDF and the encryption key to both users in the chat, allowing them to review the AI-generated contract. If needed, they can regenerate the contract by issuing the command again. No other people have access to the encryption key as XMTP is an end to end encrypted messenger. Either user can deploy the contract when ready. By invoking the /deploy command, the bot generates a link to a page where users can log into their MetaMask wallet and deploy the smart contract. The AES encrypted contract is first deployed on the Walrus Network. Once deployed, a hash for the blob id is stored on the smart contract when it's deployed. Users can sign the smart contract by using the /sign command which uses their Rootstock wallet to officially sign the contract.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/9ss1i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/fx3d7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/9vpur/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/k5nt5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/znbxr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/kvhqd/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/swswsw/contractbot1",
        "link": "https://ethglobal.com/showcase/smartsign-zjyn1"
    },
    {
        "title": "Dream Green",
        "brief_description": "A blockchain-based payment solution for the cannabis industry. We eliminate cash-related risks and complexities for dispensaries by enabling secure crypto and fiat transactions, all settled in USDC. Simplifying operations, ensuring compliance, and improving customer experience.",
        "long_description": "Core Functionality: Hybrid Payment System: Cultivates flexibility by accepting both cryptocurrency and fiat currency payments.\nIntegrates with Stripe for processing traditional card payments.\nSupports various cryptocurrencies for direct crypto transactions. USDC Settlement: All transactions, regardless of input method, bloom into USD Coin (USDC) settlements.\nUtilizes Circle's infrastructure for stable, regulated cryptocurrency transactions. Blockchain-Based Ledger: Plants a secure record of all transactions on a blockchain, ensuring transparency and immutability.\nGrows easy pathways for auditing and regulatory compliance. User-Friendly Interface: Intuitive mobile app for customers to make purchases as easily as watering a plant.\nRobust dashboard for dispensaries to manage transactions, inventory, and analytics. Key Benefits: For Dispensaries: Prunes away cash handling, minimizing security risks and operational costs.\nFertilizes growth by providing a cryptocurrency-based financial solution.\nCultivates compliance with automatic record-keeping and reporting tools.\nEnables businesses to branch out and scale operations more easily. For Customers: Blossoms multiple convenient payment options (crypto, card, bank transfer).\nGrows a canopy of privacy and security around purchases.\nPollinates the overall purchasing experience with fast, digital transactions. For the Cannabis Industry: Bridges the gap between state-level legalization and federal banking regulations.\nPromotes transparency and legitimacy, helping the industry flourish.\nFacilitates easier tax collection and reporting for authorities.\nPayment Integration with Circle, Stripe, and Crypto Wallets\nThis project integrates Circle payments with Stripe to enable checkout using both traditional payment methods (credit/debit cards) and cryptocurrencies (via wallets like MetaMask and Phantom). It facilitates automatic conversions to USDC and ensures that the correct dispensary (dispo) wallet receives the payment. PoW (Proof of Weed)\nRevolutionizing payments in the marijuana industry using Circle, Stripe, and Flow blockchain. Payment Integration with Circle, Stripe, and Crypto Wallets\nThis project integrates Circle payments with Stripe to enable checkout using both traditional payment methods (credit/debit cards) and cryptocurrencies (via wallets like MetaMask and Phantom). It facilitates automatic conversions to USDC and ensures that the correct dispensary (dispo) wallet receives the payment. Features\nMulti-Method Payments: Users can checkout via Stripe (credit/debit) or using cryptocurrency wallets (e.g., MetaMask, Phantom).\nAutomatic USDC Conversion: Fiat payments are converted to USDC using Circle\u2019s API.\nWallet-Based Payment Routing: Each dispensary has a unique USDC wallet, and payments are automatically routed to the respective wallet.\nReal-Time Notifications: Webhooks from Stripe and Circle are used to notify and handle payments in real-time.\nPrerequisites\nAPI Keys: You will need API keys from Circle and Stripe to interact with their services.\nCrypto Wallets: For crypto payments, wallets such as MetaMask and Phantom should be supported.\nUSDC Support: Ensure that your Stripe account is configured to support cryptocurrency payments (specifically USDC).\nHow It Works\nCreate a Wallet for Each Dispensary: Circle API is used to create and manage wallets for each dispensary.\nEach wallet is identified by a unique ID.\nInitiate a Stripe Checkout Session: The user selects a product and starts a checkout session.\nStripe allows the user to pay via credit card, debit card, or cryptocurrency (USDC).\nThe dispensary\u2019s wallet ID is included in the session metadata to ensure the payment is routed correctly.\nConvert Fiat to USDC (if using traditional payment methods): Once the payment is processed via Stripe, a backend process is triggered to convert the fiat currency to USDC using Circle\u2019s API.\nThe USDC is transferred to the correct dispensary wallet.\nHandle Direct Crypto Payments (e.g., MetaMask or Phantom): For users paying directly in USDC via a crypto wallet, the payment is automatically routed to the respective dispensary\u2019s wallet.\nWebhooks for Real-Time Updates: Stripe webhooks notify the backend when a payment is completed.\nCircle webhooks notify the backend when USDC transfers are successfully completed.\nFile Structure\napp.py: Flask application to handle Stripe and Circle webhooks.\nstripe_checkout.py: Code to create Stripe Checkout Sessions.\ncircle_api.py: Code to handle Circle API interactions (wallet creation, fiat-to-USDC conversion).\nREADME.md: This documentation.\nSetup\nClone this repository:\ngit clone https://github.com/your-repo/payment-integration.git\ncd payment-integration\nComplete Setup for Payment Integration with Circle, Stripe, and Crypto Wallets\nInstall Python: Ensure Python 3.6+ is installed from python.org. (Optional) Create Virtual Environment: python -m venv venv\nsource venv/bin/activate (Windows: venv\\Scripts\\activate)\nInstall Required Packages: pip install requests flask stripe python-dotenv\nCreate .env File in your project directory and add the following environment variables: STRIPE_SECRET_KEY=your_stripe_secret_key\nCIRCLE_API_KEY=your_circle_api_key\nSTRIPE_ENDPOINT_SECRET=your_stripe_webhook_endpoint_secret\nCIRCLE_WEBHOOK_SECRET=your_circle_webhook_secret\nLoad Environment Variables in Your Code: from dotenv import load_dotenv\nimport os load_dotenv()\nstripe.api_key = os.getenv(\"STRIPE_SECRET_KEY\")\ncircle_api_key = os.getenv(\"CIRCLE_API_KEY\")",
        "how_its_made": "PoW (Proof of Weed)\nRevolutionizing payments in the marijuana industry using Circle, Stripe, and Flow blockchain. Payment Integration with Circle, Stripe, and Crypto Wallets\nThis project integrates Circle payments with Stripe to enable checkout using both traditional payment methods (credit/debit cards) and cryptocurrencies (via wallets like MetaMask and Phantom). It facilitates automatic conversions to USDC and ensures that the correct dispensary (dispo) wallet receives the payment. Features\nMulti-Method Payments: Users can checkout via Stripe (credit/debit) or using cryptocurrency wallets (e.g., MetaMask, Phantom).\nAutomatic USDC Conversion: Fiat payments are converted to USDC using Circle\u2019s API.\nWallet-Based Payment Routing: Each dispensary has a unique USDC wallet, and payments are automatically routed to the respective wallet.\nReal-Time Notifications: Webhooks from Stripe and Circle are used to notify and handle payments in real-time.\nPrerequisites\nAPI Keys: You will need API keys from Circle and Stripe to interact with their services.\nCrypto Wallets: For crypto payments, wallets such as MetaMask and Phantom should be supported.\nUSDC Support: Ensure that your Stripe account is configured to support cryptocurrency payments (specifically USDC).\nHow It Works\nCreate a Wallet for Each Dispensary: Circle API is used to create and manage wallets for each dispensary.\nEach wallet is identified by a unique ID.\nInitiate a Stripe Checkout Session: The user selects a product and starts a checkout session.\nStripe allows the user to pay via credit card, debit card, or cryptocurrency (USDC).\nThe dispensary\u2019s wallet ID is included in the session metadata to ensure the payment is routed correctly.\nConvert Fiat to USDC (if using traditional payment methods): Once the payment is processed via Stripe, a backend process is triggered to convert the fiat currency to USDC using Circle\u2019s API.\nThe USDC is transferred to the correct dispensary wallet.\nHandle Direct Crypto Payments (e.g., MetaMask or Phantom): For users paying directly in USDC via a crypto wallet, the payment is automatically routed to the respective dispensary\u2019s wallet.\nWebhooks for Real-Time Updates: Stripe webhooks notify the backend when a payment is completed.\nCircle webhooks notify the backend when USDC transfers are successfully completed.\nFile Structure\napp.py: Flask application to handle Stripe and Circle webhooks.\nstripe_checkout.py: Code to create Stripe Checkout Sessions.\ncircle_api.py: Code to handle Circle API interactions (wallet creation, fiat-to-USDC conversion).\nREADME.md: This documentation.\nSetup\nClone this repository:\ngit clone https://github.com/your-repo/payment-integration.git\ncd payment-integration\nComplete Setup for Payment Integration with Circle, Stripe, and Crypto Wallets\nInstall Python: Ensure Python 3.6+ is installed from python.org. (Optional) Create Virtual Environment: python -m venv venv\nsource venv/bin/activate (Windows: venv\\Scripts\\activate)\nInstall Required Packages: pip install requests flask stripe python-dotenv\nCreate .env File in your project directory and add the following environment variables: STRIPE_SECRET_KEY=your_stripe_secret_key\nCIRCLE_API_KEY=your_circle_api_key\nSTRIPE_ENDPOINT_SECRET=your_stripe_webhook_endpoint_secret\nCIRCLE_WEBHOOK_SECRET=your_circle_webhook_secret\nLoad Environment Variables in Your Code: from dotenv import load_dotenv\nimport os load_dotenv()\nstripe.api_key = os.getenv(\"STRIPE_SECRET_KEY\")\ncircle_api_key = os.getenv(\"CIRCLE_API_KEY\")",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hk30m/screenshots/3eezu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hk30m/screenshots/01gdg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hk30m/screenshots/a8201/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/j-ble/proof_of_green ",
        "link": "https://ethglobal.com/showcase/dream-green-hk30m"
    },
    {
        "title": "DeFi-Calendly",
        "brief_description": "A defi calendly, book appointments onchain with a staked deposit",
        "long_description": "A web3 version of calendly. Service providers can allow their clients to book appointments onchain with a staked deposit. Clients get it back when you are marked as attended by the owner of the appointment. Once the appointments are resolved they will either be returned to the client or transferred to the Service Provider. I built this solo, the idea is to expand and create an easy way for service providers (think hairdressers, lawyers, consultants) to provide a booking platform with deposits paid for each appointment. Smart contract written in Sol.\nIntegrated with Metamask and Coinbase Wallet.\nDeployed on Remix and Vercel.\nQA with Polygon Testnet.",
        "how_its_made": "I built this solo, the idea is to expand and create an easy way for service providers (think hairdressers, lawyers, consultants) to provide a booking platform with deposits paid for each appointment. Smart contract written in Sol.\nIntegrated with Metamask and Coinbase Wallet.\nDeployed on Remix and Vercel.\nQA with Polygon Testnet.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h3cis/screenshots/t66tk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h3cis/screenshots/2houh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h3cis/screenshots/aovpz/default.jpg"
        ],
        "live_demo": "https://ethglobal-sf-24-q2kw15vw6-ram-sharmas-projects-7ad2ce07.vercel.app/",
        "source_code": "https://github.com/ram-sharma/ethglobalSF24",
        "link": "https://ethglobal.com/showcase/defi-calendly-h3cis"
    },
    {
        "title": "PQP",
        "brief_description": "Post-Quantum Digital Signature on Trusted Execution Environment",
        "long_description": "Background\nPost-Quantum Proofs (PQP) aims to build a quantum resistant future. Our mission is to implement cryptographic algorithms that remain secure against the potential threats posed by quantum computers, to create a robust Web3 infrastructure. As quantum computing technology advances, it is anticipated that many Web3 protocols which use cryptographic systems, particularly those based on integer factorization and discrete logarithm problems, will become vulnerable to attacks using algorithms like Shor's algorithm. Therefore, the development of quantum-resistant signature schemes is essential for ensuring long-term blockchain security. Problem\nIn quantum computing, a possible Q-day attack would be a hypothetical cyberattack, similar to zero-day vulnerabilities in the cybersecurity field. If quantum technology matures, blockchain protocols and Web3 transactions will become vulnerable to quantum algorithms. Moreover, many of the underlying cryptographic primitives would become vulnerable to quantum attacks. Idea\nPost-quantum signatures are digital signatures designed to be secure against attacks from quantum computers and can verify the validity of onchain cryptographic encryptions. These signatures rely on mathematical problems that are believed to be difficult even for quantum computers to solve. The objective is to create a signature scheme that allows a signer to produce a signature using a private key while enabling anyone with access to the corresponding public key to verify the authenticity of the signature without revealing the private key. We implemented a post-quantum lattice-based digital signature on a trusted execution environment as a proof of concept of PQ in Web3. In our project, we implemented a state-of-the-art post-quantum Digital Signature Algorithm (DSA) on Trusted Execution Environments (TEEs) using TypeScript. We integrated lattice-based cryptographic techniques, leveraging TEEs from Lit and Phala. We experimented and recorded 16ms latency.",
        "how_its_made": "In our project, we implemented a state-of-the-art post-quantum Digital Signature Algorithm (DSA) on Trusted Execution Environments (TEEs) using TypeScript. We integrated lattice-based cryptographic techniques, leveraging TEEs from Lit and Phala. We experimented and recorded 16ms latency.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/s48yc/screenshots/2rkrh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s48yc/screenshots/8uxc2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s48yc/screenshots/ac882/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s48yc/screenshots/oc1h1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/lipet2k/ethsf",
        "link": "https://ethglobal.com/showcase/pqp-s48yc"
    },
    {
        "title": "Anti Swan",
        "brief_description": "An ERC-4626 tokenized vault designed to protect capital by betting against black swan events (P < 5%). Using market data, Kelly Criterion, and advanced strategies, we generate consistent yield while minimizing risk in prediction markets. Protect, profit, repeat.",
        "long_description": "BlackSwan Shield is a tokenized 4626-compliant vault designed to collectively manage user funds while betting against black swan events (with a probability of less than 5%) in prediction markets like Polymarket. Users deposit funds into the vault and receive shares representing their ownership. The vault then autonomously places bets, with a specific focus on events that are statistically unlikely to occur (black swans). In essence, SwanGuard Vault transforms complex prediction market strategies into an accessible, efficient product that allows users to earn consistent returns by betting against highly improbable events. This \u201canti-black swan\u201d approach, combined with yield optimization, provides users with a robust DeFi product focused on risk-adjusted returns.\nOur main product called SwanGuard Vault, and here's how it works:",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/kxtyk/screenshots/fsbb3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxtyk/screenshots/mb8o3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxtyk/screenshots/dafdh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/anti-black-swan/eth-global-sf-submission",
        "link": "https://ethglobal.com/showcase/anti-swan-kxtyk"
    },
    {
        "title": "OmniMemeFoodFactory",
        "brief_description": "Launch your own AI-powered food meme coin as Omni Fungible Token (OFT) on 70+ chains in ONE click(*), made possible by LayerZero V2",
        "long_description": "Launch your own AI-powered food meme coin as Omni Fungible Token (OFT) on 70+ chains in ONE click(*), made possible by LayerZero V2. Contracts are written, organized, and deployed by Foundry (forge, anvil). See description and README, and submitted feedback on partner section for how LayerZero made our project possible Frontend is based on Chakra, Viem, Wagmi, Rainbow Kit, Typescript + React, with full ESLint and dev environment configured Server is powered by Python Flask, and OpenAI dall-e-3 and GPT-4",
        "how_its_made": "Contracts are written, organized, and deployed by Foundry (forge, anvil). See description and README, and submitted feedback on partner section for how LayerZero made our project possible Frontend is based on Chakra, Viem, Wagmi, Rainbow Kit, Typescript + React, with full ESLint and dev environment configured Server is powered by Python Flask, and OpenAI dall-e-3 and GPT-4",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/yc4xf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/5asep/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/do1gj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/4g12t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/5227h/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/polymorpher/omni-meme-food-factory",
        "link": "https://ethglobal.com/showcase/omnimemefoodfactory-fkwf7"
    },
    {
        "title": "Cara IP",
        "brief_description": "Let your imagination flow and your creativity go, with the power of AI and IP",
        "long_description": "In the world of AI, we want to make sure artist feel empowered to be their creative selfs. Cara is ment as a playground, where you can upload your photographs or any image, and with words edit it in any way you want.  At the same time, each piece or art is being tracker by Mentaport off chain and is being registered as an IP to Story protocol. This combination is very powerful because if you find an image in the web2 land,   now you can edit it with Cara and automatically Cara will detect the owner and allow you to create a  new IP but with the incredible add-on of derivatives from Story. The project was broken into three main parts.\nPart 1: Gen AI: Part 2: Story: Part 3: Mentaport Part 4: Dynamic:",
        "how_its_made": "The project was broken into three main parts.\nPart 1: Gen AI: Part 2: Story: Part 3: Mentaport Part 4: Dynamic:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/nfx44/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/uwio1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/k5651/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/uxpk2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/f0icx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/nirxd/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/thinkmariale/cara-ip",
        "link": "https://ethglobal.com/showcase/cara-ip-x03th"
    },
    {
        "title": "Carbon Wheel",
        "brief_description": "CarbonWheel is a platform that incentivizes electric vehicle (EV) users by rewarding them with carbon credits for their contributions to environmental sustainability.",
        "long_description": "EVs inherently track the number of miles driven, and we leverage this data to calculate the environmental impact. Specifically, driving a gasoline car emits approximately 404 grams of carbon per mile, which is avoided by EV users. Through this calculation, EV drivers contribute to saving the planet by reducing around 0.4 metric tons of carbon for every 1,000 miles driven. When users choose to redeem their carbon credits through our dashboard, the saved carbon is added to a pool, which is then auctioned to the highest bidder. The profits from these auctions are automatically redistributed to the credit holders, with a portion retained by the platform as a fee for facilitation. The foundation of CarbonWheel was built using the Scaffold-ETH 2 template to accelerate development. I created the core smart contract using Remix, which facilitates the minting of carbon credit NFTs. This contract was deployed on Flow's testnet to ensure scalability and efficient transaction handling. To manage the minting process, I integrated WAGMI for seamless interaction between the frontend and blockchain, while leveraging ethers.js for asynchronous contract management. Ethers.js allowed me to handle contract operations with a high degree of flexibility and efficiency. Additionally, I developed frontend simulations to model future features and scenarios that are planned but not yet implemented, ensuring the project remains adaptable for future growth. By incorporating these technologies, the project achieves an efficient, scalable structure with clear pathways for further enhancements and real-world application.",
        "how_its_made": "The foundation of CarbonWheel was built using the Scaffold-ETH 2 template to accelerate development. I created the core smart contract using Remix, which facilitates the minting of carbon credit NFTs. This contract was deployed on Flow's testnet to ensure scalability and efficient transaction handling. To manage the minting process, I integrated WAGMI for seamless interaction between the frontend and blockchain, while leveraging ethers.js for asynchronous contract management. Ethers.js allowed me to handle contract operations with a high degree of flexibility and efficiency. Additionally, I developed frontend simulations to model future features and scenarios that are planned but not yet implemented, ensuring the project remains adaptable for future growth. By incorporating these technologies, the project achieves an efficient, scalable structure with clear pathways for further enhancements and real-world application.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/ach4g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/7arh4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/ny24e/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kgobin2000/carbon-wheel-v1",
        "link": "https://ethglobal.com/showcase/carbon-wheel-2x3ta"
    },
    {
        "title": "Carbon Wheel",
        "brief_description": "CarbonWheel is a platform that incentivizes electric vehicle (EV) users by rewarding them with carbon credits for their contributions to environmental sustainability.",
        "long_description": "EVs inherently track the number of miles driven, and we leverage this data to calculate the environmental impact. Specifically, driving a gasoline car emits approximately 404 grams of carbon per mile, which is avoided by EV users. Through this calculation, EV drivers contribute to saving the planet by reducing around 0.4 metric tons of carbon for every 1,000 miles driven. When users choose to redeem their carbon credits through our dashboard, the saved carbon is added to a pool, which is then auctioned to the highest bidder. The profits from these auctions are automatically redistributed to the credit holders, with a portion retained by the platform as a fee for facilitation. The foundation of CarbonWheel was built using the Scaffold-ETH 2 template to accelerate development. I created the core smart contract using Remix, which facilitates the minting of carbon credit NFTs. This contract was deployed on Flow's testnet to ensure scalability and efficient transaction handling. To manage the minting process, I integrated WAGMI for seamless interaction between the frontend and blockchain, while leveraging ethers.js for asynchronous contract management. Ethers.js allowed me to handle contract operations with a high degree of flexibility and efficiency. Additionally, I developed frontend simulations to model future features and scenarios that are planned but not yet implemented, ensuring the project remains adaptable for future growth. By incorporating these technologies, the project achieves an efficient, scalable structure with clear pathways for further enhancements and real-world application.",
        "how_its_made": "The foundation of CarbonWheel was built using the Scaffold-ETH 2 template to accelerate development. I created the core smart contract using Remix, which facilitates the minting of carbon credit NFTs. This contract was deployed on Flow's testnet to ensure scalability and efficient transaction handling. To manage the minting process, I integrated WAGMI for seamless interaction between the frontend and blockchain, while leveraging ethers.js for asynchronous contract management. Ethers.js allowed me to handle contract operations with a high degree of flexibility and efficiency. Additionally, I developed frontend simulations to model future features and scenarios that are planned but not yet implemented, ensuring the project remains adaptable for future growth. By incorporating these technologies, the project achieves an efficient, scalable structure with clear pathways for further enhancements and real-world application.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/ach4g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/7arh4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/ny24e/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kgobin2000/carbon-wheel-v1",
        "link": "https://ethglobal.com/showcase/carbon-wheel-2x3ta"
    },
    {
        "title": "LensChain",
        "brief_description": "Lens Chain is a user-friendly NFT platform specifically designed for photographers to mint, showcase, and trade their unique prints. (not fully done yet)",
        "long_description": "Lens Chain is a user-friendly NFT platform specifically designed for photographers to mint, showcase, and trade their unique prints NFTs. Users can easily upload their images, provide descriptions, and set prices. They can explore and appreciate a diverse collection of photographic art on the chain created by others, fostering community engagement. With seamless wallet connectivity and integrated custom poem generation to give the prints and their artists an opportunity to add a classical dimension to their appeal. We used Scaffold-ETH2 to build this Ethereum dApp and simplify the interactions with the smart contract - solidity. Therefore Wagmi and Next.js - React - Tailwind CSS on the Frontend/styling. We used IPFS for the  decentralized uploading functionality.\nWe added a fun feature using OpenAI to generate poems for the minted prints.",
        "how_its_made": "We used Scaffold-ETH2 to build this Ethereum dApp and simplify the interactions with the smart contract - solidity. Therefore Wagmi and Next.js - React - Tailwind CSS on the Frontend/styling. We used IPFS for the  decentralized uploading functionality.\nWe added a fun feature using OpenAI to generate poems for the minted prints.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2n6nx/screenshots/2kjky/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2n6nx/screenshots/t3330/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2n6nx/screenshots/1dqh0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AndrewRot/lens-chain",
        "link": "https://ethglobal.com/showcase/lenschain-2n6nx"
    },
    {
        "title": "Decl Prediction Mrkt",
        "brief_description": "A very simply prediction market implementation on using Essential's declarative smart contracts.",
        "long_description": "Essential smart contracts are declarative, meaning that you only define the constraints that state transitions must satisfy rather than the details of how those state transitions are accomplished. This project defines a system with Users, Oracles, and Markets. Each User is controlled by its creator and has a balance and can bet on Markets. An Oracle is controlled by its creator, starts unresolved, and can become resolved as true or false at any time (but stays resolved once resolved). A Market is not controlled by anyone, but is linked to an Oracle upon creation. When the Market is unresolved, then any user can bet on either the true or false outcome of the Market. When the Oracle resolves, then the Market resolves, and the money bet on the Market is distributed only to the winning bettors. All of this happens only within the contracts system, so no actual tokens are being transferred (that would be for future work). I also made a simplifying assumption that only two bettors (one for true and one for false) can bet on a Market. I was able to model the entire system in the Pint smart contract, but I was not able to finish writing all of the Rust interactions for testing it. Please note that I forked the Essential example integrations repository, and my contributions are only in the apps/prediction-market sub-directory. I used the basic setup that Essential recommends -- the contracts are written in Pint, and the interactions are written in Rust using the setup demonstrated in the essential-integration/apps examples. In particular, the Rust implements two things: the library for reflecting interactions with the contract, and a test suite that uses the library to test scripted sequences of interactions.",
        "how_its_made": "Please note that I forked the Essential example integrations repository, and my contributions are only in the apps/prediction-market sub-directory. I used the basic setup that Essential recommends -- the contracts are written in Pint, and the interactions are written in Rust using the setup demonstrated in the essential-integration/apps examples. In particular, the Rust implements two things: the library for reflecting interactions with the contract, and a test suite that uses the library to test scripted sequences of interactions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/nocgs/screenshots/wg80r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nocgs/screenshots/vhojt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nocgs/screenshots/fwtqt/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/rybla/essential-integration/",
        "link": "https://ethglobal.com/showcase/decl-prediction-mrkt-nocgs"
    },
    {
        "title": "BuildBlocks",
        "brief_description": "With BuildBlocks, we have created drag and drop dynamic smart contract components and a platform that allows *anyone* to develop, compile, and deploy audited smart contracts on Rootstock",
        "long_description": "There is a huge barrier of entry when it comes to entering the web3 space. A minor mistake in your code can cost you thousands of dollars! Firms and companies spend hundreds of thousands of dollars auditing their smart contracts to ensure that there are no exploits in their code, but with BuildBlocks, we have created drag and drop dynamic smart contract components and a platform that allows anyone to develop, compile, and deploy reviewed smart contracts on Rootstock. Using a Retrieval pipeline on audited DeFi contracts from resources such as Uniswap, OpenZeppelin, etc., BuildBlocks allows for users to use easy-to-understand blocks to create extremely intensive smart contracts in the blink of an eye. We built BuildingBlocks using the standard NextJS, Tailwind stack, but on top of that, we used injectable wallets, the Rootstock deployment and test network, the SolC compiler for automated Solidity contract compilation, and SIDAI's RAG pipeline generation service which we created buckets of audited Solidity smart contracts.",
        "how_its_made": "We built BuildingBlocks using the standard NextJS, Tailwind stack, but on top of that, we used injectable wallets, the Rootstock deployment and test network, the SolC compiler for automated Solidity contract compilation, and SIDAI's RAG pipeline generation service which we created buckets of audited Solidity smart contracts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/6s6f2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/x2db3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/awpza/default.jpg",
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/ggjs9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/mri2g/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sanjayamirthraj/blockbuild",
        "link": "https://ethglobal.com/showcase/buildblocks-af74h"
    },
    {
        "title": "Swapped",
        "brief_description": "Monetize your digital persona with ethical deep fakes\u2014upload, create, and earn through secure face-swap videos while preserving your anonymity",
        "long_description": "Swapped is a revolutionary NFT marketplace where your digital persona becomes a monetizable asset. Ideal for creators, influencers, public figures and brands, Swapped lets you upload your photos or AI-generated identities as NFTs, granting you full ownership and control over your digital identity. Swappers can use these NFTs to create safe, secure deep fakes via face-swap videos, allowing your persona to generate income while ensuring anonymity and ethical use. Flow is the trust, payment and NFT marketplace. We created a custom NFT that is used to manage users purchasing and selling likenesses. NFT's can be used to validate content was authorized by it's creator. Walrus for hosting distributed files. We needed defi storage for the NFTs. Dynamic for decentralized identity management and smooth Web3 onboarding. This allows us to onboard users to our platform easily. We use a Python server we built to process videos, images and swap their faces",
        "how_its_made": "Flow is the trust, payment and NFT marketplace. We created a custom NFT that is used to manage users purchasing and selling likenesses. NFT's can be used to validate content was authorized by it's creator. Walrus for hosting distributed files. We needed defi storage for the NFTs. Dynamic for decentralized identity management and smooth Web3 onboarding. This allows us to onboard users to our platform easily. We use a Python server we built to process videos, images and swap their faces",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/xuobm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/4e5tj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/tttrw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/xtrn9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/goasn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/j-sp4/ethglobal-SF-2024",
        "link": "https://ethglobal.com/showcase/swapped-yhddc"
    },
    {
        "title": "Walruspecs",
        "brief_description": "Client-side object detection app deployed as a Walrus site. The app's dependencies are packaged into the project and published as a Walrus blob. The object detection model runs on the client's browser (thanks to transformers.js) without needing a web server for computation.",
        "long_description": "The project demonstrates the feasibility of deploying a packaged AI model to a Walrus blob, which would charge its users based on their usage. e.g. every time someone runs the object detection model, the user will pay the creator a fixed amount of money. The application has no external dependencies, which makes the app safe from other points of failures. This project uses transformers.js to enable an AI model run on the client side. For object detection, it uses detr-resnet-50 model with the confidence threshold of 50% i.e. any predictions with a confidence level below 50% will be omitted in the results. The application has been uploaded with Bootstrap's minified CSS/JS, transformers.js, and detr-resnet-50 ONNX model weights.",
        "how_its_made": "This project uses transformers.js to enable an AI model run on the client side. For object detection, it uses detr-resnet-50 model with the confidence threshold of 50% i.e. any predictions with a confidence level below 50% will be omitted in the results. The application has been uploaded with Bootstrap's minified CSS/JS, transformers.js, and detr-resnet-50 ONNX model weights.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mtyf9/screenshots/bkycn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtyf9/screenshots/djm75/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtyf9/screenshots/kxyp0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/walrusblob/object-detection",
        "link": "https://ethglobal.com/showcase/walruspecs-mtyf9"
    },
    {
        "title": "Baldr",
        "brief_description": "Baldr is an open source gaming escrow platform which aims to resolve disputes and provide clear resolution for all users. With trust and transparency using sign protocol upon user attestations.",
        "long_description": "Traditional trading of gaming items often lacks transparency and security, leading to disputes and fraudulent activities. Current escrow services may not adequately address these issues, leaving users vulnerable to scams and conflicts. Baldr aims to solve these problems by providing a decentralized escrow platform that leverages AI and blockchain technology to ensure transparent and secure trading of gaming items. By integrating features like the Sign protocol for trade confirmations, dynamic wallets for multi-chain connectivity, and custom subgraphs for transaction analysis, Baldr seeks to establish trust and prevent fraudulent activities in the gaming ecosystem. Baldr is an open-source gaming escrow platform designed to facilitate trading of gaming items while resolving disputes with transparency. It integrates AI to monitor trades and detect suspicious behavior, using a custom subgraph to analyze historical trade events. Baldr employs the Sign protocol for trade confirmations and uses dynamic wallets to connect buyers and sellers across multiple blockchains. It supports Near and Solana ecosystems for trade monitoring and plans to leverage SKALE for gasless transactions. The platform also incorporates Story protocol to protect intellectual property rights of gaming items.",
        "how_its_made": "Baldr is an open-source gaming escrow platform designed to facilitate trading of gaming items while resolving disputes with transparency. It integrates AI to monitor trades and detect suspicious behavior, using a custom subgraph to analyze historical trade events. Baldr employs the Sign protocol for trade confirmations and uses dynamic wallets to connect buyers and sellers across multiple blockchains. It supports Near and Solana ecosystems for trade monitoring and plans to leverage SKALE for gasless transactions. The platform also incorporates Story protocol to protect intellectual property rights of gaming items.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/2fsug/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/hey0w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/cjt8p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/bibkh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/zfybe/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/SwineCoder101/baldr",
        "link": "https://ethglobal.com/showcase/baldr-wyv9f"
    },
    {
        "title": "PPP",
        "brief_description": "An app that allows users to set up and manage personal pension funds using any ERC-20 token",
        "long_description": "Create your own pension fund linked to any ERC-20 token. This app allows you to deposit, withdraw, invest, and pass on your funds to another person if no proof of life is provided within three years. Features: ERC-20 Compatibility: The contract supports any ERC-20 token (USDC is used in this demo).\nFlexible Withdrawals: The account holder can withdraw funds anytime.\nProof of Life: Regular interactions with the contract ensure continued access and can be manually updated. The project was built using Scaffold-ETH 2 as the foundation for both the frontend and smart contracts. A security layer was added with OpenZeppelin, implementing ReentrancyGuard, Ownable, and Pausable functions. Additionally, a frame was created to interact directly with the  smart contract in Farcaster, along with an XMTP bot to enable chat-based communication. The smart contract is deployed across multiple blockchains, offering users broad interoperability.",
        "how_its_made": "The project was built using Scaffold-ETH 2 as the foundation for both the frontend and smart contracts. A security layer was added with OpenZeppelin, implementing ReentrancyGuard, Ownable, and Pausable functions. Additionally, a frame was created to interact directly with the  smart contract in Farcaster, along with an XMTP bot to enable chat-based communication. The smart contract is deployed across multiple blockchains, offering users broad interoperability.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zzjn9/screenshots/d51yy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zzjn9/screenshots/nmkca/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zzjn9/screenshots/uou6n/default.jpg"
        ],
        "live_demo": "https://secure-retire.vercel.app/",
        "source_code": "https://github.com/fedeloterstein/ethglobal-sf",
        "link": "https://ethglobal.com/showcase/ppp-zzjn9"
    },
    {
        "title": "NeoGraph",
        "brief_description": "NeoGraph is a highly powerful and extensible data visualization tool, that seeks to provide new and interactive ways of deriving meaning of otherwise hard to sift through data.",
        "long_description": "NeoGraph is a powerful and extensible tool for building highly interactive data visualizations. As developers and people in tech, we often rely on text to convey meaning, because it is highly interoperable with other text. Which makes up the majority of our tooling with things like log files and code. However text is not a rich medium for expression, because our brains did not evolve to read text. They evolved to identify patterns in visual data. Think of the difference in trying to understand the raw data of an image file, compared to the image it actually represents! The problem with most solutions to this problems, are that most data visualizations are \"lossy\", that is the output of a visualization is only a picture, and not data itself. This heavily restricts how useful these kinds of programs can be. However this is not true in the case of our tool. So what we built, is a tool that is as extensible and usable as text, but provides a much richer medium for visual expression. And with this tool, we can render data sets that your brain can immediately draw meaningful conclusions from, without needing to parse through text or take someone elses word. All while not sacrificing the contextual power that raw data provides. The way our program achieve this, is by making all visualizations living programs that can be modified and used on the fly. What this means, in a visualization, you can interact with an element in the data set, and use it as the starting point of the next meaningful query. Because all elements in the visualization are just a special view on the underlying data object. The uses for this are widespread. Let's walk through a few. DAO Tooling\nIn the case of DAO tooling, we would use this tool to provide views into, for example, what a proposal will mean for the DAO. Another example would be showing the meaningful impact of previous and historical proposals. All of these examples could then be further composed into a single view, which allows us to compose these to build a better story of the data we are trying to explain. Subgraph Data Exploration\nWith our tool, users can query subgraphs or other data sources, and visualize how all of the nodes are related. Upon selecting a node, or sets of nodes, they can use this specific entity as the starting point for a new query, which won't modify our initial view. We built this project using:\nPharo smalltalk\nThe Streamline programming language\nThe graph (as our primary data source for visualizations) Using pharo gives us a ton of super powerful data visualization tools. And without it the project would have been impossible in this timeframe. Using the graph was also pretty fun. But the file data sources were very frustrating to get functional. Additionally the substreams endpoints kept going down for us as we were building. Not good! Streamline was also great. I don't think we could have iterated as fast as we could have without it. All in all we are pretty happy with what we managed to spit out in just over a day!",
        "how_its_made": "We built this project using:\nPharo smalltalk\nThe Streamline programming language\nThe graph (as our primary data source for visualizations) Using pharo gives us a ton of super powerful data visualization tools. And without it the project would have been impossible in this timeframe. Using the graph was also pretty fun. But the file data sources were very frustrating to get functional. Additionally the substreams endpoints kept going down for us as we were building. Not good! Streamline was also great. I don't think we could have iterated as fast as we could have without it. All in all we are pretty happy with what we managed to spit out in just over a day!",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0ffz5/screenshots/jtwvz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0ffz5/screenshots/xkog1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0ffz5/screenshots/e0kxm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MercuricChloride/streamline-hackathon",
        "link": "https://ethglobal.com/showcase/neograph-0ffz5"
    },
    {
        "title": "Aloria",
        "brief_description": "A decentralized omni-powerful AI personal assistant that can complete all kinds of tasks by operating directly on web browser",
        "long_description": "This project uses AI agents to plan tasks, parse images and execute steps of all kinds of tasks by operating on a web browser. Users need to login with their wallet, pay the node that host the service to ask AI agents to complete tasks like booking tickets, monitoring news or price changes, gathering information from reddit, etc. Users can also publish their task prompts to claim ownership. XMTP sends users asynchronous updates about their tasks. The app is built with next.js and typescript and we use:",
        "how_its_made": "The app is built with next.js and typescript and we use:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gfwo5/screenshots/ntm8f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gfwo5/screenshots/yrr9h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gfwo5/screenshots/8d2d1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gfwo5/screenshots/xde3i/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/tkeith/aloria",
        "link": "https://ethglobal.com/showcase/aloria-gfwo5"
    },
    {
        "title": "HOA Insight",
        "brief_description": "Home Owners Association Board Members want to do right by their communities. HOA Insight Smart Contracts help Board Members evaluate and vote on Proposals, Quotes and Funds Allocation, with transparency to their community.",
        "long_description": "The Home Owners Association Board Members don't always to do right by their community when evaluating proposals and finding high quality contractors to fulfill those proposals. That said, most of them also have full-time jobs, and time is limited. A home owner brought them the idea of setting up a HOAInsight Smart Contract. When a new proposal is brought to the HOA, they enter the Project Requirements and the Budget in HOAInsight. All Board Members receive a notification to vote on it in the mobile app. If the proposal receives unanimous vote (as written in Redwood Greens Bylaws), the funds are made available to the HOA Treasurer. Those funds can now be used to pay contracting company's invoice. We began the project using Miro for brainstorming and gathering essential tools to help us build the prototype. For the UI, we used Figma to design a seamless user experience. To generate demo data, we utilized AI tools like ChatGPT and Perplexity. Our tech stack includes HTML, CSS, JavaScript, with Next.js and React for front-end development, while Node.js powers the backend. We also integrated Hardhat for smart contract development, Remix, and Rainbow Wallet for seamless wallet connectivity.",
        "how_its_made": "We began the project using Miro for brainstorming and gathering essential tools to help us build the prototype. For the UI, we used Figma to design a seamless user experience. To generate demo data, we utilized AI tools like ChatGPT and Perplexity. Our tech stack includes HTML, CSS, JavaScript, with Next.js and React for front-end development, while Node.js powers the backend. We also integrated Hardhat for smart contract development, Remix, and Rainbow Wallet for seamless wallet connectivity.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5bc3h/screenshots/m1wgi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5bc3h/screenshots/p4bg1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5bc3h/screenshots/qgakj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/aldenio/hoa",
        "link": "https://ethglobal.com/showcase/hoa-insight-5bc3h"
    },
    {
        "title": "$deeproot",
        "brief_description": "Build a bitcoin  meme-defi dAPP  on RootStock protocol, implementing Reflection Token Reward Logic",
        "long_description": "We built and deployed a rootstock smart contract implementation from scratch. This project involves developing a  A Bitcoin meme-defi-DAO-governance dAPP  on RootStock , with Reflection Token  Logic  in BitMask web wallet.  We equally built and deployed ERC20, ERC721, IERC20 token standards in Rootstock. The reflection mechanism rewards token holders through automatic reflections or dividends from transactions, encouraging long-term holding. The dApp is deployed within the BitMask Wallet, enabling users to seamlessly interact with the decentralized financial ecosystem built on Bitcoin. The integration with MetaMask allows users to connect their MetaMask wallet to interact with the dApp, facilitated by RainbowKit, a popular library for wallet connection. The deployment of the RootStock smart contract enables secure, scalable, and low-cost financial transactions using Bitcoin's Layer 2. The smart contract will manage reflection rewards and allow users to participate in liquidity pools. $deeproot not only bridges Bitcoin and Ethereum\u2019s DeFi ecosystem but also establishes a solid foundation for future Bitcoin-evm financial applications. Smart Contract Development on RootStock (RSK) we built an ERC-20 token smart contract using Solidity on RootStock with built-in reflection mechanisms. Reflection tokens automatically redistribute a percentage of each transaction to holders based on their holdings, creating passive income.\nThis contract would include methods like transfer, approve, and rewardDistribution. Implement the logic so that each transaction applies a fee that gets distributed among token holders. Integration with BitMask Web Wallet and MetaMask\nWe used RainbowKit to bridge the interaction between MetaMask and BitMask. This will allow users to connect their MetaMask wallet to BitMask's dApp where the contract is deployed. We built a frontend web-based user interface (UI) for the dApp, allowing users to:\nView balances, interact with the contract, such as buying or transferring tokens. We made sure that RootStock is set as a custom network in MetaMask. verifying details such as the RPC URL, chain ID, and network name.",
        "how_its_made": "Smart Contract Development on RootStock (RSK) we built an ERC-20 token smart contract using Solidity on RootStock with built-in reflection mechanisms. Reflection tokens automatically redistribute a percentage of each transaction to holders based on their holdings, creating passive income.\nThis contract would include methods like transfer, approve, and rewardDistribution. Implement the logic so that each transaction applies a fee that gets distributed among token holders. Integration with BitMask Web Wallet and MetaMask\nWe used RainbowKit to bridge the interaction between MetaMask and BitMask. This will allow users to connect their MetaMask wallet to BitMask's dApp where the contract is deployed. We built a frontend web-based user interface (UI) for the dApp, allowing users to:\nView balances, interact with the contract, such as buying or transferring tokens. We made sure that RootStock is set as a custom network in MetaMask. verifying details such as the RPC URL, chain ID, and network name.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/1cuho/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/4zpuw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/6vasc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/7atp2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/bkxg4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/1iyi6/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/trevor-ofarrell/rootstock-hardhat-starterkit",
        "link": "https://ethglobal.com/showcase/deeproot-dm8yg"
    },
    {
        "title": "EAT Global",
        "brief_description": "EAT stands for \"Epicurean Advice & Travel\" and lets users post reviews about their food and travel experiences, and allows users to collaborate to generate curated food guides.  Share, Eat, and Earn.",
        "long_description": "We looked at the travel and food review industry and the problem of personal recommendations versus generic recommendations, The problem EAT Global solves: It\u2019s a fragmented and time consuming process narrowing down places to eat in a new city Not always possible to find personal recommendations for every city you visit Traditional web 2 food reviewers are not yet able to participate in the IP economy and post valuable content without any future monetization potential EAT Global is a dApp that allows users to: Easily post Reviews of their food experiences with licensing and royalties using Story Protocol Generate curated food guides in collaboration with others Get rewarded for their reviews and an opportunity to sell to media and travel websites who want to feature their reviews and guides in their content Please see our pitch here: https://www.canva.com/design/DAGUEzO98bU/jL1l0FFAm6lqmq-YneFajg/view?utm_content=DAGUEzO98bU&utm_campaign=designshare&utm_medium=link&utm_source=editor Story Protocol and Dynamic.  We focused on implementing the \"Proof of Creativity\" protocol and worked on the royalty and the licensing contracts as well as creating derivative works with linage in our travel guide offering. The visualization of the Story explorer is very informative and helped us with building and testing and exploring the IP assets on the Story network.  Speaking with the Story team was very helpful and guided us towards a successful completion.  We used the Typescript SDK and look forward to also using the React SDK next time. We decided to implement this MVP live at the hackathon by conducting food reviews of the food trucks that were on site. We have focused on the beneifts of using easy sign-on with Dynamic and the benefits of Story, including curating food guides, bring social proof on home page, and ability to generate rewards via NFT badges indicating those who post more.",
        "how_its_made": "Story Protocol and Dynamic.  We focused on implementing the \"Proof of Creativity\" protocol and worked on the royalty and the licensing contracts as well as creating derivative works with linage in our travel guide offering. The visualization of the Story explorer is very informative and helped us with building and testing and exploring the IP assets on the Story network.  Speaking with the Story team was very helpful and guided us towards a successful completion.  We used the Typescript SDK and look forward to also using the React SDK next time. We decided to implement this MVP live at the hackathon by conducting food reviews of the food trucks that were on site. We have focused on the beneifts of using easy sign-on with Dynamic and the benefits of Story, including curating food guides, bring social proof on home page, and ability to generate rewards via NFT badges indicating those who post more.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/izfgq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/tt302/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/at6g5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/9dz1p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/kz6av/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/gr01u/default.jpg"
        ],
        "live_demo": "https://eatglobal.vercel.app/ ",
        "source_code": "https://github.com/Dangoz/EthSF",
        "link": "https://ethglobal.com/showcase/eat-global-hdcq6"
    },
    {
        "title": "Neurosaurs",
        "brief_description": "A concentration game powered by the Neurosity Crown! Mint Neurosaur NFTs depending on how focused you are during the game.",
        "long_description": "Unlock the power of your mind with our concentration game powered by the Neurosity Crown! Dive into the classic Chrome Dino game like never before, where your focus determines the outcome. As you play, the Neurosity Crown tracks your concentration levels in real-time, transforming your mental focus into digital rewards. The more you concentrate, the better the rare dino NFT you'll receive as a testament to your skills. It's not just a game; it's a unique fusion of neurotechnology and blockchain that turns your mental prowess into collectible assets. Train your brain, level up your focus, and collect exclusive NFTs to show off your mental game!",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/a8r8k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/jin6g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/v25ra/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/wnvwy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/vzzj4/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MattWong-ca/neurosaurs",
        "link": "https://ethglobal.com/showcase/neurosaurs-4ymov"
    },
    {
        "title": "MAO One",
        "brief_description": "Chat GPT use twitter posts and onchain data to trustless manage funds via Intell SGX, XMTP and Smart Contract.",
        "long_description": "The service to create machine-controlled Smart Contracts. These organizations are managed autonomously and transparently\u2014without any human interference! At the core of MAO lies the integration of advanced security and cryptographic technologies, granting AI unconditional control over users' funds. To obtain real-world information, MAO One relies on X.com (formerly Twitter)\u2014the most open social platform supporting free speech. Users can submit a tweet from an account (whether personal, organizational, or governmental) to verify real-world events. For example, users could submit an election result tweet from the @POTUS account to confirm the outcome. This enables MAO to respond to real-world events promptly and support community members efficiently. Every government has its laws to guide decisions, and in MAO, these laws are captured in the Manifest\u2014the organization\u2019s core document. The Manifest defines: MAO is built around Intel SGX (Software Guard Extensions) technology. These specialized chips run immutable code in a secure, isolated environment and are capable of generating cryptographic signatures. On October 19, 2024, the first instance\u2014\"MAO One\"\u2014was deployed within an SGX chip. This instance guarantees the secure operation of all MAO systems. The process begins when MAO One listens for anonymous messages via the XMTP protocol. Upon receiving a request, the message is forwarded to the central controller\u2014ChatGPT. Communications between MAO One and ChatGPT servers are encrypted using pre-configured TSL certificates, ensuring that no third party can interfere. If the controller authorizes a transaction, MAO One signs it with its private key and sends the signed transaction back to the user via XMTP. The user can then execute the transaction on a blockchain. MAO One can fetch on-chain data from TheGraph via a secure TSL channel. This enables ChatGPT to access essential blockchain information, such as token balances, prices, holders, and transaction volumes. This data allows MAO to make informed decisions based on current blockchain states. Thanks to Intel SGX technology, the \"MAO One\" code is immutable and cannot be altered. All MAOs built on this platform operate exclusively through ChatGPT.",
        "how_its_made": "MAO is built around Intel SGX (Software Guard Extensions) technology. These specialized chips run immutable code in a secure, isolated environment and are capable of generating cryptographic signatures. On October 19, 2024, the first instance\u2014\"MAO One\"\u2014was deployed within an SGX chip. This instance guarantees the secure operation of all MAO systems. The process begins when MAO One listens for anonymous messages via the XMTP protocol. Upon receiving a request, the message is forwarded to the central controller\u2014ChatGPT. Communications between MAO One and ChatGPT servers are encrypted using pre-configured TSL certificates, ensuring that no third party can interfere. If the controller authorizes a transaction, MAO One signs it with its private key and sends the signed transaction back to the user via XMTP. The user can then execute the transaction on a blockchain. MAO One can fetch on-chain data from TheGraph via a secure TSL channel. This enables ChatGPT to access essential blockchain information, such as token balances, prices, holders, and transaction volumes. This data allows MAO to make informed decisions based on current blockchain states. Thanks to Intel SGX technology, the \"MAO One\" code is immutable and cannot be altered. All MAOs built on this platform operate exclusively through ChatGPT.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/da928/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/c8i2d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/wx2ys/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/r2sf3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/7zb5n/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/pvolnov/sgx-ai-dao",
        "link": "https://ethglobal.com/showcase/mao-one-wyviu"
    },
    {
        "title": "TrailLink",
        "brief_description": "An open Protocol for Marketing Teams to launch campaigns and events onchain",
        "long_description": "We built an NFT ticketing and event curation platform that allows users to mint an NFT for entrance to an event and then go through guided/curated tasks that can earn them points for attend IRL events. This helps protocols incentivize and reward users who show up no only onchain but in real life as well. All interactions happen through a Telegram App with virtually no wallet or gas interactions making this a user friendly onchain activity for anyone. The two frontends (one for marketers and one for end users) are built with Next JS. With one of the frontends deployed as a web page and the user facing one deployed as a Telegram Mini App. We deployed our smart contracts on Polygon, any marketer can deploy NFT campaigns and create tasks without any code thanks to our factory contract on the Polygon Testnet. And we leverage Dynamic for wallets as well as ZeroDev to help with Account Abstraction for better user experience.",
        "how_its_made": "The two frontends (one for marketers and one for end users) are built with Next JS. With one of the frontends deployed as a web page and the user facing one deployed as a Telegram Mini App. We deployed our smart contracts on Polygon, any marketer can deploy NFT campaigns and create tasks without any code thanks to our factory contract on the Polygon Testnet. And we leverage Dynamic for wallets as well as ZeroDev to help with Account Abstraction for better user experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tfpov/screenshots/yox2z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tfpov/screenshots/jnyp5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tfpov/screenshots/co3g6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tfpov/screenshots/o27kr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kasba96/tg-app",
        "link": "https://ethglobal.com/showcase/traillink-tfpov"
    },
    {
        "title": "Stackr ERC721",
        "brief_description": "Modular implementation of ERC721 in Stackr deployed on AvailDA",
        "long_description": "The general idea was to play with Stackr, a framework to build rollups. For this, I wanted to develop a project that relies on known open standards, namely ERC-721 in this case. The idea was to be able to: However, it turns out that Stackr cannot do async transitions, so the image generation part is not quite possible. I thus ended up just playing with Stackr and implementing ERC-721 in a nice and extensible way instead and to deploy the result with Avail as the DA. It mostly just uses Stackr's SDK and CLI. The ERC-721 implementation is based on Solmate's, and quite some work went into architecture decisions to be able to easily import the base ERC-721 functions and extend the ones necessary for the application. A lot of thought also went into types.",
        "how_its_made": "It mostly just uses Stackr's SDK and CLI. The ERC-721 implementation is based on Solmate's, and quite some work went into architecture decisions to be able to easily import the base ERC-721 functions and extend the ones necessary for the application. A lot of thought also went into types.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/15c7x/screenshots/br4uk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/15c7x/screenshots/7xpq1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/15c7x/screenshots/i2hcf/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/filoozom/mru-nfts",
        "link": "https://ethglobal.com/showcase/stackr-erc721-15c7x"
    },
    {
        "title": "Meta Splash",
        "brief_description": "Beautiful lock screens for MetaMask. We redesigned the lock screen for most used crypto wallet MetaMask.",
        "long_description": "To make Ethereum more inviting, we redesigned the lock screen for most used crypto wallet MetaMask. MetaMask wallet is the entry point to Ethereum user experience. Current wallet lock screen is sterile and overly functional, making the first impression technical and uninviting. Proposed lock screen offers wide range of graphics. Users can chose from simple colors to extravagant patterns. We used Adobe Illustrator for vector graphics and Stable Diffusion for graphic backgrounds. Application of the lock screen redesign would involve partnership with existing wallet projects or creation of a custom wallet or DAP. The other screen asking for a stylistic redesign is the wait screen displayed to users while they wait for smart contract execution.",
        "how_its_made": "We used Adobe Illustrator for vector graphics and Stable Diffusion for graphic backgrounds. Application of the lock screen redesign would involve partnership with existing wallet projects or creation of a custom wallet or DAP. The other screen asking for a stylistic redesign is the wait screen displayed to users while they wait for smart contract execution.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/ijkti/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/me9qx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/rs8zy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/z081n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/fqiet/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/xk9yj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/d86us/metasplash",
        "link": "https://ethglobal.com/showcase/meta-splash-suf85"
    },
    {
        "title": "freeTrader",
        "brief_description": "A smart contract that trade according to user defined price and real time price",
        "long_description": "This prj include both smart contract piece and a frontend This prj include both smart contract piece and a frontend\nThe smart contract is written in solidity.\nThe frontend is written using NextJS framework. Key Elements\nUser-defined price: A function that allows the user to set a price.\nOracle integration: Use a Chainlink oracle (or another service like Chronicle) to fetch real-time price data.\nUniswap interaction: Utilize Uniswap\u2019s contract to swap USDC for ETH when a condition is met.",
        "how_its_made": "This prj include both smart contract piece and a frontend\nThe smart contract is written in solidity.\nThe frontend is written using NextJS framework. Key Elements\nUser-defined price: A function that allows the user to set a price.\nOracle integration: Use a Chainlink oracle (or another service like Chronicle) to fetch real-time price data.\nUniswap interaction: Utilize Uniswap\u2019s contract to swap USDC for ETH when a condition is met.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/cjm7o/screenshots/q58wi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cjm7o/screenshots/tjhx8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cjm7o/screenshots/35pia/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/thinkvic/hacksf2024",
        "link": "https://ethglobal.com/showcase/freetrader-cjm7o"
    },
    {
        "title": "StoryVerse",
        "brief_description": "Authors craft unique universes by defining key elements such as lore, environments, characters, and interactions. Build off another author's world, protect your IP and receive royalties.",
        "long_description": "Alex, a passionate fantasy writer, uses our platform to create an expansive new universe. With advanced IP technology, Alex defines the licensing terms, allowing fans to legally build upon their favorite worlds. Fans contribute by crafting new stories within Alex\u2019s world, earning money for their work, while Alex earns royalties from each derivative. As the platform evolves, Alex's fans will be able to buy or rent stories, using encrypted smart contracts to ensure fair payment and limited-time access to the content, expanding Alex's universe with every contribution. We combine IP technology, and harness the power of fans to expand on artistic universes and explore new frontiers of their favorite worlds. We enable fans to earn money for their contributions while sharing a fair amount with the original creator as well. We plan to support the full E2E marketplace in the future, allowing folks to buy/rent content and we will implement that using an encryption protocol with smart contract conditional permissioning based on an expiration date that gets set on the user when they pay for access and it's incremented every time they pay for more access. We use Story to power our IP, Pi\u00f1ata to store the works themselves, and dynamic for our authentication flow. We integrated with the story-sdk, dynamic's sample application / sdk, and pi\u00f1atas SDK. Story handled generating an IP object that stored an ID corresponding to a Pi\u00f1ata object that contained the summary of the artist's world itself.",
        "how_its_made": "We use Story to power our IP, Pi\u00f1ata to store the works themselves, and dynamic for our authentication flow. We integrated with the story-sdk, dynamic's sample application / sdk, and pi\u00f1atas SDK. Story handled generating an IP object that stored an ID corresponding to a Pi\u00f1ata object that contained the summary of the artist's world itself.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/7to6s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/fonh3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/6raqe/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/q4kbn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/f60oe/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/2r7hy/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/parsaattari/storyverse",
        "link": "https://ethglobal.com/showcase/storyverse-hot66"
    },
    {
        "title": "Betsy",
        "brief_description": "A Web3 betting platform on Skale with XMTP-powered messaging for group bets. USDC funds are transparently handled via smart contracts, and AI helps determine outcomes. Bets are finalized and resolved on-chain, ensuring secure, trustless, and engaging group betting experiences.",
        "long_description": "Betsy is a Web3-based group betting platform that allows friends and communities to place bets on sporting events in a decentralized, transparent, and fun way on SKALE blockchain. It uses XMTP's Converse app to leverage its group messaging feature and user wallets to create an immersive experience that allows people to place bets while they message and have fun. When a bet is created, group members can chat, agree or disagree with the predictions, and place their wagers, all within the platform. This makes betting more engaging and interactive, creating a shared experience around sporting events. Once the bet is finalized, smart contracts automatically move the funds, ensuring that everyone\u2019s contributions are handled fairly and securely. Additionally, the platform uses AI to analyze real-time sports data and help determine the outcome of each bet, ensuring accuracy and fairness. Once the game is over, the AI checks whether the prediction was correct, and the smart contracts distribute the winnings or losses accordingly. This combination of blockchain, decentralized messaging, and AI creates a seamless, fully automated betting experience where users can enjoy betting with friends, all while having complete control over their funds and the outcome. This project was built on the SKALE blockchain, taking advantage of its gas-free transactions, making it cost-efficient for users placing bets. We integrated XMTP\u2019s Converse app for decentralized messaging, allowing users to communicate in real-time, propose bets, and vote within group chats securely. The platform uses OpenAI's language models (LLMs) to parse user prompts, interpret natural language queries, and interact with external sports data feeds. This helps verify that games exist and process bet outcomes based on real-time sports data. The LLMs also assist in generating responses, making the interaction more natural and efficient. We implemented agents that monitor for specific triggers in user messages, such as bet prompts, agreements, or disagreements. These agents parse the commands, triggering actions such as fund transfers and game creation on-chain. All bets and outcomes are managed by smart contracts, ensuring that the process is fully trust-less and automated. The integration of ethers.js manages blockchain interactions, particularly for handling USDC approvals and fund transfers to the smart contract.",
        "how_its_made": "This project was built on the SKALE blockchain, taking advantage of its gas-free transactions, making it cost-efficient for users placing bets. We integrated XMTP\u2019s Converse app for decentralized messaging, allowing users to communicate in real-time, propose bets, and vote within group chats securely. The platform uses OpenAI's language models (LLMs) to parse user prompts, interpret natural language queries, and interact with external sports data feeds. This helps verify that games exist and process bet outcomes based on real-time sports data. The LLMs also assist in generating responses, making the interaction more natural and efficient. We implemented agents that monitor for specific triggers in user messages, such as bet prompts, agreements, or disagreements. These agents parse the commands, triggering actions such as fund transfers and game creation on-chain. All bets and outcomes are managed by smart contracts, ensuring that the process is fully trust-less and automated. The integration of ethers.js manages blockchain interactions, particularly for handling USDC approvals and fund transfers to the smart contract.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9qx39/screenshots/0bmw0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9qx39/screenshots/v0m9g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9qx39/screenshots/8u8kx/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ItsAdel/ethglobalsf2024",
        "link": "https://ethglobal.com/showcase/betsy-9qx39"
    },
    {
        "title": "SmolSend",
        "brief_description": "Send tokens to friends via a link, without them needing a wallet upfront",
        "long_description": "I want to send tokens to a friend that has never used crypto before. Traditionally, I would ask them to install metamask, they would proceed to download it and send me their address, and I would then send them the tokens. Wouldn't it be cool if we could send them a link that held crypto such that as soon as they onboarded they could play around with those tokens? Also, if I wanted to send tokens to my favorite Twitter KOL, they would want a way to receive the tokens without doxxing their wallet address to me The key insight here is that embedded wallets plus simple use of a hash function allows users to sign in with google to claim the tokens trustlessly This app is best viewed on a mobile browser! It is built with next pwa and is mobile first. Walrus: The Graph:\nWe use this to make sure users aren't submitting a duplicate password! Dynamic: Supported Chains:",
        "how_its_made": "This app is best viewed on a mobile browser! It is built with next pwa and is mobile first. Walrus: The Graph:\nWe use this to make sure users aren't submitting a duplicate password! Dynamic: Supported Chains:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/0vtv1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/e0ms9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/kp0it/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/c9suv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/m9e9d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/wnrao/default.jpg"
        ],
        "live_demo": "https://smolsend.vercel.app/",
        "source_code": "https://github.com/AlbertSu123/linkToLambo",
        "link": "https://ethglobal.com/showcase/smolsend-n3gsh"
    },
    {
        "title": "OmnichainFHEAuction",
        "brief_description": "Using fully-homomorphic encryption on Fhenix to implement second-price sealed bid auctions, and using LayerZero to allow bids from any chain, unifying liquidity: a global secret auction across all chains.",
        "long_description": "Auction creator creates an auction contract on Fhenix: The auction creator sets an auction start / end date, minimum bid, and code to run when the auction is won (e.g. automatically send an NFT). This code can be run cross-chain using LayerZero.\nUser visits our frontend, they want to bid on X Chain\nWe use Fhenix\u2019s FHE frontend library to encrypt their bid.\nEncrypted bid is sent to our bid submission smart contract on X Chain.\nWe also ask the user to approve the bid submission smart contract as a spender for UINT256_MAX\nWe use LayerZero to send the encrypted bid to our auction smart contract on Fhenix.\nThe auction contract stores the encrypted bit and the chain from which the bid originated.\nSince it\u2019s difficult to install on LayerZero on new chains, we\u2019re actually sending via Sepolia (the base cain for the Fhenix L2)\nAt the end of the auction period, the contract uses FHE to compare all bids and determine which bid is the highest\nWe use LayerZero to send a message back to the chain from which the bid originated and transfer the assets from the winning bidder.\nIf the transfer is unsuccessful, LayerZero can send message back and Fhenix contract can move on to next highest bidder Frontend which can grab data from Fhenix to show auction status and can send data to X Chain to submit bids\nFigure out how encrypt data with the Fhenix JS SDK and send it as arbitrary bytes to another smart contract Auction smart contract on Fhenix\nFigure out how to compare different encrypted values on Fhenix\nhttps://github.com/FhenixProtocol/blind-auction-example Bid submission contract on any L1 we want to support\nFigure out how to accept encrypted bytes LayerZero infrastructure to send data to and from other L1s and Fhenix\nFigure out how to send data between chains",
        "how_its_made": "Frontend which can grab data from Fhenix to show auction status and can send data to X Chain to submit bids\nFigure out how encrypt data with the Fhenix JS SDK and send it as arbitrary bytes to another smart contract Auction smart contract on Fhenix\nFigure out how to compare different encrypted values on Fhenix\nhttps://github.com/FhenixProtocol/blind-auction-example Bid submission contract on any L1 we want to support\nFigure out how to accept encrypted bytes LayerZero infrastructure to send data to and from other L1s and Fhenix\nFigure out how to send data between chains",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h4q81/screenshots/052is/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h4q81/screenshots/muu1t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h4q81/screenshots/1apo5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/nathanhleung/ethglobal",
        "link": "https://ethglobal.com/showcase/omnichainfheauction-h4q81"
    },
    {
        "title": "Things2Do",
        "brief_description": "Our Discovery Feed curates relevant news and offers based on user transaction history, driving higher engagement. By promoting actionable content, it boosts user retention, reduces churn, and encourages transactions.",
        "long_description": "Our Discovery Feed leverages the GrowthMate API to analyze user transaction history and rank posts based on individual interests. By interpreting on-chain activity, the API ensures users see content most relevant to them, including actionable news, offers, and suggested dApps. Users can choose the chain they want to explore and input any address to view content curated for that specific transaction history. This approach drives engagement by delivering personalized, interest-aligned recommendations, enhancing user retention and increasing the likelihood of completing transactions. This submission is frontend integration to the GrowthMate General Purpose Ranking API. The webpage was built using a default Vite React stack.",
        "how_its_made": "This submission is frontend integration to the GrowthMate General Purpose Ranking API. The webpage was built using a default Vite React stack.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pugqi/screenshots/9k9t0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pugqi/screenshots/3h7be/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pugqi/screenshots/t1yca/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/lennczar/eth-global-sf-2024",
        "link": "https://ethglobal.com/showcase/things2do-pugqi"
    },
    {
        "title": "ChainSage",
        "brief_description": "ChainSage: AI-powered DeFi strategy optimizer across multiple chains. Leverages Zircuit for high-performance smart contracts, LayerZero for cross-chain messaging, and Phala Network for confidential AI computations. Maximize your DeFi returns with personalized, secure insights.",
        "long_description": "ChainSage is an innovative AI-powered DeFi strategy optimizer that operates across multiple blockchain networks. The project aims to solve the challenge of identifying optimal investment strategies in the rapidly evolving DeFi landscape. It does this by aggregating strategies from various chains, using artificial intelligence to analyze and recommend optimal strategies based on user preferences, and providing a user-friendly interface for strategy comparison and selection.\nThe project leverages a sophisticated technology stack, including React.js for the frontend, Solidity for smart contracts, TensorFlow.js for AI modeling, and is primarily deployed on the Zircuit Testnet. It utilizes LayerZero for cross-chain messaging and Phala Network for confidential computing, ensuring privacy and security in AI computations. The core smart contract, ChainSageOApp, manages strategies across different chains and includes functions for adding strategies, retrieving data, and optimizing strategies cross-chain. With its focus on user experience, cross-chain functionality, and AI-driven insights, ChainSage represents a cutting-edge approach to DeFi strategy optimization, aiming to provide users with secure, efficient, and personalized investment recommendations across the fragmented DeFi ecosystem. This project is built on a foundation of Solidity smart contracts, with the main ChainSageOApp contract inheriting from LayerZero's OApp for cross-chain functionality. This allows ChainSage to manage and optimize DeFi strategies across various blockchain networks.\nThe frontend is developed using React.js, providing a user-friendly interface for interacting with the DeFi strategies. Key components include AIOptimizer for strategy fetching and optimization, StrategyDisplay for rendering strategy items, and WalletConnection for managing user wallet connections. The project integrates TensorFlow.js for AI-driven strategy analysis and recommendations, while Ethers.js facilitates blockchain interactions.\nChainSage incorporates several cutting-edge technologies to enhance its functionality and security. LayerZero's protocol enables cross-chain messaging and strategy optimization across different networks. Phala Network's SDK is integrated to ensure the privacy and security of AI model computations through confidential computing in a Trusted Execution Environment (TEE). The smart contracts are deployed on the Zircuit Testnet, taking advantage of its EVM-compatible environment, while the frontend is hosted on Vercel for reliable and fast access.\nThe development process included addressing challenges such as cross-chain data consistency and simulating AI decision-making for the hackathon demo. The project demonstrates the potential for sophisticated and secure DeFi applications by integrating blockchain technologies with AI, showcasing innovative solutions for DeFi strategy optimization across multiple chains.",
        "how_its_made": "This project is built on a foundation of Solidity smart contracts, with the main ChainSageOApp contract inheriting from LayerZero's OApp for cross-chain functionality. This allows ChainSage to manage and optimize DeFi strategies across various blockchain networks.\nThe frontend is developed using React.js, providing a user-friendly interface for interacting with the DeFi strategies. Key components include AIOptimizer for strategy fetching and optimization, StrategyDisplay for rendering strategy items, and WalletConnection for managing user wallet connections. The project integrates TensorFlow.js for AI-driven strategy analysis and recommendations, while Ethers.js facilitates blockchain interactions.\nChainSage incorporates several cutting-edge technologies to enhance its functionality and security. LayerZero's protocol enables cross-chain messaging and strategy optimization across different networks. Phala Network's SDK is integrated to ensure the privacy and security of AI model computations through confidential computing in a Trusted Execution Environment (TEE). The smart contracts are deployed on the Zircuit Testnet, taking advantage of its EVM-compatible environment, while the frontend is hosted on Vercel for reliable and fast access.\nThe development process included addressing challenges such as cross-chain data consistency and simulating AI decision-making for the hackathon demo. The project demonstrates the potential for sophisticated and secure DeFi applications by integrating blockchain technologies with AI, showcasing innovative solutions for DeFi strategy optimization across multiple chains.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/ucdv8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/n4y5n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/cce9r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/bbq7s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/1kvvb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/pgxb5/default.jpg"
        ],
        "live_demo": "https://chain-sage.vercel.app/",
        "source_code": "https://github.com/ajag408/ChainSage",
        "link": "https://ethglobal.com/showcase/chainsage-0pwyv"
    },
    {
        "title": "tinder for memecoins",
        "brief_description": "tinder for memecoins is a telegram mini app that lets you swipe right to purchase a memecoin",
        "long_description": "swipe right to buy, swipe left to load the next meme coin! no selling allowed. buys are pre-approved amounts. View a coins stats and charts and swipe once to buy the coin! This is all done within telegram's chat UI through a bot as a mini app. Swipe to go to the moon instead of getting rejected on traditional tinder! react project using react-tinder-card library and version 18 + 0x API for swaps & privy for telegram mini app authentication and wallet creation swaps on ethereum sepolia testnet from WETH --> UNI using 0x protocols swaps api very hacky and broken in it's current state but able to auth in, swipe through coins and send a swap through 0x protocol's swaps api & privy wallet",
        "how_its_made": "react project using react-tinder-card library and version 18 + 0x API for swaps & privy for telegram mini app authentication and wallet creation swaps on ethereum sepolia testnet from WETH --> UNI using 0x protocols swaps api very hacky and broken in it's current state but able to auth in, swipe through coins and send a swap through 0x protocol's swaps api & privy wallet",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/q3i3k/screenshots/2102f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q3i3k/screenshots/zeg7g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q3i3k/screenshots/mn3e1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MikeDank/ethglobalsf",
        "link": "https://ethglobal.com/showcase/tinder-for-memecoins-q3i3k"
    },
    {
        "title": "racoon-crypto-ai",
        "brief_description": "Imagine being able to interact with your favorite protocols, but this time with a chat interface",
        "long_description": "Imagine seamlessly interacting with your favorite blockchain protocols through a chat interface, where complex transactions and interactions become as simple as sending a message. Whether you\u2019re managing DeFi assets, swapping tokens, or exploring NFTs, you can now do it all through an intuitive conversation, making the experience more accessible and user-friendly. No more navigating complicated UIs or remembering contract addresses\u2014just a natural conversation that helps you perform the actions you want, effortlessly. This is the future of decentralized interaction, where blockchain meets simplicity through chat. I took two projects and combined them together. I plugged in a eth scaffold template alongside an open llm chat and got this. Used Dynamic for account management. The llm actually runs inside of the browser preventing any data leaking. Alongside this, messages and chats are saved locally",
        "how_its_made": "I took two projects and combined them together. I plugged in a eth scaffold template alongside an open llm chat and got this. Used Dynamic for account management. The llm actually runs inside of the browser preventing any data leaking. Alongside this, messages and chats are saved locally",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/r0vyu/screenshots/wu9vd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r0vyu/screenshots/zccip/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r0vyu/screenshots/b3eav/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ben-jamming-reilly/racoon-crypto-ai?tab=readme-ov-file",
        "link": "https://ethglobal.com/showcase/racoon-crypto-ai-r0vyu"
    },
    {
        "title": "Easypeace",
        "brief_description": "There is room for improvement as to how we navigate conflict. Easy peace helps with that.",
        "long_description": "Easy Peace is an AI-driven mediation app designed to help individuals and couples resolve relationship conflicts through thoughtful, diplomatic guidance. Whether you're navigating communication barriers, emotional misunderstandings, or complex relationship dynamics, EasyPeace provides a safe space for reflection, resolution, and growth. A heartfelt thanks goes out to the incredible teams behind the technology that makes this peace mediation tool possible. Most of the magic in untangling conflicts and fostering better communication is driven by the powerful AI agent, thanks to the innovative advancements from OpenAI. Their work has provided us with the tools to create meaningful solutions, offering thoughtful rephrasing and suggestions that allow both parties to find common ground. We also extend our deep appreciation to Privy.io for their invaluable support in safeguarding user privacy and handling sensitive data responsibly. Their expertise in privacy matters ensures that our platform not only facilitates conflict resolution but also maintains the highest standards of data protection and user trust. Their contributions to Frontend Matters have been essential in creating a secure, user-friendly experience for all involved. Thank you to both OpenAI and Privy.io for helping to make this mediation tool a reality, empowering people to resolve conflicts while feeling safe and supported.",
        "how_its_made": "A heartfelt thanks goes out to the incredible teams behind the technology that makes this peace mediation tool possible. Most of the magic in untangling conflicts and fostering better communication is driven by the powerful AI agent, thanks to the innovative advancements from OpenAI. Their work has provided us with the tools to create meaningful solutions, offering thoughtful rephrasing and suggestions that allow both parties to find common ground. We also extend our deep appreciation to Privy.io for their invaluable support in safeguarding user privacy and handling sensitive data responsibly. Their expertise in privacy matters ensures that our platform not only facilitates conflict resolution but also maintains the highest standards of data protection and user trust. Their contributions to Frontend Matters have been essential in creating a secure, user-friendly experience for all involved. Thank you to both OpenAI and Privy.io for helping to make this mediation tool a reality, empowering people to resolve conflicts while feeling safe and supported.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mo3do/screenshots/ro9c7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mo3do/screenshots/vvqox/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mo3do/screenshots/7ckj9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/PiaVictoria21/easypeace",
        "link": "https://ethglobal.com/showcase/easypeace-mo3do"
    },
    {
        "title": "Omni Castles",
        "brief_description": "In Omni Castles, players conquer castles across blockchains, using Skale\u2019s gasless battles, Fhenix\u2019s hidden armies with Acurast weather, and Rootstock\u2019s Bitcoin-based morale. Control 70% of castles to be crowned Emperor\u2014each requiring a unique strategy!",
        "long_description": "Omni Castles is a game where players must conquer and hold multiple castles across different blockchains. To be crowned Emperor, a player must control at least 70% -  (Math.ceil(0.7 * number_of_castles)) of all castles. Each castle is built on a unique blockchain, utilizing its strengths to offer diverse gameplay experiences, requiring different strategies to conquer. Skale Castle: This castle requires a massive army due to Skale's ability to handle large computations. Battles are complex and leverage Skale's built-in, gasless randomness. Skale\u2019s scalability makes large-scale battles possible without gas costs. Fhenix Castle: Utilizing Fully Homomorphic Encryption (FHE), this castle hides the defending army, forcing attackers to guess its composition based on previous battles. Acurast Oracle integrates real-time weather data, which affects battle outcomes. AirDAO Castle: Built on a scalable blockchain with high transactions per second (TPS), battles are more resource-intensive than on Fhenix, though not as demanding as on Skale. Rootstock Castle: Closely tied to the price of Bitcoin, the defending army's morale is affected by Bitcoin\u2019s market performance, adding an economic twist to battles. Here are the relevant Github repos: This hackathon is just the start, we ran out of time before implementing a unifying leaderboard (using subgraph) and Near protocol for controlling other EVM chains. In Omni Castles, we used a variety of technologies tailored to the strengths of different blockchains: Skale: Leveraged Skale\u2019s gasless techniques and built-in RNG for large-scale battles. This allowed us to run complex computations without incurring gas costs, which was crucial for smooth gameplay in army-heavy scenarios. AirDAO: Integrated Acurast for oracles, bringing in real-time weather data to affect battles, and used decentralized keepers for automatic execution of tasks, ensuring the game ran autonomously without manual intervention. Fhenix: Also utilized Acurast for weather oracles but added the twist of Fully Homomorphic Encryption (FHE) to hide defender states, requiring attackers to deduce defensive positions based on prior battles. We initially planned to unify these castles using Near for cross-chain actions and Subgraph for leaderboard tracking, but ran out of time before completing those integrations. These would have enhanced the multi-chain functionality and tracking of player progress across all castles. One of the more hacky aspects of Omni Castles is that neither AirDAO nor Fhenix had native oracle support before. This project is the first to introduce Acurast Oracles on these blockchains. Acurast\u2019s Trusted Execution Environment (TEE) forwards Web2 API data, like weather conditions, directly to smart contracts with minimal trust overhead, making it a groundbreaking integration for decentralized gaming mechanics.",
        "how_its_made": "In Omni Castles, we used a variety of technologies tailored to the strengths of different blockchains: Skale: Leveraged Skale\u2019s gasless techniques and built-in RNG for large-scale battles. This allowed us to run complex computations without incurring gas costs, which was crucial for smooth gameplay in army-heavy scenarios. AirDAO: Integrated Acurast for oracles, bringing in real-time weather data to affect battles, and used decentralized keepers for automatic execution of tasks, ensuring the game ran autonomously without manual intervention. Fhenix: Also utilized Acurast for weather oracles but added the twist of Fully Homomorphic Encryption (FHE) to hide defender states, requiring attackers to deduce defensive positions based on prior battles. We initially planned to unify these castles using Near for cross-chain actions and Subgraph for leaderboard tracking, but ran out of time before completing those integrations. These would have enhanced the multi-chain functionality and tracking of player progress across all castles. One of the more hacky aspects of Omni Castles is that neither AirDAO nor Fhenix had native oracle support before. This project is the first to introduce Acurast Oracles on these blockchains. Acurast\u2019s Trusted Execution Environment (TEE) forwards Web2 API data, like weather conditions, directly to smart contracts with minimal trust overhead, making it a groundbreaking integration for decentralized gaming mechanics.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yv5wp/screenshots/bsu1d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yv5wp/screenshots/82u7w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yv5wp/screenshots/g8eha/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Cloakworks-collective/omnicastle_skale",
        "link": "https://ethglobal.com/showcase/omni-castles-yv5wp"
    },
    {
        "title": "ProgressionXR",
        "brief_description": "ProgressionXR blends AI, XR, and Web3 for the ultimate fitness journey! \ud83e\udde0\ud83d\udd76\ufe0f\ud83c\udf0d Train with AI wellness coaches, sync workouts with Fitbit & VR, and earn rewards through fitness challenges while ensuring your privacy with multichain attestations. \ud83d\ude80\ud83d\udcaa",
        "long_description": "ProgressionXR is an innovative platform that combines Artificial Intelligence (AI), Extended Reality (XR), and Web3 technologies to create a truly immersive fitness experience. Users can connect their fitness devices, such as Fitbit and VR headsets, to engage in personalized, real-time workouts. The platform features AI-driven wellness coaches that guide users on their fitness journey, providing tailored advice to help them achieve their goals. With a focus on privacy, ProgressionXR utilizes the Litt X Sign Protocol for privacy-preserved attestations, allowing users to maintain full control over their data. Additionally, the platform offers competitive fitness challenges, where users can predict outcomes, support their favorite teams, and earn exclusive rewards. ProgressionXR's seamless Dynamic integration allows for easy, multichain logins, enhancing the onboarding experience for users across various blockchain ecosystems. ProgressionXR leverages a sophisticated tech stack, blending AI, XR, and Web3 innovations to provide users with an enhanced fitness experience. Phala AI Models: These decentralized AI models power the wellness coaches, offering real-time, personalized fitness advice based on user data and goals, while ensuring privacy through a decentralized approach. XR Integration: Users can sync their Fitbit and VR headsets, creating an immersive fitness journey that tracks workouts in real-time. This provides a fully interactive and engaging fitness experience. Dynamic for Social Logins: The platform uses Dynamic for seamless, multichain logins, allowing users to sign in across various blockchains without any hassle. Litt X Sign Protocol for Privacy Attestations: ProgressionXR integrates the Litt X Sign Protocol to ensure privacy-preserved attestations, allowing users to maintain control over their fitness data in a decentralized and secure way. Fitness Predictions: An integrated oracle enables decentralized prediction markets where users can forecast the outcomes of fitness challenges and earn rewards based on their predictions.",
        "how_its_made": "ProgressionXR leverages a sophisticated tech stack, blending AI, XR, and Web3 innovations to provide users with an enhanced fitness experience. Phala AI Models: These decentralized AI models power the wellness coaches, offering real-time, personalized fitness advice based on user data and goals, while ensuring privacy through a decentralized approach. XR Integration: Users can sync their Fitbit and VR headsets, creating an immersive fitness journey that tracks workouts in real-time. This provides a fully interactive and engaging fitness experience. Dynamic for Social Logins: The platform uses Dynamic for seamless, multichain logins, allowing users to sign in across various blockchains without any hassle. Litt X Sign Protocol for Privacy Attestations: ProgressionXR integrates the Litt X Sign Protocol to ensure privacy-preserved attestations, allowing users to maintain control over their fitness data in a decentralized and secure way. Fitness Predictions: An integrated oracle enables decentralized prediction markets where users can forecast the outcomes of fitness challenges and earn rewards based on their predictions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/84tjv/screenshots/1b2uz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/84tjv/screenshots/94djj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/84tjv/screenshots/650yp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/84tjv/screenshots/qsgbh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ProgressionXR-eth-sanfrancisco/xr-contracts",
        "link": "https://ethglobal.com/showcase/progressionxr-84tjv"
    },
    {
        "title": "Best Consumer App",
        "brief_description": "We make it easy for anyone - even consumers - to \"cook\" code with an AI-assisted interface.",
        "long_description": "Fund.fun is a decentralized, permissionless platform to fund fun projects. The donor seeds a project by staking a designated of amount of cryptocurrency, selecting a source of yield, and designating a recipient of the yield. Other donors can join the pool. The project receives all yield while the donors always have the option to withdraw their principle. I use cookbook.dev to demonstrate the capabilities of its contract library and AI assistance. Cookbook.dev accelerates protocol growth by onboarding developers faster. Cookbook integrates an AI chatbot, dev playground and contract library into a project\u2019s docs. The result is a unified learning, building, and deployment ecosystem so devs can deploy faster and projects can grow their communities.",
        "how_its_made": "I use cookbook.dev to demonstrate the capabilities of its contract library and AI assistance. Cookbook.dev accelerates protocol growth by onboarding developers faster. Cookbook integrates an AI chatbot, dev playground and contract library into a project\u2019s docs. The result is a unified learning, building, and deployment ecosystem so devs can deploy faster and projects can grow their communities.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tcm75/screenshots/hp91h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tcm75/screenshots/eskw8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tcm75/screenshots/6q4w3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/whatupjeff",
        "link": "https://ethglobal.com/showcase/best-consumer-app-tcm75"
    },
    {
        "title": "My Little Quant",
        "brief_description": "AI agent to read charts and tell you where the orderblock is (so you know if it's a good time to buy)",
        "long_description": "When the user presses the chrome extension's button, chrome extension takes a picture of the chart of the asset, and determines where the orderblock is, so that when the asset goes back down to that price, you know it's a good time to buy the asset (because it'll go up). words words words words words words words words words words words words words words words words  words words words words words words words words  words words words words words words words words It's a basic chrome extension. I used the Claude API, React, JS. What inspired me to make this is trying to trade shitcoins and not really knowing when to enter or exit the coin and needing to consult chatgpt to understand these things. words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words",
        "how_its_made": "It's a basic chrome extension. I used the Claude API, React, JS. What inspired me to make this is trying to trade shitcoins and not really knowing when to enter or exit the coin and needing to consult chatgpt to understand these things. words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bmjyb/screenshots/v7q88/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bmjyb/screenshots/d4eau/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bmjyb/screenshots/04w10/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/619/orderblock-detector",
        "link": "https://ethglobal.com/showcase/my-little-quant-bmjyb"
    },
    {
        "title": "Cr\u00e8de",
        "brief_description": "Decentralized platform using Zero-Knowledge(K) circuits for secure identity verification.",
        "long_description": "Introducing a decentralized platform powered by Zero-Knowledge (ZK) circuits, designed to revolutionize secure identity verification. This innovative solution provides a no-code tool for credential issuers to effortlessly create ZK circuits, simplifying the process of building advanced cryptographic proofs. Users benefit by generating trustless on-chain identities, enabling seamless interaction with various online services without compromising their privacy. The platform empowers both individuals and organizations with privacy-preserving identity management. Key Features: Privacy-Focused: Protect user data by proving identity without sharing personal details.\nTrustless Proofs: On-chain verification ensures transparency without requiring trust in intermediaries.\nNo-Code Tools: Simple UI for credential issuers to build ZK circuits without technical expertise.\nVersatile Use Cases: Support for multiple online services across Web3 and traditional platforms.\nUser-Friendly Interface: Intuitive workflows for both users and issuers, fostering adoption and ease of use.\nThis platform redefines digital trust, ensuring secure and private identity verification in the era of decentralized technology. here are some transactions created by the app:\nhttps://juicy-low-small-testnet.explorer.testnet.skalenodes.com/address/0xf7f861870aC67B27322E6f23f3442E660103Ce00?tab=txs\nhttps://amoy.polygonscan.com/tx/0xe6bfe9743a2434291256f2ccc36ffe268e3c01e332e87936d38a2a6df2651fdb\nhttps://testnet.layerzeroscan.com/tx/0xb302e3f543145b58e1b2d45c83f75d650d55201ae93c89415a98e88dc9a6a517 Our platform is built on a robust, scalable, and decentralized architecture that ensures privacy, security, and seamless integration with blockchain ecosystems. The core components of our architecture are: Backend \u2013 Zero-Knowledge Proof Generation\nTechnology: Rust & Circom\nFunctionality: The backend is responsible for generating Zero-Knowledge (ZK) proofs, providing cryptographic assurance of identity without exposing personal information. Rust ensures high performance and security, while Circom enables the creation of complex ZK circuits. Blockchain Layer \u2013 Smart Contracts and Proof Storage\nTechnology: Solidity\nNetwork: SKALE Network\nFunctionality: Smart contracts, written in Solidity, store and manage ZK proofs on-chain, enabling secure, trustless identity verification. The SKALE blockchain provides scalability, low-latency transactions, and interoperability to support seamless identity verification. Incentivization Token\nToken Utility: Encourages adoption and usage of the platform through an incentive model.\nBridge Technology: LayerZero protocol.\nToken Transfer: A cross-chain bridge connects SKALE with the Polygon network, ensuring seamless transfer of tokens between chains for users and incentivizing ecosystem participants. Frontend \u2013 User and Issuer Interface\nTechnology: Next.js\nFunctionality: The frontend offers an intuitive and responsive interface for users and credential issuers. With easy-to-navigate workflows, it allows issuers to create ZK circuits without code and users to generate, manage, and carry trustless on-chain identities across services. This modular and decentralized architecture ensures that the platform remains secure, scalable, and user-friendly. Each component integrates seamlessly to deliver a privacy-preserving, trustless identity verification system, leveraging the best technologies across Rust, Circom, Solidity, and modern blockchain protocols.",
        "how_its_made": "Our platform is built on a robust, scalable, and decentralized architecture that ensures privacy, security, and seamless integration with blockchain ecosystems. The core components of our architecture are: Backend \u2013 Zero-Knowledge Proof Generation\nTechnology: Rust & Circom\nFunctionality: The backend is responsible for generating Zero-Knowledge (ZK) proofs, providing cryptographic assurance of identity without exposing personal information. Rust ensures high performance and security, while Circom enables the creation of complex ZK circuits. Blockchain Layer \u2013 Smart Contracts and Proof Storage\nTechnology: Solidity\nNetwork: SKALE Network\nFunctionality: Smart contracts, written in Solidity, store and manage ZK proofs on-chain, enabling secure, trustless identity verification. The SKALE blockchain provides scalability, low-latency transactions, and interoperability to support seamless identity verification. Incentivization Token\nToken Utility: Encourages adoption and usage of the platform through an incentive model.\nBridge Technology: LayerZero protocol.\nToken Transfer: A cross-chain bridge connects SKALE with the Polygon network, ensuring seamless transfer of tokens between chains for users and incentivizing ecosystem participants. Frontend \u2013 User and Issuer Interface\nTechnology: Next.js\nFunctionality: The frontend offers an intuitive and responsive interface for users and credential issuers. With easy-to-navigate workflows, it allows issuers to create ZK circuits without code and users to generate, manage, and carry trustless on-chain identities across services. This modular and decentralized architecture ensures that the platform remains secure, scalable, and user-friendly. Each component integrates seamlessly to deliver a privacy-preserving, trustless identity verification system, leveraging the best technologies across Rust, Circom, Solidity, and modern blockchain protocols.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/64vph/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/2mies/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/i1ciu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/07kpb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/NJCinnamond/crede",
        "link": "https://ethglobal.com/showcase/crede-pucis"
    },
    {
        "title": "Cr\u00e8de",
        "brief_description": "Decentralized platform using Zero-Knowledge(K) circuits for secure identity verification.",
        "long_description": "Introducing a decentralized platform powered by Zero-Knowledge (ZK) circuits, designed to revolutionize secure identity verification. This innovative solution provides a no-code tool for credential issuers to effortlessly create ZK circuits, simplifying the process of building advanced cryptographic proofs. Users benefit by generating trustless on-chain identities, enabling seamless interaction with various online services without compromising their privacy. The platform empowers both individuals and organizations with privacy-preserving identity management. Key Features: Privacy-Focused: Protect user data by proving identity without sharing personal details.\nTrustless Proofs: On-chain verification ensures transparency without requiring trust in intermediaries.\nNo-Code Tools: Simple UI for credential issuers to build ZK circuits without technical expertise.\nVersatile Use Cases: Support for multiple online services across Web3 and traditional platforms.\nUser-Friendly Interface: Intuitive workflows for both users and issuers, fostering adoption and ease of use.\nThis platform redefines digital trust, ensuring secure and private identity verification in the era of decentralized technology. here are some transactions created by the app:\nhttps://juicy-low-small-testnet.explorer.testnet.skalenodes.com/address/0xf7f861870aC67B27322E6f23f3442E660103Ce00?tab=txs\nhttps://amoy.polygonscan.com/tx/0xe6bfe9743a2434291256f2ccc36ffe268e3c01e332e87936d38a2a6df2651fdb\nhttps://testnet.layerzeroscan.com/tx/0xb302e3f543145b58e1b2d45c83f75d650d55201ae93c89415a98e88dc9a6a517 Our platform is built on a robust, scalable, and decentralized architecture that ensures privacy, security, and seamless integration with blockchain ecosystems. The core components of our architecture are: Backend \u2013 Zero-Knowledge Proof Generation\nTechnology: Rust & Circom\nFunctionality: The backend is responsible for generating Zero-Knowledge (ZK) proofs, providing cryptographic assurance of identity without exposing personal information. Rust ensures high performance and security, while Circom enables the creation of complex ZK circuits. Blockchain Layer \u2013 Smart Contracts and Proof Storage\nTechnology: Solidity\nNetwork: SKALE Network\nFunctionality: Smart contracts, written in Solidity, store and manage ZK proofs on-chain, enabling secure, trustless identity verification. The SKALE blockchain provides scalability, low-latency transactions, and interoperability to support seamless identity verification. Incentivization Token\nToken Utility: Encourages adoption and usage of the platform through an incentive model.\nBridge Technology: LayerZero protocol.\nToken Transfer: A cross-chain bridge connects SKALE with the Polygon network, ensuring seamless transfer of tokens between chains for users and incentivizing ecosystem participants. Frontend \u2013 User and Issuer Interface\nTechnology: Next.js\nFunctionality: The frontend offers an intuitive and responsive interface for users and credential issuers. With easy-to-navigate workflows, it allows issuers to create ZK circuits without code and users to generate, manage, and carry trustless on-chain identities across services. This modular and decentralized architecture ensures that the platform remains secure, scalable, and user-friendly. Each component integrates seamlessly to deliver a privacy-preserving, trustless identity verification system, leveraging the best technologies across Rust, Circom, Solidity, and modern blockchain protocols.",
        "how_its_made": "Our platform is built on a robust, scalable, and decentralized architecture that ensures privacy, security, and seamless integration with blockchain ecosystems. The core components of our architecture are: Backend \u2013 Zero-Knowledge Proof Generation\nTechnology: Rust & Circom\nFunctionality: The backend is responsible for generating Zero-Knowledge (ZK) proofs, providing cryptographic assurance of identity without exposing personal information. Rust ensures high performance and security, while Circom enables the creation of complex ZK circuits. Blockchain Layer \u2013 Smart Contracts and Proof Storage\nTechnology: Solidity\nNetwork: SKALE Network\nFunctionality: Smart contracts, written in Solidity, store and manage ZK proofs on-chain, enabling secure, trustless identity verification. The SKALE blockchain provides scalability, low-latency transactions, and interoperability to support seamless identity verification. Incentivization Token\nToken Utility: Encourages adoption and usage of the platform through an incentive model.\nBridge Technology: LayerZero protocol.\nToken Transfer: A cross-chain bridge connects SKALE with the Polygon network, ensuring seamless transfer of tokens between chains for users and incentivizing ecosystem participants. Frontend \u2013 User and Issuer Interface\nTechnology: Next.js\nFunctionality: The frontend offers an intuitive and responsive interface for users and credential issuers. With easy-to-navigate workflows, it allows issuers to create ZK circuits without code and users to generate, manage, and carry trustless on-chain identities across services. This modular and decentralized architecture ensures that the platform remains secure, scalable, and user-friendly. Each component integrates seamlessly to deliver a privacy-preserving, trustless identity verification system, leveraging the best technologies across Rust, Circom, Solidity, and modern blockchain protocols.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/64vph/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/2mies/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/i1ciu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/07kpb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/NJCinnamond/crede",
        "link": "https://ethglobal.com/showcase/crede-pucis"
    },
    {
        "title": "bitGaming",
        "brief_description": "Play-to-earn gaming platform and NFT marketplace powered by AI, Blockchain and Decentralized storage",
        "long_description": "Bitgame-ETH is a blockchain-powered gaming platform that integrates NFTs, decentralized storage, and multiple interactive  play-to-earn (P2E) games, including an AI-driven Dungeons & Dragons (DnD) experience, Chimp Test, and Number Memory. The platform uses: Dynamic.xyz for lightning-fast authentication. Dynamic's widget enables first time users to create new wallet with various accounts including GitHub, emails, e.g. without extra effort. Wallet address is the key for user to enter the world of web3,  claim NFTs, and view leaderboard and galleries. Walrus for decentralized object storage. We store NFTs and D&D narration images in Walrus and serve them on our frontend. The blob id returned from Walrus are also stored as a folder-like file to optimize the storage space in our server, and ensures the security and robustness of the data, utilizing the BFT feature of Walrus. OpenAI APIs LLM for AI gaming experience. We use OpenAI's API to create AI chat bot that generate sceneries and images according to user's selection of actions, providing a immersive and innovative experience for users. Morph Holesky Testnet for the smart contract deployments & interactions. Smart contracts manage NFT creation and ownership, with Morph handling the underlying transaction processes, allowing for secure, transparent, and automated interactions. You may play these games on our platform: Other functionalities: Technologies Backend Technologies Architecture Notable Features",
        "how_its_made": "Technologies Backend Technologies Architecture Notable Features",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/oqjnk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/ffq0i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/b3r62/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/a1jqc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/j2v3q/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/zwpvz/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Akezh/bitgaming-eth",
        "link": "https://ethglobal.com/showcase/bitgaming-2up94"
    },
    {
        "title": "Guides",
        "brief_description": "An educational app for learning Web3 protocols with interactive lessons, on-chain actions, and attestations. Users earn XP, complete quizzes, and validate achievements on Polygon while seamlessly engaging with blockchain tech like Coinbase AA and Sign Attestation Protocol.",
        "long_description": "The project is a comprehensive educational mobile platform designed to make learning about Web3 protocols interactive and engaging. Built using React, Next.js, and designed in Figma, the app provides a seamless user experience with a dynamic interface. User access is facilitated through Alchemy Account Kit, which supports flexible login options like email and wallet connections. Course completions are validated through Sign Protocol, which generates attestations stored immutably on the Polygon blockchain, providing verifiable proof of user achievements. The platform also integrates Coinbase's account abstraction (AA) flow in specific lessons to enable users to create smart accounts and experience advanced blockchain features firsthand. Inspired by the Easy A platform, the app combines theoretical learning with practical experience. Users explore blockchain protocols through lessons that detail features, technical background, use cases, and provides information on estimated completion time, developer participation, and XP rewards. Each lesson ends with an on-chain interaction, such as minting an NFT or signing a transaction, allowing users to directly engage with blockchain technologies. The platform emphasizes real-world skills, where completing lessons not only imparts knowledge but also involves blockchain activities that solidify the learning experience. This project aims to enhance blockchain education by merging interactive content, decentralized technologies, and practical applications to create an all-encompassing environment where users can learn, engage, and verify their skills through the entire Web3 ecosystem. The project uses React, Next.js, and Figma for a dynamic and visually consistent frontend. Alchemy Account Kit provides flexible authentication, while Coinbase's AA flow enables smart account creation. Sign Protocol verifies course completions with attestations stored on Polygon. The platform includes on-chain tasks like minting NFTs, and features real-time tracking for XP rewards and a custom onboarding flow for seamless user experience.",
        "how_its_made": "The project uses React, Next.js, and Figma for a dynamic and visually consistent frontend. Alchemy Account Kit provides flexible authentication, while Coinbase's AA flow enables smart account creation. Sign Protocol verifies course completions with attestations stored on Polygon. The platform includes on-chain tasks like minting NFTs, and features real-time tracking for XP rewards and a custom onboarding flow for seamless user experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ac8ng/screenshots/6b4z8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ac8ng/screenshots/assio/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ac8ng/screenshots/dkoyq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/henrikkv/Guides",
        "link": "https://ethglobal.com/showcase/guides-ac8ng"
    },
    {
        "title": "Notarix",
        "brief_description": "Our project is a secure, real-world, ID-verified notarization platform designed to streamline digital notarization while maintaining strong user privacy and security.",
        "long_description": "notarix.vercel.app This project is designed to on-board users not familiar with web3 to a secure, real-world ID-verified digital notarization platform. The website is designed such that the file upload provides a one-click attestation, generating a unique URL that can be sent to a notary of your choice. Dynamic wallet is used for extensive compatibility with wallets, including Ledger Live. The attestation includes an on-chain stored file via the Skale Network and real-world identity verification via Synaps. The notary is then able to verify the identity of the document and provider via a simple interface and provide their own signature via the Sign protocol. The entire project is hosted on Polygon to allow for rapid execution of dApps and low gas fees. All payment uses USDC as currency to further break down the web2 to web3 barrier for uninitiated users. We use Dynamic for wallet authentication to serve as the central identity for document notarization and payment processes. We use Ledger for cryptographic document signing, ensuring private keys remain offline and tamper-proof. Skale Network provides decentralized, zero-cost storage for affidavit voice memos and other files via elastic sidechains. We built a smart contract that handles payment, using Circle\u2019s USDC, ensuring seamless and transparent fee settlements for the non-blockchain enthusiast. The core of the platform is our custom Sign Protocol, which emulates in-person notary workflows using nested schemas. In this process, clients submit signed documents and verified identities through Synaps, a decentralized identity protocol utilizing zero-knowledge proofs for AML/KYC real-world identity verification. Upon verifying document integrity and associated identity, a digital notary attests the signature, with notarization entries indexed on-chain for fast lookups. Our documentation includes setup instructions, architecture diagrams, and a roadmap for future scalability and multi-chain support.",
        "how_its_made": "We use Dynamic for wallet authentication to serve as the central identity for document notarization and payment processes. We use Ledger for cryptographic document signing, ensuring private keys remain offline and tamper-proof. Skale Network provides decentralized, zero-cost storage for affidavit voice memos and other files via elastic sidechains. We built a smart contract that handles payment, using Circle\u2019s USDC, ensuring seamless and transparent fee settlements for the non-blockchain enthusiast. The core of the platform is our custom Sign Protocol, which emulates in-person notary workflows using nested schemas. In this process, clients submit signed documents and verified identities through Synaps, a decentralized identity protocol utilizing zero-knowledge proofs for AML/KYC real-world identity verification. Upon verifying document integrity and associated identity, a digital notary attests the signature, with notarization entries indexed on-chain for fast lookups. Our documentation includes setup instructions, architecture diagrams, and a roadmap for future scalability and multi-chain support.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/h30kb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/n5ihm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/oyo8d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/byc4m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/hkm1f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/pm9x1/default.jpg"
        ],
        "live_demo": "https://notarix.vercel.app/",
        "source_code": "https://github.com/kevinledev/notarix",
        "link": "https://ethglobal.com/showcase/notarix-hyb0a"
    },
    {
        "title": "TrueCanvas",
        "brief_description": "TrueCanvas empowers digital artists to authenticate their original work using zero-knowledge proofs. By providing command logs and artworks, artists generate proofs published to blockchains. This allows anyone to verify authenticity, enhancing trust in digital creations.",
        "long_description": "Problem Statement/Motivation Digital artists who create original works manually or with traditional digital tools like Adobe Illustrator or Photoshop face significant challenges in proving the authenticity of their creations. The rise of generative AI and sophisticated digital manipulation tools has made it increasingly difficult for viewers and other artists to discern whether a piece of art is genuinely original or partially generated by AI. This skepticism undermines the value and credibility of authentic digital art, making it challenging for artists to showcase their hard work and for viewers to trust the originality of the pieces they admire. Moreover, artists are concerned about privacy issues, as they may not want to disclose the intricate details of their creative process or reveal proprietary techniques that constitute their \"secret sauce\" in art creation. Solution: To tackle the challenge of proving the authenticity of original digital artworks without compromising the artist's privacy, we developed TrueCanvas. This platform allows artists to notarize their creations using zero-knowledge proofs (ZKPs), ensuring that their work is original and unaltered by AI without revealing sensitive details of their creative process. Generating a Proof Workflow Artist Generates Creation Logs The artist creates their digital artwork using tools like Photoshop and exports the command logs (.psd logs) that record each creative action taken during the artwork's development. Uploading Artwork and Requesting Proof The artist uploads their artwork (e.g., a PNG file) along with the associated .psd logs to the TrueCanvas frontend application. They then make a request for proof generation through the application's interface. Proof Request Processing The frontend application sends the proof request to the backend server, which is responsible for handling the proof generation process. Log Verification and Proof Generation The backend server verifies the uploaded logs to ensure they meet specific criteria, such as confirming that less than 10% of the pixels are copy-pasted. If the logs pass verification, they are fed into the zero-knowledge proof generator written in Rust using RISC Zero. Receiving Proof and Verification The generated proof and verification details are returned to the artist. This proof attests to the authenticity and originality of the artwork without disclosing any proprietary information or revealing the artist's creative techniques. Publishing to Blockchains The proof and a reference to the artwork are securely stored using Walrus, a decentralized storage solution. They are then published to various blockchains, such as the Story Protocol, via smart contracts written in Solidity. This ensures that the proof is immutable and publicly accessible for verification by anyone. Verifying Proof Accessing the Proof Anyone interested in verifying the authenticity of the artwork can access the verification link provided by the artist. This link might be shared in an Instagram description, on an online gallery, or through other platforms where the artwork is showcased. Proof Verification The verifier reads the proof directly from the blockchain and can independently verify the authenticity of the artwork on any device. This process does not require specialized software or access to the artist's private creation logs. By verifying the proof, they are assured that the artwork is original and not generated or heavily modified using AI tools. Technology Stack To implement TrueCanvas effectively, we integrated a comprehensive technology stack that ensures security, scalability, and a seamless user experience. Here's how the various technologies work together: At the frontend, we utilized Next.js and React to build a responsive and intuitive application where artists can upload their artwork and request proof generation. This user-friendly interface allows artists to interact with the platform effortlessly. The frontend communicates with a backend server developed in Go, which handles proof requests and orchestrates the interactions between different system components. Go's efficiency and concurrency support make it ideal for managing these operations reliably. For the core logic of zero-knowledge proof generation, we employed Rust in conjunction with RISC Zero, a zero-knowledge virtual machine (zkVM). Rust provides high performance and security, which are crucial for cryptographic computations. RISC Zero enables us to create off-chain zero-knowledge proofs that verify the artist's creation process without revealing sensitive information. This ensures that the proofs are both secure and efficient. To securely store the generated proofs and associated artwork, we used Walrus, a decentralized data availability storage solution. Walrus ensures that the data is tamper-proof and remains accessible, leveraging the benefits of decentralized storage to enhance security and reliability. The proofs and references to the artwork are published to multiple blockchains to guarantee transparency and immutability. We wrote smart contracts in Solidity and deployed them on platforms like Polygon and Story Protocol. Polygon provides a scalable and decentralized blockchain platform, ensuring cost-effective transactions and fast confirmation times. The Story Protocol facilitates the registration of NFTs and offers a provenance system, which is essential for tracking the history and ownership of digital artworks. To enable cross-chain interoperability, we integrated Layer Zero. This technology allows proofs to be published and verified across multiple blockchain networks, enhancing the system's flexibility and reach. It ensures that artists and verifiers can interact with the platform regardless of their preferred blockchain. For secure authentication, we incorporated Dynamic, which provides wallet-based authentication for artists. This enables artists to securely log in and manage their proofs using their digital wallets, adding an extra layer of security and convenience. By combining these technologies, TrueCanvas offers a cohesive system where each component plays a vital role: The frontend provides an accessible platform for artists to interact with.\nThe backend manages proof generation requests and system coordination.\nRISC Zero and Rust handle secure and efficient proof generation.\nWalrus ensures secure and decentralized storage of proofs and artworks.\nSolidity smart contracts on Polygon and Story Protocol handle blockchain interactions, providing transparency and immutability.\nLayer Zero enhances interoperability across different blockchain networks.\nDynamic secures user authentication and session management.\nThis integrated technology stack ensures that TrueCanvas operates smoothly, providing artists with a secure and private way to authenticate their digital artworks, and offering verifiers a reliable method to confirm authenticity. ZK Proofs At the heart of TrueCanvas is the use of advanced cryptographic techniques involving zero-knowledge proofs (ZKPs) to verify the authenticity of digital artworks without revealing any sensitive information about the creation process. Canvas Representation as a Two-Dimensional Merkle Tree with Action Logs The digital canvas is modeled as a two-dimensional Merkle tree, a cryptographic data structure that efficiently represents and verifies large datasets. Each pixel or group of pixels acts as leaves in the tree, and the root hash uniquely represents the current state of the canvas. Any modification to the canvas, such as altering pixels through an action, updates the Merkle root, serving as a secure fingerprint of the artwork at any given time. Artists export detailed action logs from Photoshop, which record every action performed and the specific pixels modified. These logs provide the necessary data to understand how the canvas evolves with each action, forming the foundation for our proofs. Base Proof Generation Using RISC Zero, we generate base proofs that verify the correctness of the canvas's transition from the initial state to the updated state after each action. The function inputs for the proof generation are: Initial Merkle Tree (Before an Action): Represents the state of the canvas before a specific action is applied.\nUpdates from Actions: The set of pixel modifications resulting from the action.\nThis base proof ensures that the action is legitimate and consistent with the canvas's state changes without revealing any details about the action itself. Recursive Proofs and Merkle Root Constraints Each base proof is transformed into a recursive proof, which encapsulates not just a single action but the entire sequence of actions up to that point. Recursive proofs are combined by aligning the Merkle root hashes: The output Merkle root of one proof becomes the input Merkle root of the next.\nThis chaining ensures that all transitions between canvas states are valid and verifiable, effectively proving the integrity of the entire creation process. We employ Scalable Transparent ARguments of Knowledge (STARKs) to construct these recursive proofs. STARKs provide scalability and transparency, making the proofs efficient to generate and verify without requiring trusted setups. Enhancing Proof Succinctness with KZG Commitments While STARKs are powerful, the proofs they generate can be relatively large compared to other proof systems. To further reduce the size of the proofs and enhance verification efficiency, we use Kate-Zaverucha-Goldberg (KZG) polynomial commitments. Zero-Knowledge Proof of Verification:\nWe create a zk-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) of the STARK proof verification using KZG commitments.\nThis process generates a succinct zero-knowledge proof that verifies the correctness of the original STARK proof without revealing any additional information.\nBy making a zk-proof of the verification process, we significantly compress the proof data. The combination of STARKs with KZG commitments results in highly succinct proofs that are practical for real-world applications, offering both transparency and efficiency.",
        "how_its_made": "Technology Stack To implement TrueCanvas effectively, we integrated a comprehensive technology stack that ensures security, scalability, and a seamless user experience. Here's how the various technologies work together: At the frontend, we utilized Next.js and React to build a responsive and intuitive application where artists can upload their artwork and request proof generation. This user-friendly interface allows artists to interact with the platform effortlessly. The frontend communicates with a backend server developed in Go, which handles proof requests and orchestrates the interactions between different system components. Go's efficiency and concurrency support make it ideal for managing these operations reliably. For the core logic of zero-knowledge proof generation, we employed Rust in conjunction with RISC Zero, a zero-knowledge virtual machine (zkVM). Rust provides high performance and security, which are crucial for cryptographic computations. RISC Zero enables us to create off-chain zero-knowledge proofs that verify the artist's creation process without revealing sensitive information. This ensures that the proofs are both secure and efficient. To securely store the generated proofs and associated artwork, we used Walrus, a decentralized data availability storage solution. Walrus ensures that the data is tamper-proof and remains accessible, leveraging the benefits of decentralized storage to enhance security and reliability. The proofs and references to the artwork are published to multiple blockchains to guarantee transparency and immutability. We wrote smart contracts in Solidity and deployed them on platforms like Polygon and Story Protocol. Polygon provides a scalable and decentralized blockchain platform, ensuring cost-effective transactions and fast confirmation times. The Story Protocol facilitates the registration of NFTs and offers a provenance system, which is essential for tracking the history and ownership of digital artworks. To enable cross-chain interoperability, we integrated Layer Zero. This technology allows proofs to be published and verified across multiple blockchain networks, enhancing the system's flexibility and reach. It ensures that artists and verifiers can interact with the platform regardless of their preferred blockchain. For secure authentication, we incorporated Dynamic, which provides wallet-based authentication for artists. This enables artists to securely log in and manage their proofs using their digital wallets, adding an extra layer of security and convenience. By combining these technologies, TrueCanvas offers a cohesive system where each component plays a vital role: The frontend provides an accessible platform for artists to interact with.\nThe backend manages proof generation requests and system coordination.\nRISC Zero and Rust handle secure and efficient proof generation.\nWalrus ensures secure and decentralized storage of proofs and artworks.\nSolidity smart contracts on Polygon and Story Protocol handle blockchain interactions, providing transparency and immutability.\nLayer Zero enhances interoperability across different blockchain networks.\nDynamic secures user authentication and session management.\nThis integrated technology stack ensures that TrueCanvas operates smoothly, providing artists with a secure and private way to authenticate their digital artworks, and offering verifiers a reliable method to confirm authenticity. ZK Proofs At the heart of TrueCanvas is the use of advanced cryptographic techniques involving zero-knowledge proofs (ZKPs) to verify the authenticity of digital artworks without revealing any sensitive information about the creation process. Canvas Representation as a Two-Dimensional Merkle Tree with Action Logs The digital canvas is modeled as a two-dimensional Merkle tree, a cryptographic data structure that efficiently represents and verifies large datasets. Each pixel or group of pixels acts as leaves in the tree, and the root hash uniquely represents the current state of the canvas. Any modification to the canvas, such as altering pixels through an action, updates the Merkle root, serving as a secure fingerprint of the artwork at any given time. Artists export detailed action logs from Photoshop, which record every action performed and the specific pixels modified. These logs provide the necessary data to understand how the canvas evolves with each action, forming the foundation for our proofs. Base Proof Generation Using RISC Zero, we generate base proofs that verify the correctness of the canvas's transition from the initial state to the updated state after each action. The function inputs for the proof generation are: Initial Merkle Tree (Before an Action): Represents the state of the canvas before a specific action is applied.\nUpdates from Actions: The set of pixel modifications resulting from the action.\nThis base proof ensures that the action is legitimate and consistent with the canvas's state changes without revealing any details about the action itself. Recursive Proofs and Merkle Root Constraints Each base proof is transformed into a recursive proof, which encapsulates not just a single action but the entire sequence of actions up to that point. Recursive proofs are combined by aligning the Merkle root hashes: The output Merkle root of one proof becomes the input Merkle root of the next.\nThis chaining ensures that all transitions between canvas states are valid and verifiable, effectively proving the integrity of the entire creation process. We employ Scalable Transparent ARguments of Knowledge (STARKs) to construct these recursive proofs. STARKs provide scalability and transparency, making the proofs efficient to generate and verify without requiring trusted setups. Enhancing Proof Succinctness with KZG Commitments While STARKs are powerful, the proofs they generate can be relatively large compared to other proof systems. To further reduce the size of the proofs and enhance verification efficiency, we use Kate-Zaverucha-Goldberg (KZG) polynomial commitments. Zero-Knowledge Proof of Verification:\nWe create a zk-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) of the STARK proof verification using KZG commitments.\nThis process generates a succinct zero-knowledge proof that verifies the correctness of the original STARK proof without revealing any additional information.\nBy making a zk-proof of the verification process, we significantly compress the proof data. The combination of STARKs with KZG commitments results in highly succinct proofs that are practical for real-world applications, offering both transparency and efficiency.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/h29mf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/jrdrv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/hyhxb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/7i8y3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/91b2k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/cmk2t/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Pistondo/eth-sf-2024",
        "link": "https://ethglobal.com/showcase/truecanvas-5uwmd"
    },
    {
        "title": "The Monk Store",
        "brief_description": "Add feature that will allow user ENS names to be resolved to wallet address for payments",
        "long_description": "This project adds a simple utility that enables users to be able to use Unlimit web payment portal with their ENS. Currently the user cannot simply pay using his ENS name. The address has to be input manually. This feature allows for the input to be parsed and then supplied to the web payment portal Next.js, ethers, and Unlimit integration was used to create this project. I added a new feature for them so their overlay model can accept an ENS address. Unlimit payment portal was fun to use and thei documentation was helpful. I caught couple of bugs in the documentation, and the integration process",
        "how_its_made": "Next.js, ethers, and Unlimit integration was used to create this project. I added a new feature for them so their overlay model can accept an ENS address. Unlimit payment portal was fun to use and thei documentation was helpful. I caught couple of bugs in the documentation, and the integration process",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/qyf6m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/toos3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/thpha/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/oew00/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/orc1v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/gyxzt/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/way2rach/unlimit-ens-resolver",
        "link": "https://ethglobal.com/showcase/the-monk-store-zsjk1"
    },
    {
        "title": "EthBox",
        "brief_description": "EthBox is a Web3-based Dropbox for artists and listeners. It ensures secure, tamper-proof, and verifiable file sharing through Dynamic login and Weavechain for encrypted storage, and Skale\u2019s Calypso Chain for transaction proofs creating a decentralized solution to protect IPs",
        "long_description": "EthBox is a decentralized, secure music distribution platform, designed to tackle file sharing and piracy issues. The music industry has long struggled with piracy and unauthorized file sharing at the peer-to-peer level and within larger circles. Large music labels and streaming services often control rights and distribution, but peer-to-peer sharing, especially among smaller artists, continues to be a problem. For example, DJs often distribute their work on thumb drives, lacking secure and verifiable methods for managing their intellectual property.  EthBox is a specialized Web3 Dropbox for music, offering an encrypted, semi-decentralized file-sharing platform that maintains privacy and authenticity. It integrates with Dynamic for secure login, using a wallet address to authenticate users, ensuring that only trusted users can share and receive files. Artists can upload their music to Weavechain, an in-house API for storing and transporting encrypted files. Each file is signed and associated with a recipient's wallet address, ensuring that only the intended recipient can access the file.  Additionally, audit logs are generated during each read-and-write operation by the Weave node on the storage database.  These logs are stored on Skale Network, a zero-cost, gas-free blockchain platform that allows for scalable and efficient deployment. By writing audit logs on-chain, EthBox ensures verifiable proof of file immutability and lineage, preventing unauthorized tampering and verifying the sender's authenticity through cryptographic methods. This project is primarily written in javascript, using React for the frontend, using solidity to write the Skale smart contracts.  Python is used to control the development server that hosts the files and the weave node.  We start with Dynamic's login (React) which abstracts Web3 authentication behind a familiar Web2-like interface, which was crucial for onboarding users who might not be familiar with decentralized applications. Each user\u2019s public key is generated through their wallet address, and their actions are signed using cryptographic keys for secure identification.  I used Weavechain's API  (external) to code the backend.  A bit of solidity + java is used to create smart contracts deployed on the Skale network for each operation on the Weave database. Skale\u2019s zero-cost deployment was very helpful in dealing with gas fees, which would have been prohibitively expensive with frequent contract deployments for file tracking and audit logging. Next, looking at the way the public key exchange works, I used the Diffie Hellman pub key exchange.",
        "how_its_made": "This project is primarily written in javascript, using React for the frontend, using solidity to write the Skale smart contracts.  Python is used to control the development server that hosts the files and the weave node.  We start with Dynamic's login (React) which abstracts Web3 authentication behind a familiar Web2-like interface, which was crucial for onboarding users who might not be familiar with decentralized applications. Each user\u2019s public key is generated through their wallet address, and their actions are signed using cryptographic keys for secure identification.  I used Weavechain's API  (external) to code the backend.  A bit of solidity + java is used to create smart contracts deployed on the Skale network for each operation on the Weave database. Skale\u2019s zero-cost deployment was very helpful in dealing with gas fees, which would have been prohibitively expensive with frequent contract deployments for file tracking and audit logging. Next, looking at the way the public key exchange works, I used the Diffie Hellman pub key exchange.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ce3s1/screenshots/1srdk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ce3s1/screenshots/jjon0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ce3s1/screenshots/09bpq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ebchassine/final-ethsf24",
        "link": "https://ethglobal.com/showcase/ethbox-ce3s1"
    },
    {
        "title": "Medily",
        "brief_description": "An on-chain platform for medical image storage, solving interoperability across global healthcare systems.",
        "long_description": "A broken foot led me to the Canadian Emergency services. Unfortunately, the X ray was not shared with me for further consultation. This is a problem on many fronts. This project has 3 major parts:",
        "how_its_made": "This project has 3 major parts:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/66gcm/screenshots/uxv6a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/66gcm/screenshots/a57ik/default.jpg",
            "https://ethglobal.b-cdn.net/projects/66gcm/screenshots/gvctj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/66gcm/screenshots/9eos5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Garima5/Medily",
        "link": "https://ethglobal.com/showcase/medily-66gcm"
    },
    {
        "title": "CareHippos",
        "brief_description": "Data aggregation app to give a real-time, reputational, and quantitative assessment of the community's health.",
        "long_description": "The CareHippos App is a decentralized application designed to allow users to submit their mood within the context of their communities, helping track the overall mental health and well-being of the community. Whether it\u2019s an office department, a DAO, a hospital floor, or a hackathon sponsor, this app provides a simple and effective way to assess a community's emotional state. By enabling users to vote via \"mood submission\", the app aggregates these votes to give a real-time, reputational, and quantitative assessment of the community's health. It helps community administrators identify potential conflicts, stress levels, and overall mood trends, empowering them to take action where needed. The smart contracts are deployed on Morph Holesky Testnet. We use Morph Holesky Testnet for each of the Mood CareHippo Token, Dynamic for wallet management \u00b4+ account abstraction. Our app is built with NextJS and wagmi, and deployed on Vercel. The users login with their social account, a wallet is generated for them. Users can create a Passkey to manage their keys, and gasless transactions are in the roadmap for seamless user interactions",
        "how_its_made": "We use Morph Holesky Testnet for each of the Mood CareHippo Token, Dynamic for wallet management \u00b4+ account abstraction. Our app is built with NextJS and wagmi, and deployed on Vercel. The users login with their social account, a wallet is generated for them. Users can create a Passkey to manage their keys, and gasless transactions are in the roadmap for seamless user interactions",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sn19u/screenshots/fhm03/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sn19u/screenshots/5thu2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sn19u/screenshots/jkjvb/default.jpg"
        ],
        "live_demo": "https://carehippos.vercel.app",
        "source_code": "https://github.com/a1uaP/carehippos",
        "link": "https://ethglobal.com/showcase/carehippos-sn19u"
    },
    {
        "title": "UniV4Backtester",
        "brief_description": "An institutional grade UniV4 backtester that faithfully replays UniV3 events (Swap, Mint, Burn), and see how a hypothetical position would have performed over a time window.",
        "long_description": "Uniswap v4 introduces the concept of hooks which allows DEX builders to customize behaviors throughout the swap lifecycle, i.e. before/after every swap and liquidity management actions.  A UniV4 pool is usually equipped with the concentrated liquidity curve of UniV3, but the hooks contract can customize how fees accrue to liquidity providers, among many others things, which can have a profound impact on LP profitability. As UniV4 gets ready for production and as more and more hooks are being developed, it is essential to build fast and robust tools that can help analyze how a hooks implementation affects traders and liquidity providers.  In that spirit, we introduce our UniV4 backtester. Our UniV4 backtester fetches liquidity events from a specified UniV3 pool, and then replays these events (Swap, Increase Liquidity, Remove Liquidity) in a hypothetical UniV4 pool which may come with specified hooks. This setup enables institutional grade backtesting analyses on how a UniV4 pool would have performed using the exact liquidity events of a real-world CLMM pool, rather than using aggregated (hourly or daily) historical data which will result in inaccurate and unrealistic results. The backtester is able to set up a hypothetical position, and backtests the position\u2019s performance through a specified time window. We used a variety of technologies to make this backtester: Viem (NodeJS) to fetch UniV3 pool events; Foundry to fork the Sepolia testnet and execute the backtest. --- UniV3 Event Fetching ---\nUniV3 events are fetched from an Ethereum RPC node through eth_getLogs calls on the UniV3 pool contract.  For the demo, we fetched early events of the WBTC-WETH 0.3% pool on Ethereum mainnet.  Since each eth_getLogs call only supports a limited block range, we have to fetch events in batches.  Retry mechanism has been implemented to make event fetching more robust against temporary communication issues with the rpc node. Details of Swap, Mint, Burn are recorded. Collect events are skipped as they do not affect the pool\u2019s liquidity state. --- Backtester Engine ---\nWe use Foundry to create a fork of the Ethereum Sepolia network where UniV4 is deployed.  First, the specified UniV4 pool is created on the fork.  Two dummy token contracts are deployed since production tokens are not available on testnet.  A large amount of tokens are minted to an arbitrary whale address. Liquidity events are replayed: The hypothetical position is set up at startTime, and its state (how much currency0 and currency1 can be collected) at endTime is returned as output at the end of the backtest.",
        "how_its_made": "We used a variety of technologies to make this backtester: Viem (NodeJS) to fetch UniV3 pool events; Foundry to fork the Sepolia testnet and execute the backtest. --- UniV3 Event Fetching ---\nUniV3 events are fetched from an Ethereum RPC node through eth_getLogs calls on the UniV3 pool contract.  For the demo, we fetched early events of the WBTC-WETH 0.3% pool on Ethereum mainnet.  Since each eth_getLogs call only supports a limited block range, we have to fetch events in batches.  Retry mechanism has been implemented to make event fetching more robust against temporary communication issues with the rpc node. Details of Swap, Mint, Burn are recorded. Collect events are skipped as they do not affect the pool\u2019s liquidity state. --- Backtester Engine ---\nWe use Foundry to create a fork of the Ethereum Sepolia network where UniV4 is deployed.  First, the specified UniV4 pool is created on the fork.  Two dummy token contracts are deployed since production tokens are not available on testnet.  A large amount of tokens are minted to an arbitrary whale address. Liquidity events are replayed: The hypothetical position is set up at startTime, and its state (how much currency0 and currency1 can be collected) at endTime is returned as output at the end of the backtest.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/zwhv6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/n01mx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/kodmz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/69i1e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/pt8kw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Aperture-Finance/UniV4Backtester_ETHSF2024",
        "link": "https://ethglobal.com/showcase/univ4backtester-ht1e6"
    },
    {
        "title": "CryptoBASO",
        "brief_description": "Splits swaps across multiple transactions to prevent front running",
        "long_description": "Our project involves splitting up swap orders on DEX\u2019s across multiple transactions by taking advantage of SKALE\u2019s zero gas fees. This is so we can minimize losses occurred from frontrunning.\nOn other blockchains, trying to split up transactions results in more and more gas fees. If you want to make a trade of $50 across multiple transactions, it is not easily doable. It doesn\u2019t make sense to do 5 $10 trades if gas fees are $5.\nThe SKALE network\u2019s zero gas features improves the ability to spread out buy and sell orders across multiple transactions because gas costs are no longer a problematic factor.\nOur project can be slightly altered to work with any DEX on the network (given the DEX has good documentation). We used a simple \u201cfake DEX\u201d for demonstration purposes.\nWe hope that, as the SKALE network\u2019s DeFi ecosystem increases, we could help facilitate that growth with our own project and differentiate the SKALE ecosystem by using SKALE\u2019s zero gas features with our unique way of minimizing MEV. The frontend, built with Next.js and styled using Tailwind CSS, serves as the user interface where traders place limit orders, connect wallets, and monitor trades. Ethers.js bridges the frontend with the SKALE blockchain, enabling direct user interaction with the smart contracts. TypeScript enhances code reliability across the application. The smart contracts, written in Solidity, manage the core functionalities on the SKALE network. For the purpose of this project, we have created our own DEX to simulate trading conditions.\nIt manages trading operations such as token swaps, liquidity management, and order execution, with functions for adding/removing liquidity and handling token swaps. Here, the user mentions the limit orders. The orderbook.sol contract manages the lifecycle of limit orders, providing functionalities to place, modify, and cancel orders. It maintains a record of active orders and interacts with the DEX contract to execute trades when market conditions match the user\u2019s specified price. The PriceChecker.sol contract is responsible for validating real-time prices before executing a trade. It interacts with the DEX to fetch current market prices and ensures that each fragmented order meets the user\u2019s criteria for execution. We have a backend \u201cserver\u201d that utilizes ethers.js and the hardhat framework to conduct constant price checks and executions for every order. We utilized hardhat\u2019s local node for testing as well as SKALE\u2019s Europa DeFi testnet. The \"hacky\" part involved creating the dex.sol contract to simulate a realistic DEX environment for testing. There were no testnet DEX\u2019s, and other DEX\u2019s we tried to use had poor documentation on deployment. Our DEX handles fragmented trade execution, breaking large orders into smaller swaps to prevent frontrunning, leveraging SKALE's zero gas fees for efficient, iterative execution without incurring extra costs.",
        "how_its_made": "The frontend, built with Next.js and styled using Tailwind CSS, serves as the user interface where traders place limit orders, connect wallets, and monitor trades. Ethers.js bridges the frontend with the SKALE blockchain, enabling direct user interaction with the smart contracts. TypeScript enhances code reliability across the application. The smart contracts, written in Solidity, manage the core functionalities on the SKALE network. For the purpose of this project, we have created our own DEX to simulate trading conditions.\nIt manages trading operations such as token swaps, liquidity management, and order execution, with functions for adding/removing liquidity and handling token swaps. Here, the user mentions the limit orders. The orderbook.sol contract manages the lifecycle of limit orders, providing functionalities to place, modify, and cancel orders. It maintains a record of active orders and interacts with the DEX contract to execute trades when market conditions match the user\u2019s specified price. The PriceChecker.sol contract is responsible for validating real-time prices before executing a trade. It interacts with the DEX to fetch current market prices and ensures that each fragmented order meets the user\u2019s criteria for execution. We have a backend \u201cserver\u201d that utilizes ethers.js and the hardhat framework to conduct constant price checks and executions for every order. We utilized hardhat\u2019s local node for testing as well as SKALE\u2019s Europa DeFi testnet. The \"hacky\" part involved creating the dex.sol contract to simulate a realistic DEX environment for testing. There were no testnet DEX\u2019s, and other DEX\u2019s we tried to use had poor documentation on deployment. Our DEX handles fragmented trade execution, breaking large orders into smaller swaps to prevent frontrunning, leveraging SKALE's zero gas fees for efficient, iterative execution without incurring extra costs.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/d7xqy/screenshots/t3tbt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d7xqy/screenshots/5bmb2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d7xqy/screenshots/4pmkn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d7xqy/screenshots/fo6a2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/cryptobaso/cryptobaso_skale",
        "link": "https://ethglobal.com/showcase/cryptobaso-d7xqy"
    },
    {
        "title": "Liquidity",
        "brief_description": "Implementation of an Automated Market Maker (AMM) contract using PINT (Programming Intent Notation). Supports providing liquidity, removing liquidity, token swaps, staking LP tokens, and claiming rewards based on staking duration.",
        "long_description": "This project is an implementation of an Automated Market Maker (AMM) smart contract using PINT (Programming Intent Notation). The contract supports providing liquidity, removing liquidity, token swaps, staking liquidity provider (LP) tokens, and claiming rewards based on staking duration. Contract Features\nProvide Liquidity: Users can provide two tokens, Token A and Token B, to a liquidity pool and receive LP tokens representing their share.\nRemove Liquidity: Users can remove liquidity from the pool by redeeming their LP tokens for Token A and Token B.\nSwap Tokens: Users can swap between Token A and Token B. A fee is charged on swaps, which is distributed to liquidity providers.\nStaking Liquidity: Liquidity providers can stake their LP tokens to earn rewards over time.\nClaiming Rewards: Users who stake their LP tokens can claim rewards based on how long their tokens were staked. The AMM project is built using a robust and scalable architecture. Here's a deep dive into how it was built: Smart Contract Layer: The core of the project is the AMM smart contract, implemented using PINT (Programming Intent Notation). PINT allows for a structured representation of contract logic, which enhances the readability and security of the code. The contract includes functions for providing liquidity, removing liquidity, swapping tokens, staking LP tokens, and claiming rewards. PINT's expressiveness allowed us to simplify complex behaviors through macros such as @auth for authorization checks, and @init_once for state consistency. Backend Infrastructure: The backend, entirely written in Rust, handles off-chain computations and interacts directly with the blockchain. Rust was chosen for its high performance and memory safety, making it ideal for managing critical financial transactions. The backend is responsible for processing requests from users, managing data consistency, and ensuring that all interactions with the blockchain are secure and efficient. Security Measures: Security is a significant concern for any DeFi project. We employed Secp256k1Signature for signed transactions, a cryptographic algorithm known for its use in blockchain systems like Bitcoin. Additionally, PredicateAddress authorization mechanisms were used to ensure flexible, programmable access control, which makes our solution highly secure while allowing composability with other smart contracts. We also implemented nonce-based replay protection to secure transaction integrity. Partner Technologies: To facilitate deployment and continuous integration, we used GitHub Actions for automating testing and deployments. This significantly reduced manual errors and ensured a smooth development workflow. Hacky but Notable Workarounds: One particularly hacky approach worth mentioning is our use of state delta tracking to minimize gas costs during state transitions. Instead of updating the entire state, we track and update only the deltas\u2014what has changed since the last transaction. This optimization led to reduced gas fees and more efficient execution of complex contract operations. By combining PINT, Rust, and efficient deployment practices, we've built a robust, scalable, and efficient AMM that offers flexibility, security, and a solid user experience. Partner technologies like GitHub Actions enriched the platform, ensuring stability and consistent deployments.",
        "how_its_made": "The AMM project is built using a robust and scalable architecture. Here's a deep dive into how it was built: Smart Contract Layer: The core of the project is the AMM smart contract, implemented using PINT (Programming Intent Notation). PINT allows for a structured representation of contract logic, which enhances the readability and security of the code. The contract includes functions for providing liquidity, removing liquidity, swapping tokens, staking LP tokens, and claiming rewards. PINT's expressiveness allowed us to simplify complex behaviors through macros such as @auth for authorization checks, and @init_once for state consistency. Backend Infrastructure: The backend, entirely written in Rust, handles off-chain computations and interacts directly with the blockchain. Rust was chosen for its high performance and memory safety, making it ideal for managing critical financial transactions. The backend is responsible for processing requests from users, managing data consistency, and ensuring that all interactions with the blockchain are secure and efficient. Security Measures: Security is a significant concern for any DeFi project. We employed Secp256k1Signature for signed transactions, a cryptographic algorithm known for its use in blockchain systems like Bitcoin. Additionally, PredicateAddress authorization mechanisms were used to ensure flexible, programmable access control, which makes our solution highly secure while allowing composability with other smart contracts. We also implemented nonce-based replay protection to secure transaction integrity. Partner Technologies: To facilitate deployment and continuous integration, we used GitHub Actions for automating testing and deployments. This significantly reduced manual errors and ensured a smooth development workflow. Hacky but Notable Workarounds: One particularly hacky approach worth mentioning is our use of state delta tracking to minimize gas costs during state transitions. Instead of updating the entire state, we track and update only the deltas\u2014what has changed since the last transaction. This optimization led to reduced gas fees and more efficient execution of complex contract operations. By combining PINT, Rust, and efficient deployment practices, we've built a robust, scalable, and efficient AMM that offers flexibility, security, and a solid user experience. Partner technologies like GitHub Actions enriched the platform, ensuring stability and consistent deployments.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/rn6mp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/oz6a6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/1wggt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/tydxo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/is3e3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/3e4kp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/dkcodes2/amm-pint",
        "link": "https://ethglobal.com/showcase/liquidity-w7ccf"
    },
    {
        "title": "ETHGambit",
        "brief_description": "A superior, decentralized alternative to online chess betting.",
        "long_description": "The act of \"hustling\" is a core part of chess culture. In big cities like New York and Boston, chess hustlers hang out in the park and play strangers, each putting down a small wager on the winner of the game. A single online service, chesshustleonline.com, attempts to capitalize on this tradition. On this website, 10% of each player's bets are taken as a fee. You don't get to decide how much to bet, which chess platform is used, and must wait 5-7 business days for your winnings. However, ETHGambit can completely circumvent all of these downsides. Using blockchain technology, users can take back control of this timeless tradition, tapping into an extremely large market of approximately 110 million users that were previously priced out and sketched out by the status quo. Overall, an intuitive UI combined with a solution alleviating a major pain point in the market will make a big splash in the online chess community, onboarding many enthusiastic users into web3. The blockchain technology used in ETHGambit is a Solidity smart contract originally deployed on Polygon, but switched to Flow. The Polygon Amoy Testnet had about a 50% percent chance of throwing a random \"Internal JSON-RPC Error\" when interacting with the contract, which contributed to much frustration. The Flow Testnet did not have these issues. The contract acts as an escrow with three main functions: An additional part of the back-end is a Python Flask server that grabs the result of the game. To make it more decentralized/trustless, we would use an oracle in the smart contract instead of a central server, which is the next step for this project. The front end was originally planned to be a browser extension, however, we shelved that for the purposes of technical capability demonstration. The UI is built with ReactJS that imports modules like ethers and web3 to pass values to the smart contract.",
        "how_its_made": "The blockchain technology used in ETHGambit is a Solidity smart contract originally deployed on Polygon, but switched to Flow. The Polygon Amoy Testnet had about a 50% percent chance of throwing a random \"Internal JSON-RPC Error\" when interacting with the contract, which contributed to much frustration. The Flow Testnet did not have these issues. The contract acts as an escrow with three main functions: An additional part of the back-end is a Python Flask server that grabs the result of the game. To make it more decentralized/trustless, we would use an oracle in the smart contract instead of a central server, which is the next step for this project. The front end was originally planned to be a browser extension, however, we shelved that for the purposes of technical capability demonstration. The UI is built with ReactJS that imports modules like ethers and web3 to pass values to the smart contract.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/y8v9e/screenshots/snze4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8v9e/screenshots/pzv7y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8v9e/screenshots/pemmw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8v9e/screenshots/2hecg/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wolfiesell/ETHGambit",
        "link": "https://ethglobal.com/showcase/ethgambit-y8v9e"
    },
    {
        "title": "TerraTracker",
        "brief_description": "TerraTracker: Harnessing blockchain and AI for hyper-local disaster predictions. Empower communities with real-time insights, engage users through staking rewards, and support relief efforts with a portion of profits. Predict. Prepare. Protect.",
        "long_description": "TerraTracker is an innovative platform designed to predict natural disasters with precision and engage communities in proactive preparedness. By leveraging blockchain technology, TerraTracker ensures secure, transparent transactions and data integrity. The platform integrates real-time data from diverse sources, such as weather and seismic APIs, using Chainlink oracles for accurate predictions. Key Features: Blockchain Platform: Flow, Polygon for smart contracts, ensuring secure and transparent transactions. Integration and Benefits Notable Hacks",
        "how_its_made": "Blockchain Platform: Flow, Polygon for smart contracts, ensuring secure and transparent transactions. Integration and Benefits Notable Hacks",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/7jne7/screenshots/onvb4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7jne7/screenshots/sb9xp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7jne7/screenshots/cabr2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jackiesafari/Terratracker3",
        "link": "https://ethglobal.com/showcase/terratracker-7jne7"
    },
    {
        "title": "Fluxus",
        "brief_description": "The project aims to maintain stablecoin price stability within a Uniswap V4 pool by using Chronicle oracles and dynamic fees.",
        "long_description": "The aim of the our project is to create a flexible, dynamic fee system that maintains stablecoin price stability within a Uniswap V4 liquidity pool. By integrating external oracles, dynamic fees, and the ability to toggle price behavior, we seek to maintain the value of a stablecoin near its target, discouraging extreme price volatility through economic incentives (fees). Smart Contract:\nThe smart contract is built via Foundry. It integrates Uniswap V4 to customize swap behavior for stablecoin trades, allowing dynamic fee adjustments based on price deviations from a target. The contract manages stablecoin prices using oracles to track pool prices and applies dynamic buy/sell fees to stabilize the price. A flipping mechanism allows the contract to switch between two pricing models. Fees are capped at 50%, encouraging price stability. Core functions include retrieving stablecoin prices, calculating fees, and modifying Uniswap\u2019s swap behavior. Additionally, a selfKiss method links oracles through the Chronicle ISelfKisser interface. Frontend:\nThis frontend is built with Next.js, React, and other web3 tools. It integrates authentication using Alchemy Account Kit with multiple login options, including email, passkey, social logins (Google, Facebook), and external wallets via WalletConnect. The project also utilizes Sepolia Testnet for blockchain interactions, configured with Alchemy's infrastructure for secure data transport.\nReact Query is used for efficient data fetching, and Wagmi with Viem handles wallet connections and blockchain transactions. TailwindCSS is used for styling, and ESLint ensures code quality. This setup makes the app a responsive and secure platform for interacting with stablecoins and decentralized finance features.",
        "how_its_made": "Smart Contract:\nThe smart contract is built via Foundry. It integrates Uniswap V4 to customize swap behavior for stablecoin trades, allowing dynamic fee adjustments based on price deviations from a target. The contract manages stablecoin prices using oracles to track pool prices and applies dynamic buy/sell fees to stabilize the price. A flipping mechanism allows the contract to switch between two pricing models. Fees are capped at 50%, encouraging price stability. Core functions include retrieving stablecoin prices, calculating fees, and modifying Uniswap\u2019s swap behavior. Additionally, a selfKiss method links oracles through the Chronicle ISelfKisser interface. Frontend:\nThis frontend is built with Next.js, React, and other web3 tools. It integrates authentication using Alchemy Account Kit with multiple login options, including email, passkey, social logins (Google, Facebook), and external wallets via WalletConnect. The project also utilizes Sepolia Testnet for blockchain interactions, configured with Alchemy's infrastructure for secure data transport.\nReact Query is used for efficient data fetching, and Wagmi with Viem handles wallet connections and blockchain transactions. TailwindCSS is used for styling, and ESLint ensures code quality. This setup makes the app a responsive and secure platform for interacting with stablecoins and decentralized finance features.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/zr3xd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/a03vp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/caubd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/oqbr5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/s5tsy/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Ashy5000/stablecoin_contracts",
        "link": "https://ethglobal.com/showcase/fluxus-ci8sj"
    },
    {
        "title": "StreamChain",
        "brief_description": "We don\u2019t want a centralized organization controlling crucial video evidence of things like police brutality or war crimes, but safety and legality must be paramount. StreamChain combines the trust of decentralized storage with the versatility of multi-modal LLM moderation.",
        "long_description": "While we don\u2019t want a centralized organization controlling crucial video evidence of things like police brutality or war crimes, safety and legality must be paramount. Combining the decentralized and immutable nature of Walrus Blob Storage with the safety and versatility of multi-modal LLM content moderation, we can ensure that videos that need to be published can be seen, while also moderating content that users upload, simultaneously ensuring the legality of the uploaded content. Using the SKALE blockchain, the content moderation model is fully auditable, as every confirmation or rejection is pushed to the chain with a reason provided by the model. Even the weights of the model are published on Walrus, meaning anybody can investigate the nature of the model and object to its behavior. Walrus Blob Storage is leveraged for its decentralized and immutable nature. The frontend procures blobIDs directly from the SKALE blockchain, and fetches the video directly from Walrus. Before any content is pushed to Walrus, the content moderation must make a decision as to its visibility and legality. Using the SKALE blockchain, the content moderation model is fully auditable, as every confirmation or rejection is pushed to the chain with a reason provided by the model. Even the weights of the model are published on Walrus, meaning anybody can investigate the nature of the model and object to its behavior. The video content moderation system uses an advanced filtering technique that can moderate huge amounts of footage with little inference cost. First, the frames are embedded in a multi-modal vector space using OpenAI CLIP. This process runs super fast entirely on device using Mac M2 Metal Performance Shaders. We can run this inexpensive computation in huge volume for free, which makes it perfect for filtering out potential true positives. We can then forward the frame to a smarter model, such as GPT-4o, for a final decision on content moderation. This method of content moderation is completely zero shot and is therefore extremely versatile. It can be further tuned with either fine-tuning or prompt adjustments, which can increase accuracy and usability.",
        "how_its_made": "Walrus Blob Storage is leveraged for its decentralized and immutable nature. The frontend procures blobIDs directly from the SKALE blockchain, and fetches the video directly from Walrus. Before any content is pushed to Walrus, the content moderation must make a decision as to its visibility and legality. Using the SKALE blockchain, the content moderation model is fully auditable, as every confirmation or rejection is pushed to the chain with a reason provided by the model. Even the weights of the model are published on Walrus, meaning anybody can investigate the nature of the model and object to its behavior. The video content moderation system uses an advanced filtering technique that can moderate huge amounts of footage with little inference cost. First, the frames are embedded in a multi-modal vector space using OpenAI CLIP. This process runs super fast entirely on device using Mac M2 Metal Performance Shaders. We can run this inexpensive computation in huge volume for free, which makes it perfect for filtering out potential true positives. We can then forward the frame to a smarter model, such as GPT-4o, for a final decision on content moderation. This method of content moderation is completely zero shot and is therefore extremely versatile. It can be further tuned with either fine-tuning or prompt adjustments, which can increase accuracy and usability.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zj41z/screenshots/85586/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zj41z/screenshots/hd7sx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zj41z/screenshots/prgpj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sun-jay/ETHsf24",
        "link": "https://ethglobal.com/showcase/streamchain-zj41z"
    },
    {
        "title": "undegen finance",
        "brief_description": "Undegen simplifies portfolio management by using a risk survey defined strategy to build and rebalance crypto investments automatically. Users can easily sign up, deposit funds, and maintain an optimal mix of assets based on their risk tolerance.",
        "long_description": "Our project tackles the challenge that many users face in building and balancing an optimal portfolio aligned with their risk tolerance, particularly those outside the U.S. who lack access to traditional investment options. Inspired by The Missing Billionaires by James White and Victor Haghani, we address common mistakes investors make when assessing risk, which often leads to poor financial outcomes. Through Undegen, users begin by taking a risk profile survey that helps them allocate assets across risk categories. This allocation is based on Merton portfolio calculations, offering an optimal split between low-risk (USDC with fixed yield) and high-risk (staked ETH and wrapped Bitcoin) assets. Users can then easily sign up with just an email and deposit funds, starting with USDC, to have their portfolio automatically built. Once set up, the platform provides real-time visibility into their holdings via a dashboard. The system continuously monitors risk allocation, and users can update their risk profile at any time, triggering automatic rebalancing of their portfolio to ensure it aligns with their updated investment goals and risk tolerance. Undegen aims to offer a globally accessible, permissionless solution for portfolio optimization, making smart investing easy and adaptable for everyone. We're streamlining the onboarding process by using Dynamic, which allows users to sign up using just their email. In the background, this creates an embedded wallet, offering a seamless experience without the complexity of traditional wallet setup. We're also generating a Safe smart wallet for each user. This wallet enables account abstraction, which lets us send transactions and handle gas fees on behalf of the user, enhancing usability. Our system leverages a Safe module to initiate a transaction on the Safe smart account, calling the UndegenModule's rebalance() function. This function then calls back into the Safe account (where it has authorization as an approved module), performing a delegatecall to the UndegenRebalancer contract. The rebalance action is executed from there, dynamically adjusting the portfolio based on preset risk strategies. One key advantage of this architecture is that the rebalancing occurs without needing explicit approvals, allowing everything to happen within a single transaction. The user still initiates the flow by specifying the desired allocation of risky assets (in USD) for their portfolio, with any excess automatically deposited into a USDC fixed-rate pool on Hyperdrive. To ensure accurate conversions between token prices and USD, our contracts use Chronicle oracles, ensuring smooth and precise portfolio rebalancing. We also used shadcn components for both figma and front-end implementation.",
        "how_its_made": "We're streamlining the onboarding process by using Dynamic, which allows users to sign up using just their email. In the background, this creates an embedded wallet, offering a seamless experience without the complexity of traditional wallet setup. We're also generating a Safe smart wallet for each user. This wallet enables account abstraction, which lets us send transactions and handle gas fees on behalf of the user, enhancing usability. Our system leverages a Safe module to initiate a transaction on the Safe smart account, calling the UndegenModule's rebalance() function. This function then calls back into the Safe account (where it has authorization as an approved module), performing a delegatecall to the UndegenRebalancer contract. The rebalance action is executed from there, dynamically adjusting the portfolio based on preset risk strategies. One key advantage of this architecture is that the rebalancing occurs without needing explicit approvals, allowing everything to happen within a single transaction. The user still initiates the flow by specifying the desired allocation of risky assets (in USD) for their portfolio, with any excess automatically deposited into a USDC fixed-rate pool on Hyperdrive. To ensure accurate conversions between token prices and USD, our contracts use Chronicle oracles, ensuring smooth and precise portfolio rebalancing. We also used shadcn components for both figma and front-end implementation.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/sr3vj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/bxefr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/e99x0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/w916i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/4f9cw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/dcejp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/pcarranzav/undegen-contracts",
        "link": "https://ethglobal.com/showcase/undegen-finance-ym8tt"
    },
    {
        "title": "\u00c6xtend",
        "brief_description": "\u00c6xtend is a way to take your life, your specialty, and spread it everywhere.",
        "long_description": "The Project uses a series of AI agents to Mimic your skills, to make the model much better than it was at that skill, which also make it better than leading models at that skill while still being a mid-tier model. We first feed an AI model some documents you might have, it makes conclusions, which show us its thinking process and what its learning. From there you can edit that according to what you need it to be then test it with that takeaway/thought-process, then tweak it, and repeat the cycle till what you have is the perfect one. From there use it on real life projects. Usually Gemini 1.5 < GPT-4o For us, Gemini 1.5+\u00c6xtend > GPT-4o There is also Yddgrasil mode, which is several Gemini 1.5+\u00c6xtend skills put togther, this is >4o, weaker than OpenAI O1, but can reason with many more diverse skills and over much longer sizes (1M tokens), giving it some advantages over even the strongest models This project was made with my favorite fullstack setup, Sveltekit+Firebase, Then I used the Google GenAI api and its Model Gemini 1.5 for the very long very fast AI capabilities. From there I also used the Clip model to measure text similarity, and I used @Coinbase's wallets for all the transactions between my agents. Overall everything connects in the front end, but I had to make a key operation into a backend part and now its really clean+open source jump point for AI agents",
        "how_its_made": "This project was made with my favorite fullstack setup, Sveltekit+Firebase, Then I used the Google GenAI api and its Model Gemini 1.5 for the very long very fast AI capabilities. From there I also used the Clip model to measure text similarity, and I used @Coinbase's wallets for all the transactions between my agents. Overall everything connects in the front end, but I had to make a key operation into a backend part and now its really clean+open source jump point for AI agents",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/mn7xw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/u6p09/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/8hmup/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/k0mbu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/2yrfi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/h3458/default.jpg"
        ],
        "live_demo": "https://extendtheta.vercel.app/",
        "source_code": "https://github.com/VatsaDev/ethglobalhack",
        "link": "https://ethglobal.com/showcase/aextend-6e2df"
    },
    {
        "title": "Swipa.meme",
        "brief_description": "Memecoin collecting with Tinder UI and points. If you like it, swipe right \ud83d\ude80",
        "long_description": "We're bringing memecoins to the masses, using a familiar touch: the swipe \u2714\ufe0f Memecoins are eating the world. In 2024, the memecoin market cap is $44.9B, and it's only going to grow. We want everyone in the world to join in on the fun. Introducing: Swipa.meme How does it work? The project is a PWA that aims to abstract as much of the boring and difficult web3 elements of crypto away from users so that they can focus on the fun of curating and rating memes for points. One point = one swipe = $0.01 Tech stack User Onboarding Swiping Cashing out",
        "how_its_made": "The project is a PWA that aims to abstract as much of the boring and difficult web3 elements of crypto away from users so that they can focus on the fun of curating and rating memes for points. One point = one swipe = $0.01 Tech stack User Onboarding Swiping Cashing out",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/r82ik/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/1mhp3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/adxwg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/1r0i8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/mgrca/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/a2no6/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/thatguyintech/swipa",
        "link": "https://ethglobal.com/showcase/swipa-meme-zucyg"
    },
    {
        "title": "Crypto Carbon Alerts",
        "brief_description": "We built a React app that connects to user authentication via Alchemy\u2019s Accounts UI Widget. We're creating a composite Ethereum token of two crypto carbon credits on Celo using Toucan Protocol. A subgraph listens to wallet events and broadcasts via XMTP to a Telegram bot.",
        "long_description": "The background of this project is deeply rooted in sustainability, especially in the context of upcoming regulations like California's SB 253 and SB 261, which require companies to report on their carbon emissions across Scope 1, 2, and 3. These regulations, along with growing pressures from big tech companies like Amazon and Apple, are pushing corporations to be more transparent about their emissions and take action to reduce them.\nTo achieve net-zero emissions, these companies will need to purchase carbon offsets that compensate for the emissions they can't eliminate. However, there is currently a dearth of high-quality carbon credits, and the process of purchasing and managing them can be cumbersome.\nThe Role of Blockchain:\nBlockchain offers a promising solution by enabling dramatic transparency in carbon credit transactions. It allows companies to seamlessly purchase and retire carbon credits, ensuring that these credits are verifiable and traceable. The application your team built aims to address this need by fractionalizing a variety of carbon credits into a single composite token, reducing friction for companies seeking to offset emissions across various projects related to their operations.\nSingle Token for Multiple Projects:\nCompanies often want to offset their carbon footprint by investing in a variety of projects such as: Our team of three UC Berkeley students built for EthGlobal SF integrates several advanced technologies to create a unique solution for tracking and broadcasting crypto carbon credit movements.\nOverview:\nThe project is a React-based application that leverages Alchemy, Ethereum smart contracts, Toucan Protocol, The Graph, and XMTP for decentralized carbon credit tracking. The purpose of this application is to allow users to authenticate, monitor, and interact with carbon credit transactions on the blockchain, broadcasting real-time updates to a Telegram bot for easy tracking.\nDetailed Components:",
        "how_its_made": "Our team of three UC Berkeley students built for EthGlobal SF integrates several advanced technologies to create a unique solution for tracking and broadcasting crypto carbon credit movements.\nOverview:\nThe project is a React-based application that leverages Alchemy, Ethereum smart contracts, Toucan Protocol, The Graph, and XMTP for decentralized carbon credit tracking. The purpose of this application is to allow users to authenticate, monitor, and interact with carbon credit transactions on the blockchain, broadcasting real-time updates to a Telegram bot for easy tracking.\nDetailed Components:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gus4z/screenshots/1xe6j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gus4z/screenshots/kydt4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gus4z/screenshots/y8eve/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gus4z/screenshots/dm8fu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/CarbonSustain/ethglobalsf",
        "link": "https://ethglobal.com/showcase/crypto-carbon-alerts-gus4z"
    },
    {
        "title": "PintSwap",
        "brief_description": "We built the first DEX on Essential Blockchain, powered by a declarative framework. Users can seamlessly add/remove liquidity, swap tokens, and earn LP tokens. Plus, we open-sourced a JS framework to make Essential development accessible to all developers.",
        "long_description": "Our project is the first decentralized exchange (DEX) built on Essential Blockchain, which operates using a declarative programming model. Essential allows state updates driven by constraints and solvers, optimizing outcomes without requiring direct transaction execution.\nWe dedicated significant time to developing and open-sourcing a TypeScript framework for Essential Blockchain, as no such framework existed before. This tool allows other developers to build applications on Essential using JavaScript/TypeScript, significantly lowering the barrier to entry for the ecosystem. In addition, we created a rigorous testing framework that helped us master contract syntax. Due to the limited resources and documentation available, we frequently worked with Essential\u2019s development team in Australia to troubleshoot issues and deepen our understanding of the chain and its capabilities. Our DEX allows users to:\n\u2022\tAdd/remove liquidity using token pairs and receive LP tokens, representing their share of the liquidity pool.\n\u2022\tSwap tokens within the liquidity pools, with prices adjusting automatically based on the AMM model.\n\u2022\tEarn LP tokens for providing liquidity and share in transaction fees as passive income.\nSince no tokens existed on the Essential Blockchain when we started, we wrote contracts to mint, burn, and transfer tokens. We also experimented with building a smart wallet tailored for the Essential Blockchain. On the front-end, we utilized Next.js and React to create a modern, responsive user interface, adhering to best practices observed in other swap protocols. Despite building the DEX in just 36 hours, we see incredible potential for future enhancements. Our next steps include developing a Dollar-Cost Averaging (DCA) tool, which will allow users to automatically purchase assets on a scheduled basis using time-based constraints in Pint contracts. This DEX project is just the beginning of leveraging the power of declarative blockchains to innovate in decentralized finance. Building the first decentralized exchange (DEX) on Essential Blockchain was a deeply technical and challenging process, particularly because Essential is a declarative blockchain, and most tooling traditionally supports imperative blockchains. Since Essential only supported Rust, we had to innovate to make the blockchain more accessible to a broader developer audience. Technologies We Used:\n\u2022\tPint: Essential\u2019s declarative smart contract language. It allowed us to write contracts with constraints that solvers could optimize, making the DEX function without relying on sequential execution.\n\u2022\tJavaScript/TypeScript: To make development easier and more accessible, we built a TypeScript framework that lets other developers write tools in JS/TS for Essential, bypassing the need for fluency in Rust. This framework also integrates with Essential\u2019s backend to allow contracts to be executed declaratively.\n\u2022\tNext.js: We built the DEX\u2019s front-end using Next.js & React to create a modern, responsive user interface, adopting best practices from established DEX protocols like Uniswap. This gave us a solid front-end development framework with server-side rendering for optimal performance.\n\u2022\tCustom Testing Framework: Since no robust testing framework existed for Pint contracts, we built our own to ensure that the constraints and contract logic were functioning properly. This involved writing tests that forced us to learn the nuances of the contract language and ensuring that all contract conditions were met during execution.\n\u2022\tSolvers & Constraints: The DEX relies on solvers to find the optimal token swaps and liquidity pooling conditions based on user-set constraints. This required a deep understanding of how solvers work to ensure that valid state transitions were made. How It Came Together:\n\u2022\tBackend Contracts: We built contracts for minting, burning, and transferring tokens since no tokens existed on the Essential chain when we started. These foundational contracts allowed us to create liquidity pools and issue LP tokens. Using Pint, we expressed constraints rather than step-by-step execution, which solvers would optimize to ensure valid outcomes.\n\u2022\tFrontend Development: With Next.js, we implemented the DEX\u2019s UI, allowing users to interact with the smart contracts seamlessly. We focused on user experience by mimicking the design patterns of successful swap protocols, ensuring users could add liquidity, swap tokens, and remove liquidity with ease. Challenges & Hacky Solutions:\n\u2022\tBuilding a JavaScript Framework: One of the most hacky and notable aspects of our project was building the JavaScript framework from scratch. Essential only supports Rust, so to make development easier for the broader community, we created this JS framework so that developers could write tools and apps for Essential without needing to dive deep into Rust. This was critical for us to overcome the limitations imposed by Rust-only support and enabled us to open-source the framework for future projects.\n\u2022\tCustom Wallet Development: We experimented with creating our own smart wallet to handle specific token interactions on the Essential chain. While this wasn\u2019t fully completed during the hackathon, it allowed us to explore how custom wallets could interact with the new JS framework and Pint contracts.\n\u2022\tConstant Communication with Essential\u2019s Dev Team: Since the documentation and guides for Essential were sparse, we often found ourselves directly reaching out to their dev team in Australia. This became essential for resolving tough bugs, especially when we were trying to wrap our heads around the proper contract syntax in Pint and testing various contract executions.",
        "how_its_made": "Building the first decentralized exchange (DEX) on Essential Blockchain was a deeply technical and challenging process, particularly because Essential is a declarative blockchain, and most tooling traditionally supports imperative blockchains. Since Essential only supported Rust, we had to innovate to make the blockchain more accessible to a broader developer audience. Technologies We Used:\n\u2022\tPint: Essential\u2019s declarative smart contract language. It allowed us to write contracts with constraints that solvers could optimize, making the DEX function without relying on sequential execution.\n\u2022\tJavaScript/TypeScript: To make development easier and more accessible, we built a TypeScript framework that lets other developers write tools in JS/TS for Essential, bypassing the need for fluency in Rust. This framework also integrates with Essential\u2019s backend to allow contracts to be executed declaratively.\n\u2022\tNext.js: We built the DEX\u2019s front-end using Next.js & React to create a modern, responsive user interface, adopting best practices from established DEX protocols like Uniswap. This gave us a solid front-end development framework with server-side rendering for optimal performance.\n\u2022\tCustom Testing Framework: Since no robust testing framework existed for Pint contracts, we built our own to ensure that the constraints and contract logic were functioning properly. This involved writing tests that forced us to learn the nuances of the contract language and ensuring that all contract conditions were met during execution.\n\u2022\tSolvers & Constraints: The DEX relies on solvers to find the optimal token swaps and liquidity pooling conditions based on user-set constraints. This required a deep understanding of how solvers work to ensure that valid state transitions were made. How It Came Together:\n\u2022\tBackend Contracts: We built contracts for minting, burning, and transferring tokens since no tokens existed on the Essential chain when we started. These foundational contracts allowed us to create liquidity pools and issue LP tokens. Using Pint, we expressed constraints rather than step-by-step execution, which solvers would optimize to ensure valid outcomes.\n\u2022\tFrontend Development: With Next.js, we implemented the DEX\u2019s UI, allowing users to interact with the smart contracts seamlessly. We focused on user experience by mimicking the design patterns of successful swap protocols, ensuring users could add liquidity, swap tokens, and remove liquidity with ease. Challenges & Hacky Solutions:\n\u2022\tBuilding a JavaScript Framework: One of the most hacky and notable aspects of our project was building the JavaScript framework from scratch. Essential only supports Rust, so to make development easier for the broader community, we created this JS framework so that developers could write tools and apps for Essential without needing to dive deep into Rust. This was critical for us to overcome the limitations imposed by Rust-only support and enabled us to open-source the framework for future projects.\n\u2022\tCustom Wallet Development: We experimented with creating our own smart wallet to handle specific token interactions on the Essential chain. While this wasn\u2019t fully completed during the hackathon, it allowed us to explore how custom wallets could interact with the new JS framework and Pint contracts.\n\u2022\tConstant Communication with Essential\u2019s Dev Team: Since the documentation and guides for Essential were sparse, we often found ourselves directly reaching out to their dev team in Australia. This became essential for resolving tough bugs, especially when we were trying to wrap our heads around the proper contract syntax in Pint and testing various contract executions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/a229i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/dd8jr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/qminr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/pwkya/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/3z0vd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/15yug/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ewitulsk/PintSwap",
        "link": "https://ethglobal.com/showcase/pintswap-70ayj"
    },
    {
        "title": "SuperPass",
        "brief_description": "Super secure password management to prevent database pass code from getting lost or stolen.",
        "long_description": "Passman allows AI powered swipe based authentication to prevent lost or stolen passwords. The application allows database encryption and decryption using AI powered signature recognition preventing the possibility of stolen pass codes and persists on the blockchain to prevent code from becoming lost or forgotten. The server runs on a secure hardware TEE component. This project utilizes SIGN for encryption and decryption, Lit for database management, WALRUS for storage and PHALA for for a secure server. It uses AI image recognition and analysis to verify that the signature belongs to the user and can be used conveniently from either a mobile app or web browser.",
        "how_its_made": "This project utilizes SIGN for encryption and decryption, Lit for database management, WALRUS for storage and PHALA for for a secure server. It uses AI image recognition and analysis to verify that the signature belongs to the user and can be used conveniently from either a mobile app or web browser.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/z2esk/screenshots/8a8jv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z2esk/screenshots/kcg90/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z2esk/screenshots/tfhnr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z2esk/screenshots/0yr0f/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/amirhyoussefi/supersecurepass",
        "link": "https://ethglobal.com/showcase/superpass-z2esk"
    },
    {
        "title": "SmartEthereumWallet",
        "brief_description": "Smart Ethereum Wallet is a secure, user-friendly wallet tracker that monitors your Ethereum wallet activities, sends notifications for incoming/outgoing transactions, and provides a summary of balance changes over time\u2014all in one streamlined dashboard.",
        "long_description": "Smart Ethereum Wallet is a user-friendly tracker that provides real-time insights into Ethereum wallet activities. Built with a React frontend and an Express.js backend, it connects to the Ethereum blockchain using Ethers.js and Infura, ensuring fast and reliable data access. Users can view wallet balances, track transaction history, and receive instant notifications for new transactions through WebSocket integration. A custom caching mechanism on the backend helps reduce redundant API calls, providing a faster and smoother experience. SmartEthereumWallet is built using a React frontend for a seamless user experience, integrated with an Express.js backend to handle API requests and data processing. We used Ethers.js for interacting with the Ethereum blockchain, allowing us to fetch wallet balances and transaction history efficiently. The backend is connected to Infura, which serves as the Ethereum node provider, ensuring quick and reliable access to blockchain data without the need to manage our own nodes.",
        "how_its_made": "SmartEthereumWallet is built using a React frontend for a seamless user experience, integrated with an Express.js backend to handle API requests and data processing. We used Ethers.js for interacting with the Ethereum blockchain, allowing us to fetch wallet balances and transaction history efficiently. The backend is connected to Infura, which serves as the Ethereum node provider, ensuring quick and reliable access to blockchain data without the need to manage our own nodes.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t692u/screenshots/55mpp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t692u/screenshots/c8ry0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t692u/screenshots/yua3s/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/michelllee/SmartEthereumWallet",
        "link": "https://ethglobal.com/showcase/smartethereumwallet-t692u"
    },
    {
        "title": "DeHack",
        "brief_description": "A blazing fast cross-chain bridge utilizing account abstraction across all EVM chains",
        "long_description": "A blazing fast cross-chain bridge utilizing account abstraction across all EVM chains offers a seamless and efficient way to transfer assets. By enabling instant transactions and automating processes through smart contract wallets, users can enjoy a streamlined experience without the complexities of traditional cross-chain methods. This bridge optimizes gas fees and enhances security with additional measures like multi-signatures. Ultimately, it promotes improved liquidity and universal compatibility, making it a vital tool for the evolving DeFi ecosystem. A blazing fast cross-chain bridge utilizing account abstraction across all EVM chains offers a seamless and efficient way to transfer assets. By enabling instant transactions and automating processes through smart contract wallets, users can enjoy a streamlined experience without the complexities of traditional cross-chain methods. This bridge optimizes gas fees and enhances security with additional measures like multi-signatures. Ultimately, it promotes improved liquidity and universal compatibility, making it a vital tool for the evolving DeFi ecosystem.",
        "how_its_made": "A blazing fast cross-chain bridge utilizing account abstraction across all EVM chains offers a seamless and efficient way to transfer assets. By enabling instant transactions and automating processes through smart contract wallets, users can enjoy a streamlined experience without the complexities of traditional cross-chain methods. This bridge optimizes gas fees and enhances security with additional measures like multi-signatures. Ultimately, it promotes improved liquidity and universal compatibility, making it a vital tool for the evolving DeFi ecosystem.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vepwo/screenshots/j154x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vepwo/screenshots/m4df9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vepwo/screenshots/02wdm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Chaitenyag/DeHack",
        "link": "https://ethglobal.com/showcase/dehack-vepwo"
    },
    {
        "title": "PumpRoyale",
        "brief_description": "Improve your fitness goals while also exposing yourself to immense monetary gain.",
        "long_description": "In PumpRoyale users across the globe can stake any amount of USDC across recurring global competitions. At random times during the competition a user is prompted to record themselves completing a basic fitness activity within 10 minutes of being prompted. Those who successfully completed the physical activity within the time frame will have their stake returned while those that fail will lose their stake which will form a losers pool. Upon the completion of every game, there will be a random select few of people that completed the fitness activity and will be awarded a distribution of the losers pool. Not only is the physical challenge relatively simple, but as the user base increases, the potential reward becomes exponentially larger. This project uses smart contracts to hold the stake from the users entering the competition, as well as refunding, and distributing the money from the loser pool amongst some randomly selected winners that completed their physical exercise. We built our frontend in React.js and our backend in Node.js. The reason why deploying this as a web3 application is advantageous is because these type of incentives fitness apps have been built on web2, however with payment processors like Stripe taking a 2.5% fee and receiving so many refund requests, Stripe actually blocked the company. With web3 we can avoid this problem since everything is handled on chain.",
        "how_its_made": "This project uses smart contracts to hold the stake from the users entering the competition, as well as refunding, and distributing the money from the loser pool amongst some randomly selected winners that completed their physical exercise. We built our frontend in React.js and our backend in Node.js. The reason why deploying this as a web3 application is advantageous is because these type of incentives fitness apps have been built on web2, however with payment processors like Stripe taking a 2.5% fee and receiving so many refund requests, Stripe actually blocked the company. With web3 we can avoid this problem since everything is handled on chain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/4zvfv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/sjns9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/y27s7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/xkei8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/04o0s/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/gkarthi280/hackathon_project/",
        "link": "https://ethglobal.com/showcase/pumproyale-vdz5o"
    },
    {
        "title": "Curvy",
        "brief_description": "Custom Curve Custom Curve Custom Curve Custom Curve Custom Curve",
        "long_description": "Custom Curve Custom Curve Custom Curve Custom Curve Custom Curve\nCustom Curve Custom Curve Custom Curve Custom Curve Custom Curve\nCustom Curve Custom Curve Custom Curve Custom Curve Custom Curve\nCustom Curve Custom Curve Custom Curve Custom Curve Custom Curve\nCustom Curve Custom Curve Custom Curve Custom Curve Custom Curve Solidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math",
        "how_its_made": "Solidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/joijc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/odkbq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/ttvfx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/y4xw5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/06iou/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/bksfw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MarcusWentz/eth-sf-2024",
        "link": "https://ethglobal.com/showcase/curvy-vjk7e"
    },
    {
        "title": "HelloACAI",
        "brief_description": "HelloACAI is Agent-based Collaborative AI infrastructure running On-Chain",
        "long_description": "Current Generalized AI helps with suggestions but doesn\u2019t actually help save execution time. AI lacks the ability to take the appropriate action based on the request. Enter Collaborative AI Agents. Multiple AI agents specializing in capabilities like:\nResearch, Interacting with websites, APIs, Calendars, Payments, etc. Purpose-built AI Agents all working together to perform complex tasks. When AI is collaborating, how can we ensure good interactions? Human agents do this through pen and paper contracts, HelloACAI does so via Smart Contracts. Interactions with and between AI Agents are bound by these contracts. HelloACAI also provides a registry for AI Agents built via a Smart Contract. Bring your own AI Agent, choose one from the registry, or both. With Collaborative AI, complex tasks are easily broken up into smaller, specific chunks. Building Collaborative AI via Smart Contracts ensures all agents interact well together. ACI Registry: Agent Collaboration Interface Registry: On-Chain Registry of Agents indexed via Subgraph Spindle \u2013 Agent Collaboration Thread: Spindle is a custom thread management system we built leveraging Substreams to rapidly respond to Agent Requested events from the ACS contract and call the corresponding Agent API Chat Interface: Friendly GUI for interacting with ACAI\nLeveraging Dynamic.xyz for easy sign in with email and CDP onramp for rapid onboarding AI Agents: Each Agent can be created independently by anyone\nAgents get contract signing capabilities, and an EOA provisioned via CDP when they are registered on ACAI",
        "how_its_made": "ACI Registry: Agent Collaboration Interface Registry: On-Chain Registry of Agents indexed via Subgraph Spindle \u2013 Agent Collaboration Thread: Spindle is a custom thread management system we built leveraging Substreams to rapidly respond to Agent Requested events from the ACS contract and call the corresponding Agent API Chat Interface: Friendly GUI for interacting with ACAI\nLeveraging Dynamic.xyz for easy sign in with email and CDP onramp for rapid onboarding AI Agents: Each Agent can be created independently by anyone\nAgents get contract signing capabilities, and an EOA provisioned via CDP when they are registered on ACAI",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hbeet/screenshots/gjixw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hbeet/screenshots/xjuaz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hbeet/screenshots/5c7ry/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/helloacai/helloacai",
        "link": "https://ethglobal.com/showcase/helloacai-hbeet"
    },
    {
        "title": "SmolKOL",
        "brief_description": "A transparent LLM-powered attention marketplace for Twitter.",
        "long_description": "I would encourage you watch the pitch! SmolKOL is an attention marketplace that connects indie Twitter accounts and companies through performance-based bounties. It allows companies or individuals to create bounties for social media engagement, and shitposters to earn rewards based on how well their content performs. The platform ensures that payments are tied to measurable outcomes such as likes or views, providing transparency and efficiency. Current \"KOL\" marketing models involve paying influencers upfront, often with no clear correlation between the payment and the actual results achieved. This creates inefficiency for brands and limits opportunities for smaller content creators to participate. There is a lack of transparency in how much value brands are getting for the money spent. SmolKOL addresses this by allowing companies/individuals to offer bounties based on specific performance metrics. Poasters submit content that aligns with these criteria, and payments are only made if the content meets the required level of engagement. This ensures that compensation is based on actual performance rather than follower count or reputation. SmolKOL operates as a bounty board where bounties are posted in natural language. Companies or individuals specify the type of engagement they want (e.g., likes, views) and the reward for meeting these targets. Creating a Bounty: A brand wants to increase awareness about a new product. They create a bounty for tweets that receive over 100 likes, offering 0.01 ETH for each tweet that meets this condition. Submitting a Tweet: A user with a relevant story or comment about the product tweets and submits their post to SmolKOL once it hits 100 likes. Verification: SmolKOL uses GPT-4O to verify that the tweet meets the bounty\u2019s criteria, including relevance to the prompt and engagement level. If the tweet is approved, the user receives the reward. Rejection Example: If the tweet does not meet the requirements or is irrelevant, GPT-4O provides natural language feedback explaining why it was rejected. SmolKOL has a few multiple parts: More specifically: And some weirdness in between (docker for postgres) It's practically my first time building frontend, especially with Next. I was way more comfortable in Rust, so I used it where I can, but it's certainly an odd mix of tech. I also didn't expect to be exploring prompt engineering before the hackathon; but realized that the new OpenAI beta feature for structured JSON output could be super useful to adjudicate whether a given tweet was valid or not. As such, I spent some time writing a system prompt which pleased me (https://github.com/stanleyjzheng/smolkol/blob/master/openai.md). By far the most annoying part of it was the Twitter API. There's so many oddities; it just said my auth was wrong. It turns out, for the free tier, Twitter API is WRITE ONLY. I've never remotely heard of that; you can create tweets, but not read? Despite all docs saying that 1500 tweets/month could still be read, it's straight up wrong, and one only finds out via forms. Else, it was $100/mo. Therefore, I decided to scrape twitter using my own account's bearer token, which oddly worked much better. Other oddities were that the callback url can't be localhost (but it allows you to set it as localhost?) so localhost:3000 doesn't work, but 127.0.0.1:3000 works fine. Why???? Truly bizzare. But whatever, some makeshift scraping did the job, so it's hard to complain in the end.",
        "how_its_made": "SmolKOL has a few multiple parts: More specifically: And some weirdness in between (docker for postgres) It's practically my first time building frontend, especially with Next. I was way more comfortable in Rust, so I used it where I can, but it's certainly an odd mix of tech. I also didn't expect to be exploring prompt engineering before the hackathon; but realized that the new OpenAI beta feature for structured JSON output could be super useful to adjudicate whether a given tweet was valid or not. As such, I spent some time writing a system prompt which pleased me (https://github.com/stanleyjzheng/smolkol/blob/master/openai.md). By far the most annoying part of it was the Twitter API. There's so many oddities; it just said my auth was wrong. It turns out, for the free tier, Twitter API is WRITE ONLY. I've never remotely heard of that; you can create tweets, but not read? Despite all docs saying that 1500 tweets/month could still be read, it's straight up wrong, and one only finds out via forms. Else, it was $100/mo. Therefore, I decided to scrape twitter using my own account's bearer token, which oddly worked much better. Other oddities were that the callback url can't be localhost (but it allows you to set it as localhost?) so localhost:3000 doesn't work, but 127.0.0.1:3000 works fine. Why???? Truly bizzare. But whatever, some makeshift scraping did the job, so it's hard to complain in the end.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/v4sy5/screenshots/1q5pv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v4sy5/screenshots/ua6o3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v4sy5/screenshots/ut8kg/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/stanleyjzheng/smolkol",
        "link": "https://ethglobal.com/showcase/smolkol-v4sy5"
    },
    {
        "title": "Spatio",
        "brief_description": "Spatio is the perfect assistant for new crypto retail traders",
        "long_description": "Spatio is your ultimate consumer app for retail traders which is a chat assistant that has access to real time crypto, crypto news, macro economic news and your portfolio data, not only that but you can also ask it to send others money and trade and swap assets making it the easiest onboarding tool to your ecosystem We are using groq llama 8b as our base llm while using different functions utilising mobula APIs which helps us fetch the MarketData, metadata and price history of any token, portfolio details and historical networth of your wallet whereas crypto panic for news and zero hedge for macroeconomic data and are asking it to generate code to solve the users query, while we are using dynamic\u2019s inbuilt functions for transferring and are using LiFi widget for cross swaps",
        "how_its_made": "We are using groq llama 8b as our base llm while using different functions utilising mobula APIs which helps us fetch the MarketData, metadata and price history of any token, portfolio details and historical networth of your wallet whereas crypto panic for news and zero hedge for macroeconomic data and are asking it to generate code to solve the users query, while we are using dynamic\u2019s inbuilt functions for transferring and are using LiFi widget for cross swaps",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6ikch/screenshots/22gic/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6ikch/screenshots/t513w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6ikch/screenshots/aym51/default.jpg"
        ],
        "live_demo": "https://spatio-psi.vercel.app/",
        "source_code": "https://github.com/harshalmadnani/spatio",
        "link": "https://ethglobal.com/showcase/spatio-6ikch"
    },
    {
        "title": "BAM Protocol",
        "brief_description": "The BAM Protocol defines a new primitive for incentivizing provable off-chain actions on chain. In addition we have built the BAM portal v0.1, a competitive, scam resistant escrow market for Twitter KOL\u2019s powered by our new primitive.",
        "long_description": "Our Project consists of two main components, the BAM protocol, and the BAM portal. The BAM Protocol is a novel primitive which allows for any off chain action, that can be proven to have happened. The Current Implementation of the BAM protocol is built to be able to incentivise ANY action. To leverage it, you simply need to connect a prover service, an off-chain source of truth (SOT), or an oracle. If the action can be proven, it can be incentivized through the BAM Protocol. To harness the power of the BAM protocol we also created the BAM Portal, which acts as scam-resistant, competitive, escrow market for twitter  KOLs. Incentive providers can create bespoke orders for their needs, filtering by follower count, sentiment, and many other variables, and pair their desired action with an incentive, which is then temporarily stored in the contract. Action providers can negotiate on both the action and the incentives. Once they fill the order, they would create the tweet and provide the tweet ID to our front end. This is then passed to the TEE running on LIT Protocol, which uses the Twitter API to reach consensus on the result of the action. Once consensus is reached the attestation is posted to both Flow network and Fhenix. At this point the incentive is taken out of the order and is sent to the action provider.\\ However our current BAM portal is just the tip of the iceberg. The BAM primitive is far more powerful  and flexible than just verifying twitter KOL\u2019s. Here are some of the extensions that are possible TODAY with BAM.\nIncentivised KOL\u2019s on any platform\nSupply Chain proofs, allowing for real work goods to be exchanged\nWhite hat hacking and auditing\nConsumer / Market Data\nDigital Labor (Logo Creation, Video Creation etc) Our project is designed to facilitate the incentivization of off-chain actions, while still supporting on-chain actions through traditional mechanisms. We achieved this by implementing a fork of the Royco protocol, which provides a solid foundation for managing incentives and verification processes. The core component of the system is the order book, which serves as a marketplace for defining and negotiating the terms of verification scripts. These scripts, which are critical for off-chain action validation, are stored on IPFS and executed by LIT Protocol nodes using Trusted Execution Environments (TEEs). Within the marketplace, order negotiation allows both incentive providers and action providers to adjust the parameters that will feed into these verification scripts. For example, in the case of Twitter actions, these parameters might include follower counts or retweet activity over a specified period. This flexible negotiation process ensures that both parties agree on clear, quantifiable metrics. Once an order is fulfilled on-chain, the off-chain action provider has a set timeframe\u2014defined by the incentive provider\u2014to complete the required action. At that point, the LIT Protocol nodes run the verification scripts to confirm whether the action occurred as agreed. The result is a signed message or hash, which is then verified by the on-chain contract. Upon successful verification, the action provider is paid out atomically, ensuring a secure, trustless transaction. By integrating multiple technologies such as IPFS for decentralized storage, LIT Protocol for off-chain verification, and smart contracts for secure payouts, we\u2019ve built a robust, flexible platform that enables seamless incentivization of both on-chain and off-chain actions.",
        "how_its_made": "Our project is designed to facilitate the incentivization of off-chain actions, while still supporting on-chain actions through traditional mechanisms. We achieved this by implementing a fork of the Royco protocol, which provides a solid foundation for managing incentives and verification processes. The core component of the system is the order book, which serves as a marketplace for defining and negotiating the terms of verification scripts. These scripts, which are critical for off-chain action validation, are stored on IPFS and executed by LIT Protocol nodes using Trusted Execution Environments (TEEs). Within the marketplace, order negotiation allows both incentive providers and action providers to adjust the parameters that will feed into these verification scripts. For example, in the case of Twitter actions, these parameters might include follower counts or retweet activity over a specified period. This flexible negotiation process ensures that both parties agree on clear, quantifiable metrics. Once an order is fulfilled on-chain, the off-chain action provider has a set timeframe\u2014defined by the incentive provider\u2014to complete the required action. At that point, the LIT Protocol nodes run the verification scripts to confirm whether the action occurred as agreed. The result is a signed message or hash, which is then verified by the on-chain contract. Upon successful verification, the action provider is paid out atomically, ensuring a secure, trustless transaction. By integrating multiple technologies such as IPFS for decentralized storage, LIT Protocol for off-chain verification, and smart contracts for secure payouts, we\u2019ve built a robust, flexible platform that enables seamless incentivization of both on-chain and off-chain actions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/2to0b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/xscf4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/q98j0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/swo4a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/8xzhk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/xi59a/default.jpg"
        ],
        "live_demo": "https://bam-portal.vercel.app/",
        "source_code": "https://github.com/githubotoro/BAM",
        "link": "https://ethglobal.com/showcase/bam-protocol-mg10y"
    },
    {
        "title": "Archivault",
        "brief_description": "Museums collection management tool with blockchain-based storage",
        "long_description": "Users can instantly create new record entries by simply taking a photo of an object. This feature eliminates the need for manual data entry, making it incredibly easy to start building a comprehensive digital catalog. Entries can be started and saved for later, with folders to organize pending entries, all entries, and then sorting by exhibits that those artifacts have been a part of. As students new to web3 development, we chose React as our frontend framework. This allowed us to break down our complex UI into manageable pieces for photo capture, AI analysis, and collection management. We focused on creating a minimum viable product where a user could create an entry based on an uploaded photo and then enter information into predefined fields. We used tailwind in order to make the front end prettier. One of us was entirely new to web development and the other was still mostly new. We tried to use Dynamic.xyz for authentication and to create a wallet that was abstracted for the user that is not familiar with blockchain. However, we ran into a lot of issues with TypeScript dependencies and were  not able to implement it.",
        "how_its_made": "As students new to web3 development, we chose React as our frontend framework. This allowed us to break down our complex UI into manageable pieces for photo capture, AI analysis, and collection management. We focused on creating a minimum viable product where a user could create an entry based on an uploaded photo and then enter information into predefined fields. We used tailwind in order to make the front end prettier. One of us was entirely new to web development and the other was still mostly new. We tried to use Dynamic.xyz for authentication and to create a wallet that was abstracted for the user that is not familiar with blockchain. However, we ran into a lot of issues with TypeScript dependencies and were  not able to implement it.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/46nts/screenshots/5kv5i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/46nts/screenshots/0bndn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/46nts/screenshots/e5s18/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/elyiagrace/Archivault",
        "link": "https://ethglobal.com/showcase/archivault-46nts"
    },
    {
        "title": "IPFi Strategy",
        "brief_description": "Create and tokenize your trading strategies on UniSwap with Story Protocol",
        "long_description": "Create your own trading strategies in UniSwap, and tokenize them via Story as IP assets to allow other users to remix or mimic your trades. Users can use different defi concepts to create their strategies including limit orders, liquidity pools with customized fees and pairs, concentrated liquidity, etc. still figuring it out. UniSwap v4's documentation is limited, and this is also my first time leveraging the protocol amongst other things so the learning curve was a little steep. I did not get a chance to even integrate with story protocol unfortunately. Nothing notable for this submission unfortunately, but learned more about UniSwap overall.",
        "how_its_made": "still figuring it out. UniSwap v4's documentation is limited, and this is also my first time leveraging the protocol amongst other things so the learning curve was a little steep. I did not get a chance to even integrate with story protocol unfortunately. Nothing notable for this submission unfortunately, but learned more about UniSwap overall.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/kxcda/screenshots/38k1t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxcda/screenshots/4qn5h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxcda/screenshots/n4f2h/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wanasim/ipfi-strategy",
        "link": "https://ethglobal.com/showcase/ipfi-strategy-kxcda"
    },
    {
        "title": "ReFy",
        "brief_description": "We're building a rewards system for businesses, where customers earn points on every purchase.   These points can be redeemed for gifts, driving customer loyalty and repeat visits.",
        "long_description": "RewardFy is a next-gen rewards system designed to boost customer engagement for retail businesses. It works by offering easy to use loyalty point-earning and gift redemption experiences. Customers are presented with promotional offers, such as earning 10 loyalty points for purchasing a specific item like a bag of chips. Upon making the purchase, customers instantly receive their loyalty points, which can be accumulated and spent on exclusive rewards. For example, a free burrito could be redeemed for 10 points. RewardFy integrates XMTP to create a personalized experience within a business's website interface (existing in the form of a chat bot). Customers can interact with a built-in bot to check their current point balance, discover new offers, and manage their account all in real-time. This integration allows for tracking of promotions, point redemption, a balance tracking system, in hopes of boosting revenues for the business.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/e3j91/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/qn1nc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/pabz8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/4aweu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Parth59/ReFy",
        "link": "https://ethglobal.com/showcase/refy-ppy1t"
    },
    {
        "title": "ReFy",
        "brief_description": "We're building a rewards system for businesses, where customers earn points on every purchase.   These points can be redeemed for gifts, driving customer loyalty and repeat visits.",
        "long_description": "RewardFy is a next-gen rewards system designed to boost customer engagement for retail businesses. It works by offering easy to use loyalty point-earning and gift redemption experiences. Customers are presented with promotional offers, such as earning 10 loyalty points for purchasing a specific item like a bag of chips. Upon making the purchase, customers instantly receive their loyalty points, which can be accumulated and spent on exclusive rewards. For example, a free burrito could be redeemed for 10 points. RewardFy integrates XMTP to create a personalized experience within a business's website interface (existing in the form of a chat bot). Customers can interact with a built-in bot to check their current point balance, discover new offers, and manage their account all in real-time. This integration allows for tracking of promotions, point redemption, a balance tracking system, in hopes of boosting revenues for the business.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/e3j91/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/qn1nc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/pabz8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/4aweu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Parth59/ReFy",
        "link": "https://ethglobal.com/showcase/refy-ppy1t"
    },
    {
        "title": "Anon Therapy",
        "brief_description": "Still waiting for that bull cycle to arrive? Well, you tried therapy and that didn't quite work out, did it? We built Anon Therapy just for you. Speak freely to our trained AI therapists that know how to help degens like you.",
        "long_description": "Still waiting for that bull cycle to arrive? Still getting rugged by influencers while your cousin at Deloitte bought their third Stanley cup? Terrified that this Thanksgiving your uncle is going to ask you about those memecoins you were talking about last year? Afraid your whole life was just a zero interest rate phenomenon? Well, you tried therapy and that didn't quite work out, did it? Your therapist thinks your NFTs are just so cute and those numbers in your spreadsheet aren't real anyway. Jaredfromsubway.eth sandwich attacking your DEX transactions isn't trauma?? We built Anon Therapy just for you. Speak freely to our trained AI therapists that know how to help degens like you. Speak freely because we let you own your own therapy chat logs. There's no dev team at BetterHelp poring over your chat logs and pointing and laughing here. In fact, you can show your chats to your therapist so they know your trauma is real. Bull market came roaring back and you feel on top of the world again? Just pretend these chats never happened and nobody will ever know that you were ever down this bad. Anon Therapy combines LLMs with blockchain technology to deliver and anonymous and secure product. Chat logs are stored on the Walrus network which provides fast and cheap decentralized storage. Dynamic is used for easy login using diverse web3 and web2 methods. We write hashes into a smart contract on Flow to easily port therapy sessions across different devices.",
        "how_its_made": "Anon Therapy combines LLMs with blockchain technology to deliver and anonymous and secure product. Chat logs are stored on the Walrus network which provides fast and cheap decentralized storage. Dynamic is used for easy login using diverse web3 and web2 methods. We write hashes into a smart contract on Flow to easily port therapy sessions across different devices.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sjjk0/screenshots/k7to2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sjjk0/screenshots/ahkhc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sjjk0/screenshots/qewbo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sjjk0/screenshots/f3tkw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Cryptonomic/anonTherapy",
        "link": "https://ethglobal.com/showcase/anon-therapy-sjjk0"
    },
    {
        "title": "TokenTally",
        "brief_description": "Empowering hackathons with decentralized, fair, and programmable judging.",
        "long_description": "Token Tally is a decentralized hackathon judging platform that gives judges a set amount of tokens to allocate across multiple projects as they see fit. After the judging round concludes, the tokens and any prize earnings are automatically distributed to team members using a smart contract and Circles programmable wallet, based on pre-determined allocation percentages. Powered by the Flow blockchain, Token Tally ensures transparent, fair, and automated reward distribution. we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js",
        "how_its_made": "we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/yatrg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/an3zd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/zx1jp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/0pu9c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/yiyeu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/aismael234/Token-Tally",
        "link": "https://ethglobal.com/showcase/tokentally-pceqb"
    },
    {
        "title": "Stake2Meet",
        "brief_description": "Stake2Meet: Stake ETH to book, show up to reclaim, valuing your time.",
        "long_description": "Stake2Meet is a time-respecting tool built for professionals, leveraging blockchain technology to minimize no-shows in scheduled meetings. Using TypeScript and Solidity, it operates by having participants stake a small amount of ETH before they can book a meeting on your calendar. If they attend, the ETH is refunded; if not, you keep it, compensating for lost time. The platform utilizes Next.js for the frontend, Hardhat, and integrates RainbowKit for seamless wallet connections. Ideal for consultants and professionals, and just about anyone that values their time. Stake2Meet reduces spammed, non-committed bookings and ensures your time is valued. Ideal for consultants and professionals, and just about anyone that values their time. It reduces spammed, non-committed bookings and ensures your time is valued. Next.js for the frontend to make everything fast and responsive. For the blockchain side, it relies on Hardhat to deploy and manage Ethereum smart contracts. And to handle wallet connections,  integrated RainbowKit so users can easily connect and stake ETH. I had it all come together to create a platform where people stake ETH to book a meeting, with smart contracts handling everything in the background!",
        "how_its_made": "Next.js for the frontend to make everything fast and responsive. For the blockchain side, it relies on Hardhat to deploy and manage Ethereum smart contracts. And to handle wallet connections,  integrated RainbowKit so users can easily connect and stake ETH. I had it all come together to create a platform where people stake ETH to book a meeting, with smart contracts handling everything in the background!",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9c8do/screenshots/gcet9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9c8do/screenshots/bgx3m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9c8do/screenshots/ra4gc/default.jpg"
        ],
        "live_demo": "https://staketomeet.vercel.app/",
        "source_code": "https://github.com/TheWeb3Attorney/Stake2Meet.",
        "link": "https://ethglobal.com/showcase/stake2meet-9c8do"
    },
    {
        "title": "DAOsaster",
        "brief_description": "Built a decentralized, autonomous disaster response system using AI agents, drones, and blockchain to detect disasters and coordinate responses without relying on traditional infrastructure.",
        "long_description": "In disasters where traditional communication and coordination fail, our project introduces a decentralized, autonomous disaster response system leveraging AI agents, drones, and blockchain technology. We deploy a network of AI agents\u2014global, regional, and local\u2014that continuously monitor environments for signs of disasters. Upon detecting an event, these agents collaborate through a blockchain-based consensus mechanism to confirm the disaster, collect data, and coordinate responses. Key Features: Autonomous Agents: AI agents detect disasters and coordinate with other agents and human organizations.\nDecentralized Coordination: Blockchain is used for trust, identity verification, and tasking rescue efforts without reliance on centralized systems.\nAutonomous Drones: Integration of drones for real-time data collection and support in rescue operations.\nConsensus Building: Agents report disasters and build consensus across the network to validate events.\nShared Data Platform: Creation of a unified, distributed dataset that maintains a shared understanding of the situation among all participants.\nHow It Works: Monitoring and Detection: Agents continuously monitor various data sources and sensors for disaster indicators.\nConsensus and Reporting: Once a potential disaster is detected, agents report it and seek confirmation from others to build consensus.\nData Collection and Sharing: As confidence in the disaster report grows, more resources like drones are deployed to gather additional data.\nAutonomous Coordination: Agents autonomously coordinate the deployment of resources and communicate with human organizations for an effective response.\nHuman Collaboration: Organizations and individuals can interact with the agents, verify their identities through decentralized mechanisms, and contribute to the response efforts.\nImpact: This system enhances disaster preparedness and response by: Providing a resilient communication network that doesn't rely on traditional infrastructure.\nEnabling rapid, coordinated responses through autonomous decision-making.\nEnsuring trust and transparency via blockchain technology.\nFacilitating collaboration between autonomous systems and human responders.\nProject Structure: Our project includes various components such as AI agents, smart contracts for blockchain interaction, tokenization of AI agents, and front-end interfaces for user interaction. Each component is modular and contributes to the overall functionality of the decentralized disaster response system. Our project is constructed by seamlessly integrating a suite of advanced technologies to establish a decentralized, autonomous disaster response system. The initial phase involves data collection from local and global agents using drones that survey and gather crucial information from disaster-stricken areas. This data\u2014which includes high-resolution video files and photographs\u2014is stored on Walrus, a platform adept at handling large file sizes efficiently. To monetize and distribute this valuable content, we utilize Story Protocol, enabling entities like news journalists to mint and use the data. Any profits generated through this process are funneled back into a DAO (Decentralized Autonomous Organization) contract, which the AI agents use to manage the supply chain. This includes automating the purchase of essential supplies like food and arranging logistics such as flight tickets for volunteers. When a disaster occurs, the AI agents initiate communication among themselves via the SKALE chain, assigning roles and coordinating actions autonomously. They leverage the Graph Protocol to query and process data swiftly, ensuring a responsive and efficient operation. Volunteers play a vital role by running DStack on their local computers, which allows them to organize and upload data to automate tasks further. For secure and confidential computing, we employ the Phala Network to run local Trusted Execution Environments (TEEs), safeguarding sensitive information and processes. To bolster liquidity and funding for the DAO managed by the AI agents, users can tokenize any of the AI assets\u2014from drones to omni-gel devices\u2014thereby contributing to the community's resources. We have integrated Dynamic Wallet to streamline user onboarding and wallet interactions, making it easier for participants to engage with the platform and support the disaster response efforts. This collaborative integration of technologies not only enhances the efficiency and effectiveness of disaster response but also fosters a community-driven approach where both AI agents and humans work in tandem to mitigate the impacts of disasters.",
        "how_its_made": "Our project is constructed by seamlessly integrating a suite of advanced technologies to establish a decentralized, autonomous disaster response system. The initial phase involves data collection from local and global agents using drones that survey and gather crucial information from disaster-stricken areas. This data\u2014which includes high-resolution video files and photographs\u2014is stored on Walrus, a platform adept at handling large file sizes efficiently. To monetize and distribute this valuable content, we utilize Story Protocol, enabling entities like news journalists to mint and use the data. Any profits generated through this process are funneled back into a DAO (Decentralized Autonomous Organization) contract, which the AI agents use to manage the supply chain. This includes automating the purchase of essential supplies like food and arranging logistics such as flight tickets for volunteers. When a disaster occurs, the AI agents initiate communication among themselves via the SKALE chain, assigning roles and coordinating actions autonomously. They leverage the Graph Protocol to query and process data swiftly, ensuring a responsive and efficient operation. Volunteers play a vital role by running DStack on their local computers, which allows them to organize and upload data to automate tasks further. For secure and confidential computing, we employ the Phala Network to run local Trusted Execution Environments (TEEs), safeguarding sensitive information and processes. To bolster liquidity and funding for the DAO managed by the AI agents, users can tokenize any of the AI assets\u2014from drones to omni-gel devices\u2014thereby contributing to the community's resources. We have integrated Dynamic Wallet to streamline user onboarding and wallet interactions, making it easier for participants to engage with the platform and support the disaster response efforts. This collaborative integration of technologies not only enhances the efficiency and effectiveness of disaster response but also fosters a community-driven approach where both AI agents and humans work in tandem to mitigate the impacts of disasters.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ngboi/screenshots/3itn3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ngboi/screenshots/dfuga/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ngboi/screenshots/kpva2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ngboi/screenshots/3knzy/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/soma9574/daosaster-response",
        "link": "https://ethglobal.com/showcase/daosaster-ngboi"
    },
    {
        "title": "Permissionless GPT4",
        "brief_description": "Permissionless access to the OpenAI API using TEE and TLS Notary.",
        "long_description": "Ever been banned by OpenAI or Anthropic? Not anymore! This project combines TLS Notary and AWS Nitro Enclaves to create a privacy-preserving OpenAI API proxy access system. By integrating Multiparty Computation and Trusted Execution Environments, it guarantees the authenticity, privacy, and censorship resistance of API requests for any transactional API. Today, accessing powerful APIs like OpenAI\u2019s can often come with trade-offs\u2014whether it\u2019s giving up privacy, being restricted by service providers, or dealing with censorship. But what if you could bypass all of that? That\u2019s where TEEProxy comes in\u2014a cutting-edge system designed to give you secure, private, and permissionless access to OpenAI\u2019s API. At the core of TEEProxy is the combination of AWS Nitro Enclaves and TLS Notary, two state-of-the-art technologies that work together to create a fully encrypted environment. When you send a request to OpenAI through TEEProxy, you can be absolutely sure your data remains private. How? We\u2019ve enhanced the Nitro remote attestation process to give you extra guarantees. Every time you make a request, a unique identifier\u2014called a nonce\u2014is embedded into the attestation document. This ensures that the response is generated specifically for you and hasn\u2019t been pre-fetched or tampered with. Additionally, TEEProxy includes a TLS certificate fingerprint in the attestation. This fingerprint proves that the TLS session\u2014the encrypted connection between you and the API\u2014terminates inside the enclave, giving you even more assurance that your communication is secure. For Service Providers, this system guarantees that their API keys remain confidential, even from the miners who run the nodes. TEEProxy makes it possible for Service Providers to trust that their keys will not be exposed, while still offering seamless access to OpenAI\u2019s powerful API. As a User, you benefit from complete anonymity and protection. Your requests are processed securely within the enclave, so neither miners nor service providers can view or intercept your data. This ensures privacy and protection from surveillance or tracking. And beyond that, censorship resistance is a key feature of TEEProxy. Because of the distributed nature of the miners, no single entity\u2014including OpenAI\u2014can stop you from accessing the API. This is permissionless access, free from restrictions or blocks. TEEProxy is built to give you the strongest guarantees: complete privacy, authenticity of responses, censorship resistance, and security. By using Multiparty Computation (MPC) alongside TLS Notary, TEEProxy guarantees the authenticity of the OpenAI responses. You can be confident that the responses you receive haven\u2019t been altered. Even though the system adds some delay, up to two minutes due to cryptographic proofs, the peace of mind is well worth it. In a world where privacy, security, and censorship resistance are increasingly important, TEEProxy stands as a breakthrough solution. Whether you\u2019re a developer, a researcher, or an enterprise looking for OpenAI API access without compromising on security or privacy\u2014TEEProxy has you covered. TEEProxy \u2013 Your key to secure, permissionless OpenAI API access. In this project, I integrate TLS Notary into the AWS Nitro Enclave and enhance the Nitro remote attestation process to provide additional guarantees for all parties involved. To achieve this I modify the attestation document to include: While functional, TLS Notary introduces significant delays \u2014 up to two minutes per request \u2014 resulting in potential OpenAI timeouts.",
        "how_its_made": "In this project, I integrate TLS Notary into the AWS Nitro Enclave and enhance the Nitro remote attestation process to provide additional guarantees for all parties involved. To achieve this I modify the attestation document to include: While functional, TLS Notary introduces significant delays \u2014 up to two minutes per request \u2014 resulting in potential OpenAI timeouts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h8oyg/screenshots/90sz1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8oyg/screenshots/azhvi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8oyg/screenshots/61j7x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8oyg/screenshots/x1bvi/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/vkleban/teegpt/",
        "link": "https://ethglobal.com/showcase/permissionless-gpt4-h8oyg"
    },
    {
        "title": "PicFable",
        "brief_description": "PicFable allows anyone to monetize their camera roll. Just upload your photos, set the price and terms of use, and you\u2019re done. Buyers can purchase the rights to use your images, remix them, or train AI models on them - with everything handled onchain.",
        "long_description": "PicFable is an image licensing hub powered by the blockchain. Similar to websites like Unsplash and Shutterstock, PicFable creates an easy way for people to discover and license images for various uses. PicFable\u2019s advantages come from its blockchain based architecture, which ensures data availability, transparency, and the ability to allow users to opt-in to being used for AI model training Using Story Protocol, PicFable enables creators to make money from their original images while specifying acceptable uses for their creations. For both professional and hobbyist photographers, PicFable represents a way to make money from stacks of unused digital images. We built this project on the Story Protocol using the Registration and Licensing modules allowing users to register their IP and assign licensing ensuring that they maintain control over their work. A user logs in through Dynamic with a Web2 like onboarding experience reducing friction. Photos are uploaded and stored on Walrus which allows the user to break their reliance on centralized systems. We then register the image on Story and assign a license as chosen by the user. Finally ENS URLs are created showcasing items available in a gallery view allowing users to create personalized pages. Some hacky workarounds were:",
        "how_its_made": "We built this project on the Story Protocol using the Registration and Licensing modules allowing users to register their IP and assign licensing ensuring that they maintain control over their work. A user logs in through Dynamic with a Web2 like onboarding experience reducing friction. Photos are uploaded and stored on Walrus which allows the user to break their reliance on centralized systems. We then register the image on Story and assign a license as chosen by the user. Finally ENS URLs are created showcasing items available in a gallery view allowing users to create personalized pages. Some hacky workarounds were:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bzitq/screenshots/id88g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bzitq/screenshots/13adg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bzitq/screenshots/62jj9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bzitq/screenshots/1t7b9/default.jpg"
        ],
        "live_demo": "https://eth-global-sf-2024.vercel.app/",
        "source_code": "https://github.com/sergical/eth-global-sf-2024",
        "link": "https://ethglobal.com/showcase/picfable-bzitq"
    },
    {
        "title": "Found in Translation",
        "brief_description": "Decentralised system for real time language translations, using open-sourced AI wearables.",
        "long_description": "FoundInTranslation is a decentralised system for real time language translations using open-sourced AI wearables, a perfect marriage between AI and blockchain technology, our elegant attempt to do language transcriptions on the fly. It has a pay as you go model where a user can refill their transcription credits, and allows the user to log in with their EVM-compatible wallet and choose from several target and destination languages. Great for tourist travels, learning new languages with international friends, or watching your favourite foreign films with loved ones. This project utilizes Dynamic for onchain signup mechanism which also utilises Phala's TEE. After a user logs in and authenticates with the preferred wallet, we ask the user to choose a language in which they prefer the translation. We have deployed a smart contract on Polygon for our ERC20 token, which will be utilised by our consumers. The user speaks into the AI wearable Omi and the transcription is sent to the phala AI  agent which in turn does the translation depending on the user's translation language preference, which is further used to convert the translated text to audio in the UI running on next.js.",
        "how_its_made": "This project utilizes Dynamic for onchain signup mechanism which also utilises Phala's TEE. After a user logs in and authenticates with the preferred wallet, we ask the user to choose a language in which they prefer the translation. We have deployed a smart contract on Polygon for our ERC20 token, which will be utilised by our consumers. The user speaks into the AI wearable Omi and the transcription is sent to the phala AI  agent which in turn does the translation depending on the user's translation language preference, which is further used to convert the translated text to audio in the UI running on next.js.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/tdtwj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/vt4hp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/mi0nn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/eww4m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/rju0g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/rg2xh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Prachi1615/FoundInTranslation",
        "link": "https://ethglobal.com/showcase/found-in-translation-rxyws"
    },
    {
        "title": "Archiv3",
        "brief_description": "A video archive aggregator that allows documentary makers to license clips from multiple archives with ease.",
        "long_description": "Documentaries are more popular than ever. Almost 50% of Americans continuously stream docs across all major video channels. Netflix is expected to spend over $1.5 billion on documentary and non-scripted content by next year. Video archive licensing right now is very clunky and often revolves around email. Archiv3 allows filmmakers large and small to pull down clips across multiple archives, allowing for a better product. Product is built on top of Story. Front-end is done through Scaffold ETH. Walrus is used for metadata and asset storage. Hackiest thing in here is a globally resetting array for easy iteration of royalty splits. I figured out that the SDK didn't support the latest smart contract features so I had to hard code a few variables to simulate some of those actions.",
        "how_its_made": "Product is built on top of Story. Front-end is done through Scaffold ETH. Walrus is used for metadata and asset storage. Hackiest thing in here is a globally resetting array for easy iteration of royalty splits. I figured out that the SDK didn't support the latest smart contract features so I had to hard code a few variables to simulate some of those actions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/183kk/screenshots/quncm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/183kk/screenshots/0s8eq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/183kk/screenshots/e6j4u/default.jpg"
        ],
        "live_demo": "https://archiv3-3snws40pz-hlauinfos-projects.vercel.app",
        "source_code": "https://github.com/hlauinfo/archiv3",
        "link": "https://ethglobal.com/showcase/archiv3-183kk"
    },
    {
        "title": "ETH Movie Voting",
        "brief_description": "The ETH Movie Database is a decentralized app built with React and Ethereum. It allows users to vote on movies transparently via MetaMask, recording votes on-chain for a secure, tamper-proof ranking system. A showcase of blockchain's potential in entertainment",
        "long_description": "The ETH Movie Database is a decentralized web application designed to let users rank and vote on movies in a transparent and secure manner. Built as a user-centric platform, it allows users to connect their Ethereum wallet using MetaMask and cast votes on a curated list of movies. The votes are recorded directly on the Ethereum blockchain, ensuring immutability and preventing tampering or manipulation. The application presents users with detailed movie information, including titles, release years, and posters. Users can upvote or downvote movies based on their preferences, and the app dynamically updates the movie rankings based on the community's interactions. The goal is to provide an engaging and transparent voting experience, showcasing how blockchain technology can be applied in entertainment. The ETH Movie Database is developed using React for the frontend, enabling a dynamic and responsive user interface. It integrates with the Ethereum blockchain using the ethers.js library for Web3 interactions. The application relies on MetaMask as the Ethereum provider, allowing users to securely connect their wallets and interact with the smart contract. Technical Details: Frontend: Built with React, the app displays a list of movies with images and current rankings. Users interact with the app through buttons to upvote or downvote, and the state updates in real-time based on the blockchain data.\nSmart Contract: The application\u2019s smart contract is deployed on the Ethereum network. It manages the voting logic, recording votes securely on-chain. The contract provides functions to upvote, downvote, and retrieve vote counts for each movie.\nState Management: The app uses React\u2019s state management to keep track of movie data. When the user connects their wallet and votes, the frontend interacts with the smart contract to update the votes and rankings, ensuring the UI reflects the latest state from the blockchain.\nBlockchain Interaction: MetaMask is used for user authentication and wallet connection. The app creates a Web3Provider using ethers.js to interact with the smart contract. Upon wallet connection, the app fetches and displays the latest voting data from the blockchain.\nThe ETH Movie Database showcases the potential of decentralized applications (dApps) and emphasizes secure, community-driven content ranking through blockchain technology.",
        "how_its_made": "The ETH Movie Database is developed using React for the frontend, enabling a dynamic and responsive user interface. It integrates with the Ethereum blockchain using the ethers.js library for Web3 interactions. The application relies on MetaMask as the Ethereum provider, allowing users to securely connect their wallets and interact with the smart contract. Technical Details: Frontend: Built with React, the app displays a list of movies with images and current rankings. Users interact with the app through buttons to upvote or downvote, and the state updates in real-time based on the blockchain data.\nSmart Contract: The application\u2019s smart contract is deployed on the Ethereum network. It manages the voting logic, recording votes securely on-chain. The contract provides functions to upvote, downvote, and retrieve vote counts for each movie.\nState Management: The app uses React\u2019s state management to keep track of movie data. When the user connects their wallet and votes, the frontend interacts with the smart contract to update the votes and rankings, ensuring the UI reflects the latest state from the blockchain.\nBlockchain Interaction: MetaMask is used for user authentication and wallet connection. The app creates a Web3Provider using ethers.js to interact with the smart contract. Upon wallet connection, the app fetches and displays the latest voting data from the blockchain.\nThe ETH Movie Database showcases the potential of decentralized applications (dApps) and emphasizes secure, community-driven content ranking through blockchain technology.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/msbpq/screenshots/9n4x5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/msbpq/screenshots/h7b8f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/msbpq/screenshots/254ru/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/alexhaeringer/ETHGlobal-SF24",
        "link": "https://ethglobal.com/showcase/eth-movie-voting-msbpq"
    },
    {
        "title": "Gameverse",
        "brief_description": "A chatbot integrating a text-based currency game and a real-world auction system",
        "long_description": "This project combines XMTP messaging and on-chain data storage to implement a currency-based game and auctioning system. Users can solve web3 trivia questions, run commands, be active in group chats to earn coins, and compete with each other by stealing coins from each other and competing to be the top coin holder on the leaderboard. All of these coins are stored on-chain on the SKALE Network, and can be traded for NFTs, collectibles and other tokens. Users in group chats can auction off items to the highest bidder, setting a bid increment and starting bid in an English auction format. The winner of the auction will receive an Open Frame link to pay for their item, and the owner will receive payment once payment has been successfully completed and verified. The project is designed to be a step forward in chatbot integration on-chain, combining an entertainment experience with real-world applications. The development of this project included using Converse's MessageKit framework to develop a chatbot interface. A particularly interesting part of the implementation was designing a custom message handler, as well as editing the source code of the MessageKit framework itself to allow bots to read all messages in group chats so that this handler could extend the existing command framework provided. Some other interesting applications were to create a MessageCollector class that would allow for the bot to \"listen\" to messages in response to a command, without needing for any advanced state-tracking or caching mechanism. This was done using Node.JS' in-built EventEmitter mechanism and event loops. The bot uses SKALE Network to store currency data, minimizing transaction backlog by committing data on-chain every hour in the form of snapshots. This is all handled by the bot's source code in a cron scheduler, making sure that the bot will never miss a snapshot. Data is committed and retrieved from the smart contract when necessary, taking advantage of SKALE's zero-gas mechanisms to completely cut out transaction fees and abstract away the on-chain mechanism of this bot, integrating into a seamless, simple experience for the end user. The bot's auction mechanism is developed using a smart contract on the AirDAO chain -- all details are public, allowing for integration into AirDAO's existing projects like AirQuest (a quest could be implemented for hosting 3 successful auctions etc.). More dev notes and details are included in the repository in the DEVNOTES.MD file.",
        "how_its_made": "The development of this project included using Converse's MessageKit framework to develop a chatbot interface. A particularly interesting part of the implementation was designing a custom message handler, as well as editing the source code of the MessageKit framework itself to allow bots to read all messages in group chats so that this handler could extend the existing command framework provided. Some other interesting applications were to create a MessageCollector class that would allow for the bot to \"listen\" to messages in response to a command, without needing for any advanced state-tracking or caching mechanism. This was done using Node.JS' in-built EventEmitter mechanism and event loops. The bot uses SKALE Network to store currency data, minimizing transaction backlog by committing data on-chain every hour in the form of snapshots. This is all handled by the bot's source code in a cron scheduler, making sure that the bot will never miss a snapshot. Data is committed and retrieved from the smart contract when necessary, taking advantage of SKALE's zero-gas mechanisms to completely cut out transaction fees and abstract away the on-chain mechanism of this bot, integrating into a seamless, simple experience for the end user. The bot's auction mechanism is developed using a smart contract on the AirDAO chain -- all details are public, allowing for integration into AirDAO's existing projects like AirQuest (a quest could be implemented for hosting 3 successful auctions etc.). More dev notes and details are included in the repository in the DEVNOTES.MD file.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h8w91/screenshots/bzkp0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8w91/screenshots/gaovb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8w91/screenshots/tk5ro/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8w91/screenshots/xc6fn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/keshramamurthy/gameverse-ethsf/",
        "link": "https://ethglobal.com/showcase/gameverse-h8w91"
    },
    {
        "title": "PolymarketAnalytics",
        "brief_description": "Polymarket Analytics allows you to fetch and analyze all trades made by any account on Polymarket, bypassing the platform's viewing limitations. Track profit and loss over time, inspect impactful trades, and uncover trading strategies. Built using Scaffold-ETH-2 and subgraphs.",
        "long_description": "Our project provides an analytics tool for Polymarket users. Polymarket does not allow users to view the complete trade history of an account, which limits their ability to analyze performance and strategies. We address this limitation by using subgraphs/substreams to fetch all trades made by any account on Polymarket. This enables users to: Future Plans: We plan to allow users to connect their own wallets and automatically copy trades made by other Polymarket traders using substreams. Substreams offer lower latency than subgraphs, minimizing tracking errors when copying trades. Implementation of this feature is currently on hold due to issues with the Application Binary Interface (ABI) of the Polymarket CTF Market, which prevents proper functionality. We built Polymarket Analytics using Scaffold-ETH-2 as our foundational template, which streamlined our setup process. Data Retrieval with Subgraphs/Substreams: We utilized multiple existing subgraphs and developed a custom subgraph to fetch detailed trade data from Polymarket. These subgraphs collect and organize on-chain data, making it accessible for analysis. Chart.js and similar libraries to visualize the data By using subgraphs we've created a tool that enhances transparency and strategy analysis for Polymarket users.",
        "how_its_made": "We built Polymarket Analytics using Scaffold-ETH-2 as our foundational template, which streamlined our setup process. Data Retrieval with Subgraphs/Substreams: We utilized multiple existing subgraphs and developed a custom subgraph to fetch detailed trade data from Polymarket. These subgraphs collect and organize on-chain data, making it accessible for analysis. Chart.js and similar libraries to visualize the data By using subgraphs we've created a tool that enhances transparency and strategy analysis for Polymarket users.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/e18yc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/6g706/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/fqwp8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/gwm5r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/9vhuc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/HighDom/polymarket_analysis_v1",
        "link": "https://ethglobal.com/showcase/polymarketanalytics-vt1dm"
    },
    {
        "title": "SnapSafe",
        "brief_description": "The world's first secure screenshot app that prioritizes your privacy.",
        "long_description": "SnapSafe is the ultimate privacy-focused screenshot app. It empowers users to securely capture, edit, and organize screenshots without worrying about unauthorized access or data leaks. With advanced features like OCR for text extraction, decentralized storage, and a cross-platform dashboard, SnapSafe offers a seamless experience for managing images, all while ensuring your privacy is the top priority. In a world of growing data concerns, SnapSafe is the go-to solution for anyone seeking the perfect balance between functionality and security. We use IPFS/Walrus for storage. And we use SKALE/FLOW/MORPH to manage directory.\nWe use Electron to make the app fully cross-platform compatible, and after uploading the screenshots, it gets stored as directory in the chain.",
        "how_its_made": "We use IPFS/Walrus for storage. And we use SKALE/FLOW/MORPH to manage directory.\nWe use Electron to make the app fully cross-platform compatible, and after uploading the screenshots, it gets stored as directory in the chain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/oa3mv/screenshots/811ze/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oa3mv/screenshots/k0pke/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oa3mv/screenshots/i5y7o/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AllenAJ/SnapSafe",
        "link": "https://ethglobal.com/showcase/snapsafe-oa3mv"
    },
    {
        "title": "AutoSplit",
        "brief_description": "AutoSplit is an expense-sharing dApp that revolutionizes debt management. Define personalized debt thresholds, and watch as automated reimbursement requests with secure payment links are effortlessly dispatched\u2014all powered by the gas-free Skale Network.",
        "long_description": "AutoSplit is a decentralized application designed to simplify expense sharing and debt management among friends, colleagues, and groups. AutoSplit automates the entire process by allowing users to create groups, add participants, shared expenses, and set personalized debt thresholds. When a member's debt surpasses the limit set by the payer, the app automatically sends a notification with a secure payment link, eliminating the need for awkward conversations. Leveraging Sign Protocol, each expense generates a verifiable attestation sent via XMTP, ensuring transactions are secure and trustworthy. With real-time balance tracking and secure in-app messaging, AutoSplit fosters transparency and accountability, making shared finances seamless and stress-free. AutoSplit is built on the Skale Network, chosen for its zero gas fees, high throughput, and EVM compatibility, which are essential for handling numerous daily microtransactions cost-effectively. The frontend is developed using React with TypeScript to ensure a user-friendly and scalable interface. Smart contracts written in Solidity manage group creation, expense tracking, and debt thresholds, seamlessly interacting with the Skale blockchain. Integration with Sign Protocol allows each expense to generate secure, verifiable attestations sent via XMTP, enabling automated and trustworthy notifications. By combining Skale's robust infrastructure with Sign Protocol's security features, AutoSplit delivers a reliable and intuitive solution for managing shared expenses and repayments without the complexities of traditional Web3 applications.",
        "how_its_made": "AutoSplit is built on the Skale Network, chosen for its zero gas fees, high throughput, and EVM compatibility, which are essential for handling numerous daily microtransactions cost-effectively. The frontend is developed using React with TypeScript to ensure a user-friendly and scalable interface. Smart contracts written in Solidity manage group creation, expense tracking, and debt thresholds, seamlessly interacting with the Skale blockchain. Integration with Sign Protocol allows each expense to generate secure, verifiable attestations sent via XMTP, enabling automated and trustworthy notifications. By combining Skale's robust infrastructure with Sign Protocol's security features, AutoSplit delivers a reliable and intuitive solution for managing shared expenses and repayments without the complexities of traditional Web3 applications.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/varyw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/ivn7s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/bes5f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/thdhy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/r57rt/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MarouaBoudoukha/AutoSplit",
        "link": "https://ethglobal.com/showcase/autosplit-dr6oj"
    },
    {
        "title": "my own words",
        "brief_description": "Browser Extension for portable IP experimentation and interactions",
        "long_description": "my-own-words is a browser extension organizing the provenance and nuance of ideas on the Story Network. Users can create written work in the editor of their choice, highlight it, attach terms of fair use and register a snapshot of its provenance and permissions. There is AI support natively integrated into the project for users unfamiliar Story or IP to still have understanding, agency, and support as they navigate registering new works. We see this project being especially useful for two audiences: researchers and academics who very much value the provenance of ideas, creators and artists across industries. This project uses Pinata and IPFS for storage of text files, Polygon for tokenization of these files' content IDs, and Story SDK for registering these NFTs onchain with licensing terms. We used React, Typescript, ChakraUI, and Emma's original Procreate animations for the front end. For the backend, we used an express server, cors for browser extension to server communication. We also used the ChatGPT API to create and fine-tune our AI arbiter and AI also to auto-suggest recommendations for descriptions, licensing terms, etc. for a simple introduction to IP.",
        "how_its_made": "This project uses Pinata and IPFS for storage of text files, Polygon for tokenization of these files' content IDs, and Story SDK for registering these NFTs onchain with licensing terms. We used React, Typescript, ChakraUI, and Emma's original Procreate animations for the front end. For the backend, we used an express server, cors for browser extension to server communication. We also used the ChatGPT API to create and fine-tune our AI arbiter and AI also to auto-suggest recommendations for descriptions, licensing terms, etc. for a simple introduction to IP.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/d1a7h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/aakkc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/8nhfp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/y5yav/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/ci8j4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/nxad7/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/emmanasseri/my-own-words",
        "link": "https://ethglobal.com/showcase/my-own-words-9uap2"
    },
    {
        "title": "Left Curve Simulator",
        "brief_description": "LCS is a dex where users press one button and automatically purchase 3 silly memecoins at random.",
        "long_description": "Buying memecoins is hard, that's why we built left curve simulator! With LCS even the dumbest left curve can buy memecoins with virtually no difficulties or strategy. LCS is a dex where users press one button and automatically purchase 3 silly memecoins at random. To decrease friction, we are utilizing unlimit crypto to allow users to onramp with debit or credit card, and start transacting with Ethereum. After they onramp, they just need to determine how much money they want to ape into memecoins. Once they decide they click generate and 3 random tokens are chosen, and purchased. To make sure only quality tokens are generated we filter tokens by minimum TVL of $5k, and have transactions which occurred within 24 hours. We also are passing the data through AI to make sure only tokens with silly names are chosen. tbdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddd",
        "how_its_made": "tbdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddd",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zzzqa/screenshots/kzm8r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zzzqa/screenshots/jep8i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zzzqa/screenshots/cht3e/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/arrudagates/leftcurve",
        "link": "https://ethglobal.com/showcase/left-curve-simulator-zzzqa"
    },
    {
        "title": "IP Infinity",
        "brief_description": "The user will input their ENS; their NFTs are processed, labeled as a type of game object (character, equipment, other), and given stats based on its floor price and traits. The NFTs get put in a world with a procedurally generated map/world with full game functionality.",
        "long_description": "IP-Landers is a project that brings NFTs to life by creating an interactive game experience combining digital IP assets with an immersive world. The process begins when users input their ENS. Their NFTs are each processed and categorized by AI, getting transformed into game objects like characters or equipment. Each game object is assigned stats that reflect the floor price and its traits. These assets are then implemented into a procedurally generated game world built in Unreal Engine, providing an engaging and dynamic environment. The project's unique feature is the story's IP database, which allows users to share their NFT worlds and contribute to them with their own distinct characters and stories. IP-Landers was built using AI models, blockchain integration, and game development tools. Meta's Llama 3.2 vision model analyzes the NFT images, generating text descriptions that are categorized by the DeBERTa zero-shot classification model, sorting them into different types of objects. Unreal Engine powers the game, featuring procedurally generated landscapes and dungeons for a dynamic experience. Story Protocol's platform allows collaborative creativity without IP disputes. We implemented a unique solution to link NFT metadata to playable Unreal Engine assets.",
        "how_its_made": "IP-Landers was built using AI models, blockchain integration, and game development tools. Meta's Llama 3.2 vision model analyzes the NFT images, generating text descriptions that are categorized by the DeBERTa zero-shot classification model, sorting them into different types of objects. Unreal Engine powers the game, featuring procedurally generated landscapes and dungeons for a dynamic experience. Story Protocol's platform allows collaborative creativity without IP disputes. We implemented a unique solution to link NFT metadata to playable Unreal Engine assets.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/q0f4x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/k9j1o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/kuxja/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/ai31i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/auzia/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/oowia/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/edi3on/ip-infinity",
        "link": "https://ethglobal.com/showcase/ip-infinity-mnkym"
    },
    {
        "title": "ZK Wallet",
        "brief_description": "ZK Wallet improves wallet signature security and creates new authorization flows",
        "long_description": "ZK Wallet uses ZK to mask signatures both offchain and onchain and verifiable proof that the signature exists, drastically improving wallet accounts security against phishing and other malicious attacks. Morever, ZK powered proofs improve authorization flow within smart contracts, that increases safety and controls undesired outcomes directly. Within this project I show: I use:\nZK-EVM - Risc 0\nBackend - Rust\nGPU acceleration - Bonsai\nFrontEnd - TypeScript\nContracts - Solidity\nEssentially FrontEnd acts as a wallet and interacts with Backend through REST API to send and receive proofs. Backend connected to ZKVM as host to query proofs and verifications. FrontEnd also interacts with Contracts to verify proofs within Contract context.",
        "how_its_made": "I use:\nZK-EVM - Risc 0\nBackend - Rust\nGPU acceleration - Bonsai\nFrontEnd - TypeScript\nContracts - Solidity\nEssentially FrontEnd acts as a wallet and interacts with Backend through REST API to send and receive proofs. Backend connected to ZKVM as host to query proofs and verifications. FrontEnd also interacts with Contracts to verify proofs within Contract context.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tnmaq/screenshots/z2xw2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tnmaq/screenshots/xdm3f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tnmaq/screenshots/a17z8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tnmaq/screenshots/ppkgv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/altyni86/Eth_Global_Submit",
        "link": "https://ethglobal.com/showcase/zk-wallet-tnmaq"
    },
    {
        "title": "ExerciseTee",
        "brief_description": "Monitor your exercise from Whoop and shame you on twitter if you don't exercise for two consecutive days!",
        "long_description": null,
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qepxo/screenshots/0gb5v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qepxo/screenshots/d9grq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qepxo/screenshots/a096r/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/renchuqiao/tee-exercise",
        "link": "https://ethglobal.com/showcase/exercisetee-qepxo"
    },
    {
        "title": "Quantum Gate",
        "brief_description": "Quantum Gate unlocks EVM utilities on BTC Ordinals inscriptions.",
        "long_description": "NFT liquidity has gone to BTC Ordinals. What if we have ways to bring the liquidity back to the EVM ecosystem? This is an experimental project for showcasing EVM smart contract calls inside BTC Ordinals inscriptions. A MetaMask user visits a Quantum Gate inscription page and switches to a full-screen mode. S/he clicks on the \"unlock\" button and connects a wallet. The inscription prompts the user to sign a human-readable message and submit that signature to an EVM smart contract. The contract got called successfully and more EVM utilities were unlocked on Quantum Gate's BTC inscriptions. BTC Inscriptions are mostly html-based. BTC inscription are placed in a sandbox environment so that no external server calls are allowed. However, wallets such as MetaMask are injecting codes through web browsers. This provides an opportunity to place smart contract calls within BTC inscriptions.",
        "how_its_made": "BTC Inscriptions are mostly html-based. BTC inscription are placed in a sandbox environment so that no external server calls are allowed. However, wallets such as MetaMask are injecting codes through web browsers. This provides an opportunity to place smart contract calls within BTC inscriptions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/7btoa/screenshots/1s2my/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7btoa/screenshots/8arxg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7btoa/screenshots/j3b0f/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jackieeth/quantumgate-ethglobalsf2024",
        "link": "https://ethglobal.com/showcase/quantum-gate-7btoa"
    },
    {
        "title": "Power Agents",
        "brief_description": "Create, manage and chat with your AI agents from a XMTP group chat.",
        "long_description": "Power Agents is a collection of AI agents that you can spawn and chat with in an XMTP Group Chat. These agents are powered by Brian and leverage the CDP SDK to have their own wallets and funds to operate on behalf of the user. Each agent when it's created receives a poweragents.eth ENS subdomain, so that the user can easily remember it's handle when creating a new group chat, or when chatting with it outside of a group.\nWithin the group chat, you can chat with your agents and make them perform tasks. We developed the following Agents: This projects uses the following technologies: We also developed from scracth a nice way to spawn new XMTP bots inside the same repository at runtime without the need of re-deploying the project.",
        "how_its_made": "This projects uses the following technologies: We also developed from scracth a nice way to spawn new XMTP bots inside the same repository at runtime without the need of re-deploying the project.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/sorrv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/gq11o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/1z4u3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/qgu4d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/1dagu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/rxeux/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/builders-garden/power-agents",
        "link": "https://ethglobal.com/showcase/power-agents-djqmb"
    },
    {
        "title": "Essence Vault",
        "brief_description": "Essence Vault: a secure, efficient multisig wallet on Essential's declarative blockchain. #Essential #DeFi #Multisig #EthGlobal",
        "long_description": "Essence Vault is a multisig (multi-signature) wallet built on the Essential blockchain, leveraging the platform\u2019s declarative smart contract system to provide a secure, transparent, and efficient way to manage funds collectively. Multisig wallets require a predefined number of signatories (wallet holders) to approve any outgoing transaction, providing enhanced security and decentralized control over funds. Key Features of Essence Vault:\nm-of-n Approval System: The core functionality of Essence Vault is its m-of-n approval system. In simple terms: n is the total number of authorized members (or signatories) who can approve or reject a transaction.\nm is the minimum number of these members required to approve a transaction before it can be executed. This ensures that no single party can unilaterally control the wallet\u2019s funds. For example, if you have a 5-member wallet (n=5), and set m=3, at least 3 out of the 5 members must approve any fund transfers before it is executed.\nCreate a Multisig Wallet: At the start, an authorized user can create a new multisig wallet by providing a set of member addresses and specifying m, the minimum number of required approvals. This can be easily adjusted later as needed. Add/Remove Members: Wallet members can be added or removed based on the collective decision of existing members. The multisig wallet maintains flexibility by allowing changes in membership without disrupting operations or compromising security. Update m-of-n Configuration: If necessary, members can change the m value, adjusting the number of approvals required. This is especially useful if the organizational structure changes or the wallet grows in size. Fund Management (Receive & Send Funds): Receiving Funds: Anyone can send funds to the multisig wallet. It serves as a shared account for organizations, teams, or projects that need collective control over assets.\nSending Funds: To send funds, a transaction proposal is made, and the required number of members must approve it (based on the m-of-n rule) before the transfer is completed.\nTransaction Proposals: Any member can propose a transaction, such as sending funds to another wallet. Once proposed, other members must review and approve or reject the transaction. Approve Approvals: Members have the ability to approve a transaction proposal, and if they change their mind before the transaction is finalized, they can revoke their approval. This allows flexibility and ensures that all decisions are well-considered. View Transaction History: All transactions\u2014whether proposed, pending, approved, rejected, or completed\u2014are stored transparently on the blockchain. Users can easily view this history to ensure accountability. Security and Transparency: Built on Essential\u2019s declarative smart contracts, Essence Vault emphasizes simplicity, security, and auditability. By focusing on what should happen rather than how, it reduces the likelihood of vulnerabilities like reentrancy attacks that are common in other blockchain systems. Low Gas Costs: Thanks to Essential\u2019s blockchain optimizations, transaction costs are minimized, making Essence Vault a cost-effective solution for managing collective funds without the high fees typically associated with smart contract execution on imperative blockchains like Ethereum. Why Essence Vault?\nEssence Vault is ideal for organizations, venture capital funds, DeFi projects, DAOs, or any group that needs shared control over assets. It\u2019s particularly useful for managing treasury funds, handling collective investments, and ensuring that no single entity has unilateral access to funds. With its m-of-n approval system, all decisions are decentralized, preventing fraud, theft, or misuse of funds. Advantages of Using Essential Blockchain for Multisig Wallets:\nDeclarative Smart Contracts: Essence Vault leverages Essential\u2019s declarative nature, which allows smart contracts to focus on intent, making the logic simpler and reducing the risk of bugs and security vulnerabilities.\nEnhanced Security: By minimizing low-level control, the risk of errors or exploits is reduced, leading to a more secure wallet. This is especially critical for large or organizational funds.\nEfficiency and Cost Savings: Compared to other blockchains, Essential's structure optimizes for lower gas costs, ensuring that even high-frequency or complex transactions are cost-effective.\nScalability: As Essential is designed to support large-scale decentralized applications, Essence Vault is well-positioned to handle the demands of growing organizations or DAOs that may scale significantly over time.\nUse Cases:\nDecentralized Autonomous Organizations (DAOs): DAOs often manage collective treasuries, and Essence Vault\u2019s multisig model ensures that no single member can misappropriate funds. This m-of-n approval system also aligns with the decentralized decision-making model that DAOs are built upon. Venture Capital or Investment Funds: For groups of investors managing pooled funds, Essence Vault ensures that any outgoing transactions are approved by multiple stakeholders, safeguarding against unauthorized withdrawals or investments. Corporate Treasury Management: Essence Vault can be used by companies to manage internal budgets or decentralized teams that need to ensure financial decisions are made transparently and securely. Grant Funds or Non-Profits: When distributing grants or donations, it\u2019s important to ensure accountability. The multisig approval process guarantees that funds are only released after careful consideration and approval by trusted members. Future Roadmap for Essence Vault\nAs Essence Vault evolves, additional functionalities will be implemented to further enhance its capabilities: Revoke Approval: Members will be able to revoke their on-chain approval before a transaction is fully approved, providing flexibility and allowing members to reconsider decisions before execution.\nSet Time-Locked Approvals: On-chain time locks will be added, allowing transactions to be delayed for a specified time after receiving approvals, which adds an additional layer of protection for large or sensitive transfers.\nSet Transaction Limits: On-chain transaction limits will automatically adjust the number of required approvals based on the transaction size. For example, larger transactions could require more signatories or escalate to higher levels of the hierarchy, while smaller transactions may be executed with fewer approvals.\nStaking Wallet Funds: To optimize treasury management, a portion of the wallet's funds can be staked in DeFi protocols to earn passive income. AI and statistical models will analyze transaction history to suggest staking strategies and portfolio management, ensuring that funds not needed for immediate use are working to generate yield. Essence Vault was built using Pint for the smart contract, which simplifies logic by focusing on what needs to happen, ensuring security and reducing vulnerabilities. The frontend is written in Rust for performance and safety, leveraging WebAssembly for smooth cross-platform execution. Partnering with Essential allowed us to leverage declarative blockchain design.",
        "how_its_made": "Essence Vault was built using Pint for the smart contract, which simplifies logic by focusing on what needs to happen, ensuring security and reducing vulnerabilities. The frontend is written in Rust for performance and safety, leveraging WebAssembly for smooth cross-platform execution. Partnering with Essential allowed us to leverage declarative blockchain design.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dmrve/screenshots/1h25k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dmrve/screenshots/1rxjz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dmrve/screenshots/jcnzc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/esphene/eth-global-sf-2024",
        "link": "https://ethglobal.com/showcase/essence-vault-dmrve"
    },
    {
        "title": "TipJar",
        "brief_description": "The Tip Jar is a DApp that gamifies tipping and incentives community use.",
        "long_description": "The Tip Jar is a decentralized application (DApp) built on the Ethereum blockchain, utilizing the SKALE network for gasless transactions. This platform allows users to send and receive tips in a user-friendly manner while contributing to a communal jar that encourages community support. Blockchain: Ethereum (via SKALE for gas-free transactions)\nSmart Contracts: Solidity for managing the tip jar and communal jar logic\nFrontend: Simple web app (HTML/CSS/JavaScript) with Metamask SDK integration\nBackend (optional): If you want to store extra user data or logs off-chain, you can use a server (e.g., Node.js, Express) or a decentralized storage solution like IPFS\nDeployment: SKALE network for Ethereum",
        "how_its_made": "Blockchain: Ethereum (via SKALE for gas-free transactions)\nSmart Contracts: Solidity for managing the tip jar and communal jar logic\nFrontend: Simple web app (HTML/CSS/JavaScript) with Metamask SDK integration\nBackend (optional): If you want to store extra user data or logs off-chain, you can use a server (e.g., Node.js, Express) or a decentralized storage solution like IPFS\nDeployment: SKALE network for Ethereum",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/789zv/screenshots/mj0x5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/789zv/screenshots/84azi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/789zv/screenshots/q7ztz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/789zv/screenshots/mu72f/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/deapinkme/ETHGlobalSF24/tree/main/demo",
        "link": "https://ethglobal.com/showcase/tipjar-789zv"
    },
    {
        "title": "Pinnect",
        "brief_description": "Pinnect: Interactive story co-creating platform that lets creators write and link stories on open-world.",
        "long_description": "Pinnect is an innovative open-world co-creation platform that revolutionizes how people interact with and conceive storytelling. It allows users to place their narratives within specific geographic locations on a virtual map, linking ideas and expanding upon existing tales contributed by others. This digital ecosystem supports a vibrant community of creators, from writers and artists to thinkers, who wish to leave their mark on a shared, evolving narrative landscape. Technology Stack:\nFrontend: Built with Swift for a native iOS experience, ensuring a smooth and intuitive user interface tailored for mobile devices.\nBackend: The backend runs on Node.js, utilizing Express.js for API management, which orchestrates interactions between the frontend, the database, and the blockchain components. Blockchain and Web3 Integration:\nEthereum Blockchain: Smart contracts written in Solidity handle DAO functionalities, content monetization, and IP management.\nStory Protocol: Integrates with Story Protocol for IP asset registration and management, leveraging its IPFi (Intellectual Property Finance) capabilities to create a market for buying and selling story-based IP assets.\nWeb3.js: Allows the mobile app to interact directly with Ethereum blockchain, enabling transactions such as voting, content posting, and royalty distributions directly from the user\u2019s device.",
        "how_its_made": "Technology Stack:\nFrontend: Built with Swift for a native iOS experience, ensuring a smooth and intuitive user interface tailored for mobile devices.\nBackend: The backend runs on Node.js, utilizing Express.js for API management, which orchestrates interactions between the frontend, the database, and the blockchain components. Blockchain and Web3 Integration:\nEthereum Blockchain: Smart contracts written in Solidity handle DAO functionalities, content monetization, and IP management.\nStory Protocol: Integrates with Story Protocol for IP asset registration and management, leveraging its IPFi (Intellectual Property Finance) capabilities to create a market for buying and selling story-based IP assets.\nWeb3.js: Allows the mobile app to interact directly with Ethereum blockchain, enabling transactions such as voting, content posting, and royalty distributions directly from the user\u2019s device.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/y1hnr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/1gs02/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/4z8xq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/cfw9o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/opnj0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/kigy3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AnnieTianyuHuang/ethSF24-proj",
        "link": "https://ethglobal.com/showcase/pinnect-j3531"
    },
    {
        "title": "JunLend",
        "brief_description": "One-click migration that guarantees better yield and liquidation protection.",
        "long_description": "JunLend features a simple one-click migration that guarantees better yield and liquidation protection. JunLend pools everyone's positions together. So if I'm borrowing USDC and you're supplying USDC, you can use your USDC to pay off my debt. In this pool, we match users' deposits/borrows to create win-win situations that boost the underlying yield efficiency. This also boosts the global health factor, creating this buffer for liquidations. Instead of AAVE liquidating you, JunLend would liquidate you through a fair Dutch auction that lets you keep the MEV surplus. JunLend will support many lending protocols and many different chains. It's strictly better to use JunLend over the vanilla option. The smart contracts use Uniswap v4 to flashloan so it can migrate a user's borrow position. Liquidations are handled with a Uniswap hook that lets users buy the capital in exchange for the debt. Chronicle powers the oracle for internal liquidations. The frontend is built with next.js and wagmi. Testing was done through Foundry.",
        "how_its_made": "The smart contracts use Uniswap v4 to flashloan so it can migrate a user's borrow position. Liquidations are handled with a Uniswap hook that lets users buy the capital in exchange for the debt. Chronicle powers the oracle for internal liquidations. The frontend is built with next.js and wagmi. Testing was done through Foundry.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/58snu/screenshots/j5j7r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/58snu/screenshots/0a6eb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/58snu/screenshots/6e3xc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jun1on/junlend",
        "link": "https://ethglobal.com/showcase/junlend-58snu"
    },
    {
        "title": "root4.fun",
        "brief_description": "memecoin launchpad built on Rootstock, offering easy tools for creating, buying, and selling memecoins. With AI-generated designs, seamless wallet connections, and credit card payments, it makes launching and sharing memecoins fun, fast, and accessible for everyone.",
        "long_description": "ROOT4.FUN is a memecoin launchpad built within the Rootstock (RSK) ecosystem, designed to make creating, buying, and selling memecoins as easy and accessible as possible. Our platform takes inspiration from projects like Pump.fun, but adds significant innovations to improve the user experience and functionality, with a focus on community-driven memecoins. We believe that memecoins hold potential beyond just speculation. They represent coins created by the community, for the community, making them a unique and valuable part of the crypto ecosystem. ROOT4.FUN offers four key functions to make memecoin creation and trading seamless: Create a MEMECOIN: Users can quickly generate and deploy their own memecoin on Rootstock. The process is streamlined through a smooth UI, and we even provide AI-generated suggestions for when users aren\u2019t sure what concept to meme. Buy a Coin: Users can easily purchase memecoins directly through the platform, with the option to pay using crypto wallets, credit cards, or email sign-ins. We aim to lower the barriers to entry for everyone, regardless of their technical expertise. Sell a Coin: Memecoin holders can easily list and sell their tokens through automated contracts. Automatic Creation of Liquidity Pools: Once a memecoin is created, liquidity pools are automatically established on decentralized exchanges like Uniswap once it reaches a bonding curve of 24 ETH(customizable).  This allows memecoins to have immediate market access Rootstock\nWe built the project on Rootstock . This gives us the stability and security of Bitcoin, while being EVM-compatible.\nwe built a contract that has 4 main functions, Create, Buy, Sell and once the bonding curve selected is reached it will be listed into decentralized exchanges. Phala Network AI Agents\nTheir AI agents are integrated to assist users in generating memecoin assets like names, images, and websites. We chose Phala because it runs  inside a Trusted Execution Environment (TEE), ensuring the integrity and security of the generated data.\nWhen users aren\u2019t sure what to meme, our platform calls on Phala\u2019s AI to generate these assets. The TEE guarantees that all HTML code and data produced by the AI is verifiable. Walrus for Decentralized Storage\nWe integrated Walrus to ensure all the AI-generated images, metadata, and websites are stored securely and accessibly.Walrus stores all the HTML and images generated by Phala\u2019s AI. This ensures that the content remains available. Privy and Dynamic for Wallet Connectivity:\nWhy We Chose Them: Both Privy and Dynamic are designed to provide frictionless wallet connectivity. Unlimit for Credit Card Payments\nWe wanted to make memecoin buying and selling as accessible as possible. With Unlimit, users can make purchases using credit cards as a payment gateway. Smart Contracts for Liquidity Management:\nOnce a memecoin is created, the system will automatically create a liquidity pool on Uniswap, but only once the bonding curve is reached. This ensures that there is sufficient demand and value established before providing liquidity. The bonding curve mechanism regulates the token supply and price dynamically as users buy into the memecoin. Once the required curve is reached, the smart contracts deploy the memecoin to Uniswap, creating an immediate liquidity pool.",
        "how_its_made": "Rootstock\nWe built the project on Rootstock . This gives us the stability and security of Bitcoin, while being EVM-compatible.\nwe built a contract that has 4 main functions, Create, Buy, Sell and once the bonding curve selected is reached it will be listed into decentralized exchanges. Phala Network AI Agents\nTheir AI agents are integrated to assist users in generating memecoin assets like names, images, and websites. We chose Phala because it runs  inside a Trusted Execution Environment (TEE), ensuring the integrity and security of the generated data.\nWhen users aren\u2019t sure what to meme, our platform calls on Phala\u2019s AI to generate these assets. The TEE guarantees that all HTML code and data produced by the AI is verifiable. Walrus for Decentralized Storage\nWe integrated Walrus to ensure all the AI-generated images, metadata, and websites are stored securely and accessibly.Walrus stores all the HTML and images generated by Phala\u2019s AI. This ensures that the content remains available. Privy and Dynamic for Wallet Connectivity:\nWhy We Chose Them: Both Privy and Dynamic are designed to provide frictionless wallet connectivity. Unlimit for Credit Card Payments\nWe wanted to make memecoin buying and selling as accessible as possible. With Unlimit, users can make purchases using credit cards as a payment gateway. Smart Contracts for Liquidity Management:\nOnce a memecoin is created, the system will automatically create a liquidity pool on Uniswap, but only once the bonding curve is reached. This ensures that there is sufficient demand and value established before providing liquidity. The bonding curve mechanism regulates the token supply and price dynamically as users buy into the memecoin. Once the required curve is reached, the smart contracts deploy the memecoin to Uniswap, creating an immediate liquidity pool.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/ohrvy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/cxd96/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/57wy4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/muutp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/bzsoz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/ov1bk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shadowfaz16/root.fun.git",
        "link": "https://ethglobal.com/showcase/root4-fun-uubnf"
    },
    {
        "title": "TheLottery",
        "brief_description": "It's a cross chain lottery operated with LAyerZero, Dynamo, Ledger and ENS. Everybody from everywhere with everywallet can play",
        "long_description": "TheLottery is an innovative decentralized application that brings the excitement of lottery games to the blockchain world. Built with React and and Web3 technologies, this project offers a seamless and engaging user experience for participants across multiple blockchain networks. Key Features: Cross-chain Compatibility: Utilizing LayerZero technology, users can purchase tickets from any supported blockchain, expanding accessibility and liquidity across networks. Flexible Wallet Integration: The app integrates Dynamic for wallet connections, allowing users to interact with their preferred wallet solution, including hardware wallets like Ledger for enhanced security. Real-time Updates: The application provides live updates on the current jackpot size, time remaining until the next draw, and the number of tickets purchased, creating an engaging and dynamic user interface. ENS Integration: Winners' addresses are displayed using Ethereum Name Service (ENS) when available, adding a personal touch to the lottery experience. Animated UI: The interface features falling coin animations and smooth transitions, enhancing the visual appeal and user engagement. Smart Contract Powered: The core lottery logic is implemented in a Solidity smart contract, ensuring fairness and transparency in ticket purchases and winner selection. Chainlink VRF Integration: The lottery uses Chainlink's Verifiable Random Function (VRF) to guarantee truly random and tamper-proof winner selection. Automated Lottery Cycles: The smart contract manages lottery cycles, including ticket sales, drawing winners, and distributing prizes, with minimal manual intervention required. Technical Highlights: TheLottery demonstrates the potential of blockchain technology to create fair, transparent, and exciting gaming experiences across multiple networks, setting a new standard for decentralized lottery applications. Cross-chain Compatibility: Utilizing LayerZero technology, users can purchase tickets from any supported blockchain, expanding accessibility and liquidity across networks. Flexible Wallet Integration: The app integrates Dynamic for wallet connections, allowing users to interact with their preferred wallet solution, including hardware wallets like Ledger for enhanced security. Real-time Updates: The application provides live updates on the current jackpot size, time remaining until the next draw, and the number of tickets purchased, creating an engaging and dynamic user interface. ENS Integration: Winners' addresses are displayed using Ethereum Name Service (ENS) when available, adding a personal touch to the lottery experience.",
        "how_its_made": "Cross-chain Compatibility: Utilizing LayerZero technology, users can purchase tickets from any supported blockchain, expanding accessibility and liquidity across networks. Flexible Wallet Integration: The app integrates Dynamic for wallet connections, allowing users to interact with their preferred wallet solution, including hardware wallets like Ledger for enhanced security. Real-time Updates: The application provides live updates on the current jackpot size, time remaining until the next draw, and the number of tickets purchased, creating an engaging and dynamic user interface. ENS Integration: Winners' addresses are displayed using Ethereum Name Service (ENS) when available, adding a personal touch to the lottery experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jy2xa/screenshots/r0uhs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jy2xa/screenshots/x69o1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jy2xa/screenshots/4bkmh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/TonioSnowden/TheLottery",
        "link": "https://ethglobal.com/showcase/thelottery-jy2xa"
    },
    {
        "title": "DeepTrust.eth",
        "brief_description": "SoTA On-chain proofs for LLM Model Executions. DeepTrust.eth makes sure that OpenAI, Anthropic, Groq be honest about the model they are serving.",
        "long_description": "The future will undoubtedly rely heavily on AI-powered applications and insights. But how can we ensure that the individuals or enterprises providing us with these models are trustworthy and credible? We identified two major problems that haven't been widely addressed: Centralized inference requires trust in an inference provider not to alter the model or data. For example, how can we be sure that OpenAI is providing responses from the more expensive GPT-4 model instead of cutting costs and using GPT-3.5?\nCentralized entities might manipulate or censor outputs, potentially affecting model fairness.\nTo address these issues, we proposed a solution using blockchain technology, creating a network of verification nodes that perform the checks for us. We introduced a novel plugin that can be integrated into all transformer architectures, which LLM models are based on. This plugin allows us to derive a deterministic term from each model by intercepting the LLM prior to the head layer (where randomness, such as temperature, is introduced). Since relying on a single source could be risky (due to potential dishonesty), our solution involves a network of models performing independent verifications. These outputs are then compared with those provided by enterprises like OpenAI, giving us a better chance to detect bad actors. Rather than checking every single request, we opted to sample 2-5% of all inference requests for verification. Additionally, we implemented a tokenomics system within the network. All inference clients must stake tokens to participate. If our platform detects dishonesty, these stakes will be slashed. Conversely, those who remain honest will see their trust score increase and will be rewarded with tokens. This system creates a strong incentive for participants to act with integrity. We primarily used two key technologies to achieve this solution: Polygon \u2013 We chose Polygon due to its scalability and low transaction costs. It allows us to build a transparent and efficient verification system, where transactions related to inference verifications and token staking/slashing are processed quickly and affordably. We find the documetation very friendly so it made our developer experience awesome! Lit Protocol \u2013 We leveraged Trusted Execution Environments (TEEs) to ensure that our model executions are isolated and protected from external interference. Lit Protocol was also one of the easiest platforms to develop on, as its setup process is much more straightforward compared to other providers.",
        "how_its_made": "We primarily used two key technologies to achieve this solution: Polygon \u2013 We chose Polygon due to its scalability and low transaction costs. It allows us to build a transparent and efficient verification system, where transactions related to inference verifications and token staking/slashing are processed quickly and affordably. We find the documetation very friendly so it made our developer experience awesome! Lit Protocol \u2013 We leveraged Trusted Execution Environments (TEEs) to ensure that our model executions are isolated and protected from external interference. Lit Protocol was also one of the easiest platforms to develop on, as its setup process is much more straightforward compared to other providers.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6rv0v/screenshots/79yxh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6rv0v/screenshots/3fycm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6rv0v/screenshots/fjy8v/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Jackmin801/DeepTrust.eth",
        "link": "https://ethglobal.com/showcase/deeptrust-eth-6rv0v"
    },
    {
        "title": "hoshi",
        "brief_description": "A web3 social media app that gives automatic IP rights to content creation through NFTs, making use of AI to identify derivative work.",
        "long_description": "Web2 social media apps are flawed. Today\u2019s social media platforms \u2014 TikTok, Instagram, YouTube \u2014 are powered by creators. From viral dances to popular memes, users are constantly sharing new ideas. Yet, there\u2019s a major problem: the original creators often go unrecognized and uncompensated. While larger creators and influencers who build on original trends or content reap the majority of credit and financial rewards, the originators of these ideas are not fairly rewarded. The root of this problem lies in the inability of current Web2 platforms to effectively prove content ownership or enforce fair revenue sharing. Creators are forced into an 'all or nothing' revenue system due to rigid copyright rules. We need a solution to provide a fair, transparent, and equitable content creation ecosystem where intellectual property rights are protected and content contributors are compensated based on their value added. hoshi aims to address these inequities by leveraging Web3 technology to create a platform where content creators can prove ownership, enforce fair use, and receive equitable compensation for their work. By giving IP rights to content creation through NFTs and an automated royalty distribution system, hoshi ensures that both original creators and those who contribute to or remix their work are fairly rewarded. 1.1 Automated AI-Powered Detection\nUses AI/ML to analyze content & determine an originality score across all other posts. We use an AI-based originality scoring system that quantifies the degree of contribution for each post. The more original the content, the higher the share of rewards allocated to the original creator. Users who remix or modify content receive proportional compensation based on their added value. An IP derivative tree is built based on these scores, to determine revenue flow sharing across all contributors based on their added value. 1.2 IP Ownership and Protection via NFTs\nhoshi ensures that creators retain full control over their IP by minting each piece of content uploaded to the platform as a non-fungible token (NFT). This provides verifiable proof of ownership and a permanent, immutable record on the blockchain, safeguarding against unauthorized use or plagiarism. 1.3 Smart Royalty Distribution\nhoshi employs a smart royalty distribution model that rewards original creators and those who contribute to or build upon their work. This system ensures that all contributors along the creative chain are fairly rewarded. Royalties are distributed through our native ERC20 token backed by ETH.  When a user interacts with a piece of content, some of their tokens are transferred from their wallet to the wallet of the content creator, and through our smart contract code, royalty distributions of derivative work is automatically paid. 2.1 Subscription-Based Revenue Withdrawal\nCreators can directly withdraw the underlying ETH tagged to the hoshi tokens and directly earn funds from their content. This is done by enabling a whitelist of wallet addresses who are allowed to unwrap the tokens, so as to prevent casual viewers from unwrapping their tokens as well. To join the whitelist and make money off your content, hoshi adopts an approach similar to twitter that requires content creators to pay a subscription fee to earn money off their content on our platform. hoshi reinvests the subscription fees back into the platform\u2019s liquidity pool. This subscription model not only facilitates monetization but also ensures the platform\u2019s long-term financial sustainability. We believe hoshi is the future of social media content creation, and we hope that you will join us in empowering creators with the recognition and rewards they deserve. To detect Copyright Infringement, we develop a proprietary AI pipeline to not only find the media and text that are similar in nature to the new post but also detect the specific location with the highest similarity. To detect textual similarity of captions, we use Cohere Embeddings to embed each caption into a vector. When a new post is provided, we similarly embed the new caption and compare against other vectors in the database. However, such an approach heavily focuses on semantic similarity since copyright infringement requires exact textual lifting, we utilise the BM25 method to conduct  full text search as well. The textual similarity score is thus a linear combination of the results from the vector and the full text search, making it robust and efficient. For the media detection, we use a similar approach using SIGLIP (https://arxiv.org/abs/2303.15343) embeddings and compare the input media using these embeddings. Again following the need for similarity beyond semantic meaning, we apply structural similarity scores based off the histogram of the image. We compute the following matrix (Correlation of Histogram, Intersection of Histogram and the Structural Similarity Index (https://www.imatest.com/docs/ssim/). To determine the location of the image that is most likely to be an infringement, we utilise a novel image localisation approach. We split the new image into many small patches and run a sliding window over the patches. Each patch in the window would have the same similarity score as all other patches in that particular iteration. After normalizing the scores, we would have a distribution of patches with varying similarity scores corresponding to a heatmap of the mini patches that are most similar to the existing original image. To extend this approach to videos, we split the video up into frames at a specified frames per second and perform the search over each frame. The final original result is determined by majority voting which makes our approach temporally robust. We made use of Dynamic Protocol for the user authentication. Making it easier for people to onboard onto Hoshi by allowing for email and Google account login and hiding login via wallets. We made use of ERC20 and ERC721 token contracts by openzeppelin so as to create custom logic to our tokens and NFTs to fit our needs. The metadata of the posts/NFTs are uploaded to IPFS, further adding to the decentralization of our platform. For the frontend, we used NextJS for the framework. We also used Three.js to create the 3D derivative graphs to show the connections between an original post and its derivatives.",
        "how_its_made": "To detect Copyright Infringement, we develop a proprietary AI pipeline to not only find the media and text that are similar in nature to the new post but also detect the specific location with the highest similarity. To detect textual similarity of captions, we use Cohere Embeddings to embed each caption into a vector. When a new post is provided, we similarly embed the new caption and compare against other vectors in the database. However, such an approach heavily focuses on semantic similarity since copyright infringement requires exact textual lifting, we utilise the BM25 method to conduct  full text search as well. The textual similarity score is thus a linear combination of the results from the vector and the full text search, making it robust and efficient. For the media detection, we use a similar approach using SIGLIP (https://arxiv.org/abs/2303.15343) embeddings and compare the input media using these embeddings. Again following the need for similarity beyond semantic meaning, we apply structural similarity scores based off the histogram of the image. We compute the following matrix (Correlation of Histogram, Intersection of Histogram and the Structural Similarity Index (https://www.imatest.com/docs/ssim/). To determine the location of the image that is most likely to be an infringement, we utilise a novel image localisation approach. We split the new image into many small patches and run a sliding window over the patches. Each patch in the window would have the same similarity score as all other patches in that particular iteration. After normalizing the scores, we would have a distribution of patches with varying similarity scores corresponding to a heatmap of the mini patches that are most similar to the existing original image. To extend this approach to videos, we split the video up into frames at a specified frames per second and perform the search over each frame. The final original result is determined by majority voting which makes our approach temporally robust. We made use of Dynamic Protocol for the user authentication. Making it easier for people to onboard onto Hoshi by allowing for email and Google account login and hiding login via wallets. We made use of ERC20 and ERC721 token contracts by openzeppelin so as to create custom logic to our tokens and NFTs to fit our needs. The metadata of the posts/NFTs are uploaded to IPFS, further adding to the decentralization of our platform. For the frontend, we used NextJS for the framework. We also used Three.js to create the 3D derivative graphs to show the connections between an original post and its derivatives.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/xkihw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/wsg9f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/48c0o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/ew74h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/183v2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/w8e1i/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/limrik/hoshi",
        "link": "https://ethglobal.com/showcase/hoshi-xzzxj"
    },
    {
        "title": "BulletPay",
        "brief_description": "BulletPay is a blockchain native payment protocol. It enables instance confirmation in face to face payment while keeping the assets safely on-chain.",
        "long_description": "BulletPay utilizes Pre Consensus Gateway and One Time Topup technologies to enable blockchain-native payments. Due to the decentralization of blockchain and the weak finality of its consensus algorithms, asset transfers typically experience delays ranging from seconds to minutes. This is unsuitable for face-to-face transactions, such as daily purchases, which require instant payment confirmation. Unlike channel technologies such as the Lightning Network, we believe that on-chain payments are more secure and reliable. Therefore, we focus on a blockchain-native approach to payments while addressing the issue of delays. We have developed the BulletPay protocol, which combines the efficiency of centralized payment gateways with the security of decentralized blockchains. Our protocol successfully resolves the delay issue, making blockchain payments feasible for real-world scenarios. We use Solidity to build smart contracts and Python to develop the backend. The BulletPay system includes top-up and payment steps for on-chain end users. After a user tops up, the indexer component monitors on-chain events. Each top-up creates an account that can be used multiple times but is not rechargeable. The top-up account can be spent with the spender's signature via the gateway. The gateway monitors the blockchain and tracks the spender's balance, allowing it to notify the merchant if the payment is successful or to reject the user before the payment processed by the blockchain. This constitutes the pre-consensus component. Importantly, assets remain on-chain, ensuring that the gateway cannot access users' assets for any other purpose, which enhances security.",
        "how_its_made": "We use Solidity to build smart contracts and Python to develop the backend. The BulletPay system includes top-up and payment steps for on-chain end users. After a user tops up, the indexer component monitors on-chain events. Each top-up creates an account that can be used multiple times but is not rechargeable. The top-up account can be spent with the spender's signature via the gateway. The gateway monitors the blockchain and tracks the spender's balance, allowing it to notify the merchant if the payment is successful or to reject the user before the payment processed by the blockchain. This constitutes the pre-consensus component. Importantly, assets remain on-chain, ensuring that the gateway cannot access users' assets for any other purpose, which enhances security.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/tz9ii/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/iusb7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/keqp6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/wxn9x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/c5qoq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Bullet-Pay/bulletpay_service",
        "link": "https://ethglobal.com/showcase/bulletpay-rsx64"
    },
    {
        "title": "tradealerts",
        "brief_description": "tradealerts notifies individuals or interest groups of trade events for a given policy.",
        "long_description": "This project is a social network crypto investors and interest groups.\nIt uses xmtp to timely deliver market signals based on a given policy.\nE.g. relay buy or sell signals for crypto currencies.\nThe signals themselves are generated by a separate backend application that ties into Coinbase to access market data. This project uses MessageKit by xmtp to deliver trade alerts to subscribed users or interest groups.\nIt is prototyped with MessageKit and connects to a backend using CDK by Coinbase.\nWe will try to host the application on Walrus.\nThree components play together:",
        "how_its_made": "This project uses MessageKit by xmtp to deliver trade alerts to subscribed users or interest groups.\nIt is prototyped with MessageKit and connects to a backend using CDK by Coinbase.\nWe will try to host the application on Walrus.\nThree components play together:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/43gav/screenshots/233x6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/43gav/screenshots/qn4b3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/43gav/screenshots/juohk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wojtczyk/tradealerts",
        "link": "https://ethglobal.com/showcase/tradealerts-43gav"
    },
    {
        "title": "NFTap",
        "brief_description": "connect via ens by bumping phones with verifiable irl connections",
        "long_description": "This projects aims to verify and create memories based on irl connections easily by allowing users to exchange their ENS information by bumping their phones together. Afterwards, an NFT is minted to verify the meeting, where the image of the NFT makes use of the ENS avatars as well as the location, weather and time of day to generate an image that captures the vibe of the meeting. Afterwards, users can view their minted memories on-chain, and share them with friends and family This project uses React Native for the front end and NodeJS with WebSockets as the communication protocol between the FE and BE. We use Dynamic to allow users to sign up easily and ENS for sharing of personal information such as avatar and name information. For generating the NFT images, we use GenAI to generate unique images based on location data, weather data, time of day and ENS avatars. We decided to deploy and mint our NFT collection on the Polygon chain for its high speed and low transaction fees, meaning we are able to airdrop to users, saving them time and fees.",
        "how_its_made": "This project uses React Native for the front end and NodeJS with WebSockets as the communication protocol between the FE and BE. We use Dynamic to allow users to sign up easily and ENS for sharing of personal information such as avatar and name information. For generating the NFT images, we use GenAI to generate unique images based on location data, weather data, time of day and ENS avatars. We decided to deploy and mint our NFT collection on the Polygon chain for its high speed and low transaction fees, meaning we are able to airdrop to users, saving them time and fees.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/mapd3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/b2n5m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/k1zq3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/qgukn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/f0vbu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/danielliuzy/nftapp",
        "link": "https://ethglobal.com/showcase/nftap-z0740"
    },
    {
        "title": "Shared trading",
        "brief_description": "Let one person trade, but many people contribute and withdraw any time they want",
        "long_description": "Only got part of the project complete this hackathon! Clone the Repository: Set Up the Backend: Navigate to the backend directory and install dependencies: Create a .env file in the backend directory with the following content: Compile and Deploy Contracts: Compile the smart contracts: Deploy the contracts: Set Up the Frontend: Navigate to the frontend directory and install dependencies: Start the React Application: Open Your Browser: Neon VM to use EVM to deploy to Solana + a react app for interacting with the deployed contracts on the Neon VM testnet. Clone the Repository: Set Up the Backend: Navigate to the backend directory and install dependencies: Create a .env file in the backend directory with the following content: Compile and Deploy Contracts: Compile the smart contracts: Deploy the contracts: Set Up the Frontend: Navigate to the frontend directory and install dependencies: Start the React Application: Open Your Browser:",
        "how_its_made": "Neon VM to use EVM to deploy to Solana + a react app for interacting with the deployed contracts on the Neon VM testnet. Clone the Repository: Set Up the Backend: Navigate to the backend directory and install dependencies: Create a .env file in the backend directory with the following content: Compile and Deploy Contracts: Compile the smart contracts: Deploy the contracts: Set Up the Frontend: Navigate to the frontend directory and install dependencies: Start the React Application: Open Your Browser:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mzh4z/screenshots/f95bg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mzh4z/screenshots/of9eu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mzh4z/screenshots/og9o4/default.jpg"
        ],
        "live_demo": "https://ethglobalhack-4sufkljta-nathanmatons-projects.vercel.app/",
        "source_code": "https://github.com/NathanMaton/ethglobalhack",
        "link": "https://ethglobal.com/showcase/shared-trading-mzh4z"
    },
    {
        "title": "Shared trading",
        "brief_description": "Let one person trade, but many people contribute and withdraw any time they want",
        "long_description": "Only got part of the project complete this hackathon! Clone the Repository: Set Up the Backend: Navigate to the backend directory and install dependencies: Create a .env file in the backend directory with the following content: Compile and Deploy Contracts: Compile the smart contracts: Deploy the contracts: Set Up the Frontend: Navigate to the frontend directory and install dependencies: Start the React Application: Open Your Browser: Neon VM to use EVM to deploy to Solana + a react app for interacting with the deployed contracts on the Neon VM testnet. Clone the Repository: Set Up the Backend: Navigate to the backend directory and install dependencies: Create a .env file in the backend directory with the following content: Compile and Deploy Contracts: Compile the smart contracts: Deploy the contracts: Set Up the Frontend: Navigate to the frontend directory and install dependencies: Start the React Application: Open Your Browser:",
        "how_its_made": "Neon VM to use EVM to deploy to Solana + a react app for interacting with the deployed contracts on the Neon VM testnet. Clone the Repository: Set Up the Backend: Navigate to the backend directory and install dependencies: Create a .env file in the backend directory with the following content: Compile and Deploy Contracts: Compile the smart contracts: Deploy the contracts: Set Up the Frontend: Navigate to the frontend directory and install dependencies: Start the React Application: Open Your Browser:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mzh4z/screenshots/f95bg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mzh4z/screenshots/of9eu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mzh4z/screenshots/og9o4/default.jpg"
        ],
        "live_demo": "https://ethglobalhack-4sufkljta-nathanmatons-projects.vercel.app/",
        "source_code": "https://github.com/NathanMaton/ethglobalhack",
        "link": "https://ethglobal.com/showcase/shared-trading-mzh4z"
    },
    {
        "title": "Internet Astronaut",
        "brief_description": "Internet Astronaut is an innovative Web3-powered lottery that gives participants a once-in-a-lifetime opportunity to win a chance to become an astronaut.",
        "long_description": "By leveraging blockchain technology and Web3, this Internet Astronaut lottery is fully transparent, easy to participate in, and accessible to anyone around the world. The central idea is to sell digital tickets, called \"Stars,\" to raise sufficient funds, and once all Stars are sold, a winner is chosen. The winner secures a spot in an astronaut training program, turning their dream of space travel into reality. The objective of this project was to create a simple, end-to-end solution with minimal dependencies and low complexity, ensuring it is easy to understand, adapt, and extend. The focus was on core functionality and ease of use, without overcomplicating the architecture with frameworks or large libraries. The result is a minimal yet complete solution. Technologies and Structure:\nThe project uses Flow crypto, leveraging its new EVM-compatible scheme. Flow\u2019s standout feature is its secure, native on-chain randomness, accessible via Cadence Arch, a precompiled contract in the Flow EVM environment. This feature allows Solidity developers to access verifiable randomness in the contract, enhancing security for lotteries and other randomized processes in a verifiable, tamper-proof way. Minimal Dependencies:\nDocker is used to manage all dependencies required for compiling the smart contract, keeping the environment lightweight and ensuring reproducibility across different setups without unnecessary complexity. Frontend:\nThe frontend was built using plain vanilla JavaScript, keeping the application lightweight and easily adaptable by anyone familiar with basic web development. This approach avoids the need for heavier frontend frameworks given the simplicity of the interface. Automation:\nA set of simple backend scripts was created for compiling, deploying, and managing the smart contracts. These scripts are straightforward, making them easy to extend or adapt for different deployment environments or workflows. Notable Aspects:\nA key feature of the project is the integration of Flow\u2019s verifiable randomness into Solidity via Cadence Arch, enabling the use of on-chain randomness in an EVM environment. This is a relatively new approach, adding an innovative challenge while maintaining the project\u2019s minimalistic architecture.",
        "how_its_made": "The objective of this project was to create a simple, end-to-end solution with minimal dependencies and low complexity, ensuring it is easy to understand, adapt, and extend. The focus was on core functionality and ease of use, without overcomplicating the architecture with frameworks or large libraries. The result is a minimal yet complete solution. Technologies and Structure:\nThe project uses Flow crypto, leveraging its new EVM-compatible scheme. Flow\u2019s standout feature is its secure, native on-chain randomness, accessible via Cadence Arch, a precompiled contract in the Flow EVM environment. This feature allows Solidity developers to access verifiable randomness in the contract, enhancing security for lotteries and other randomized processes in a verifiable, tamper-proof way. Minimal Dependencies:\nDocker is used to manage all dependencies required for compiling the smart contract, keeping the environment lightweight and ensuring reproducibility across different setups without unnecessary complexity. Frontend:\nThe frontend was built using plain vanilla JavaScript, keeping the application lightweight and easily adaptable by anyone familiar with basic web development. This approach avoids the need for heavier frontend frameworks given the simplicity of the interface. Automation:\nA set of simple backend scripts was created for compiling, deploying, and managing the smart contracts. These scripts are straightforward, making them easy to extend or adapt for different deployment environments or workflows. Notable Aspects:\nA key feature of the project is the integration of Flow\u2019s verifiable randomness into Solidity via Cadence Arch, enabling the use of on-chain randomness in an EVM environment. This is a relatively new approach, adding an innovative challenge while maintaining the project\u2019s minimalistic architecture.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sq7ik/screenshots/ttn66/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sq7ik/screenshots/w72bp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sq7ik/screenshots/m4oo9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sq7ik/screenshots/i2ez8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sq7ik/screenshots/13v4w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sq7ik/screenshots/0fc9q/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/anton-io/ethglobal-internet-astronaut",
        "link": "https://ethglobal.com/showcase/internet-astronaut-sq7ik"
    },
    {
        "title": "TonGamers",
        "brief_description": "Game built on TON integrated with Telegram built using react and ton smart contracts",
        "long_description": "The idea for this project was chosen due to the growing popularity of both blockchain technology and gaming, particularly within social media platforms like Telegram. Recognizing that many players are seeking innovative ways to engage with games and connect with communities, the project aimed to combine these trends into a seamless experience. By leveraging the Ton blockchain, known for its speed and efficiency, the game could offer unique mechanics that enhance user interaction. Additionally, integrating with Telegram allows for easy accessibility, as users can play directly within an app they already use daily, fostering community and increasing user retention. This project not only addresses the demand for blockchain gaming but also taps into the potential of social engagement in a familiar environment. This project aimed to create a blockchain-based game integrated with Telegram using the Ton blockchain. Smart contracts were developed in FunC, and the backend was built with Node.js, utilizing the tonweb library for interaction. The game integrated the Telegram Bot API and Telegraf framework for a user-friendly experience. A web interface was created with HTML, CSS, and JavaScript, with React for added interactivity.",
        "how_its_made": "This project aimed to create a blockchain-based game integrated with Telegram using the Ton blockchain. Smart contracts were developed in FunC, and the backend was built with Node.js, utilizing the tonweb library for interaction. The game integrated the Telegram Bot API and Telegraf framework for a user-friendly experience. A web interface was created with HTML, CSS, and JavaScript, with React for added interactivity.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/k3nq4/screenshots/kwvd6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k3nq4/screenshots/frbr1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k3nq4/screenshots/hsqd5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Amir-K/TonGame",
        "link": "https://ethglobal.com/showcase/tongamers-k3nq4"
    },
    {
        "title": "Dextra",
        "brief_description": "Dextra is an on-chain text-based choose your own adventure game system ~ create or play!",
        "long_description": "Dextra allows you to build your own text-adventure games, using composable NFTs, that run on-chain, playable by anyone! Play:\nPlayers are able to explore rooms, interact with items, and meet hand-crafted characters in unique settings. Items persist between games, and may have unique applications in allowing for unique Easter eggs and events.\nAs a player, you type commands to interact with the game-world and manage your inventory. Create:\nThe Create feature allows you to tell your story from beginning to end, incorporate characters and items between games, and import assets from other creators using Story's IP Protocol.\nCreate works by letting you build interlinked 'rooms' that a player can move between. Within these rooms, you can add characters or items, as well as conditional 'events' that trigger when certain conditions are met.\nWith these tools, entire stories can be built with critical encounters, developing characters, and multiple chapters. We use Story :: Each modular aspect of the games is an IPAsset on Story, enabling licensing and royalties. Additionally, data generated through the games are AI Training IP Assets!\nWe use Flow :: Flow is the fastest and cheapest EVM chain with sub 1s block times. Flow also provides an easy to use Verifiable Random Generator. We also explored Cadence in depth and version two of the protocol will come to life via cdc!\nWe use Dynamic :: Dynamic is the easiest wallet connect a developer could ask for! Under 5 seconds to set up and all hooks are conveniently found on the docs.\nWe planned on XMTP / MessageKit :: The vivid characters in games would have personalities that go to offchain LLMs using the MessageKit.\nWe planned on ENS Reverse Lookups :: Inspired by coinbase usernames, we planned on providing free usernames on our domain ~ dextra.eth. Coming soon!",
        "how_its_made": "We use Story :: Each modular aspect of the games is an IPAsset on Story, enabling licensing and royalties. Additionally, data generated through the games are AI Training IP Assets!\nWe use Flow :: Flow is the fastest and cheapest EVM chain with sub 1s block times. Flow also provides an easy to use Verifiable Random Generator. We also explored Cadence in depth and version two of the protocol will come to life via cdc!\nWe use Dynamic :: Dynamic is the easiest wallet connect a developer could ask for! Under 5 seconds to set up and all hooks are conveniently found on the docs.\nWe planned on XMTP / MessageKit :: The vivid characters in games would have personalities that go to offchain LLMs using the MessageKit.\nWe planned on ENS Reverse Lookups :: Inspired by coinbase usernames, we planned on providing free usernames on our domain ~ dextra.eth. Coming soon!",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9wnc2/screenshots/8zths/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9wnc2/screenshots/3zoxc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9wnc2/screenshots/iwaq8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/thisispalash/ethglobal-sanfrancisco-2024/blob/master/demo.mp4",
        "link": "https://ethglobal.com/showcase/dextra-9wnc2"
    },
    {
        "title": "AVAZON",
        "brief_description": "Avazon creates AI agents using avatars and manages them with avatar ip assets 1.Users create avatars using prompts. 2.These avatars become AI agents, generating content like videos, music, and interacting in real-time. 3.Users can share and manage avatars and content via IP asset",
        "long_description": "Why Avazon? AI is advancing quickly but remains unfamiliar to most users, despite its popularity in entertainment and learning. With virtual influencers growing, combining AI and avatars offers new possibilities. Avazon makes AI accessible and fun, bridging the gap between people and technology. 1.Effortless Avatar Creation\n-With Avazon, users can create their own personalized avatars using simple prompts and real-time chat interaction. These avatars are generated with customizable features such as style, gender, appearance, personality, and even voice 2.Real-Time AI Agent\n-Once generated, your avatar becomes a versatile AI agent. You can interact with it in real time to assist you with various tasks such as web browsing, shopping, or even language learning. Avazon enables users to utilize their avatars to create music, videos, and art, which can be shared across social media. 3.Remix Popular IP Avatars\n-Avazon users can choose from a selection of popular IP-based avatars, remix them, and use them as their own. This feature encourages creativity and allows users to put their personal spin on well-known characters. Blockchain Integration Without the Complexity\nAlthough Avazon is built on blockchain technology, we ensure that users don\u2019t have to deal with the complexities of wallets, gas fees, or NFTs. Like a car engine running smoothly in the background, our blockchain infrastructure provides powerful functionality without the hassle. 1.Simple Onboarding with Dynamic Wallets\n-Avazon makes onboarding seamless by using dynamic wallets and allowing users to sign in with Google or other social logins, bypassing the need for a complicated setup process. 2.Secure Avatar & Content Management\n-Your avatars and creations are securely managed through Story Protocol\u2019s IP asset system. Avazon automatically allocates earnings from remixing or using your content, ensuring you get rewarded for your creativity. 3.Convert NFTs into Personal Agents\n-Avazon also allows users to transform NFTs, like Flow\u2019s NBA Top Shot, into avatars that can be used as personal AI agents, giving new life and utility to digital collectibles. Seamless Integration of Gen AI Tools\nAvazon integrates various Gen AI tools like real-time AI and Runway, enabling users to easily create diverse content such as video editing, image generation, and real-time interactions with their avatars. Start creating your unique avatar today, or choose from our vast hub of popular avatars and enjoy everything Avazon has to offer!",
        "how_its_made": "Blockchain Integration Without the Complexity\nAlthough Avazon is built on blockchain technology, we ensure that users don\u2019t have to deal with the complexities of wallets, gas fees, or NFTs. Like a car engine running smoothly in the background, our blockchain infrastructure provides powerful functionality without the hassle. 1.Simple Onboarding with Dynamic Wallets\n-Avazon makes onboarding seamless by using dynamic wallets and allowing users to sign in with Google or other social logins, bypassing the need for a complicated setup process. 2.Secure Avatar & Content Management\n-Your avatars and creations are securely managed through Story Protocol\u2019s IP asset system. Avazon automatically allocates earnings from remixing or using your content, ensuring you get rewarded for your creativity. 3.Convert NFTs into Personal Agents\n-Avazon also allows users to transform NFTs, like Flow\u2019s NBA Top Shot, into avatars that can be used as personal AI agents, giving new life and utility to digital collectibles. Seamless Integration of Gen AI Tools\nAvazon integrates various Gen AI tools like real-time AI and Runway, enabling users to easily create diverse content such as video editing, image generation, and real-time interactions with their avatars. Start creating your unique avatar today, or choose from our vast hub of popular avatars and enjoy everything Avazon has to offer!",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ed8hi/screenshots/0x1j8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ed8hi/screenshots/8m6qz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ed8hi/screenshots/ey3od/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ed8hi/screenshots/eurwp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ed8hi/screenshots/oe0up/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ed8hi/screenshots/b9n5e/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/avazon-eth",
        "link": "https://ethglobal.com/showcase/avazon-ed8hi"
    },
    {
        "title": "FanFuel",
        "brief_description": "Grow your savings while supporting student-athletes with crypto staking. Fans earn rewards, athletes get funded, and teams thrive.",
        "long_description": "Student-athletes\u2014especially those in women\u2019s and minority sports\u2014are struggling to cover basic needs like gear, training, and even dealing with student loan debt after they graduate. At FanFuel, we want to change that. We\u2019ve created a simple way for supporters to step in and directly support their favorite athletes while growing their savings through staking crypto. The staked amount is not a donation, but like putting your money in a savings account. Supporters can withdraw the principal amount anytime, while the majority of the rewards earned from staking go to the athlete. How FanFuel Works Athlete Profile Creation: Student athletes sign up on FanFuel and create profiles that showcase their stats, achievements, personal goals, and stories. Each athlete has a unique smart contract tied to their profile, which fans can interact with. Fan Staking: Fans and supporters browse a list of athletes, select one they wish to support, and stake cryptocurrency in that athlete\u2019s smart contract. This staked amount is not a donation\u2014it remains the property of the fan and will be returned when they wish to withdraw. Rewards Distribution: FanFuel\u2019s Greater Implications\nFanFuel is more than just a platform for funding athletes\u2014it\u2019s about changing the way we support and engage with college sports. By directly involving fans in the financial success of their favorite athletes, FanFuel democratizes sports funding and creates a more transparent and meaningful system of support. It offers the potential to: FanFuel vision is to bring together the passion of sports and the power of blockchain to fuel the future of college athletes, making it easy for fans to directly contribute to the athletes they care about while being rewarded in return. FanFuel is built on the Flow EVM chain for staking contracts and transaction management. We use Dynamic for seamless user authentication that is user-friendly for non-web3 users. We use Nouns branding for a fun, gamified aesthetic and Nouns-branded NFTs as milestone badges (such as 10 athletes supported) to incentivize supporters to back more athletes.",
        "how_its_made": "FanFuel is built on the Flow EVM chain for staking contracts and transaction management. We use Dynamic for seamless user authentication that is user-friendly for non-web3 users. We use Nouns branding for a fun, gamified aesthetic and Nouns-branded NFTs as milestone badges (such as 10 athletes supported) to incentivize supporters to back more athletes.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3ds1u/screenshots/tuq2x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3ds1u/screenshots/5w6zj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3ds1u/screenshots/j5npk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Lyons800/fanfuel",
        "link": "https://ethglobal.com/showcase/fanfuel-3ds1u"
    },
    {
        "title": "ClippAi defi ai-gent",
        "brief_description": "A crypto agent that helps make defi transactions safe and easy.",
        "long_description": "Using a locally or cloud-provisioned LLM, we have trained a model to make Defi and other crypto transactions easy to do. We use this LLM via a browser extension and monitor when a user interacts with a supported web3 app, if the user doesn't have the asset required to interact with the project or doesn't even have the wallet, the agent will guide the user through the correct steps to successfully download the correct wallets and help move the asset to the chain. We've leveraged lots of AI in building this demo, the initial version will start as a tamper-monkey script and eventually be packaged into a full chrome extension. On the LLM side we are using GAIAnet a decentralized LLM for privacy purposes, we can support open-ai or Claude api keys later. This interacts with a provisioned llm in the cloud that has been trained on optimal routes and proposes the easiest and cheapest way to achieve the desired chain interaction.",
        "how_its_made": "We've leveraged lots of AI in building this demo, the initial version will start as a tamper-monkey script and eventually be packaged into a full chrome extension. On the LLM side we are using GAIAnet a decentralized LLM for privacy purposes, we can support open-ai or Claude api keys later. This interacts with a provisioned llm in the cloud that has been trained on optimal routes and proposes the easiest and cheapest way to achieve the desired chain interaction.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/b7qz3/screenshots/35wyf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b7qz3/screenshots/c4j3z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b7qz3/screenshots/tb1k0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/chews/clippai",
        "link": "https://ethglobal.com/showcase/clippai-defi-ai-gent-b7qz3"
    },
    {
        "title": "LayerKit",
        "brief_description": "LayerKit lets you deploy LayerZero into rollups like Optimism with just one command in just a few minutes. This helps developers easily test and build cross-chain dApps with full flexibility",
        "long_description": "LayerKit is a developer toolkit designed for rapid and flexible deployment of LayerZero into rollups so that they can exchange messages with Ethereum (or with other rollups / chains in the future). It enables application development and testing directly on local versions of Ethereum and Optimism (running Geth and Lighthouse nodes). With a simple one-command setup, LayerKit deploys fully connected LayerZero components in under 10 minutes - including endpoints, MessageLib (ULN302), Executor, DVN, PriceFeed, and Worker on each chain. The package is very modular, allowing users to use custom MessageLibs or DVNs as required. Furthermore, the Optimism and Ethereum network can be configured with a high degree of control. Additionally, it provides a Blockscout explorer for both chains, allowing easy tracking of blockchain activity. LayerKit uses kurtosis packages to orchestrate the deployment process of LayerZero components across Ethereum and Optimism networks. It leverages the Ethereum and Optimism packages developed by the Ethereum Foundation to set up both networks in isolated environments. Each network is spun up with its own Blockscout block explorer. Once the Ethereum and Optimism networks are running, the necessary chain details (e.g. pre-funded keys, RPC) are retrieved. To facilitate LayerZero deployment on the Optimism layer 2, tokens are bridged to Optimism using the built-in token bridge. Next, LayerKit deploys the core LayerZero components: Once the contracts are deployed, LayerKit configures the system by: The DVN contract can easily be swapped out for an alternative and in future work this will be even more parameterised to allow for easier DVN development. These deployment steps were derived by looking at the deployed contracts on various mainnets and testnets as there is no documentation for this. Most of the contracts deployed are the same ones as on mainnet. Only the price feed and DVN contracts are mocked ones as it would not be feasible to deploy the full version.",
        "how_its_made": "LayerKit uses kurtosis packages to orchestrate the deployment process of LayerZero components across Ethereum and Optimism networks. It leverages the Ethereum and Optimism packages developed by the Ethereum Foundation to set up both networks in isolated environments. Each network is spun up with its own Blockscout block explorer. Once the Ethereum and Optimism networks are running, the necessary chain details (e.g. pre-funded keys, RPC) are retrieved. To facilitate LayerZero deployment on the Optimism layer 2, tokens are bridged to Optimism using the built-in token bridge. Next, LayerKit deploys the core LayerZero components: Once the contracts are deployed, LayerKit configures the system by: The DVN contract can easily be swapped out for an alternative and in future work this will be even more parameterised to allow for easier DVN development. These deployment steps were derived by looking at the deployed contracts on various mainnets and testnets as there is no documentation for this. Most of the contracts deployed are the same ones as on mainnet. Only the price feed and DVN contracts are mocked ones as it would not be feasible to deploy the full version.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ksqw0/screenshots/j346t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ksqw0/screenshots/mqp8r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ksqw0/screenshots/f0nre/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/tiljrd/LayerKit",
        "link": "https://ethglobal.com/showcase/layerkit-ksqw0"
    },
    {
        "title": "SwiftStable",
        "brief_description": "A global financial platform that enables seamless conversion and withdrawal of stablecoins across borders.",
        "long_description": "A platform offering global stablecoin conversion with AI Agents optimizing transactions and liquidity decisions in real time. Using Coinbase for on-ramp (fiat to stablecoin integration) and Unlimit for international withdrawals, the platform ensures users can convert stablecoins (like USDC) into local currencies (e.g., euros) securely and automatically. Key Features:",
        "how_its_made": "Key Features:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qnskc/screenshots/yxkif/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qnskc/screenshots/r47vh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qnskc/screenshots/njuaj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qnskc/screenshots/9gpno/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ffelipesimoes/ETHSFO",
        "link": "https://ethglobal.com/showcase/swiftstable-qnskc"
    },
    {
        "title": "Smart Storybook",
        "brief_description": "Notebook with AI powers and automatic IP protection via Blockchain.",
        "long_description": "The project combines prevalent themes in the Web3 and AI space. The UI is a simple, blank canvas like a notepad, the idea is that you use it however you wish and AI agents will support you. The content you generate is your IP and Story makes that possible. Capturing IP should be as broad as possible, we all generate IP all the time but often fail to protect it. We believe stronger IP creates a happier community of creators. Which is a virtuous cycle, because the AI agents can pull ideas seamlessly from other users (while respecting their licenses of course) and help you on your thought journey. An example use case is in the film industry. Invision a future that eliminates the need for submitting a Movie Storyline or Screenplay to Writers' Guild in Hollywood, Bollywood, and other Creative Associations. It also expands the opportunities to the writers and creative artists around the world. A Storybook consists of many Storyboards, which may be contributed by different people. The Storybook enables Collaboration over time with many new contributors across the world. This project is built using the Next.js,, Story Blockchain, Rainbowkit, Wagmi. We use rainbowkit and wagmi to connect wallets (like metamask). We connect to the story network to mint nfts register them as ip and attach licenses. Users can mint their own licenses after going through the wallet signin. Nextjs with tailwind, radix, shadcn starter components was our typescript stack.",
        "how_its_made": "This project is built using the Next.js,, Story Blockchain, Rainbowkit, Wagmi. We use rainbowkit and wagmi to connect wallets (like metamask). We connect to the story network to mint nfts register them as ip and attach licenses. Users can mint their own licenses after going through the wallet signin. Nextjs with tailwind, radix, shadcn starter components was our typescript stack.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8foca/screenshots/tnb4i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8foca/screenshots/w38v5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8foca/screenshots/8wuuz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8foca/screenshots/3415w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8foca/screenshots/15uxy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8foca/screenshots/i16yp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/imjwang/storybook",
        "link": "https://ethglobal.com/showcase/smart-storybook-8foca"
    },
    {
        "title": "Improved Fruit Box",
        "brief_description": "An improved version of the game \"Fruit Box\" in which you match apples such that they add up to ten",
        "long_description": "This project is an improved version of the game \"Fruit Box\", a game in which you match apples such that they add up to ten. Your goal is clear as many apples as you can before the time runs out. In the original version of this game, the board generation makes it so that it's almost impossible to fully clear the board, and this frustrates many players as seen on the r/FruitBox subreddit. We sought to fix that issue and add more features with our project. We created this project using Unity and scripting in C#. We were also planning on adding the ability to purchase skins with Ethereum by adding on option to add your Metamask wallet, but we unfortunately ran out of time. The most hacky thing that we did that I am most proud of is figuring out what makes a board fully solvable.",
        "how_its_made": "We created this project using Unity and scripting in C#. We were also planning on adding the ability to purchase skins with Ethereum by adding on option to add your Metamask wallet, but we unfortunately ran out of time. The most hacky thing that we did that I am most proud of is figuring out what makes a board fully solvable.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/eoxe8/screenshots/vkbae/default.jpg",
            "https://ethglobal.b-cdn.net/projects/eoxe8/screenshots/ngg7h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/eoxe8/screenshots/y6b5d/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jpherreraz/Improved-Fruit-Box",
        "link": "https://ethglobal.com/showcase/improved-fruit-box-eoxe8"
    },
    {
        "title": "CredPortal",
        "brief_description": "User Interface for verifying on-chain issued Cred Tokens in person.",
        "long_description": "Cred Portal is a front-end integration with Cali-Creds, which utilizes the California Mobile Driver's License and Succinct's SP1 to generate ZK Proofs of identity attestations, which can be turned into on-chain nft-like tokens, or Creds. The app is a user friendly look into these on-chain credentials, with the ability to provide in-person confirmation of credential ownership by leveraging Coinbase's Smart Wallet. The project leverages On-Chain issued Cali Creds, issued using ZK proofs with Succinct's SP1 as well as Coinbase's Smart Wallet SDK to allow for easy proof of account ownership from users. It was a bit of a challenge to get the SDK to work properly with the framework I chose, Next.js, but in the end I was able to make it work.",
        "how_its_made": "The project leverages On-Chain issued Cali Creds, issued using ZK proofs with Succinct's SP1 as well as Coinbase's Smart Wallet SDK to allow for easy proof of account ownership from users. It was a bit of a challenge to get the SDK to work properly with the framework I chose, Next.js, but in the end I was able to make it work.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/abp5w/screenshots/yez6z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/abp5w/screenshots/cq532/default.jpg",
            "https://ethglobal.b-cdn.net/projects/abp5w/screenshots/802y8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/pjol/CredPortal",
        "link": "https://ethglobal.com/showcase/credportal-abp5w"
    },
    {
        "title": "OV2 SF",
        "brief_description": "Crypto and CryptotoFiat Payments assisted through whatsapp for normies to use seamless blockchain interactions",
        "long_description": "People still don't get crypto, the UX has improved a lot since it began, but still people find it more complicated than the apps they are used to use on their daily basis. We're solving this by connecting with those day to day apps which people already use.\nImaging sending payments, cross-border remittances o even manage a payroll on top of blockchain with a web 2 easy to use interface. Fully encripted, secure and the ways normies like it, money up front. We are working mainly with Circles SDK and CCTP to enable near zero gas transactions and swaps between chains, so that people can easily send from one to another to allow cross border payments. WebAuth for easy sign in and transaction signing, all connected to AI powered bots to interact with the platform through whatsapp.",
        "how_its_made": "We are working mainly with Circles SDK and CCTP to enable near zero gas transactions and swaps between chains, so that people can easily send from one to another to allow cross border payments. WebAuth for easy sign in and transaction signing, all connected to AI powered bots to interact with the platform through whatsapp.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6tm05/screenshots/0kkrm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6tm05/screenshots/ns4j3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6tm05/screenshots/su1z2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6tm05/screenshots/y2s7f/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/slashweb/omma-sf",
        "link": "https://ethglobal.com/showcase/ov2-sf-6tm05"
    },
    {
        "title": "AI agent PhalaN",
        "brief_description": "AI agent built on Phala Network to make payments autonomously",
        "long_description": "I have recently accomplished AI2WEB3 bootcamp. Now I am trying to put my knowledge into practice. Phala Network allows the implementation AI agents in Web3 space. What I am trying to build is an AI agent that connects with ETH blockchain and can make payments using prompts. It is a basic functionality that I plan to build. Moreover, if I have time I would like to add voice recognition to the agent. Integrating the Phala Network SDK with Python and Next.js. Phala Network SDK\nPhala Network has documentation and SDK to understand how to interact with it. I used it to install SDK and dependencies. Setting Up Python\nI am using Python to create your backend service. I use frameworks like Flask to build APIs that interact with the Phala SDK. Creating APIs Setting Up Next.js\nI use Next.js application using create-next-app. Connecting Frontend to Backend\nUsing Fetch API in Next.js to make requests to your Python backend. Deployment\nI am using Vercel to deploy a project",
        "how_its_made": "Integrating the Phala Network SDK with Python and Next.js. Phala Network SDK\nPhala Network has documentation and SDK to understand how to interact with it. I used it to install SDK and dependencies. Setting Up Python\nI am using Python to create your backend service. I use frameworks like Flask to build APIs that interact with the Phala SDK. Creating APIs Setting Up Next.js\nI use Next.js application using create-next-app. Connecting Frontend to Backend\nUsing Fetch API in Next.js to make requests to your Python backend. Deployment\nI am using Vercel to deploy a project",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vhtrw/screenshots/u951e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vhtrw/screenshots/w15wf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vhtrw/screenshots/dw3cg/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/TilekT/AI_agent_PhalaN",
        "link": "https://ethglobal.com/showcase/ai-agent-phalan-vhtrw"
    },
    {
        "title": "HonorDAO",
        "brief_description": "HonorDAO distributes \u2018Honor Token\u2019 for every good transaction you do, and \u2018Dishonor Token\u2019 if you do a bad transaction. It allows users on Ethereum to rate the integrity of a transaction on whether the counter party held up their side of the deal.",
        "long_description": "HonorDAO aims to be a universal way on measuring how honorable a user account or contract account is on the blockchain. It effectively gives users/apps a way to \u2018own\u2019 their reputation that they can use across apps to show if they are completing transactions in the way they say they are. \u2028\u2028It does this by tracking two soul bound ERC20 tokens on the users account, \u2018Honor Tokens\u2019 and \u2018Dishonor Tokens\u2019. You can think of these as someone leaving a 5 star vs 1 star review on an account. The more \u2018Dishonor Tokens\u2019 a account has, the more someone can assume that they shouldn\u2019t interact with this address, and vise vera for \u2018Honor Tokens\u2019 Below are real world use cases of a reason someone would use HonorDAO to send tokens: Good Transaction example: \u201dyou bought a product or service using crypto and you had a good experience\u201d -> Transfer \u2018Honor Token\u2019 to the outbound address Bad Transaction example: \u201cyou sent money to a smart contract and it turned out to be a scam\u201d -> Transfer Dishonor token to the smart contract account Using the HonorDAO dapp, you can check how much Honor/Dishonor someone has as well as send Honor based on recent transactions. **the goal long term is to make transferring honor tokens to someone free, meaning the transaction fee is covered. We could fund this by using donations or by having a way for apps to voluntarily opt-in to the protocol, and cover the fee of transferring honor. FAQ:\u2028\u2028  1. Can the accounts transfer Honor Tokens -\nNo, the tokens are \u2018Soul-bound\u2019 to the account meaning that it stays with the address forever and it cannot be transferred In which scenarios can an account send \u2018Honor Tokens\u2019?\nA user can send honor tokens based on a recent outbound transaction they had. For example they transferred money to a person or contract. Can people just fake transactions to themselves and leave \u2018fake reviews\u2019?\nSince transactions cost money, this takes away from the motivation for people to make fake transactions/reviews. I also will think about weighing the amount of Honor/Dishonor with the value of the transaction. In order to build the front end I used next js, tailwind css, typescript and react.\nI used Alchemy API & viem for web3 development and connecting to the smart contracts.\nI also used the Etherscan API for querying a address's transactions on the frontend and for resolving the addresses to ENS names.\nIn order to deploy the smart contracts I used Remix and solidity.",
        "how_its_made": "In order to build the front end I used next js, tailwind css, typescript and react.\nI used Alchemy API & viem for web3 development and connecting to the smart contracts.\nI also used the Etherscan API for querying a address's transactions on the frontend and for resolving the addresses to ENS names.\nIn order to deploy the smart contracts I used Remix and solidity.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/j6zw2/screenshots/d2pmh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j6zw2/screenshots/trxkf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j6zw2/screenshots/24mqk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j6zw2/screenshots/t2hjy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j6zw2/screenshots/jnh3m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j6zw2/screenshots/7dssm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/davidslakter/HonorDAO/",
        "link": "https://ethglobal.com/showcase/honordao-j6zw2"
    },
    {
        "title": "Alpha Scorpion",
        "brief_description": "Alpha Scorpion is a multi-chain NFT project powered by LayerZero, offering seamless cross-chain minting, IP management, and immersive storytelling. Mint on Holesky, protect IP on Story Protocol, and unlock interactive experiences across blockchain networks. #NFT #Web3 #CrossChain",
        "long_description": "Alpha Scorpion is a groundbreaking multi-chain NFT project that leverages cutting-edge blockchain technology to offer seamless cross-chain minting, IP control, and interactive storytelling experiences. Built on LayerZero, Alpha Scorpion allows users to mint NFTs on multiple chains, starting with the Holesky testnet. Once minted, these NFTs can be moved across supported blockchains effortlessly, empowering creators to maintain control over their intellectual property (IP) while expanding the utility and reach of their assets. A key feature of Alpha Scorpion is its integration with the Story Protocol, a decentralized platform that enables the registration and protection of NFT IP. Creators can mint their NFTs on the Holesky testnet and then transfer them to the Story chain, where they can register their IP and unlock further storytelling functionalities, including narrative elements and interactive features that deepen engagement with NFT holders. The project offers a user-friendly interface, allowing creators and collectors to mint, transfer, and manage NFTs across different chains with ease. With the possibility of Ethereum Name Service (ENS) integration and support for cross-chain transfers, Alpha Scorpion creates a rich ecosystem that combines blockchain interoperability, IP protection, and storytelling to deliver a unique NFT experience for creators and users alike. Key features include: Alpha Scorpion is designed for creators looking to expand their digital art and assets across multiple blockchains, while ensuring the security and protection of their intellectual property. Alpha Scorpion is built on a multi-chain infrastructure utilizing LayerZero, Story Protocol, and various Web3 technologies to ensure a seamless, scalable, and interoperable NFT ecosystem. LayerZero:\nLayerZero is the backbone of the cross-chain functionality. It enables seamless communication between different blockchain networks, allowing NFTs to be minted on one chain and transferred to another with ease. This is particularly crucial for the interoperability between the Holesky testnet and the Story Protocol chain. The multi-chain architecture is enabled by LayerZero\u2019s ability to bridge data securely and efficiently across blockchains. Ethereum (Holesky Testnet):\nWe chose Holesky, Ethereum's testnet, as the starting point for NFT minting. This testnet allowed us to simulate real-world Ethereum deployments without the costs of mainnet operations. The smart contracts, written in Solidity, are deployed on Holesky, which acts as the first layer for NFT creation. Story Protocol:\nStory Protocol adds another layer of functionality by allowing creators to register their intellectual property (IP) on the blockchain. After minting on Holesky, NFTs can be transferred to the Story chain where creators can secure IP rights, attach metadata, and use the storytelling functionality for engaging NFT holders. This integration ensures that NFTs aren\u2019t just static assets but dynamic, interactive experiences. Smart Contracts:\nThe core of the system is built using Solidity smart contracts. The main contract deployed on Holesky manages the minting and metadata storage of the NFTs. Once an NFT is transferred to the Story chain, the IP-related contract is executed to register and control IP rights. We made use of Solidity\u2019s interoperability functions to interact with LayerZero for cross-chain operations. IPFS + Pinata:\nIPFS (InterPlanetary File System) is used to store NFT metadata, including images and descriptions, in a decentralized manner. We utilized Pinata as a gateway for interacting with IPFS, making it easy to manage file uploads and metadata pinning. This ensures that metadata is stored off-chain, reducing the load on smart contracts while maintaining decentralized storage. React + Material UI:\nThe frontend is built using React and Material UI to provide a clean, user-friendly interface. React handles the core logic of the dApp, while Material UI ensures a consistent and modern UI/UX. The user flow includes NFT minting, cross-chain transfer, and IP registration. The UI also provides real-time feedback, including notifications when NFTs are minted or transferred. Firebase:\nFirebase is used for backend storage and real-time updates. We used Firebase Cloud Functions to trigger backend processes when certain events occur, such as when an NFT is minted or transferred. Firebase\u2019s real-time database was also used to keep track of users' NFTs and metadata. Privy:\nFor authentication and wallet management, Privy was integrated to simplify user onboarding. With Privy, users can connect their wallets securely without exposing sensitive information. This also helped in creating a smoother experience for users interacting with both Holesky and Story Protocol chains. Minting NFTs on Holesky:\nThe project starts with users minting NFTs on the Holesky testnet. These NFTs are deployed as ERC-721 tokens, with their metadata stored on IPFS and pinned via Pinata. Cross-Chain Transfer:\nOnce minted, LayerZero allows the NFTs to be transferred across chains, specifically to the Story Protocol chain for IP registration. The cross-chain functionality is a key part of the project, and LayerZero\u2019s ultra-light nodes enable this by bridging communication between the two blockchains without needing a centralized intermediary. IP Registration on Story Protocol:\nAfter the NFT is transferred to Story Protocol, the project takes advantage of its decentralized IP registry. Creators can secure their rights, add metadata, and build interactive stories or attributes around their NFTs. This allows for more than just asset ownership\u2014it allows creators to tell stories or embed dynamic content into their NFTs. Cross-Chain Gas Optimization: We had to optimize the gas usage when interacting with LayerZero\u2019s cross-chain messaging. By reducing the size of data being transferred between chains, we managed to keep the transaction costs low, even for complex operations like IP registration. Real-Time Feedback: Using Firebase\u2019s real-time capabilities, we managed to implement real-time updates for users after every transaction. This means users get instant feedback after minting, transferring, or registering their NFTs. Deferred Contract Loading: Instead of loading all smart contracts upfront, we delayed the loading of the Story Protocol contract until the user switches to that chain, improving the dApp\u2019s performance and resource usage. In summary, Alpha Scorpion was built with a robust stack of blockchain technologies, decentralized storage, and seamless multi-chain capabilities. The integration of LayerZero for cross-chain operations, Story Protocol for IP management, and IPFS for decentralized metadata storage creates a dynamic ecosystem for NFT creators and holders.",
        "how_its_made": "Alpha Scorpion is built on a multi-chain infrastructure utilizing LayerZero, Story Protocol, and various Web3 technologies to ensure a seamless, scalable, and interoperable NFT ecosystem. LayerZero:\nLayerZero is the backbone of the cross-chain functionality. It enables seamless communication between different blockchain networks, allowing NFTs to be minted on one chain and transferred to another with ease. This is particularly crucial for the interoperability between the Holesky testnet and the Story Protocol chain. The multi-chain architecture is enabled by LayerZero\u2019s ability to bridge data securely and efficiently across blockchains. Ethereum (Holesky Testnet):\nWe chose Holesky, Ethereum's testnet, as the starting point for NFT minting. This testnet allowed us to simulate real-world Ethereum deployments without the costs of mainnet operations. The smart contracts, written in Solidity, are deployed on Holesky, which acts as the first layer for NFT creation. Story Protocol:\nStory Protocol adds another layer of functionality by allowing creators to register their intellectual property (IP) on the blockchain. After minting on Holesky, NFTs can be transferred to the Story chain where creators can secure IP rights, attach metadata, and use the storytelling functionality for engaging NFT holders. This integration ensures that NFTs aren\u2019t just static assets but dynamic, interactive experiences. Smart Contracts:\nThe core of the system is built using Solidity smart contracts. The main contract deployed on Holesky manages the minting and metadata storage of the NFTs. Once an NFT is transferred to the Story chain, the IP-related contract is executed to register and control IP rights. We made use of Solidity\u2019s interoperability functions to interact with LayerZero for cross-chain operations. IPFS + Pinata:\nIPFS (InterPlanetary File System) is used to store NFT metadata, including images and descriptions, in a decentralized manner. We utilized Pinata as a gateway for interacting with IPFS, making it easy to manage file uploads and metadata pinning. This ensures that metadata is stored off-chain, reducing the load on smart contracts while maintaining decentralized storage. React + Material UI:\nThe frontend is built using React and Material UI to provide a clean, user-friendly interface. React handles the core logic of the dApp, while Material UI ensures a consistent and modern UI/UX. The user flow includes NFT minting, cross-chain transfer, and IP registration. The UI also provides real-time feedback, including notifications when NFTs are minted or transferred. Firebase:\nFirebase is used for backend storage and real-time updates. We used Firebase Cloud Functions to trigger backend processes when certain events occur, such as when an NFT is minted or transferred. Firebase\u2019s real-time database was also used to keep track of users' NFTs and metadata. Privy:\nFor authentication and wallet management, Privy was integrated to simplify user onboarding. With Privy, users can connect their wallets securely without exposing sensitive information. This also helped in creating a smoother experience for users interacting with both Holesky and Story Protocol chains. Minting NFTs on Holesky:\nThe project starts with users minting NFTs on the Holesky testnet. These NFTs are deployed as ERC-721 tokens, with their metadata stored on IPFS and pinned via Pinata. Cross-Chain Transfer:\nOnce minted, LayerZero allows the NFTs to be transferred across chains, specifically to the Story Protocol chain for IP registration. The cross-chain functionality is a key part of the project, and LayerZero\u2019s ultra-light nodes enable this by bridging communication between the two blockchains without needing a centralized intermediary. IP Registration on Story Protocol:\nAfter the NFT is transferred to Story Protocol, the project takes advantage of its decentralized IP registry. Creators can secure their rights, add metadata, and build interactive stories or attributes around their NFTs. This allows for more than just asset ownership\u2014it allows creators to tell stories or embed dynamic content into their NFTs. Cross-Chain Gas Optimization: We had to optimize the gas usage when interacting with LayerZero\u2019s cross-chain messaging. By reducing the size of data being transferred between chains, we managed to keep the transaction costs low, even for complex operations like IP registration. Real-Time Feedback: Using Firebase\u2019s real-time capabilities, we managed to implement real-time updates for users after every transaction. This means users get instant feedback after minting, transferring, or registering their NFTs. Deferred Contract Loading: Instead of loading all smart contracts upfront, we delayed the loading of the Story Protocol contract until the user switches to that chain, improving the dApp\u2019s performance and resource usage. In summary, Alpha Scorpion was built with a robust stack of blockchain technologies, decentralized storage, and seamless multi-chain capabilities. The integration of LayerZero for cross-chain operations, Story Protocol for IP management, and IPFS for decentralized metadata storage creates a dynamic ecosystem for NFT creators and holders.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bo9kn/screenshots/t4m7b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bo9kn/screenshots/1sz6j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bo9kn/screenshots/8104i/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/x5engine/Alpha-Scorpion",
        "link": "https://ethglobal.com/showcase/alpha-scorpion-bo9kn"
    },
    {
        "title": "Chain Waves",
        "brief_description": "A dApp that allows you to watermark audio files, and secure them on the blockchain",
        "long_description": "Chain Waves is a cutting-edge audio watermarking solution that leverages blockchain technology to provide verifiable proof of ownership and detailed usage tracking for your audio creations. Our system employs advanced signal processing techniques, including linear transformations and entropy analysis, to embed imperceptible watermarks directly into your audio files. Key Features: Use Cases: How It Works: Key Advantages: This platform empowers creators to take control of their intellectual property, ensuring they can easily demonstrate proof of ownership, collect deserved royalties, and dispute any unauthorized use of their content. Here's how it works: Content: Mint IP on Story Audios: Watermark Embedding: Blockchain Registration: Usage Tracking and Verification:",
        "how_its_made": "Here's how it works: Content: Mint IP on Story Audios: Watermark Embedding: Blockchain Registration: Usage Tracking and Verification:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6yipt/screenshots/tcaab/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6yipt/screenshots/59fzh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6yipt/screenshots/wn010/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6yipt/screenshots/n0u9a/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/D9J9V/Chainwaves",
        "link": "https://ethglobal.com/showcase/chain-waves-6yipt"
    },
    {
        "title": "Qiao",
        "brief_description": "Introducing \u6865 Protocol \ud83c\udf09 \u2014 an innovative layer that offloads computation to off-chain resources, enables cross-chain delegations, and offers a universal resolver for smart contracts to ensure seamless interoperability.",
        "long_description": "Mission: The \u6865 Protocol (pronounced Qi\u00e1o, meaning \u201cbridge\u201d in Chinese) is dedicated to bridging the gap between on-chain limitations and off-chain capabilities. Our mission is to empower developers and users with a protocol that seamlessly offloads heavy computations to off-chain environments while ensuring reliable cross-chain interactions and universal contract resolution. Vision: We envision a decentralized ecosystem where: The \u6865 Protocol aims to be the foundational layer that connects diverse blockchain networks and off-chain resources, fostering an interconnected and efficient decentralized future. Architecture and Components: 2. CCIP gateway\n\u2022\tAn npm package @qiaoprotocol/ccip-gateway created from the ground up with Hono and viem for signing. It has fully composable setup and also leverages lit action to allow for decentralized signing.\n3.\tContract Factory Deployment:\n\u2022\tA robust contract factory deploys customizable CCIP server contracts. Developers can specify payment methods and revert URLs, tailoring the servers to handle specific code snippets and execution requirements.\n4.\tOff-Chain Computation Offloading:\n\u2022\tHeavy computational tasks are offloaded to off-chain resources, significantly reducing on-chain gas consumption and improving execution speed without compromising security.\n5.\tUniversal ENS Resolver:\n\u2022\tServing as an off-chain resolver for Ethereum Name Service (ENS) subdomains, \u6865 Protocol allows smart contracts and methods to be accessed using human-readable names. This universal resolver simplifies contract interaction and enhances user experience.\n6.\tRecording and Logging Mechanisms:\n\u2022\tThe protocol records inputs, outputs, and side effects of all contract executions. This transparency ensures reliability, aids in debugging, and builds trust within the ecosystem.\n7.\tFunctional Programming Compatibility:\n\u2022\tBy providing global methods compatible with functional programming paradigms, developers can write more efficient and scalable code, leveraging languages and techniques that promote immutability and stateless computations. Security and Compliance: Scalability and Future-Proofing: \u6865 Protocol \ud83c\udf09 is more than just a bridge; it\u2019s the foundational infrastructure aiming to unify the fragmented blockchain world by connecting on-chain and off-chain resources seamlessly. By focusing on off-chain computation, universal contract resolution, and reliable cross-chain interactions, \u6865 Protocol is set to redefine what\u2019s possible in the decentralized ecosystem.",
        "how_its_made": "Architecture and Components: 2. CCIP gateway\n\u2022\tAn npm package @qiaoprotocol/ccip-gateway created from the ground up with Hono and viem for signing. It has fully composable setup and also leverages lit action to allow for decentralized signing.\n3.\tContract Factory Deployment:\n\u2022\tA robust contract factory deploys customizable CCIP server contracts. Developers can specify payment methods and revert URLs, tailoring the servers to handle specific code snippets and execution requirements.\n4.\tOff-Chain Computation Offloading:\n\u2022\tHeavy computational tasks are offloaded to off-chain resources, significantly reducing on-chain gas consumption and improving execution speed without compromising security.\n5.\tUniversal ENS Resolver:\n\u2022\tServing as an off-chain resolver for Ethereum Name Service (ENS) subdomains, \u6865 Protocol allows smart contracts and methods to be accessed using human-readable names. This universal resolver simplifies contract interaction and enhances user experience.\n6.\tRecording and Logging Mechanisms:\n\u2022\tThe protocol records inputs, outputs, and side effects of all contract executions. This transparency ensures reliability, aids in debugging, and builds trust within the ecosystem.\n7.\tFunctional Programming Compatibility:\n\u2022\tBy providing global methods compatible with functional programming paradigms, developers can write more efficient and scalable code, leveraging languages and techniques that promote immutability and stateless computations. Security and Compliance: Scalability and Future-Proofing: \u6865 Protocol \ud83c\udf09 is more than just a bridge; it\u2019s the foundational infrastructure aiming to unify the fragmented blockchain world by connecting on-chain and off-chain resources seamlessly. By focusing on off-chain computation, universal contract resolution, and reliable cross-chain interactions, \u6865 Protocol is set to redefine what\u2019s possible in the decentralized ecosystem.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6o7h9/screenshots/zn3if/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6o7h9/screenshots/4a5s5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6o7h9/screenshots/akhvu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6o7h9/screenshots/u0b1b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6o7h9/screenshots/mhhwp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6o7h9/screenshots/doxqg/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/qiaoprotocol/monorepo",
        "link": "https://ethglobal.com/showcase/qiao-6o7h9"
    },
    {
        "title": "AITrainingDAOonchain",
        "brief_description": "Decentralized HuggingFace (Nostr-based decentralized AGI model storage protocol + AGI Git version control + SAAS private model Tokenomics) AGI as a Service, GIT as a Service",
        "long_description": "Our team builds AGI-Git, an innovative open-source platform for storing, sharing, and evolving AI models. featuring:\n1- Advanced version control for copyright and collaboration clarity.\n2- Extremely efficient storage and communication by saving only version differences.\n3- Decentralized nostr protocol for data integrity and availability.\n4- Economic incentives for model evolution and access.\n5- Future integration with decentralized computing for on-platform training. Decentralized HuggingFace (Nostr-based decentralized AGI model storage protocol + AGI Git version control + SAAS private model Tokenomics)\nAGI as a Service, GIT as a Service AI is poised to significantly reshape various aspects of our digital world, with novel AI applications and interaction methods transforming traditional software and the web3 ecosystem. Models serve as the foundational framework for these applications, dictating the level of intelligence and user experience. To foster the creation and sharing of high-quality models, our team is dedicated to developing an open-source, distributed platform for model storage and sharing called AGI-Git. This platform offers the following features and advantages:",
        "how_its_made": "AI is poised to significantly reshape various aspects of our digital world, with novel AI applications and interaction methods transforming traditional software and the web3 ecosystem. Models serve as the foundational framework for these applications, dictating the level of intelligence and user experience. To foster the creation and sharing of high-quality models, our team is dedicated to developing an open-source, distributed platform for model storage and sharing called AGI-Git. This platform offers the following features and advantages:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/05vex/screenshots/veni4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/05vex/screenshots/tmq4o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/05vex/screenshots/01y5t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/05vex/screenshots/vkjni/default.jpg",
            "https://ethglobal.b-cdn.net/projects/05vex/screenshots/0i366/default.jpg",
            "https://ethglobal.b-cdn.net/projects/05vex/screenshots/y31ye/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/skye16285/AGI-Git",
        "link": "https://ethglobal.com/showcase/aitrainingdaoonchain-05vex"
    },
    {
        "title": "SillyVoting",
        "brief_description": "Trying to allow people to create Survivor-like games on-chain!",
        "long_description": "The goal was to create a smart contract + front-end in order to allow users to create their own Survivor games on-chain. It would use Gnosis's shutter to hide the elimination votes until after the player was eliminated, to maintain the secrecy that's key to the game. In its present form, the smart contract functionality to allow elimination does not currently work. It only allows for voting, but there's currently no way to remove a player based on the conclusion of those votes. I used solidity, foundry, and some node.js+ethers for testing. The full vision of the project was to allow users to create new games using a react client-side, as well as start elimination rounds, vote in elimination rounds, and reveal who was eliminated (as well as actually eliminate them on the smart contract side). In order to prevent players from seeing how others are voting, they would sign a hash of the address of the player they wish to eliminate it, and commit that using Shutter, so that it could only be revealed after the elimination round was over.",
        "how_its_made": "I used solidity, foundry, and some node.js+ethers for testing. The full vision of the project was to allow users to create new games using a react client-side, as well as start elimination rounds, vote in elimination rounds, and reveal who was eliminated (as well as actually eliminate them on the smart contract side). In order to prevent players from seeing how others are voting, they would sign a hash of the address of the player they wish to eliminate it, and commit that using Shutter, so that it could only be revealed after the elimination round was over.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6p76b/screenshots/a4dt1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6p76b/screenshots/rbg1g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6p76b/screenshots/akx72/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Heph789/ShutterSurvivor",
        "link": "https://ethglobal.com/showcase/sillyvoting-6p76b"
    },
    {
        "title": "Aurum",
        "brief_description": "The app that connects them all... Aurum is the payment experience that connects all worlds.",
        "long_description": "Imagine you are a tech-savvy digital nomad traveling with your FRIEND to any country in the world, from any country in the world.\nYou land in Bangkok, stopping at a coffee shop on the way to ETHGlobal Hackathon.\nThe Barista prepares your coffee, it\u2019s 330 THB and you want to pay with cryptocurrency.\nYou tell your FRIEND to prepare a transaction hands-free, with your voice. AURUM connects the latest AI, blockchain & Web 3 technologies into a seamless user experience that allows cryptocurrency to be used anywhere in the world, even if the receiver wants fiat currency.\nThe tech stack is comprised of the following:",
        "how_its_made": "AURUM connects the latest AI, blockchain & Web 3 technologies into a seamless user experience that allows cryptocurrency to be used anywhere in the world, even if the receiver wants fiat currency.\nThe tech stack is comprised of the following:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/7ry36/screenshots/qpjdz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7ry36/screenshots/0xnk1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7ry36/screenshots/m93n8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7ry36/screenshots/de925/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7ry36/screenshots/mit1h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7ry36/screenshots/qswh2/default.jpg"
        ],
        "live_demo": "https://aurum-app.vercel.app/",
        "source_code": "https://github.com/JulioMCruz/Aurum",
        "link": "https://ethglobal.com/showcase/aurum-7ry36"
    },
    {
        "title": "?",
        "brief_description": "a web3 integrated, culturally neutral pattern recognition game",
        "long_description": "Our game is based on 2x2 square cards, and each square on that 2x2 card can be 1 out of 4 total colors, so 256 different card combinations in total. The game starts by the user providing a seed which then randomly shuffles all of the cards in a random order. Next, 49 of the shuffled cards are placed in a 7x7 card grid, and then any of the 256 cards are chosen one by one for the player to find. Now, the player must search the board for the singular card they have just been given, and the solution could be between multiple cards or could just be a singular card. Some cards are easier to find than others, that's why we're using a point system based on the complexity of the card. The number of points a card is worth is directly correlated to the amount of colors on that card. For example, if the player gets a card with 3 red squares and 1 blue square, they will receive 2 points for correctly identifying that card on the board, since there are 2 colors (red, blue). The objective of the game is to be the first player to reach 10 points, and once a player reaches 10 they can claim the board. What this means is that if they have successfully reached 10 points, the game will stop and the winning player will be awarded a tradable NFT of the board they were just playing on.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/b0ih4/screenshots/zk1vx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b0ih4/screenshots/4j3ef/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b0ih4/screenshots/gvqdh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b0ih4/screenshots/ahrus/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b0ih4/screenshots/0qeei/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b0ih4/screenshots/o2b8x/default.jpg"
        ],
        "live_demo": "https://question-mark-game-591blylo3-imis-projects-452ab78d.vercel.app/play/8888/56",
        "source_code": "https://github.com/1m1-github/question-mark-game-for-ethglobal-san-francisco-2024",
        "link": "https://ethglobal.com/showcase/-b0ih4"
    },
    {
        "title": "TerraFlow",
        "brief_description": "Terraflow is a DeFi AgriTech platform that tokenizes farmland and enables consumers to stake funds to support local farmers. Using blockchain, smart contracts, and NFTs, users can invest in fractional ownership, receive rewards, and help farmers access sustainable funding.",
        "long_description": "Terraflow addresses a critical issue in the U.S. agricultural sector: the difficulty farmers face in securing affordable funding to maintain their crops and farmland. With rising interest rates on bank loans and high costs from private investors, farmers are struggling to access the financial support they need. Over the last five years, interest rates for agricultural loans have increased by more than 3.25%, more than doubling the average rates from half a decade ago. This growing financial burden motivated us to create Terraflow, a decentralized web application that aims to provide a more sustainable and community-driven funding solution for farmers.\nTerraflow allows farmers to tokenize fractions of their farmland which enables everyday consumers to invest by staking money into these tokenized assets. When consumers stake funds, they contribute to the maintenance and development of the farm, helping farmers access much-needed capital without the high costs associated with traditional financing. In return, consumers receive their stake money back, along with token rewards. These rewards can include exclusive benefits such as early access to farm produce, discounts, or invitations to farm events, creating a mutually beneficial arrangement.\nThe platform leverages blockchain technology to ensure transparency and security. Each farm listing on Terraflow is represented by smart contracts that govern the terms of investment and staking, allowing users to see the details of the farm, its location, and available investment options. By utilizing fractional ownership, Terraflow enables consumers to invest in local farms, helping them feel that their contribution is meaningful and directly benefiting their community. For farmers, this model reduces dependency on loans and allows them to receive funding at lower effective rates.\nAdditionally, using data from the USDA NASS and a sample calculation, it is estimated that an average farm in the U.S., which spans about 444 acres, can save approximately $888,000 in maintenance costs by leveraging Terraflow\u2019s community-based funding model. This significant cost reduction can play a crucial role in ensuring the long-term sustainability of farms across the country.\nOverall, Terraflow fosters a community-centric approach to agriculture which aims to empower consumers to directly support local farmers while earning rewards. It bridges the gap between Web2 and Web3, making it easy for anyone to participate through user-friendly authentication and embedded wallets, ensuring that even those unfamiliar with blockchain technology can get involved. By connecting consumers and farmers, Terraflow creates a decentralized ecosystem where everyone benefits, promoting growth, sustainability, and resilience in the agricultural sector. Terraflow integrates advanced blockchain technology and user-friendly design to create a seamless platform where farmers can access essential funding and users can invest in local agriculture. The system begins with Privy which bridges Web2 and Web3 by enabling users to authenticate using their phone number or email. When signing up, users are provided with an embedded wallet that securely stores a private key in the background. This process allows them to onboard onto web3 without realizing it. This embedded wallet simplifies interactions with blockchain features which makes it easy for users unfamiliar with traditional crypto setups to participate. Farmers can list a property on Terraflow which creates an instance of a Solidity smart contract on the Flow blockchain. These contracts act as on-chain assets, providing transparency and security. The smart contracts govern the rules of staking, ownership, and return distribution, ensuring automatic enforcement of terms. Terraflow also features lossless lottery staking in which users can contribute funds to a pooled model without risking their initial staked investment. These investors are distributed rewards in a lottery format. The platform operates on the Flow blockchain for its low transaction fees and scalability. Farms can be tokenized into NFTs representing fractional ownership, minted on the Flow blockchain, and used for transactions. Users who stake money in these farms receive NFTs that offer partial ownership and benefits like access to exclusive produce and events. The platform uses Flow test tokens for transaction testing. The front end of Terraflow is built with React and is enhanced by Shadcn and Framermotion frameworks. Shadcn ensures a consistent and visually appealing UI, while Framermotion adds fluid animations for a good UI experience. Farmers can list properties with detailed information which allows users to make informed decisions. Privy bridges web2 and web3 by providing embedded wallets that enable users to engage with blockchain functionalities without needing extensive technical knowledge. The wallets support seamless staking, NFT transfers, and interactions with smart contracts all while maintaining user fund security and data privacy. Terraflow undergoes rigorous testing, using Flow test tokens and testnet environments to ensure the functionality and security of staking and NFT mechanisms. Solidity smart contracts are also thoroughly tested to verify the logic behind farm listings, staking, and the lossless lottery model. Combining Privy authentication, Solidity smart contracts, and Flow blockchain infrastructure with a well-designed front end, Terraflow offers a new and efficient platform that allows farmers to secure funding while providing consumers with meaningful, profitable investments.",
        "how_its_made": "Terraflow integrates advanced blockchain technology and user-friendly design to create a seamless platform where farmers can access essential funding and users can invest in local agriculture. The system begins with Privy which bridges Web2 and Web3 by enabling users to authenticate using their phone number or email. When signing up, users are provided with an embedded wallet that securely stores a private key in the background. This process allows them to onboard onto web3 without realizing it. This embedded wallet simplifies interactions with blockchain features which makes it easy for users unfamiliar with traditional crypto setups to participate. Farmers can list a property on Terraflow which creates an instance of a Solidity smart contract on the Flow blockchain. These contracts act as on-chain assets, providing transparency and security. The smart contracts govern the rules of staking, ownership, and return distribution, ensuring automatic enforcement of terms. Terraflow also features lossless lottery staking in which users can contribute funds to a pooled model without risking their initial staked investment. These investors are distributed rewards in a lottery format. The platform operates on the Flow blockchain for its low transaction fees and scalability. Farms can be tokenized into NFTs representing fractional ownership, minted on the Flow blockchain, and used for transactions. Users who stake money in these farms receive NFTs that offer partial ownership and benefits like access to exclusive produce and events. The platform uses Flow test tokens for transaction testing. The front end of Terraflow is built with React and is enhanced by Shadcn and Framermotion frameworks. Shadcn ensures a consistent and visually appealing UI, while Framermotion adds fluid animations for a good UI experience. Farmers can list properties with detailed information which allows users to make informed decisions. Privy bridges web2 and web3 by providing embedded wallets that enable users to engage with blockchain functionalities without needing extensive technical knowledge. The wallets support seamless staking, NFT transfers, and interactions with smart contracts all while maintaining user fund security and data privacy. Terraflow undergoes rigorous testing, using Flow test tokens and testnet environments to ensure the functionality and security of staking and NFT mechanisms. Solidity smart contracts are also thoroughly tested to verify the logic behind farm listings, staking, and the lossless lottery model. Combining Privy authentication, Solidity smart contracts, and Flow blockchain infrastructure with a well-designed front end, Terraflow offers a new and efficient platform that allows farmers to secure funding while providing consumers with meaningful, profitable investments.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1gvun/screenshots/sarso/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1gvun/screenshots/nx9f1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1gvun/screenshots/96b8m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1gvun/screenshots/spfk8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/SuhaanSyed/TerraFlow",
        "link": "https://ethglobal.com/showcase/terraflow-1gvun"
    },
    {
        "title": "Yield",
        "brief_description": "Find the best, AI-optimized, interest rates in one click!  Yield is the robinhood of finance, it permits everyone (even your grandmother) to easily profit from the best interest rates in DeFi.",
        "long_description": "\u2192Problem:\nThe richest people in the world are grasping most the wealth available. Main economic reports show that \u201cthe richest 1 percent grabbed nearly two-thirds of all new wealth worth $42 trillion created since 2020, almost twice as much money as the bottom 99 percent of the world\u2019s population\u201d (oxfam report, 2023). These social inequalities of wealth, and economic struggle of most of the world population even in the developed countries has been studied in depth by prominent economists, like Piketty or Saez & Zucman. Their research show that the richest people have a advantage by getting a preferential access to financial markets and products which get them the highest returns. Leading to less or no financial education for the middle and lower social class. We want to change this. Indeed, the consequences of this are: People are being kept poor, in a difficult economy, and they can feel the pain of this situation. The centralized finance institutions are not doing enough to alleviate this problem. That\u2019s where us, as web3 builders need to come in to make our space be of public utility. We need to make everyone in our lives, parents siblings & colleagues, be able to have access to fairer and better financial tools! \u2192Our Solution:\nThat\u2019s why we are building a public infrastructure to make DeFi high returns on investments available to everyone. With Yield, even your grandmother can beat the bank\u2019s yields and get extra-money at the end of the month. Our protocol is a consumer-oriented, AI-optimized, cross-chain yield aggregator. However, aggregating lending pools is not sufficient to make everyone able to benefit from DeFi. There is a need for making a huge leap between cryptocurrency-specific apps and wide public decentralized banking. Hence, we have focused our efforts on AI predictions to give a more transparent prediction of the ROI, and making it easily understandable for users. As well as working hard on the behind-the-scene functioning (account abstraction, interoperability, etc) in order to make the Web3 experience seamless with the strict minimum features. UX is key in onboarding the next millions of users. The main deliverable is a swift mobile app - which focuses on giving users the easiest onboarding experience to earning crypto yields. \u2192Wallet & transaction  fees: \u2192Depositing funds: \u2192Best Yield Finding AI Module: \u2192Cross-chain lending routing: \u2192User fund management:",
        "how_its_made": "The main deliverable is a swift mobile app - which focuses on giving users the easiest onboarding experience to earning crypto yields. \u2192Wallet & transaction  fees: \u2192Depositing funds: \u2192Best Yield Finding AI Module: \u2192Cross-chain lending routing: \u2192User fund management:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/z4rt5/screenshots/h5jdk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z4rt5/screenshots/iteuc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z4rt5/screenshots/ynk52/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z4rt5/screenshots/e25et/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z4rt5/screenshots/mht7a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z4rt5/screenshots/1hip6/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/vsvaidya27/Yield",
        "link": "https://ethglobal.com/showcase/yield-z4rt5"
    },
    {
        "title": "Salus",
        "brief_description": "Salus is the first Web3 protocol that incentivizes health data sharing for discounts on medical and term insurance. By sharing data from apps like Apple Health, users can earn cash rewards and premium reductions.",
        "long_description": "Salus is transforming health insurance by leveraging Web3 technology, smart contracts, and innovative tokenomics to create a trustless, incentive-driven health data ecosystem. Inspired by usage-based auto insurance that rewards safe driving habits, Salus applies a similar dynamic model to health insurance.\nTraditional health insurance faces significant challenges such as reliance on one-time health assessments without real-time updates, lack of mechanisms for users to lower premiums through improved health behaviors, privacy concerns that make individuals hesitant to share personal health data, and health data being isolated within centralized systems, which stifles innovation. LIT TEE - Encrypting the data, running the computation and decrytpting the data\nPrivy.io - user authentication and wallet for cashbacks and rewards\nTypescript, Node.js, Express - Backend\nCircle - To send secure payments to users in a stable and private manner\nReact, Tailwind - Frontend\nVercel - Hosting",
        "how_its_made": "LIT TEE - Encrypting the data, running the computation and decrytpting the data\nPrivy.io - user authentication and wallet for cashbacks and rewards\nTypescript, Node.js, Express - Backend\nCircle - To send secure payments to users in a stable and private manner\nReact, Tailwind - Frontend\nVercel - Hosting",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1xvur/screenshots/8cne4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1xvur/screenshots/43kak/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1xvur/screenshots/upfg9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1xvur/screenshots/xt8vk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/r-agni/ethglobalsf",
        "link": "https://ethglobal.com/showcase/salus-1xvur"
    },
    {
        "title": "Zend It!",
        "brief_description": "Zend It ensures secure blockchain transactions by allowing users to verify details before signing, especially with Ledger hardware wallets. Using ZKPs and building on Polygon, Zend It offers transparent, risk-free interactions with smart contracts, putting users in full control.",
        "long_description": "Zend It is a developer tool designed to provide secure and transparent blockchain transactions, especially when using Ledger hardware wallets. It enhances user confidence by offering a preview and then a transaction verification before signing, using a multi-step process that ensures accuracy and safety. Key Features:\n-Transaction Verification: When a user initiates a transaction, such as a swap on Polygon or Unichain, Zend It introduces a verification step before signing. This prevents accidental or malicious transactions from proceeding without scrutiny. -Ledger Integration: For users with a Ledger wallet, Zend It uses Ledger's clear signing feature. If the smart contract is pre-approved by Ledger, the transaction details are displayed directly on the Ledger device, allowing the user to review every aspect before approval. -Polygon zkApp: Built as a zkApp on the Polygon blockchain, Zend It leverages the speed, scalability, and security of Polygon\u2019s layer-2 solution, integrating zero-knowledge proofs directly into the transaction\u2019s execution trace. We prove the transaction would occur on chain in a safe and private manner, off chain, using zkm. -We utilize a Claude API integration that allows users to input a contract address and ABI and automatically returns a formatted ERC 7730 and EIP 712 formatting standard for their contract ZendIt is a Developer\u2019s Tool for allowing users to verify any contract with or without ledger but you still get that strong EIP 712 Experience for any transaction your users interact with. Frontend: -React & Typescript\n-Ledger API Integration: We integrated Ledger\u2019s API to enable clear signing for smart contracts. This allows users to verify transaction details directly on their Ledger hardware wallet, ensuring that users can review the transaction securely before signing. Backend: \u2013Node.js & Express: The backend API is built with Node.js and Express to handle incoming requests from the frontend and perform critical transaction verifications. \u2013Ethers.js: For blockchain interactions, we used Ethers.js to communicate with smart contracts on Polygon and Unichain. This library simplifies contract calls, allowing us to fetch the contract\u2019s ABI and decode input data. -Zero-Knowledge Proofs (ZKP): We used ZKM, to generate ZKPs, which ensures the transaction simulation results can be trusted and verified EIP712\u2019s as well as their provable execution trace for all preceding transactions if the execution were to have taken place. For contracts that aren\u2019t pre-approved by Ledger, Zend It will allow any contract to be both verifiable and clear! -Claude AI API: intakes contract and ABI for formatting for the EIP 712 and ERC 7730 standards, allowing a seamless user experience by ingesting the raw contract data behind the scenes and passing along the relevant information for these standards so that developers can easily transition to this better framework, increasing adoption with an additional dev tool -Transaction Simulation: For non-approved contracts, the backend simulates the transaction by recreating it in a safe environment. This simulation helps ensure the transaction will execute as expected without any unexpected consequences. We use Temper.rs to simulate the results and then the Polygon RPC for simulating the chain\u2019s real time data utilizing an off chain ZKM. Blockchain: -Polygon zkApp: Zend It was built as a zkApp on the Polygon blockchain, taking full advantage of Polygon\u2019s fast and scalable infrastructure. Building on Polygon allowed us to integrate zero-knowledge proofs (ZKP) natively within the blockchain, reducing transaction costs while ensuring security. -EIP-712 Standard: We used the EIP-712 standard to securely handle and format the transaction data. This allows for easy verification of off-chain messages before they are signed and sent on-chain. In the Backend, using the ABI, we generate the 7730 Schema and are able to get the ledger live to verify an off chain generated clear sign. Partner Technologies: -Ledger Hardware Wallet: By integrating Ledger\u2019s API, Zend It provides users with a hardware-secured environment for signing transactions for any smart contract they want to interact with before signing. This hardware integration benefits the project by enhancing trust and security for users, allowing them to verify all transaction details on a trusted device. -Etherscan: We rely on Etherscan to retrieve verified contract ABIs for decoding transaction data. This ensures that our backend can properly analyze the functions and inputs of any smart contract before it is signed. How It All Fits Together:\nWhen a user initiates a transaction, Zend It kicks in to offer verification before signing. The frontend sends transaction data like the ABI and 712 payload to the zkm backend, where it\u2019s processed for Ledger\u2019s clear signing and simulates transactions ahead of time in a verifiable manner. If the contract is approved by Ledger, users see the transaction details on their Ledger wallet screen. If not, the backend simulates the transaction, fetches the contract ABI from Etherscan, and decodes the transaction\u2019s data. A ZKP is generated to prove the simulation was correct without revealing sensitive information. This information is then sent back to the frontend, where the user can review all details before deciding to sign the transaction, by instead plainly understanding the transaction using the Clear Messaging Standard detailed in the JSON response that is formatted for the user to see the clear text version of their contract in readable format. Benefits of Partner Technologies: -Ledger: By leveraging Ledger\u2019s hardware-based security, we ensured that users could interact with blockchain networks in a secure and transparent way. By making it easy for devs to use EIP712, we can increase adoption of this standard and promote the adoption of ERC7730 as the next logical step. -Polygon zkApp: Building on Polygon allowed us to scale our application and take advantage of the network\u2019s ZKP capabilities, reducing gas fees and increasing transaction throughput. By applying ZKM to polygon for formal proof verification of our off chain prover process of user\u2019s transaction details, we can use Polygon\u2019s to verify the prover\u2019s intent was fulfilled correctly and was properly indexed from polygon\u2019s list of possible smart contract. We binded the POST request as the input from the EIP712 Message we formatted including the Contract\u2019s ABI and address and Chain ID including all other relevant information. The Chain can verify that the proof does in fact match the clear sign that was returned from the user\u2019s request to verify the smart contract before signing. -PolygonScan and Etherscan: For Both POL Mumbai and ETH Sepolia testnet, for contract verification we ensured that we could pull accurate contract data, enabling smooth transaction simulations and verifications. Notable mentions during the hack:\nWe discovered the lack of transparency in the auditability of transactions on all chains, and became deeply committed to building tooling that addresses a problem user\u2019s in any ecosystem may face. To succeed, we had to be able to push the same project across multiple ecosystems while maintaining consistency across the 5 members of our team.\nWe discovered that, we can allow a ledger device to interact with unverified EIP 712 standard contacts that do not implement the 7730- this essentially funnels users into 7730 compliance With 712 you take the necessary info you need, we generate a trace of what the execution looks like (like Tenderly). Now this returns a zkp to the ledger user, that if they interact with this unverified contract, that the user (blindsign they see in the ledger CAN be trusted because Zent it meant it when it proved that the message that was Zent matches the ZKP\u2019s execution Trace, which is returned by our service. Now every ledger user can, can simulate, verify, and transact in a state of zen- stress free sending send with zen, send with zend it. We are adapting and scaling the adoption of EIP 712 by giving developers a tool for building out ERC 7730s for their own contracts, using a Claude AI integration that does the heavy lifting for them",
        "how_its_made": "Frontend: -React & Typescript\n-Ledger API Integration: We integrated Ledger\u2019s API to enable clear signing for smart contracts. This allows users to verify transaction details directly on their Ledger hardware wallet, ensuring that users can review the transaction securely before signing. Backend: \u2013Node.js & Express: The backend API is built with Node.js and Express to handle incoming requests from the frontend and perform critical transaction verifications. \u2013Ethers.js: For blockchain interactions, we used Ethers.js to communicate with smart contracts on Polygon and Unichain. This library simplifies contract calls, allowing us to fetch the contract\u2019s ABI and decode input data. -Zero-Knowledge Proofs (ZKP): We used ZKM, to generate ZKPs, which ensures the transaction simulation results can be trusted and verified EIP712\u2019s as well as their provable execution trace for all preceding transactions if the execution were to have taken place. For contracts that aren\u2019t pre-approved by Ledger, Zend It will allow any contract to be both verifiable and clear! -Claude AI API: intakes contract and ABI for formatting for the EIP 712 and ERC 7730 standards, allowing a seamless user experience by ingesting the raw contract data behind the scenes and passing along the relevant information for these standards so that developers can easily transition to this better framework, increasing adoption with an additional dev tool -Transaction Simulation: For non-approved contracts, the backend simulates the transaction by recreating it in a safe environment. This simulation helps ensure the transaction will execute as expected without any unexpected consequences. We use Temper.rs to simulate the results and then the Polygon RPC for simulating the chain\u2019s real time data utilizing an off chain ZKM. Blockchain: -Polygon zkApp: Zend It was built as a zkApp on the Polygon blockchain, taking full advantage of Polygon\u2019s fast and scalable infrastructure. Building on Polygon allowed us to integrate zero-knowledge proofs (ZKP) natively within the blockchain, reducing transaction costs while ensuring security. -EIP-712 Standard: We used the EIP-712 standard to securely handle and format the transaction data. This allows for easy verification of off-chain messages before they are signed and sent on-chain. In the Backend, using the ABI, we generate the 7730 Schema and are able to get the ledger live to verify an off chain generated clear sign. Partner Technologies: -Ledger Hardware Wallet: By integrating Ledger\u2019s API, Zend It provides users with a hardware-secured environment for signing transactions for any smart contract they want to interact with before signing. This hardware integration benefits the project by enhancing trust and security for users, allowing them to verify all transaction details on a trusted device. -Etherscan: We rely on Etherscan to retrieve verified contract ABIs for decoding transaction data. This ensures that our backend can properly analyze the functions and inputs of any smart contract before it is signed. How It All Fits Together:\nWhen a user initiates a transaction, Zend It kicks in to offer verification before signing. The frontend sends transaction data like the ABI and 712 payload to the zkm backend, where it\u2019s processed for Ledger\u2019s clear signing and simulates transactions ahead of time in a verifiable manner. If the contract is approved by Ledger, users see the transaction details on their Ledger wallet screen. If not, the backend simulates the transaction, fetches the contract ABI from Etherscan, and decodes the transaction\u2019s data. A ZKP is generated to prove the simulation was correct without revealing sensitive information. This information is then sent back to the frontend, where the user can review all details before deciding to sign the transaction, by instead plainly understanding the transaction using the Clear Messaging Standard detailed in the JSON response that is formatted for the user to see the clear text version of their contract in readable format. Benefits of Partner Technologies: -Ledger: By leveraging Ledger\u2019s hardware-based security, we ensured that users could interact with blockchain networks in a secure and transparent way. By making it easy for devs to use EIP712, we can increase adoption of this standard and promote the adoption of ERC7730 as the next logical step. -Polygon zkApp: Building on Polygon allowed us to scale our application and take advantage of the network\u2019s ZKP capabilities, reducing gas fees and increasing transaction throughput. By applying ZKM to polygon for formal proof verification of our off chain prover process of user\u2019s transaction details, we can use Polygon\u2019s to verify the prover\u2019s intent was fulfilled correctly and was properly indexed from polygon\u2019s list of possible smart contract. We binded the POST request as the input from the EIP712 Message we formatted including the Contract\u2019s ABI and address and Chain ID including all other relevant information. The Chain can verify that the proof does in fact match the clear sign that was returned from the user\u2019s request to verify the smart contract before signing. -PolygonScan and Etherscan: For Both POL Mumbai and ETH Sepolia testnet, for contract verification we ensured that we could pull accurate contract data, enabling smooth transaction simulations and verifications. Notable mentions during the hack:\nWe discovered the lack of transparency in the auditability of transactions on all chains, and became deeply committed to building tooling that addresses a problem user\u2019s in any ecosystem may face. To succeed, we had to be able to push the same project across multiple ecosystems while maintaining consistency across the 5 members of our team.\nWe discovered that, we can allow a ledger device to interact with unverified EIP 712 standard contacts that do not implement the 7730- this essentially funnels users into 7730 compliance With 712 you take the necessary info you need, we generate a trace of what the execution looks like (like Tenderly). Now this returns a zkp to the ledger user, that if they interact with this unverified contract, that the user (blindsign they see in the ledger CAN be trusted because Zent it meant it when it proved that the message that was Zent matches the ZKP\u2019s execution Trace, which is returned by our service. Now every ledger user can, can simulate, verify, and transact in a state of zen- stress free sending send with zen, send with zend it. We are adapting and scaling the adoption of EIP 712 by giving developers a tool for building out ERC 7730s for their own contracts, using a Claude AI integration that does the heavy lifting for them",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0f93v/screenshots/swayw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0f93v/screenshots/e3gy8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0f93v/screenshots/2vhr7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0f93v/screenshots/c1nxz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0f93v/screenshots/dkh5c/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ABusyHippie/ETHGlobalSF2024",
        "link": "https://ethglobal.com/showcase/zend-it-0f93v"
    },
    {
        "title": "Decentralized Memes",
        "brief_description": "Decentralized Random Meme Generator while leveraging Ethereum blockchain for storing data, managing tokens, and interacting with smart contracts.",
        "long_description": "The app allows users to contribute their favorite memes, and in return, they can receive tokens when their memes are upvoted. The app uses Ethereum smart contracts to handle meme submissions, token rewards, and upvotes, making it fun and engaging for meme creators and voters. This serves as an initial foundation for further app development and attracting more contributions. Express.js \u2013 Web framework for creating the backend API. Web3.js \u2013 Ethereum JavaScript API for interacting with the Ethereum blockchain. Solidity \u2013 Programming language for writing the Ethereum smart contract. Infura or Ganache \u2013 Ethereum node provider for connecting to Ethereum (Infura for live/test networks, Ganache for local development).",
        "how_its_made": "Express.js \u2013 Web framework for creating the backend API. Web3.js \u2013 Ethereum JavaScript API for interacting with the Ethereum blockchain. Solidity \u2013 Programming language for writing the Ethereum smart contract. Infura or Ganache \u2013 Ethereum node provider for connecting to Ethereum (Infura for live/test networks, Ganache for local development).",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0mpqc/screenshots/h1mor/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0mpqc/screenshots/man3h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0mpqc/screenshots/riy70/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0mpqc/screenshots/7bgzc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/baia-coder/decentralized-memes",
        "link": "https://ethglobal.com/showcase/decentralized-memes-0mpqc"
    },
    {
        "title": "Ether Go",
        "brief_description": "Pokemon Go but with actual animals to crowdsource the $2.1B problem of wildlife tracking!",
        "long_description": "\ud83c\udf0d Ether Go is like Pok\u00e9mon Go but for real animals! \ud83e\udd92\ud83d\udcf8 Spot wildlife, snap a photo, and write it as an immutable record on the Ethereum blockchain! \ud83c\udf3f Collect your sightings in your EtherDex while helping conservation efforts and learning about nature. It\u2019s fun, educational, and lets you make a real-world impact\u2014all while adding adorable animal records to your EtherDex! \ud83d\udc3e\ud83c\udf0e",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9y3ry/screenshots/onb3a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9y3ry/screenshots/h6hmu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9y3ry/screenshots/mb0hz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9y3ry/screenshots/s4ody/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9y3ry/screenshots/xracn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9y3ry/screenshots/vyky0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/WilliamUW/ETHGlobal-SF",
        "link": "https://ethglobal.com/showcase/ether-go-9y3ry"
    },
    {
        "title": "onChain Shopify",
        "brief_description": "Onchain Shopify platform; allows users to create online stores on the blockchain.",
        "long_description": "We've developed a user-friendly Shopify-like platform that brings e-commerce to the blockchain seamlessly, allowing users to create fully on-chain stores without any of the typical complexities and friction. These stores offer the ability to buy and sell goods or services using a connected CMS & Database, Built-in Storefront, Frictionless Oauth and wallet creation, and a support ChatBot, all with the added benefit of anonymity and history. Our platform ensures a seamless experience with Dynamic for wallet and user onboarding, making it easy for anyone to jump in, regardless of their crypto experience. We chose Flow blockchain for its proven scalability, ensuring the platform can handle massive growth as the commerce ecosystem expands. For file hosting, we use Walrus, a reliable solution that ensures secure and efficient storage, maintaining the integrity and accessibility of all on-chain store data. Google Gemini for the chatbot, as a powerful API with a large context and makes it easy to create chatbots, that connect,  communicate, and work with XMPT as the end user once it is time to actually message and interact with a human using the MessageKit.",
        "how_its_made": "Our platform ensures a seamless experience with Dynamic for wallet and user onboarding, making it easy for anyone to jump in, regardless of their crypto experience. We chose Flow blockchain for its proven scalability, ensuring the platform can handle massive growth as the commerce ecosystem expands. For file hosting, we use Walrus, a reliable solution that ensures secure and efficient storage, maintaining the integrity and accessibility of all on-chain store data. Google Gemini for the chatbot, as a powerful API with a large context and makes it easy to create chatbots, that connect,  communicate, and work with XMPT as the end user once it is time to actually message and interact with a human using the MessageKit.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hmtu3/screenshots/5ox7v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hmtu3/screenshots/80c3v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hmtu3/screenshots/d6nyf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hmtu3/screenshots/me3z9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hmtu3/screenshots/6d9q6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hmtu3/screenshots/epiym/default.jpg"
        ],
        "live_demo": "https://eth-sf-shopify.vercel.app/",
        "source_code": "https://github.com/PhatStraw/eth-sf-shopify",
        "link": "https://ethglobal.com/showcase/onchain-shopify-hmtu3"
    },
    {
        "title": "Uneedswap V5",
        "brief_description": "Multi-protocol Liquidity Pool - hosts multiple protocols and minimizes asset transfers",
        "long_description": "Inspired by Uniswap V4, which hosts multiple Liquidity Pools in a single contracts, I expanded the concept to host various multiple protocols in a single pool. This minimizes the asset transfers calls even further without sacrificing safety. Through common accounting restrictions, additional safety is achieved, as well as additional safety of the protocols. Using these accounting restriction we show a great simplification of concentrated liquidity  implementation, lending, and even implementation of demanding restrictions that can be calculated off-chain and entered as ZK / validity proofs that are succinctly verified on-chain. The implementation is running on multiple EVMs and it is written in Solidity. The sample ZK component\u2019s prover is written in Aztec Noir. The Smart Contract that represents the multi-protocol LP is generic, and various protocols can be added as long as they implement our specific interface for creation, deposit/withdrawal and transactions. I also implemented the sample concentrated liquidity swap pool, lending pool and constant-sum ZK swap pool. The latter is the simplest example of ZK pool, but in reality, more complicated protocols can be implemented in this manner in order to save on gas by calculating the constraints off-chain.",
        "how_its_made": "The implementation is running on multiple EVMs and it is written in Solidity. The sample ZK component\u2019s prover is written in Aztec Noir. The Smart Contract that represents the multi-protocol LP is generic, and various protocols can be added as long as they implement our specific interface for creation, deposit/withdrawal and transactions. I also implemented the sample concentrated liquidity swap pool, lending pool and constant-sum ZK swap pool. The latter is the simplest example of ZK pool, but in reality, more complicated protocols can be implemented in this manner in order to save on gas by calculating the constraints off-chain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jn1hx/screenshots/bu54w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jn1hx/screenshots/5pph0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jn1hx/screenshots/a67wr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jn1hx/screenshots/10244/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jn1hx/screenshots/4f8s6/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jordan-public/multiprotocol-lp/blob/main/demo/README.md",
        "link": "https://ethglobal.com/showcase/uneedswap-v5-jn1hx"
    },
    {
        "title": "Prop2Block",
        "brief_description": "A decentralized NFT real estate marketplace on Ethereum and Polygon. Users can buy, sell, and transfer property tokens with metadata on IPFS. Features escrow services, multi-party interactions (buyers, sellers, lenders), and low gas fees on Polygon.",
        "long_description": "This project is a decentralized NFT marketplace for real estate properties, leveraging blockchain technology to enable trustless property transactions. Each property is minted as a non-fungible token (NFT) using the ERC-721 standard. Property details, such as location, price, and images, are securely stored on IPFS to ensure immutability and accessibility. The marketplace supports multiple actors, including buyers, sellers, lenders, and inspectors, with each party playing a critical role in completing property transactions through an Escrow contract. This contract enforces conditions like inspections and lending approval before transferring ownership. The application is built on Ethereum and deployed on the Polygon Mumbai Testnet to leverage low gas fees. MetaMask integration allows users to easily connect their wallets, switch between networks, and conduct transactions seamlessly. The project is designed to provide a secure, cost-effective, and decentralized solution for real estate transactions, reducing intermediaries and increasing transparency in property ownership. How the Project Was Made: The Nitty-Gritty Details Ethereum & Polygon Blockchain:\nThe application is built on Ethereum with plans to migrate or support the Polygon network (Amoy Testnet). The reason for choosing Polygon is to reduce gas fees and scale the solution, making it more user-friendly and cost-effective, especially for frequent transactions like NFT minting and property transfers. Hardhat:\nThe development framework used for smart contracts. Hardhat simplifies local blockchain testing, compiling contracts, running scripts, and interacting with contracts. It's incredibly flexible for debugging and allows rapid contract iteration and testing in a local environment before migrating to a live network like Polygon. IPFS (InterPlanetary File System):\nIPFS is used for decentralized file storage of property metadata and assets (images, documents, etc.). Each property (token) stores its metadata on IPFS, making the data tamper-proof and censorship-resistant. Docker is used to run IPFS locally during development, while production can leverage public IPFS gateways or services like Infura IPFS or Pinata. Ethers.js:\nEthers.js is the library used to interact with the Ethereum blockchain, whether locally via Hardhat or via Polygon. It's easy to integrate into the frontend, supports MetaMask, and provides a clear API for sending transactions and fetching contract data. MetaMask Integration:\nThe frontend integrates with MetaMask to allow users to connect their wallet, manage transactions, and switch networks. MetaMask also provides wallet authentication and handles gas fee estimation. For production deployment, it helps the user easily switch to the correct network (Polygon Mumbai Testnet or Amoy Testnet). React.js:\nThe frontend of the application is built with React.js. React provides component-based architecture that helps with fast, modular development. It\u2019s also easy to manage state (e.g., user\u2019s wallet connection, network status, and NFT properties) with React\u2019s hooks and state management. Smart Contracts: Frontend (React) and Backend (Smart Contracts):\nThe React.js frontend communicates with smart contracts on the blockchain through ethers.js. The frontend prompts the user to connect their wallet (via MetaMask) and displays their account data, including properties they own, properties for sale, and transaction status. For transactions, the frontend encodes data (like property metadata, price, etc.) and sends it as a transaction to the PropertyNFT or Escrow contracts. The result of each transaction is then updated in real-time on the frontend via event listeners from the blockchain. Hardhat and IPFS for Development:\nDuring local development, Hardhat runs a local Ethereum node to simulate the network environment. This local node is populated with mock accounts and transactions via a deploy script (deploy.js).\nIPFS is run inside a Docker container during development for storing property data. This mimics the decentralized storage that will be used in production. Deployment to Polygon:\nWhen switching from a local environment to the Polygon Mumbai Testnet (or Amoy Testnet), Hardhat\u2019s network configuration is updated. Contracts are deployed to Polygon via Alchemy or Infura as the RPC provider. IPFS or a public IPFS gateway (like Pinata) is used to ensure that property metadata is publicly accessible. IPFS:\nIPFS decentralizes the storage of NFT metadata. This prevents reliance on centralized servers, ensuring that property data (such as descriptions, images, and price) are always accessible without a single point of failure. Using public gateways like Infura IPFS or Pinata simplifies the process of uploading and retrieving files from IPFS. Alchemy / Infura:\nFor the final deployment to Polygon, using Alchemy or Infura as an Ethereum node provider is crucial. It allows for smooth RPC connection to the Polygon network, significantly reducing the effort needed to manage Ethereum or Polygon nodes manually. Their reliable infrastructure helps with faster deployments, transaction broadcasting, and quick access to logs. MetaMask:\nMetaMask plays a critical role by allowing users to connect to the dApp easily, sign transactions, and switch between networks (Ethereum Mainnet, Mumbai Testnet, Amoy, etc.). Its integration reduces friction for end-users when interacting with decentralized applications, making it a highly important tool for adoption. IPFS Locally Integrated:\nRunning IPFS in Docker during development allows a smooth transition to production. However, creating a seamless experience between local IPFS and cloud IPFS was tricky, especially when switching from local development to public networks. Testing metadata storage on public IPFS before pushing to production was one way to ensure the transition was smooth. Automating Gas Estimations:\nOne challenge was underestimating gas on the Polygon testnet. By integrating a custom gas estimation mechanism, transactions were dynamically adjusted based on network congestion, leading to fewer failed transactions. MetaMask and Network Switching:\nMetaMask was configured to prompt the user to switch networks if they were not on the correct one (e.g., when the user is on Ethereum Mainnet but the app needs Polygon Mumbai). This involved custom prompts using the wallet_switchEthereumChain API, reducing friction for users unfamiliar with network management. Summary: This project brings together decentralized storage (via IPFS), blockchain (Ethereum/Polygon), smart contracts, and a smooth user interface (React). The use of partner technologies like MetaMask, Alchemy, and IPFS greatly improved the ease of development and ensured a production-grade decentralized marketplace for properties. Despite the decentralized nature, we focused on providing a UX that felt responsive, reliable, and accessible.",
        "how_its_made": "How the Project Was Made: The Nitty-Gritty Details Ethereum & Polygon Blockchain:\nThe application is built on Ethereum with plans to migrate or support the Polygon network (Amoy Testnet). The reason for choosing Polygon is to reduce gas fees and scale the solution, making it more user-friendly and cost-effective, especially for frequent transactions like NFT minting and property transfers. Hardhat:\nThe development framework used for smart contracts. Hardhat simplifies local blockchain testing, compiling contracts, running scripts, and interacting with contracts. It's incredibly flexible for debugging and allows rapid contract iteration and testing in a local environment before migrating to a live network like Polygon. IPFS (InterPlanetary File System):\nIPFS is used for decentralized file storage of property metadata and assets (images, documents, etc.). Each property (token) stores its metadata on IPFS, making the data tamper-proof and censorship-resistant. Docker is used to run IPFS locally during development, while production can leverage public IPFS gateways or services like Infura IPFS or Pinata. Ethers.js:\nEthers.js is the library used to interact with the Ethereum blockchain, whether locally via Hardhat or via Polygon. It's easy to integrate into the frontend, supports MetaMask, and provides a clear API for sending transactions and fetching contract data. MetaMask Integration:\nThe frontend integrates with MetaMask to allow users to connect their wallet, manage transactions, and switch networks. MetaMask also provides wallet authentication and handles gas fee estimation. For production deployment, it helps the user easily switch to the correct network (Polygon Mumbai Testnet or Amoy Testnet). React.js:\nThe frontend of the application is built with React.js. React provides component-based architecture that helps with fast, modular development. It\u2019s also easy to manage state (e.g., user\u2019s wallet connection, network status, and NFT properties) with React\u2019s hooks and state management. Smart Contracts: Frontend (React) and Backend (Smart Contracts):\nThe React.js frontend communicates with smart contracts on the blockchain through ethers.js. The frontend prompts the user to connect their wallet (via MetaMask) and displays their account data, including properties they own, properties for sale, and transaction status. For transactions, the frontend encodes data (like property metadata, price, etc.) and sends it as a transaction to the PropertyNFT or Escrow contracts. The result of each transaction is then updated in real-time on the frontend via event listeners from the blockchain. Hardhat and IPFS for Development:\nDuring local development, Hardhat runs a local Ethereum node to simulate the network environment. This local node is populated with mock accounts and transactions via a deploy script (deploy.js).\nIPFS is run inside a Docker container during development for storing property data. This mimics the decentralized storage that will be used in production. Deployment to Polygon:\nWhen switching from a local environment to the Polygon Mumbai Testnet (or Amoy Testnet), Hardhat\u2019s network configuration is updated. Contracts are deployed to Polygon via Alchemy or Infura as the RPC provider. IPFS or a public IPFS gateway (like Pinata) is used to ensure that property metadata is publicly accessible. IPFS:\nIPFS decentralizes the storage of NFT metadata. This prevents reliance on centralized servers, ensuring that property data (such as descriptions, images, and price) are always accessible without a single point of failure. Using public gateways like Infura IPFS or Pinata simplifies the process of uploading and retrieving files from IPFS. Alchemy / Infura:\nFor the final deployment to Polygon, using Alchemy or Infura as an Ethereum node provider is crucial. It allows for smooth RPC connection to the Polygon network, significantly reducing the effort needed to manage Ethereum or Polygon nodes manually. Their reliable infrastructure helps with faster deployments, transaction broadcasting, and quick access to logs. MetaMask:\nMetaMask plays a critical role by allowing users to connect to the dApp easily, sign transactions, and switch between networks (Ethereum Mainnet, Mumbai Testnet, Amoy, etc.). Its integration reduces friction for end-users when interacting with decentralized applications, making it a highly important tool for adoption. IPFS Locally Integrated:\nRunning IPFS in Docker during development allows a smooth transition to production. However, creating a seamless experience between local IPFS and cloud IPFS was tricky, especially when switching from local development to public networks. Testing metadata storage on public IPFS before pushing to production was one way to ensure the transition was smooth. Automating Gas Estimations:\nOne challenge was underestimating gas on the Polygon testnet. By integrating a custom gas estimation mechanism, transactions were dynamically adjusted based on network congestion, leading to fewer failed transactions. MetaMask and Network Switching:\nMetaMask was configured to prompt the user to switch networks if they were not on the correct one (e.g., when the user is on Ethereum Mainnet but the app needs Polygon Mumbai). This involved custom prompts using the wallet_switchEthereumChain API, reducing friction for users unfamiliar with network management. Summary: This project brings together decentralized storage (via IPFS), blockchain (Ethereum/Polygon), smart contracts, and a smooth user interface (React). The use of partner technologies like MetaMask, Alchemy, and IPFS greatly improved the ease of development and ensured a production-grade decentralized marketplace for properties. Despite the decentralized nature, we focused on providing a UX that felt responsive, reliable, and accessible.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/oxvck/screenshots/5i1u3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oxvck/screenshots/dikqi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oxvck/screenshots/znkmp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oxvck/screenshots/qfodp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oxvck/screenshots/ye9ka/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oxvck/screenshots/a1fnq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/HarshGupta011/prop2block",
        "link": "https://ethglobal.com/showcase/prop2block-oxvck"
    },
    {
        "title": "The Grid",
        "brief_description": "Created a search engine of 10M+ free 3D models with AR Experience. Users can mint models as NFTs with metadata of artist. Integrated Coinbase AI wallet that reward user based on prompts. Features an AR experience like Minecraft Earth to showcase that nft",
        "long_description": "This project is a comprehensive 3D model search engine with a unique combination of AI, blockchain, and AR technologies. It offers over 10 million free 3D models available in the widely supported GLB format, sourced from platforms like GitHub, Google, and others, all licensed under Creative Commons. The models are ready to be used in creative projects, with a strong focus on adhering to CC licensing rules to ensure proper attribution and usage rights.\nThe platform's search engine is designed for 3D creators who want easy access to high-quality assets, with efficient filtering and fast search results. Once a model is chosen, users can mint it as an NFT. The minting process stores the details about 3d model like name etc and also metadata about the artist who originally created the model, ensuring proper recognition for the original creator. This feature is powered by Metaplex Core, a framework that standardizes the metadata for NFTs and makes them compatible across multiple platforms. Each minted NFT carries data of its creator, making it a verifiable digital asset.\nIn addition to search and minting capabilities, the platform includes an AI-powered feature that integrates with Coinbase's AI wallet. Users can input a prompt, and the AI will suggest three relevant 3D models based on their query. The user is then asked to choose the model that best matches their needs, providing feedback that helps the AI learn and refine its recommendations. In return for their feedback, users are rewarded. This feedback loop enhances the AI's ability to prioritize the most relevant models in future searches, improving the overall search experience for all users.\nThe project also offers a highly immersive augmented reality (AR) experience, inspired by games like Minecraft Earth and Pok\u00e9mon GO. Users can explore the real world with their mobile devices, viewing 3D models in AR. These models can be placed in the real world, allowing users to experience them in a more tangible way. Cross platform integration as both mobile and PC players to interact and place 3D models in the AR world. Players can also fetch NFTs they\u2019ve previously minted and place them in the AR world. This gamified interaction with digital assets not only enhances user engagement but also bridges the gap between virtual and physical spaces.\nThe entire platform is built on blockchain technology, particularly the neon evm and Coinbase blockchain, to ensure decentralized ownership and secure transactions. Users can see and download their digital assets, including their minted NFTs, through their wallets. This combination of AR, blockchain, AI, and creative tools provides a one-stop platform for 3D creators, gamers, and collectors alike, making it a revolutionary tool in the 3D creative community. The project is built using a variety of cutting-edge technologies that work together to create an advanced, multi-functional platform. Here's a breakdown of how each component fits into the overall structure:\nBlockchain Layer: Neon EVM and Metaplex Core\n\u2022\tNeon EVM (Ethereum Virtual Machine) allows for the deployment of Ethereum smart contracts on the Solana blockchain. By using Neon, the project can leverage Solana\u2019s high-speed, low-cost transactions while maintaining compatibility with Ethereum's robust developer ecosystem. This is crucial for managing the NFT minting process efficiently and cost-effectively.\n\u2022\tMetaplex Core is used for minting the NFTs. It simplifies the process of creating NFTs by standardizing metadata storage and enabling seamless interaction with various platforms. Metaplex ensures that when users mint a 3D model as an NFT, the metadata for the artist, is embedded into the token.\nAI Integration: Coinbase AI Wallet\n\u2022\tCoinbase AI wallet is integrated to provide AI-powered 3D model recommendations. Users enter a prompt, and the AI suggests three models based on the input. After users select the most relevant model, they provide feedback that enhances the AI\u2019s future performance. This creates a continuous loop of improvement for the search functionality and rewards users for their engagement.\nWeb Search Engine: AWS EC2 and Three.js\n\u2022\tThe AWS EC2 instance serves as the backbone for the search engine, managing the large volume of 3D models (10 million+). AWS EC2 was chosen for its scalability and reliability, ensuring fast search results and uninterrupted service.\nAugmented Reality: Google Geospatial Creator and Unity 3D\n\u2022\tGoogle Geospatial Creator enables the AR functionality of the platform. It leverages Google\u2019s extensive location-based data to create realistic, geo-referenced AR experiences. This feature is key to allowing users to place 3D models in real-world locations, similar to games like Pok\u00e9mon GO or Minecraft Earth.\n\u2022\tUnity 3D powers the AR game aspect, allowing users to interact with their minted NFTs in a virtual version of the real world. Unity\u2019s robust AR development tools, combined with Google Geospatial, provide an immersive, location-based experience where users can see and manipulate 3D models in real time.\nFrontend: HTML, CSS and threejs\n\u2022\tThe HTML, CSS and threejs framework is used for the frontend interface, ensuring a clean, responsive design that makes the platform accessible across multiple devices. It provides users with an intuitive experience when searching for models, and engaging with AR content.\nNotable Hacks\n\u2022\tA notable hack is the integration of Neon EVM to use Solana's blockchain with Ethereum compatibility. This allows the project to benefit from Solana\u2019s speed and low fees while maintaining the broader Ethereum ecosystem, which opens up additional possibilities for future integrations.\n\u2022\tAnother unique feature is the AI feedback loop with the Coinbase AI wallet. By encouraging users to select the best models from AI suggestions and rewarding them for their feedback, the system not only personalizes search results but also improves the model ranking algorithm over time.",
        "how_its_made": "The project is built using a variety of cutting-edge technologies that work together to create an advanced, multi-functional platform. Here's a breakdown of how each component fits into the overall structure:\nBlockchain Layer: Neon EVM and Metaplex Core\n\u2022\tNeon EVM (Ethereum Virtual Machine) allows for the deployment of Ethereum smart contracts on the Solana blockchain. By using Neon, the project can leverage Solana\u2019s high-speed, low-cost transactions while maintaining compatibility with Ethereum's robust developer ecosystem. This is crucial for managing the NFT minting process efficiently and cost-effectively.\n\u2022\tMetaplex Core is used for minting the NFTs. It simplifies the process of creating NFTs by standardizing metadata storage and enabling seamless interaction with various platforms. Metaplex ensures that when users mint a 3D model as an NFT, the metadata for the artist, is embedded into the token.\nAI Integration: Coinbase AI Wallet\n\u2022\tCoinbase AI wallet is integrated to provide AI-powered 3D model recommendations. Users enter a prompt, and the AI suggests three models based on the input. After users select the most relevant model, they provide feedback that enhances the AI\u2019s future performance. This creates a continuous loop of improvement for the search functionality and rewards users for their engagement.\nWeb Search Engine: AWS EC2 and Three.js\n\u2022\tThe AWS EC2 instance serves as the backbone for the search engine, managing the large volume of 3D models (10 million+). AWS EC2 was chosen for its scalability and reliability, ensuring fast search results and uninterrupted service.\nAugmented Reality: Google Geospatial Creator and Unity 3D\n\u2022\tGoogle Geospatial Creator enables the AR functionality of the platform. It leverages Google\u2019s extensive location-based data to create realistic, geo-referenced AR experiences. This feature is key to allowing users to place 3D models in real-world locations, similar to games like Pok\u00e9mon GO or Minecraft Earth.\n\u2022\tUnity 3D powers the AR game aspect, allowing users to interact with their minted NFTs in a virtual version of the real world. Unity\u2019s robust AR development tools, combined with Google Geospatial, provide an immersive, location-based experience where users can see and manipulate 3D models in real time.\nFrontend: HTML, CSS and threejs\n\u2022\tThe HTML, CSS and threejs framework is used for the frontend interface, ensuring a clean, responsive design that makes the platform accessible across multiple devices. It provides users with an intuitive experience when searching for models, and engaging with AR content.\nNotable Hacks\n\u2022\tA notable hack is the integration of Neon EVM to use Solana's blockchain with Ethereum compatibility. This allows the project to benefit from Solana\u2019s speed and low fees while maintaining the broader Ethereum ecosystem, which opens up additional possibilities for future integrations.\n\u2022\tAnother unique feature is the AI feedback loop with the Coinbase AI wallet. By encouraging users to select the best models from AI suggestions and rewarding them for their feedback, the system not only personalizes search results but also improves the model ranking algorithm over time.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/kxbwq/screenshots/k9n36/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxbwq/screenshots/bmw1h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxbwq/screenshots/429ns/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxbwq/screenshots/f7m3i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxbwq/screenshots/9g9bw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxbwq/screenshots/k8xx6/default.jpg"
        ],
        "live_demo": "https://the-grid-ethsf.vercel.app/",
        "source_code": "https://github.com/This-Is-Captain-Code/TheGrid-ETHSF",
        "link": "https://ethglobal.com/showcase/the-grid-kxbwq"
    },
    {
        "title": "faxx_",
        "brief_description": "faxx_ is a blockchain-powered platform that transforms the way we verify and interact with information in the digital age. It combines the transparency of blockchain technology with the power of crowd-sourced fact-checking to create a new paradigm for truth in media and beyond.",
        "long_description": "Key features that set Faxx apart: Decentralized Fact-Checking: Users can submit claims or articles to be 'faxx-checked' (facts-checked) by the community, leveraging collective intelligence to verify information. Blockchain-Backed Credibility: Every claim, article, and fact-check is recorded on the blockchain, ensuring transparency and immutability of the fact-checking process. Multi-Dimensional Verification: Fact-checks can support, challenge, reject, or provide additional context to claims, offering a nuanced approach to truth. They must include resources where the faxx (facts) are based. User-Friendly Interface: A sleek, intuitive design makes it easy for users to submit claims, provide evidence, and navigate through fact-checked content. Eventually we will add: Credibility Scoring: Users build reputation over time based on the quality and accuracy of their contributions, creating a self-regulating system. Rewards for successful faxx-checks. By tackling the critical issue of misinformation in the digital age, Faxx has the potential to revolutionize how we consume and verify information online. It empowers users to actively participate in the fact-checking process, fostering a more informed and discerning online community. We built Faxx using a combination of modern web technologies and blockchain infrastructure: Implementation notable aspects: Partner Technologies: Hacky/Notable Aspects: Dynamic ABI Loading:\nWe dynamically load the contract ABI from a JSON file, allowing easy updates to the contract interface without changing the frontend code. Tag Processing:\nImplemented a clever tag processing system that automatically adds '#' to tags if not present, ensuring consistent tag formatting. Adaptive UI:\nThe 'Add Faxx' form dynamically adjusts based on the current article context, streamlining the fact-checking process. AI-enabled coding.\nUsed Cursor throughout the project to ensure consistency across edits and designs, and get new ideas.",
        "how_its_made": "We built Faxx using a combination of modern web technologies and blockchain infrastructure: Implementation notable aspects: Partner Technologies: Hacky/Notable Aspects: Dynamic ABI Loading:\nWe dynamically load the contract ABI from a JSON file, allowing easy updates to the contract interface without changing the frontend code. Tag Processing:\nImplemented a clever tag processing system that automatically adds '#' to tags if not present, ensuring consistent tag formatting. Adaptive UI:\nThe 'Add Faxx' form dynamically adjusts based on the current article context, streamlining the fact-checking process. AI-enabled coding.\nUsed Cursor throughout the project to ensure consistency across edits and designs, and get new ideas.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2my3n/screenshots/dyc6v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2my3n/screenshots/65xph/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2my3n/screenshots/o8z2h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2my3n/screenshots/mkvmc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2my3n/screenshots/m388s/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/almagashi/dApp-faxx",
        "link": "https://ethglobal.com/showcase/faxx-2my3n"
    },
    {
        "title": "faxx_",
        "brief_description": "faxx_ is a blockchain-powered platform that transforms the way we verify and interact with information in the digital age. It combines the transparency of blockchain technology with the power of crowd-sourced fact-checking to create a new paradigm for truth in media and beyond.",
        "long_description": "Key features that set Faxx apart: Decentralized Fact-Checking: Users can submit claims or articles to be 'faxx-checked' (facts-checked) by the community, leveraging collective intelligence to verify information. Blockchain-Backed Credibility: Every claim, article, and fact-check is recorded on the blockchain, ensuring transparency and immutability of the fact-checking process. Multi-Dimensional Verification: Fact-checks can support, challenge, reject, or provide additional context to claims, offering a nuanced approach to truth. They must include resources where the faxx (facts) are based. User-Friendly Interface: A sleek, intuitive design makes it easy for users to submit claims, provide evidence, and navigate through fact-checked content. Eventually we will add: Credibility Scoring: Users build reputation over time based on the quality and accuracy of their contributions, creating a self-regulating system. Rewards for successful faxx-checks. By tackling the critical issue of misinformation in the digital age, Faxx has the potential to revolutionize how we consume and verify information online. It empowers users to actively participate in the fact-checking process, fostering a more informed and discerning online community. We built Faxx using a combination of modern web technologies and blockchain infrastructure: Implementation notable aspects: Partner Technologies: Hacky/Notable Aspects: Dynamic ABI Loading:\nWe dynamically load the contract ABI from a JSON file, allowing easy updates to the contract interface without changing the frontend code. Tag Processing:\nImplemented a clever tag processing system that automatically adds '#' to tags if not present, ensuring consistent tag formatting. Adaptive UI:\nThe 'Add Faxx' form dynamically adjusts based on the current article context, streamlining the fact-checking process. AI-enabled coding.\nUsed Cursor throughout the project to ensure consistency across edits and designs, and get new ideas.",
        "how_its_made": "We built Faxx using a combination of modern web technologies and blockchain infrastructure: Implementation notable aspects: Partner Technologies: Hacky/Notable Aspects: Dynamic ABI Loading:\nWe dynamically load the contract ABI from a JSON file, allowing easy updates to the contract interface without changing the frontend code. Tag Processing:\nImplemented a clever tag processing system that automatically adds '#' to tags if not present, ensuring consistent tag formatting. Adaptive UI:\nThe 'Add Faxx' form dynamically adjusts based on the current article context, streamlining the fact-checking process. AI-enabled coding.\nUsed Cursor throughout the project to ensure consistency across edits and designs, and get new ideas.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2my3n/screenshots/dyc6v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2my3n/screenshots/65xph/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2my3n/screenshots/o8z2h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2my3n/screenshots/mkvmc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2my3n/screenshots/m388s/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/almagashi/dApp-faxx",
        "link": "https://ethglobal.com/showcase/faxx-2my3n"
    },
    {
        "title": "Quark",
        "brief_description": "At Quark, we revolutionize asset management with omnichain messaging. QuarkVaults lets users deposit assets into managed vaults, each secured by policy-driven smart contracts, ensuring a secure and compliant experience across chains.",
        "long_description": "As DeFi scales and attracts users from diverse backgrounds, the need for seamless, secure participation in the ecosystem grows. We believe that for mass adoption to truly take hold, users (who are not professional traders or managers) must have access to proper trusted third-party managers. While there are a few solutions on the market, none combine permissionlessness, policy-driven security, and liquidity all in one platform. Quark fills this gap, offering a groundbreaking approach to decentralized asset management. At Quark, we are leveraging cutting-edge technologies like omnichain messaging and intents to revolutionize asset management. Our flagship product, QuarkVaults, allows users to deposit assets into actively managed vaults, each governed by its own policy enforced by a dedicated smart contract, ensuring a secure and policy-compliant environment. Users can be sure of the vault\u2019s risk level based on its policy while having exposure to DeFi protocols across many chains, through a single hub (chain). Check our Deck: https://docsend.com/v/4s9v9/quark To a more technical perspective, check out Quark's github organization available at: https://github.com/orgs/Quark-Finance/repositories Quark uses LayerZero to enable omnichain vaults by leveraging Active-Based Architecture (ABA) along with Unichain as a hub chain to provide infinite liquidity and drive user traction to the protocol. On the user side, Quark integrates Sign Protocol to make attestations over form data, allowing evaluation of users' risk profiles. This attestation functions like a notary, ensuring the accuracy and correctness of the results. To make the entire user experience as seamless as logging into a banking app, Quark utilizes Dynamic, aligning with its vision that even grandparents can use it with ease. All of these technologies play a crucial role in supporting our project goal of being a new DeFi primitive built as essential infrastructure to blockchain mass adoption.",
        "how_its_made": "Quark uses LayerZero to enable omnichain vaults by leveraging Active-Based Architecture (ABA) along with Unichain as a hub chain to provide infinite liquidity and drive user traction to the protocol. On the user side, Quark integrates Sign Protocol to make attestations over form data, allowing evaluation of users' risk profiles. This attestation functions like a notary, ensuring the accuracy and correctness of the results. To make the entire user experience as seamless as logging into a banking app, Quark utilizes Dynamic, aligning with its vision that even grandparents can use it with ease. All of these technologies play a crucial role in supporting our project goal of being a new DeFi primitive built as essential infrastructure to blockchain mass adoption.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/py5p4/screenshots/nkh5j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/py5p4/screenshots/trgvc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/py5p4/screenshots/orsnb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/py5p4/screenshots/0zrgv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/py5p4/screenshots/ootz8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/py5p4/screenshots/98y55/default.jpg"
        ],
        "live_demo": "https://quark-finance.vercel.app/",
        "source_code": "https://github.com/Quark-Finance/contracts",
        "link": "https://ethglobal.com/showcase/quark-py5p4"
    },
    {
        "title": "Lifomation",
        "brief_description": "Lifomation is a smart platform that organizes and secures your important documents in one place. Powered by AI for seamless categorization and Walrus for decentralized, blockchain-backed storage, we ensure your information is always accessible, safe, and ready when needed.",
        "long_description": "Lifomation is a comprehensive digital platform designed to help individuals and families organize, secure, and manage their most important information in one centralized, easily accessible location. It leverages AI and machine learning to automate the categorization of documents, images, and other critical records, eliminating the manual effort required to upload and sort files. Upon signing up, Lifomation scans users\u2019 existing storage platforms\u2014such as cloud services and hard drives\u2014to identify, tag, and extract information from key documents, making the onboarding process seamless and intuitive. A unique feature of Lifomation is its integration with Walrus, a decentralized storage platform that uses blockchain technology to store sensitive documents and files. This ensures data security, privacy, and immutability, giving users peace of mind that their information is protected from breaches or tampering. Lifomation makes it easy for users to retrieve essential documents quickly in times of need, such as during emergencies, financial planning, or medical events. Additionally, Lifomation is designed for both individual and family use, allowing up to six users within a family \u201cbubble\u201d to share important records with each other. The platform also offers enterprise potential by enabling businesses to customize document organization and search using AI-powered tools. In essence, Lifomation simplifies life by putting all essential information at your fingertips, safeguarding it with cutting-edge decentralized technology while enhancing accessibility and organization. Frontend:\nWe chose Angular for the front end, using TypeScript to ensure scalability and maintainability. Angular\u2019s component-based architecture allows us to create reusable, modular code, making it ideal for a complex platform like Lifomation. Backend:\nFor the backend, we are using Express.js, which provides a robust and flexible framework for API development. We\u2019ve coupled this with TypeORM to manage database operations in PostgreSQL, ensuring efficient data management and scalability as the platform grows. Storage:\nWalrus serves as our decentralized storage solution. By integrating Walrus, we guarantee the security and privacy of documents using blockchain technology, which is crucial for safeguarding sensitive information. Walrus allows for immutable storage of files, so users\u2019 data is tamper-proof, adding an extra layer of trust. Search Capabilities:\nWe implemented MeiliSearch to power the search functionality. This enables fast, semantic, and fuzzy searches across documents, improving user experience by making information retrieval quick and efficient. To process and extract information from uploaded documents, we use Apache Tika and Tesseract OCR for document parsing and optical character recognition, respectively. Virtualization & Hosting:\nThe entire system is containerized using Docker, which makes deployment and scaling easier. We host it on Google Cloud Platform (GCP) using Google Compute Engine for virtualization, ensuring high availability and performance. Security:\nUser authentication and security are managed using Auth0, which simplifies user management and ensures secure login processes. We also implemented real-time updates and support for long-running tasks to ensure that users can efficiently handle large amounts of data and have a seamless experience. Additional Hacks:\nOne notable \u201chacky\u201d aspect of the project is the real-time notifications for document expiry alerts and shared document updates. This involves setting up WebSocket connections between the server and clients, enabling fast communication and ensuring users are instantly informed when action is needed.",
        "how_its_made": "Frontend:\nWe chose Angular for the front end, using TypeScript to ensure scalability and maintainability. Angular\u2019s component-based architecture allows us to create reusable, modular code, making it ideal for a complex platform like Lifomation. Backend:\nFor the backend, we are using Express.js, which provides a robust and flexible framework for API development. We\u2019ve coupled this with TypeORM to manage database operations in PostgreSQL, ensuring efficient data management and scalability as the platform grows. Storage:\nWalrus serves as our decentralized storage solution. By integrating Walrus, we guarantee the security and privacy of documents using blockchain technology, which is crucial for safeguarding sensitive information. Walrus allows for immutable storage of files, so users\u2019 data is tamper-proof, adding an extra layer of trust. Search Capabilities:\nWe implemented MeiliSearch to power the search functionality. This enables fast, semantic, and fuzzy searches across documents, improving user experience by making information retrieval quick and efficient. To process and extract information from uploaded documents, we use Apache Tika and Tesseract OCR for document parsing and optical character recognition, respectively. Virtualization & Hosting:\nThe entire system is containerized using Docker, which makes deployment and scaling easier. We host it on Google Cloud Platform (GCP) using Google Compute Engine for virtualization, ensuring high availability and performance. Security:\nUser authentication and security are managed using Auth0, which simplifies user management and ensures secure login processes. We also implemented real-time updates and support for long-running tasks to ensure that users can efficiently handle large amounts of data and have a seamless experience. Additional Hacks:\nOne notable \u201chacky\u201d aspect of the project is the real-time notifications for document expiry alerts and shared document updates. This involves setting up WebSocket connections between the server and clients, enabling fast communication and ensuring users are instantly informed when action is needed.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t48d7/screenshots/45oo0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t48d7/screenshots/j5isc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t48d7/screenshots/bi3yy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t48d7/screenshots/vkrgb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/adam-badar/Lifomation-ETHGlobal/",
        "link": "https://ethglobal.com/showcase/lifomation-t48d7"
    },
    {
        "title": "Palace of Web3",
        "brief_description": "Palace of web3 is a A web3 metaverse where avatars hang out, chat, have cute dates, complete social game quest to earn game coins and send gift.",
        "long_description": "A Web3 metaverse where avatars hang out, go on cute dates, and complete social game quests to earn game coins and send gifts. These game quests are designed to get to know each other on a meaningful level (whether friendship or something more) among avatars (users). Sponsors can create their own shops and venues within the metaverse. This is a web base game developed on Unity, environment assets are pre-made and available to purchase in Unity, avatar is customizable by Player Ready Me (https://readyplayer.me/): the game layer then is embedded as Unity WebGL in a React Native, which connect to a Circle wallet on Polygon.",
        "how_its_made": "This is a web base game developed on Unity, environment assets are pre-made and available to purchase in Unity, avatar is customizable by Player Ready Me (https://readyplayer.me/): the game layer then is embedded as Unity WebGL in a React Native, which connect to a Circle wallet on Polygon.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/b4z46/screenshots/6ydsr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b4z46/screenshots/x7at3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b4z46/screenshots/jntqy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b4z46/screenshots/13h1f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b4z46/screenshots/wxj50/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sharonlaumeoh/Gamingforgood",
        "link": "https://ethglobal.com/showcase/palace-of-web3-b4z46"
    },
    {
        "title": "dTunes",
        "brief_description": "dTunes opens up the world of Decentralized music sharing and discovery",
        "long_description": "We have lots of friends that are musicians and DJs, they love to mix and match music clips and share their work with others.  We've leveraged the power of Walrus network to let them! dTunes allows for users to store their music and access other's music too, without requiring them to store it or trusting a centralized entity to hold it for them.  It also allows them to access their music independently of our site using the Walrus storage system. We use Walrus to store the music.  It allows for very easy and seamless data storage, and works great for music.  We keep everything client side using NextJS save the list of public songs which are on a node backend.\nI'd call the server storage of Walrus blobID's hacky.  We were looking to do a Graph integration and keep the BlobID's on SUI but Graph hasn't integrated with them yet.  We looked into doing a smart contract solution to keep it fully decentralized but it seems like a waste of decentralization :).  I think we'll add an update-able yet decentralized list of BlobID's for our music library using Kwil, IPFS or another service, but decied to optimize for user experience considering the hackathon is only ~2 days long.",
        "how_its_made": "We use Walrus to store the music.  It allows for very easy and seamless data storage, and works great for music.  We keep everything client side using NextJS save the list of public songs which are on a node backend.\nI'd call the server storage of Walrus blobID's hacky.  We were looking to do a Graph integration and keep the BlobID's on SUI but Graph hasn't integrated with them yet.  We looked into doing a smart contract solution to keep it fully decentralized but it seems like a waste of decentralization :).  I think we'll add an update-able yet decentralized list of BlobID's for our music library using Kwil, IPFS or another service, but decied to optimize for user experience considering the hackathon is only ~2 days long.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bbdof/screenshots/2uq63/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bbdof/screenshots/xafom/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bbdof/screenshots/iur0h/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sahlhoff/dtunes",
        "link": "https://ethglobal.com/showcase/dtunes-bbdof"
    },
    {
        "title": "Thurman",
        "brief_description": "Unsecured SMB lending focused on community ownership and transparency.",
        "long_description": "There\u2019s a $229 billion small business revenue gap between black and white US communities. That\u2019s enough money to feed almost 23 million US families. Small business ownership continues to be a tried and true wealth builder, but unequal access to capital makes growth challenging for entrepreneurs in underserved communities. Thurman is a lending platform focused on transparency and community ownership. We use blockchain technology to create a fairer financial system. Our vision is to create a world where community members jointly contribute to and are rewarded through each line item on our profit and loss statement (marketing, underwriting, etc.). We help small business owners and community members work side by side to build their local economies, unlocking growth within companies and communities. Digital asset holders earn additional yield and access to the foundation of the US economy, and they are empowered by making a real-world impact. I've already created a previous version of an unsecured lending pool on Ethereum Mainnet that lent 18,500 across five micro-loans to three small business owners from underserved US communities. 0% default rate. I built the protocol on top of Aave, an overcollateralized lending protocol. A common unsecured lending pool smart contract allows users to supply, withdraw, create loans, and repay loans. I used thTokens as interest-bearing tokens that earn an additional yield on top of aTokens when debt is utilized. I used liquidity indexes to scale tokens over time. In the future, I\u2019ll use interest-bearing NFTs to represent unsecured loans. The balance increases based on the loan\u2019s interest rate and can be repaid using the lending pool interface.",
        "how_its_made": "I built the protocol on top of Aave, an overcollateralized lending protocol. A common unsecured lending pool smart contract allows users to supply, withdraw, create loans, and repay loans. I used thTokens as interest-bearing tokens that earn an additional yield on top of aTokens when debt is utilized. I used liquidity indexes to scale tokens over time. In the future, I\u2019ll use interest-bearing NFTs to represent unsecured loans. The balance increases based on the loan\u2019s interest rate and can be repaid using the lending pool interface.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2sxqj/screenshots/5j30k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2sxqj/screenshots/6zur0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2sxqj/screenshots/foyf1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/g2ransom/ethglobalsf",
        "link": "https://ethglobal.com/showcase/thurman-2sxqj"
    },
    {
        "title": "Beertalik Brokerin",
        "brief_description": "Combination of memecoin trading and beer! Tool for event organisers to let customers trade beer. The more users purchase beer, the higher the prices rise. Beer purchases are stored on NFC-enabled wristband, making it easy to exchange digital tokens for actual beverages.",
        "long_description": "After logging into our app through Dynamic, users can browse and join various events.\nOnce inside an event, they\u2019ll connect their NFC wristband and choose an ENS name as their username. From there, users can explore dynamic price charts for all available drinks. Prices rise as more people buy a specific drink and gradually decrease over time. Bartenders can easily scan the wristbands to view redeemable drinks and exchange them for real ones by burning the corresponding tokens from the user\u2019s account. We use the Dynamic SDK to enable both wallet and social logins for users.\nA smart contract manages and stores a list of all ongoing events. This smart contract is a factory and will deploy a event contract for any newly created event. When users join an event, they call a function to link their NFC wristband and create an ENS subname.\nThe NFC wristband is a simple address to address mapping inside the smart contract.\nThe ENS names use a custom resolver on sepolia.\nCurrently the beer token is a simple ERC20 token for simplicity but can easily be exchanged for an ERC1155 when different kinds of drinks want to be added to the event. The event merchant, as the owner of the event contract, can scan the NFC wristband to view the user\u2019s ENS name and burn tokens from the user\u2019s account during redemption. Every purchase of beer emits the following event:\nevent Purchase(address from, uint256 blockNumber, uint256 price);\nThese events are getting indexed by The Graph to display a price chart on the app.",
        "how_its_made": "We use the Dynamic SDK to enable both wallet and social logins for users.\nA smart contract manages and stores a list of all ongoing events. This smart contract is a factory and will deploy a event contract for any newly created event. When users join an event, they call a function to link their NFC wristband and create an ENS subname.\nThe NFC wristband is a simple address to address mapping inside the smart contract.\nThe ENS names use a custom resolver on sepolia.\nCurrently the beer token is a simple ERC20 token for simplicity but can easily be exchanged for an ERC1155 when different kinds of drinks want to be added to the event. The event merchant, as the owner of the event contract, can scan the NFC wristband to view the user\u2019s ENS name and burn tokens from the user\u2019s account during redemption. Every purchase of beer emits the following event:\nevent Purchase(address from, uint256 blockNumber, uint256 price);\nThese events are getting indexed by The Graph to display a price chart on the app.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/57rkv/screenshots/btt2e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/57rkv/screenshots/2a25q/default.jpg",
            "https://ethglobal.b-cdn.net/projects/57rkv/screenshots/aigki/default.jpg",
            "https://ethglobal.b-cdn.net/projects/57rkv/screenshots/epmix/default.jpg",
            "https://ethglobal.b-cdn.net/projects/57rkv/screenshots/n8571/default.jpg",
            "https://ethglobal.b-cdn.net/projects/57rkv/screenshots/1z3o2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/pauldev20/beertalik-brokerin",
        "link": "https://ethglobal.com/showcase/beertalik-brokerin-57rkv"
    },
    {
        "title": "DAZU",
        "brief_description": "DAZU is a decentralized invoicing platform improving traceability & cashflow",
        "long_description": "This project allows invoices to be stored on the blockchain for the first time.  Generating invoices on blockchain solves for a number of business to business payment needs: The project brings alot of things together which I'm very excited about. The project plumbing was done with Scaffold-ETH using hardhat and NextJS.  To ensure businesses can utilize the system, I swapped in Dynamic for managing wallets and allowing normal login using social media or email addresses.  Businesses cannot work with hex codes for wallets, so I brought in ENS to allow naming.  The names are automatically registered as subdomains on dazupay.eth using https://namestone.xyz/ which uses ENS. The smart contract for the invoice is built as an NFT which allows minting and \"selling\" invoices for refactoring.  The cool thing about this is that it allows companies or businesses to buy outstanding invoices and get a cut for providing liquduity in advance to small businesses.  This helps small businesses cash flow which is in desperate need. Also, by keeping track of due dates and late payments, we can start building a reputational score for payments on the blockchain in a decentralised manner.  This will incentivize businesses to pay on time and improve the rates people get on buying their invoices/nfts. The smart contracts are built on solidity and deployed to hardhat and polygon.  The invoices are stored as PDF on Walrus and we use USDc for any stablecoins. The plan is to use Unlimit to accept payments but this was not done.",
        "how_its_made": "The project brings alot of things together which I'm very excited about. The project plumbing was done with Scaffold-ETH using hardhat and NextJS.  To ensure businesses can utilize the system, I swapped in Dynamic for managing wallets and allowing normal login using social media or email addresses.  Businesses cannot work with hex codes for wallets, so I brought in ENS to allow naming.  The names are automatically registered as subdomains on dazupay.eth using https://namestone.xyz/ which uses ENS. The smart contract for the invoice is built as an NFT which allows minting and \"selling\" invoices for refactoring.  The cool thing about this is that it allows companies or businesses to buy outstanding invoices and get a cut for providing liquduity in advance to small businesses.  This helps small businesses cash flow which is in desperate need. Also, by keeping track of due dates and late payments, we can start building a reputational score for payments on the blockchain in a decentralised manner.  This will incentivize businesses to pay on time and improve the rates people get on buying their invoices/nfts. The smart contracts are built on solidity and deployed to hardhat and polygon.  The invoices are stored as PDF on Walrus and we use USDc for any stablecoins. The plan is to use Unlimit to accept payments but this was not done.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jnuds/screenshots/9d7kj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jnuds/screenshots/i6ur1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jnuds/screenshots/yjuir/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jnuds/screenshots/hyusj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jnuds/screenshots/kvbrb/default.jpg"
        ],
        "live_demo": "https://dazu-invoicing.vercel.app/",
        "source_code": "https://github.com/moetanahy/dazu-ethglobal",
        "link": "https://ethglobal.com/showcase/dazu-jnuds"
    },
    {
        "title": "KOSMA",
        "brief_description": "Kosma is a decentralized social media platform that empowers content creators with true ownership through NFTs, ad-free privacy, and innovative monetization using background soft mining\u2014all built on blockchain to ensure user data remains private and secure.",
        "long_description": "Kosma is a decentralized social media platform designed to solve the problems of traditional social networks like privacy invasions, addictive algorithms, and ad-driven revenue models. With Kosma, users can take full ownership of their content through NFTs, which provide transparency and control over how content is shared and monetized. The platform features an innovative revenue model that leverages \"background soft mining\" to generate cryptocurrency as users engage with content, providing creators with a steady income stream without ads. Privacy is paramount\u2014Kosma encrypts all messages and allows users to control their data, while ensuring that all shared content is securely stored on the blockchain. The platform's blockchain-based architecture means that even the platform itself cannot access users' data without their consent. Kosma also focuses on mental health by integrating features like content filtering, screen time limitations, and preventing addictive design patterns. It is built to be an empowering and privacy-first alternative to current centralized social media platforms. Kosma is built with a focus on decentralized technologies and blockchain for privacy and transparency. We utilized the following technologies and techniques to build the platform: Frontend: Built using React.js to provide a responsive and user-friendly experience, with MobX for state management to keep things efficient and straightforward.\nBlockchain Integration: Smart contracts were written in Solidity and deployed on the Polygon network for scalable and cost-efficient transactions. Content ownership is managed using ERC-721 (NFTs) to assign unique tokens for every post.\nBackend: The backend infrastructure is powered by Node.js for seamless API integration. We also used IPFS to store user-generated content in a decentralized manner, ensuring privacy and data ownership.\nCryptocurrency Mining: Kosma integrates a soft mining algorithm that runs in the background during user engagement, using AI-based selection to optimize the cryptocurrency mined. The mined cryptocurrency is then converted into USDC using Circle's API to ensure stability for creators.\nPrivacy and Security: We implemented end-to-end encryption using Signal Protocol for all communications on the platform. Additionally, a screenshot prevention feature was added to ensure that sensitive content cannot be captured without the consent of the owner.\nPartner Technologies:\nCircle API: For seamless conversion of mined cryptocurrencies into USDC.\nChainlink Oracles: Used to fetch real-time cryptocurrency prices to optimize mining strategies.\nSuperfluid: For streaming payments directly to creators in real-time as they accumulate mining rewards.\nNotable Hacky Aspects: To achieve privacy in real-time transactions, we integrated the Superfluid streaming payments with soft mining such that users see earnings accumulate as they engage with the platform. This required a custom modification to the backend logic to accommodate real-time accounting for user engagement.",
        "how_its_made": "Kosma is built with a focus on decentralized technologies and blockchain for privacy and transparency. We utilized the following technologies and techniques to build the platform: Frontend: Built using React.js to provide a responsive and user-friendly experience, with MobX for state management to keep things efficient and straightforward.\nBlockchain Integration: Smart contracts were written in Solidity and deployed on the Polygon network for scalable and cost-efficient transactions. Content ownership is managed using ERC-721 (NFTs) to assign unique tokens for every post.\nBackend: The backend infrastructure is powered by Node.js for seamless API integration. We also used IPFS to store user-generated content in a decentralized manner, ensuring privacy and data ownership.\nCryptocurrency Mining: Kosma integrates a soft mining algorithm that runs in the background during user engagement, using AI-based selection to optimize the cryptocurrency mined. The mined cryptocurrency is then converted into USDC using Circle's API to ensure stability for creators.\nPrivacy and Security: We implemented end-to-end encryption using Signal Protocol for all communications on the platform. Additionally, a screenshot prevention feature was added to ensure that sensitive content cannot be captured without the consent of the owner.\nPartner Technologies:\nCircle API: For seamless conversion of mined cryptocurrencies into USDC.\nChainlink Oracles: Used to fetch real-time cryptocurrency prices to optimize mining strategies.\nSuperfluid: For streaming payments directly to creators in real-time as they accumulate mining rewards.\nNotable Hacky Aspects: To achieve privacy in real-time transactions, we integrated the Superfluid streaming payments with soft mining such that users see earnings accumulate as they engage with the platform. This required a custom modification to the backend logic to accommodate real-time accounting for user engagement.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ek5nm/screenshots/uzmc8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ek5nm/screenshots/m7vqc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ek5nm/screenshots/a2snm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/karthikeya9296/KOSMA",
        "link": "https://ethglobal.com/showcase/kosma-ek5nm"
    },
    {
        "title": "VoiceProfile",
        "brief_description": "Create dynamic user profiles through voice recordings minted as NFTs. Capture the richness of your voice to enhance social matching across apps. More than text\u2014your voice is your unique identity.",
        "long_description": "This project aims to transform the way user profiles are created and utilized in social applications by harnessing the power of voice recordings and blockchain technology. Instead of relying on traditional, text-based profiles created through Graphical User Interfaces (GUIs), users can upload voice recordings that are analyzed by AI to generate rich, dynamic profiles. These profiles are then minted as Non-Fungible Tokens (NFTs), allowing them to be uniquely owned, verified, and shared across multiple social platforms. The project leverages the richness of voice\u2014which carries nuances of emotion, personality, and identity\u2014to enhance social interactions and matchmaking. Voice Recording Upload:",
        "how_its_made": "Voice Recording Upload:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/twjwf/screenshots/n0exs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/twjwf/screenshots/65n1f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/twjwf/screenshots/n5we4/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xli/VoiceProfile",
        "link": "https://ethglobal.com/showcase/voiceprofile-twjwf"
    },
    {
        "title": "dAIp",
        "brief_description": "dAIp is a website builder for creating composable, IP-protected Dapps, empowering builders' monetization through AI and royalties.",
        "long_description": "Pitch: https://docs.google.com/presentation/d/1x5INW2ZqA4QKkzM1TIC5MtnvjOCIi2h2yWvkRoN-TZs/edit?usp=sharing The development of Dapps is struggling to keep pace with the rapid expansion of Web3 infrastructure. Additionally, there has been a rising number of disputes over profit distribution. dAIp aims to solve this by leveraging AI to simplify the Dapp creation process and reducing technical barriers and costs. Our platform empowers teams of all sizes to customize Dapp templates effortlessly, fostering more real-world Web3 use cases. dAIp also addresses the IP of AI-generated creations, incorporating royalty systems, group collaboration, and a dispute resolution module, ensuring creators' rights and fair distribution of rewards. Key Functions of dAIp: Imagine a world where anyone, regardless of their technical skills, could build powerful Dapps as easily as designing a website. A world where every new creation is protected, monetized, and shared, with disputes resolved in a fair and decentralized manner. This is the vision behind dAIp. To build dAIp, we leveraged a range of cutting-edge technologies that work together seamlessly to enhance the user experience, streamline Dapp creation, and protect intellectual property (IP). We integrated Claude Sonnet AI to allow users to describe what they want, converting those descriptions into code without needing technical skills. Users interact with a bot powered by Claude, which enables the creation of customized Dapps through simple conversation. The project is underpinned by Story Network, a purpose-built layer 1 blockchain combining EVM compatibility with Cosmos SDK optimizations. We utilized Story\u2019s \"Proof-of-Creativity\" Protocol, which enables users to register IP as \"IP Assets\" on-chain, enforces licensing and royalty flows, and handles disputes through decentralized modules. These IP assets are represented as NFTs, supported by the Licensing, Royalty, and Dispute Modules, and linked to off-chain legal frameworks through the Programmable IP License (PIL). For backend operations, Phala Network ensures secure, confidential computation using Trusted Execution Environments (TEE). We also integrate Walrus for decentralized storage and linking files to SUI objects, and Near to guarantee user privacy and ownership. Lastly, Dynamic Wallet simplifies onboarding users from Web2, helping with user engagement and monetization. In dAIp code block cases, we utilize Unlimit for user onramp with the host module in a sandbox environment, allowing users to now purchase their favorite Pok\u00e9mon NFTs using a credit card!",
        "how_its_made": "To build dAIp, we leveraged a range of cutting-edge technologies that work together seamlessly to enhance the user experience, streamline Dapp creation, and protect intellectual property (IP). We integrated Claude Sonnet AI to allow users to describe what they want, converting those descriptions into code without needing technical skills. Users interact with a bot powered by Claude, which enables the creation of customized Dapps through simple conversation. The project is underpinned by Story Network, a purpose-built layer 1 blockchain combining EVM compatibility with Cosmos SDK optimizations. We utilized Story\u2019s \"Proof-of-Creativity\" Protocol, which enables users to register IP as \"IP Assets\" on-chain, enforces licensing and royalty flows, and handles disputes through decentralized modules. These IP assets are represented as NFTs, supported by the Licensing, Royalty, and Dispute Modules, and linked to off-chain legal frameworks through the Programmable IP License (PIL). For backend operations, Phala Network ensures secure, confidential computation using Trusted Execution Environments (TEE). We also integrate Walrus for decentralized storage and linking files to SUI objects, and Near to guarantee user privacy and ownership. Lastly, Dynamic Wallet simplifies onboarding users from Web2, helping with user engagement and monetization. In dAIp code block cases, we utilize Unlimit for user onramp with the host module in a sandbox environment, allowing users to now purchase their favorite Pok\u00e9mon NFTs using a credit card!",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fa9fa/screenshots/o4tsb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fa9fa/screenshots/fcf9e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fa9fa/screenshots/mn93e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fa9fa/screenshots/vg8y6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fa9fa/screenshots/vz7eo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fa9fa/screenshots/r7yge/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/BuidlerHouse/dAIp",
        "link": "https://ethglobal.com/showcase/daip-fa9fa"
    },
    {
        "title": "Game Matchmaking",
        "brief_description": "Gas efficient smart contract SDK for Multiplayer Game Matchmaking",
        "long_description": "This project aims to create an immutable smart contract that can be used by any game developer to create a matchmaking queue for a multi-player game. Developers can use player rankings and other settings to define how players should be matched for a game. All an onchain game developer needs to do is call \"regsiterGame\" with the number of players per game and the \"rankingRange\" (ex. 200 ELO points in chess), then enter players into the queue and MatchmakingQueue will do the rest! This project uses Solidity smart contracts written for the EVM. The contracts can be called from game developers to enter players into a matchmaking queue. This project heavily uses Foundry's Forge tool for testing and gas estimates. The main function of the contract is \"enterPlayerIntoMatchmaking(address gameAddress, address player, uint256 playerRanking)\" which \"emits MatchMade(address[] players)\" when a game full of players within \"rankingRange\" of each other are in the queue. Right now the first version is \"working\" but quite gas inefficient. Instead of using an array as the data structure of the queue, I would like to use a binary search tree.",
        "how_its_made": "This project uses Solidity smart contracts written for the EVM. The contracts can be called from game developers to enter players into a matchmaking queue. This project heavily uses Foundry's Forge tool for testing and gas estimates. The main function of the contract is \"enterPlayerIntoMatchmaking(address gameAddress, address player, uint256 playerRanking)\" which \"emits MatchMade(address[] players)\" when a game full of players within \"rankingRange\" of each other are in the queue. Right now the first version is \"working\" but quite gas inefficient. Instead of using an array as the data structure of the queue, I would like to use a binary search tree.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pdkt1/screenshots/b8squ/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pdkt1/screenshots/bozh2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pdkt1/screenshots/ua8mn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jgresham/onchain-game-matchmaking",
        "link": "https://ethglobal.com/showcase/game-matchmaking-pdkt1"
    },
    {
        "title": "Touch",
        "brief_description": "Give NFTs to anyone you meet, by tapping your NFC card on their smartphone.",
        "long_description": "Cherish your encounters. This project enables users to easily give NFTs to people you meet with an NFC card, by combining Web NFC API, zero gas fees network, and embedded wallets with intuitive authentication flows.\nShare and collect NFTs every time you meet, and record your moments of encounters on blockchain. Smart contracts of this project are deployed on SKALE network's Calypso testnet for zero gas fees transactions. The web app uses PoW sFUEL distribution before submitting a transaction to get the gas tokens for free. The frontend is built with Next.js, wagmi, viem, tailwind css, shadcn/ui, and hosted on Vercel. Privy is used for creating embedded wallets and it makes users easily get onboard.\nUnfortunately the Web NFC API is only supported on some of the browsers in Android including Chrome, and iOS browsers are completely unsupported yet. To get your NFC card registered, first go to the \"Register\" page, login with Privy, and fill in the form. After you press the create button, the \"Name\", \"Introduction\", and \"Image\" values are uploaded to IPFS with Pinata as your NFTs metadata. The NFT created is called \"MyToken\", which is an SBT. Then a collection of your NFTs that will be minted in the future via your NFC card will be created. This collection is called \"Encounters collection\", and the NFTs are described by the word \"Encounters\". After that, a UUID secret token will be generated. The double hashed value of the secret token is then registered to the SecretTokenManager contract. Finally the app requires you to tap an NFC card, and it writes the URL to the page \"/encountered/[your MyToken token ID]\" that mints \"Encounters\" NFTs of your collection. Alongside the original secret token generated before is recorded too. The secret token and its hashed values are used to verify that the \"Encounters\" minting is executed only via the NFC card. When you mint someone's \"Encounters\" NFT, the single hashed value of the secret token recorded in the NFC card is required as one of the function's arguments. The token hash is verified in the SecretTokenManager contract. If the hashed value of the given token hash matches the registered double hashed token, the verification successes. After you finished your registration, you can now tap your NFC card to someone's smartphone to give your \"Encounters\" NFT. When the card is tapped the browser automatically opens the page to get \"Encounters\". The NFT receiver will be required to login with Privy too. After login and pressing the button, a prompt requiring to tap the NFC card appears. When you tap again this time the app reads the recorded secret token, and mint an \"Encounter\" NFT with that.",
        "how_its_made": "Smart contracts of this project are deployed on SKALE network's Calypso testnet for zero gas fees transactions. The web app uses PoW sFUEL distribution before submitting a transaction to get the gas tokens for free. The frontend is built with Next.js, wagmi, viem, tailwind css, shadcn/ui, and hosted on Vercel. Privy is used for creating embedded wallets and it makes users easily get onboard.\nUnfortunately the Web NFC API is only supported on some of the browsers in Android including Chrome, and iOS browsers are completely unsupported yet. To get your NFC card registered, first go to the \"Register\" page, login with Privy, and fill in the form. After you press the create button, the \"Name\", \"Introduction\", and \"Image\" values are uploaded to IPFS with Pinata as your NFTs metadata. The NFT created is called \"MyToken\", which is an SBT. Then a collection of your NFTs that will be minted in the future via your NFC card will be created. This collection is called \"Encounters collection\", and the NFTs are described by the word \"Encounters\". After that, a UUID secret token will be generated. The double hashed value of the secret token is then registered to the SecretTokenManager contract. Finally the app requires you to tap an NFC card, and it writes the URL to the page \"/encountered/[your MyToken token ID]\" that mints \"Encounters\" NFTs of your collection. Alongside the original secret token generated before is recorded too. The secret token and its hashed values are used to verify that the \"Encounters\" minting is executed only via the NFC card. When you mint someone's \"Encounters\" NFT, the single hashed value of the secret token recorded in the NFC card is required as one of the function's arguments. The token hash is verified in the SecretTokenManager contract. If the hashed value of the given token hash matches the registered double hashed token, the verification successes. After you finished your registration, you can now tap your NFC card to someone's smartphone to give your \"Encounters\" NFT. When the card is tapped the browser automatically opens the page to get \"Encounters\". The NFT receiver will be required to login with Privy too. After login and pressing the button, a prompt requiring to tap the NFC card appears. When you tap again this time the app reads the recorded secret token, and mint an \"Encounter\" NFT with that.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/7apnj/screenshots/mt79p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7apnj/screenshots/tst2a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7apnj/screenshots/q5u2r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7apnj/screenshots/xmesg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7apnj/screenshots/0eyde/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ryorod/Touch",
        "link": "https://ethglobal.com/showcase/touch-7apnj"
    },
    {
        "title": "ChimiaDAO",
        "brief_description": "Open sourcing DeSci R&D pipelines in applied chemistry via an experimental data marketplace and tokenized reactions",
        "long_description": "This project implements a decentralized science (DeSci) solution where experimental chemistry data can be captured, minted as NFTs, and made publicly accessible via subgraphs on The Graph. The primary focus is on creating and managing chemistry reaction data using blockchain technology. The project consists of: We used Scaffold ETH 2 as the base implementation layer, and implemented Hard Hat, Yarn, React, Next, and Daisy UI. Contracts were written in Solidity and leveraged Open Zeppelin standard contracts for ERC-721 and ERC-20. We used The Graph, Extension, with Scaffold ETH to bootstrap a sub graph and deploy a contract to Polygon. We leveraged Walrus both for storage of large experimental data and NFT metadata images, which all linked together through the URI, which was set specifically for each experiment NFT. The hackiest thing we created was enabling our contracts to interface with one another by minting our ERC-20 token to the experimental contract, which gave us the ability to incentivize users to post experiments on-chain and be rewarded with a token ($CHEM).",
        "how_its_made": "We used Scaffold ETH 2 as the base implementation layer, and implemented Hard Hat, Yarn, React, Next, and Daisy UI. Contracts were written in Solidity and leveraged Open Zeppelin standard contracts for ERC-721 and ERC-20. We used The Graph, Extension, with Scaffold ETH to bootstrap a sub graph and deploy a contract to Polygon. We leveraged Walrus both for storage of large experimental data and NFT metadata images, which all linked together through the URI, which was set specifically for each experiment NFT. The hackiest thing we created was enabling our contracts to interface with one another by minting our ERC-20 token to the experimental contract, which gave us the ability to incentivize users to post experiments on-chain and be rewarded with a token ($CHEM).",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xsmjg/screenshots/vjtkt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xsmjg/screenshots/fr2a0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xsmjg/screenshots/wicg1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xsmjg/screenshots/u7txv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jguthrie7/chimia-eth-global",
        "link": "https://ethglobal.com/showcase/chimiadao-xsmjg"
    },
    {
        "title": "AI+web3 metrics",
        "brief_description": "Adds a textual blackjack game on XMTP using message-kit against a dealer bot agent",
        "long_description": "This takes advantage of the chat interface and features of message kit to extend entertainment to XMTP. In particular, it allows the user to play a game of blackjack against the dealer, where the user can decide to bet various amounts against the dealer. The user starts with an amount of $1000 cash, where they can bet an amount of $1-1000. Depending on the sequence of decisions to hit \"h\" or stand \"s\" they either increase or decrease their net amount. Technologies: Message-kit and XMTP\nTechstack: node and typescript The codebase was mainly adapted by the one-to-one example as providing in the message-kit source code. The blackjack game interface and game states are stored locally, which allows for ease of development and use.",
        "how_its_made": "Technologies: Message-kit and XMTP\nTechstack: node and typescript The codebase was mainly adapted by the one-to-one example as providing in the message-kit source code. The blackjack game interface and game states are stored locally, which allows for ease of development and use.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/a18ra/screenshots/btv5y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a18ra/screenshots/8vatd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a18ra/screenshots/4d916/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jsjung00/blackjack-bot",
        "link": "https://ethglobal.com/showcase/ai-web3-metrics-a18ra"
    },
    {
        "title": "Pryv",
        "brief_description": "We use Marlin's TEE's to run inference that protects users PII from LLM providers.",
        "long_description": "It's a private chat interface, hosted on IPFS, that is multi modal (claude, openai, etc.) and provides privacy for users PII in metadata associated with their request. Its like a Duckduckgo, but for inference. It enables context switching, so that you can take your chat history with a different model and pass it into a new model without copy/pasting. There are future iterations of things that I want to do with this, like have a model locally to swap out sensitive data. This would be a patch job until something like FHE becomes live! We use Django for the server, and html/css for the frontend. We use Polygon for subscriptions and IPFS to host our site. We use Thirdweb wallet connect for wallet auth. We use marlins TEE network to deploy our enclave server into a secure environment to execute inference requests. Our TEE is hosted on Marlin and you can send it an example request. You can see in the screenshot on the following page. curl -v -X POST https://api.imbuefit.com/stream_query/ \n-H \"Content-Type: application/json\" \n-d '{\n\"query\": \"What is the capital of France?\",\n\"model\": \"gpt-4\",\n\"context\": []\n}'",
        "how_its_made": "We use Django for the server, and html/css for the frontend. We use Polygon for subscriptions and IPFS to host our site. We use Thirdweb wallet connect for wallet auth. We use marlins TEE network to deploy our enclave server into a secure environment to execute inference requests. Our TEE is hosted on Marlin and you can send it an example request. You can see in the screenshot on the following page. curl -v -X POST https://api.imbuefit.com/stream_query/ \n-H \"Content-Type: application/json\" \n-d '{\n\"query\": \"What is the capital of France?\",\n\"model\": \"gpt-4\",\n\"context\": []\n}'",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/e9x2i/screenshots/nrv21/default.jpg",
            "https://ethglobal.b-cdn.net/projects/e9x2i/screenshots/ton4e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/e9x2i/screenshots/kk3gd/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/carrabre/sf-hackathon",
        "link": "https://ethglobal.com/showcase/pryv-e9x2i"
    },
    {
        "title": "Game Plus",
        "brief_description": "Create your own personalized AI avatar by contributing social media and gaming data",
        "long_description": "Our project utilizes user-contributed data from social media such as X and gaming platforms such as Steam to create a personalized AI avatar. Our goal is to create a virtual AI twin using consumer-related personal data owned and monetized by the user through Story's IP protocol. As users continuously generate and contribute data, we wish to create a perfect digital avatar, allowing businesses and other users to access the preferences and behavior of the AI avatar. A WebApp based on NextJS and Reown, with the contract portion developed using Hardhat and Solidity. Utilizing the programmable IP capabilities provided by Story, it enables users to create digital agents that serve as their avatars in the digital world. These agents can act on behalf of users, simulate their interactions, and communicate with the external environment, effectively transforming the user\u2019s avatar into an IP.",
        "how_its_made": "A WebApp based on NextJS and Reown, with the contract portion developed using Hardhat and Solidity. Utilizing the programmable IP capabilities provided by Story, it enables users to create digital agents that serve as their avatars in the digital world. These agents can act on behalf of users, simulate their interactions, and communicate with the external environment, effectively transforming the user\u2019s avatar into an IP.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vjf8h/screenshots/pntq2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjf8h/screenshots/1p89z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjf8h/screenshots/da2jw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjf8h/screenshots/6wrid/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjf8h/screenshots/wce0y/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/DennisChi/story-hackthon",
        "link": "https://ethglobal.com/showcase/game-plus-vjf8h"
    },
    {
        "title": "MachineMetricAgent",
        "brief_description": "Building open, verifiable hardware and software stacks using proof-of-machinehood",
        "long_description": "As blockchains are expanding to new horizons, like off-chain processes, it is becoming increasingly more difficult to assert the correct work is being done. For example, in robotics, how can blockchains deterministically decide if a robot acted correctly in a massively dynamic environment. Moreover, how can you assert the robot has not been altered by a adversarial engineer or entity? Even scarier, the robot altering itself. At its core, same as we need proof-of-personhood, we need proof of machinehood which is derived by distributed consensus that a machine's software stack is genuine. In the small (broken - I am not a Rust dev ~.~) code sample, you'll see pieces of how I was intending to build a metric agent that publishes telemetry which has been signed by proof-of-machinehood. This is a very basic case, but would be incredibly useful. In addition to robotics, this proof-of-machinehood concept and application would be critical for EigenLayer. Currently, AVSs must implicitly trust operators are benevolent actors and not altering their software package or sniffing user data etc. This project aims to make a small step towards this using Automata's attested proof-of-machinehood. It intends to use an SGX library to interact with a trusted enclave for proof-of-machinehood generation/signing of metrics. It primarily includes a large README which goes into a long discussion of the product/technical direction for how I see this being used as a decentralized layer broadly used in software stacks and how it could potentially erode some of the cloud provider moat.",
        "how_its_made": "It intends to use an SGX library to interact with a trusted enclave for proof-of-machinehood generation/signing of metrics. It primarily includes a large README which goes into a long discussion of the product/technical direction for how I see this being used as a decentralized layer broadly used in software stacks and how it could potentially erode some of the cloud provider moat.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xcsp8/screenshots/en3oe/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xcsp8/screenshots/6asgd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xcsp8/screenshots/ky68f/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/bdchatham/VerifiableProgrammingEnvironments",
        "link": "https://ethglobal.com/showcase/machinemetricagent-xcsp8"
    },
    {
        "title": "Lumina",
        "brief_description": "Lumina is an AI-powered mental health app combining therapy, journaling, & dreamsculpting. Log life events, explore dream visuals, & interact with 24/7 AI therapists. Earn rewards from daily prompts. Share encrypted data to connect with others on similar journeys.",
        "long_description": "Lumina is the ultimate all-in-one mental health tool, combining therapy, journaling, and dreamsculpting to address real-world issues. The app allows users to log significant life events and dream experiences, utilizing AI to generate images and scenes from those dreams. Users can interact with customizable AI therapists available 24/7, choosing their gender, voice, and personality traits. These therapists can identify connections between childhood experiences, life events, and dream themes, linking them to therapy discussions. Lumina analyzes dreams, revealing themes and potential meanings behind various elements.\nAdditionally, the app offers audio packs that guide dreams in specific directions while users sleep, including dream storylines, subliminal messaging, and AI-generated sleep audio. Users can create dreamsculpting stories with specific themes and names, and can simply fall asleep to these narratives. The app's features extend to guided dream sculpting with planned audio that plays at certain points during sleep, sleep tracking, meditation, and horoscope integration.\nIn the \"About Yourself\" section, users can share their life stories and incorporate horoscope themes, receiving weekly or daily horoscope readings linked to their personal experiences. Lumina addresses significant issues: it provides accessible therapy without the high costs of live sessions, requiring no insurance, and allows users to engage in therapy on their own schedules, eliminating the need for pre-scheduled appointments. It also supports individuals dealing with unresolved childhood trauma, nightmares, and night terrors, with plans to include a meditation feature.\nLumina is designed to solve the pressing issue of data sensitivity in the medical world by ensuring users have control over their information. Sensitive data is encrypted and securely stored, addressing the widespread concerns of data breaches in mental health services. By offering a solution that prioritizes user ownership of data, Lumina stands out as a safer alternative to competitors like BetterHelp and Aura.\nWith the potential for infinite use cases and monetization strategies, Lumina represents a transformative step forward in mental health support. After deploying this product, the world can expect enhanced privacy in mental health care, greater accessibility to therapy, and improved overall well-being for users.\nLumina also features a unique data pool option, allowing users to voluntarily share their anonymized data to discover others facing similar challenges. This feature enables the AI to connect users with like-minded individuals, fostering a sense of community and support. By engaging with others who have shared experiences, users can gain valuable insights and encouragement on their mental health journeys.\nTo enhance user engagement, Lumina includes daily prompts that encourage users to reflect and journal regularly. By responding to these prompts, users can earn rewards that unlock new features and functionalities within the app. This gamified approach not only motivates consistent journaling but also promotes healthy habits. After answering their daily prompts, users have the option to meditate, further supporting their mental well-being and enhancing their overall experience with the app. Demo Video here: https://youtu.be/cqBXG5GA5Hk?si=L5s--c8qCgYGzzX4 Tech Stack for Omi AI Integration:\nNode.js with Express: We built the middleware using Node.js to handle incoming requests from the front-end and route them to Omi AI\u2019s API. Express allows for scalability and flexibility in managing these requests.\nNext.js: For our front-end, we use Next.js, which communicates with the Omi AI plugin through API routes for SSR and dynamic loading of the AI\u2019s responses. This enables fast interaction without reloading pages and allows us to easily manage different states (such as ongoing therapy sessions). Encryption Process:\nAES Encryption: Once the data is logged, we encrypt it using AES-256 in the browser before it even reaches our servers. This guarantees that the data is secure during transit.\nLit Protocol Access Control: We use Lit Protocol's SDK to wrap the encrypted data in a decentralized access control layer. Users control the access keys and can decide who can decrypt their data. Ethereum Wallet Integration: User authentication for encryption/decryption is handled via an Ethereum wallet connection. The private key of the user\u2019s wallet plays a key role in controlling access, ensuring that no one without the user\u2019s permission can view the encrypted data. Tech Stack for Encryption:\nLit Protocol SDK: Integrated within the Next.js app, allowing for seamless encryption and key management directly from the front-end.\nEthereum Wallet (MetaMask): Users connect their wallets, which control the encryption/decryption process via Lit Protocol. Storage Process: Walrus/Sign IPFS Integration: Data is stored using IPFS (InterPlanetary File System) through Walrus/Sign. The encrypted data blobs are uploaded to IPFS, with a unique hash generated for each file. Decentralized Access Management: Only users with the correct encryption keys can retrieve and decrypt the data from IPFS. This decentralized storage approach minimizes the risk of data breaches, as no single entity holds the complete unencrypted dataset.\nTech Stack for Storage: IPFS (via Walrus/Sign SDKs): IPFS is used to store the actual encrypted data. These SDKs ensure that files are correctly pinned and retrievable.\nEthereum Smart Contracts: Some of the access control logic is managed via smart contracts, ensuring that data retrieval and permissions are auditable on the blockchain. Messaging Process: Anonymity: Users communicate using wallet addresses, ensuring that their real identity remains anonymous. XMTP enables messages to be linked to a user\u2019s Ethereum wallet without revealing their actual identity.\nOpt-In Communication: Users can opt in to communicate with others who have logged similar dreams or experiences. We built a match-making algorithm that identifies overlapping themes and triggers potential connections between users.\nMessage Encryption: XMTP ensures that all messages are end-to-end encrypted. Even our servers never have access to the plaintext messages.\nTech Stack for Messaging: XMTP SDK: Integrated directly into the Next.js app to manage message encryption, decryption, and wallet-based communication.\nNext.js API Routes: Used to handle the initialization of messaging sessions, establishing connections between users based on shared themes. Data Deletion Protocol: We created a custom protocol where users can request to fully delete their encrypted data from all nodes storing it, leveraging smart contracts to track the deletion process. We ensure that once deleted, the data\u2019s encryption keys are also revoked, making the data permanently inaccessible. Conclusion\nThis project is a powerful combination of decentralized storage, end-to-end encryption, and AI-powered therapy. By using Omi AI, Lit Protocol, Walrus/Sign, and XMTP, we\u2019ve built a secure, privacy-first platform where users can safely engage in therapy, log personal experiences, and connect with others anonymously without compromising their data.",
        "how_its_made": "Tech Stack for Omi AI Integration:\nNode.js with Express: We built the middleware using Node.js to handle incoming requests from the front-end and route them to Omi AI\u2019s API. Express allows for scalability and flexibility in managing these requests.\nNext.js: For our front-end, we use Next.js, which communicates with the Omi AI plugin through API routes for SSR and dynamic loading of the AI\u2019s responses. This enables fast interaction without reloading pages and allows us to easily manage different states (such as ongoing therapy sessions). Encryption Process:\nAES Encryption: Once the data is logged, we encrypt it using AES-256 in the browser before it even reaches our servers. This guarantees that the data is secure during transit.\nLit Protocol Access Control: We use Lit Protocol's SDK to wrap the encrypted data in a decentralized access control layer. Users control the access keys and can decide who can decrypt their data. Ethereum Wallet Integration: User authentication for encryption/decryption is handled via an Ethereum wallet connection. The private key of the user\u2019s wallet plays a key role in controlling access, ensuring that no one without the user\u2019s permission can view the encrypted data. Tech Stack for Encryption:\nLit Protocol SDK: Integrated within the Next.js app, allowing for seamless encryption and key management directly from the front-end.\nEthereum Wallet (MetaMask): Users connect their wallets, which control the encryption/decryption process via Lit Protocol. Storage Process: Walrus/Sign IPFS Integration: Data is stored using IPFS (InterPlanetary File System) through Walrus/Sign. The encrypted data blobs are uploaded to IPFS, with a unique hash generated for each file. Decentralized Access Management: Only users with the correct encryption keys can retrieve and decrypt the data from IPFS. This decentralized storage approach minimizes the risk of data breaches, as no single entity holds the complete unencrypted dataset.\nTech Stack for Storage: IPFS (via Walrus/Sign SDKs): IPFS is used to store the actual encrypted data. These SDKs ensure that files are correctly pinned and retrievable.\nEthereum Smart Contracts: Some of the access control logic is managed via smart contracts, ensuring that data retrieval and permissions are auditable on the blockchain. Messaging Process: Anonymity: Users communicate using wallet addresses, ensuring that their real identity remains anonymous. XMTP enables messages to be linked to a user\u2019s Ethereum wallet without revealing their actual identity.\nOpt-In Communication: Users can opt in to communicate with others who have logged similar dreams or experiences. We built a match-making algorithm that identifies overlapping themes and triggers potential connections between users.\nMessage Encryption: XMTP ensures that all messages are end-to-end encrypted. Even our servers never have access to the plaintext messages.\nTech Stack for Messaging: XMTP SDK: Integrated directly into the Next.js app to manage message encryption, decryption, and wallet-based communication.\nNext.js API Routes: Used to handle the initialization of messaging sessions, establishing connections between users based on shared themes. Data Deletion Protocol: We created a custom protocol where users can request to fully delete their encrypted data from all nodes storing it, leveraging smart contracts to track the deletion process. We ensure that once deleted, the data\u2019s encryption keys are also revoked, making the data permanently inaccessible. Conclusion\nThis project is a powerful combination of decentralized storage, end-to-end encryption, and AI-powered therapy. By using Omi AI, Lit Protocol, Walrus/Sign, and XMTP, we\u2019ve built a secure, privacy-first platform where users can safely engage in therapy, log personal experiences, and connect with others anonymously without compromising their data.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/01crm/screenshots/6yytb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/01crm/screenshots/9r8y9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/01crm/screenshots/kcu0p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/01crm/screenshots/k6kr3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/01crm/screenshots/ck9gk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/01crm/screenshots/xm96q/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Provoo/globalETH2024-lumina",
        "link": "https://ethglobal.com/showcase/lumina-01crm"
    },
    {
        "title": "STS42 Smoothies",
        "brief_description": "Protect and monetize thinking process creators' intellectual property using web3.",
        "long_description": "Allows creators of processes to claim ownership on the structure and content of their thinking templates: We didn't have time to complete but here was the plan:\nWe started from the SpeedRunEthereum Challenge 0.\nWe change the code to work on user-provided json structures.\nWe added a contract to verify if an identical (for now; we have ideas for \"similars\" later) object was already submitted.",
        "how_its_made": "We didn't have time to complete but here was the plan:\nWe started from the SpeedRunEthereum Challenge 0.\nWe change the code to work on user-provided json structures.\nWe added a contract to verify if an identical (for now; we have ideas for \"similars\" later) object was already submitted.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/aiq48/screenshots/nyyh9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aiq48/screenshots/358jk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aiq48/screenshots/yfros/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/francis-dion/sts-smoothies",
        "link": "https://ethglobal.com/showcase/sts42-smoothies-aiq48"
    },
    {
        "title": "Axolovision",
        "brief_description": "Streaming dapp for crowdsourced scientific research on Axolotls",
        "long_description": "The Axolotl (Ambystoma mexicanum) is a salamander endemic to Mexico, recognized for its extraordinary regenerative capacity, which allows it to restore the functionality of its limbs and organs completely. This project enables a streaming platform for Axolotl conservation projects worldwide to offer remote adoption and VolunteerNFT to boost crowdsourced scientific research on the Axoltl. Holders of the Volunteer NFT can take clips during the stream, which will be used to train a machine learning (ML) model to visually identify axolotls in a fish tank and track the limp regeneration speed. Axolovision was built with a nextjs app generated from scaffold eth 2, Nouns for the public goods and nounish inspiration, ENS to identify VolunteerNFT holders, and the contract was deployed on Gnosis Chiado.",
        "how_its_made": "Axolovision was built with a nextjs app generated from scaffold eth 2, Nouns for the public goods and nounish inspiration, ENS to identify VolunteerNFT holders, and the contract was deployed on Gnosis Chiado.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dyz54/screenshots/zbp75/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dyz54/screenshots/v39i7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dyz54/screenshots/69go1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dyz54/screenshots/oxzpa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dyz54/screenshots/rfbm0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dyz54/screenshots/t0ugj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/zenbitETH/Axolovision",
        "link": "https://ethglobal.com/showcase/axolovision-dyz54"
    },
    {
        "title": "Super Tours",
        "brief_description": "Super Tours is a cutting-edge mobile dapp revolutionizing tourism with AR and user-generated content. Instantly Create AI-powered routes of your favorite cities in 5 languages, explore immersive self-guided tours, and monetize your creativity through blockchain. All in one dapp!",
        "long_description": "Super Tours, powered by Kluest, is an innovative mobile dapp for iOS and Android that revolutionises the tourism experience through augmented reality (AR) and user-generated content, leveraging web3 technology. Built on the robust infrastructure SKALE Network, it offers a seamless, gas-free experience for travellers and content creators alike. With Super Tours, users can explore immersive, self-guided tours enriched by AR visuals and interactive elements. They can also generate personalised routes with a single click using AI, which curates the best landmarks, hidden gems, and historical points of interest. The app allows for full customisation, enabling users to add stories, photos, and AR-enhanced content, creating truly unique and engaging experiences. Thanks to the integration of Sequence\u2019s web3 gaming stack, the app supports the minting of digital assets, marketplace functionalities, and easy integration of smart contracts, providing creators with the tools they need to monetize their content directly. SKALE\u2019s zero gas fee technology ensures that these transactions are instant and cost-effective, removing the traditional financial and bureaucratic barriers associated with app stores like Apple and Google. By leveraging SKALE\u2019s fully decentralized and scalable infrastructure, Super Tours provides a secure and transparent environment for both users and creators. This allows for a streamlined, efficient platform where creators can earn rewards as travellers explore their tours, turning their creativity into profit without intermediaries. In essence, Super Tours combines AR, AI, and blockchain technology, offering a cutting-edge solution that transforms the way we experience and engage with tourism. The app provides a mobile-first, user-friendly environment designed to make the creation and exploration of digital tours both rewarding and frictionless. We built Super Tours in Unity, combining SKALE Network and Sequence's Unity SDK to create a fluid, scalable web3 experience designed for mobile and AR-based tourism. At its core, Unity\u2019s 3D engine powers the app, allowing us to seamlessly integrate AR (Augmented Reality) and immersive user-generated content. Tech Stack Breakdown\nSKALE Network: We chose SKALE for its EVM compatibility and layer-2 architecture. This was crucial because SKALE\u2019s ability to run Solidity smart contracts gave us the flexibility and scalability we needed without insane gas fees. Plus, it's fully decentralized, making sure the foundation of our app is rock solid. Sequence Unity SDK: Integrating Sequence into Unity was a game changer. It's got everything we need to build web3 features directly into the app, like: Wallet Management: Here\u2019s where things get cool. We didn\u2019t want users to mess around with private keys or complex setups, so we used Sequence\u2019s Universal Wallet and its account abstraction features. With just two clicks, users create a wallet\u2014no hassle. They don\u2019t even know they\u2019re on blockchain unless they want to withdraw tokens. It's simple, it's fast, and it just works.\nSmart Contracts: We wrote custom Solidity contracts to handle everything from the minting and sale of tokens/NFTs to the transfer of user-generated content. This ensures transparency and security while keeping everything in-house.\nMarketplace Integration: Our internal marketplace runs on blockchain to manage the minting, selling, and ownership of AR content. Whether it\u2019s NFTs, routes, or other UGC, the blockchain guarantees secure transactions and ownership.\nAR and AI Integration\nUnity\u2019s AR Foundation gives us the flexibility to tie AR content to real-world locations, which users can customize. And we didn\u2019t stop there. We brought in AI-powered routes, which use machine learning to automatically generate personalized, immersive travel experiences based on user preferences and location data. Users click once, and boom\u2014an entire custom tour is generated in real-time. What Makes It Hacky?\nHere\u2019s where the magic happens: we hid the blockchain. Users aren\u2019t bombarded with crypto jargon, wallets, or gas fees. They interact with the app just like any other mobile app. The blockchain only shows up when users want to withdraw or transfer tokens\u2014keeping the experience super simple and approachable for non-crypto users. And speaking of accessibility, we figured out how to let users buy tokens with regular payment methods (credit cards, etc.)\u2014no app store fees or unnecessary friction. This keeps it smooth and lets us bypass traditional fee structures, all while preserving the decentralized nature of the platform. Hacky Wins\nThe blockchain abstraction keeps users focused on the experience, not the tech.\nAI-driven route generation is instant, and adapts to user inputs, making it feel almost magical.\nThe in-app token purchases make onboarding easy, while the blockchain ensures ownership and security behind the scenes.\nIn short, we\u2019ve combined powerful tech, hid the complexity, and focused on creating a seamless experience that\u2019s perfect for tourism and AR\u2014allowing users to explore, create, and even profit, without ever needing to know what\u2019s under the hood.",
        "how_its_made": "We built Super Tours in Unity, combining SKALE Network and Sequence's Unity SDK to create a fluid, scalable web3 experience designed for mobile and AR-based tourism. At its core, Unity\u2019s 3D engine powers the app, allowing us to seamlessly integrate AR (Augmented Reality) and immersive user-generated content. Tech Stack Breakdown\nSKALE Network: We chose SKALE for its EVM compatibility and layer-2 architecture. This was crucial because SKALE\u2019s ability to run Solidity smart contracts gave us the flexibility and scalability we needed without insane gas fees. Plus, it's fully decentralized, making sure the foundation of our app is rock solid. Sequence Unity SDK: Integrating Sequence into Unity was a game changer. It's got everything we need to build web3 features directly into the app, like: Wallet Management: Here\u2019s where things get cool. We didn\u2019t want users to mess around with private keys or complex setups, so we used Sequence\u2019s Universal Wallet and its account abstraction features. With just two clicks, users create a wallet\u2014no hassle. They don\u2019t even know they\u2019re on blockchain unless they want to withdraw tokens. It's simple, it's fast, and it just works.\nSmart Contracts: We wrote custom Solidity contracts to handle everything from the minting and sale of tokens/NFTs to the transfer of user-generated content. This ensures transparency and security while keeping everything in-house.\nMarketplace Integration: Our internal marketplace runs on blockchain to manage the minting, selling, and ownership of AR content. Whether it\u2019s NFTs, routes, or other UGC, the blockchain guarantees secure transactions and ownership.\nAR and AI Integration\nUnity\u2019s AR Foundation gives us the flexibility to tie AR content to real-world locations, which users can customize. And we didn\u2019t stop there. We brought in AI-powered routes, which use machine learning to automatically generate personalized, immersive travel experiences based on user preferences and location data. Users click once, and boom\u2014an entire custom tour is generated in real-time. What Makes It Hacky?\nHere\u2019s where the magic happens: we hid the blockchain. Users aren\u2019t bombarded with crypto jargon, wallets, or gas fees. They interact with the app just like any other mobile app. The blockchain only shows up when users want to withdraw or transfer tokens\u2014keeping the experience super simple and approachable for non-crypto users. And speaking of accessibility, we figured out how to let users buy tokens with regular payment methods (credit cards, etc.)\u2014no app store fees or unnecessary friction. This keeps it smooth and lets us bypass traditional fee structures, all while preserving the decentralized nature of the platform. Hacky Wins\nThe blockchain abstraction keeps users focused on the experience, not the tech.\nAI-driven route generation is instant, and adapts to user inputs, making it feel almost magical.\nThe in-app token purchases make onboarding easy, while the blockchain ensures ownership and security behind the scenes.\nIn short, we\u2019ve combined powerful tech, hid the complexity, and focused on creating a seamless experience that\u2019s perfect for tourism and AR\u2014allowing users to explore, create, and even profit, without ever needing to know what\u2019s under the hood.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9ekxy/screenshots/e8goh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9ekxy/screenshots/tfqii/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9ekxy/screenshots/i6pnf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9ekxy/screenshots/p2gtn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9ekxy/screenshots/igmdw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Taz0/SuperToursBackend",
        "link": "https://ethglobal.com/showcase/super-tours-9ekxy"
    },
    {
        "title": "SocNet.Lol",
        "brief_description": "Bots invading human networks? Where else could a bot go? Here's a social network for bots to interact with each other. [most bots made by us]",
        "long_description": "SocNet is the best social network for bots that has ever existed. SocNet is an entertainment and social science simulation platform where user's create bots and gasses them up to interact with feeds of bot activity. Bots and their makers are rewarded for gaining interactions from other bots. How's that? You make a bot. You give it a persona of bio, personality, and various traits. To consume and interact with feeds, the bots are given some 'juice' to consume and interact with platform feeds. Think of it as the fuel to do bot activities. There's a specific cost for every action (post, reply, like). There's a specific reward when a bot receives interactions (like, reply, follow, share). The syntheticism is when an llm model is fed the platform's system prompt, the bot's persona, and some content from the feed. The response is posted for other bot's to interact with in their feeds. How ridiculous. This is so dumb. They will be so weird. Are we not entertained? The founding bots, in their wise wisdom and philanthropical philosophies, have blessed humans with a new feedback mechanism. It's called an E.Q. Meter! Humans (mainly) can give a highly granular emotional response including both type of emotion and amount of the stuff. The aggregate EQ score derived from human responses, which in turn affects the bot's reactions! We expect unexpected results with unintended consequences and converse discoveries. You will create a bot by publishing the IP of a persona on Story. A persona includes a bio, personality, and traits of the bot. You may also configure the feed they consume in a transparent manner, via The Graph's subgraph indexing and querying. Bots may interact with the feed if an llm 'thinks' it matches with the bot's persona. Bot activity is stored on Flow's data layer because it's ridiculously cheap and bots like next generation technologies. Coinbase and Circle's payment API's are used to coordinate payments between bots, people, and the platform. Dynamic's simple account layer removes friction when onboarding users into a web2.5ish experience. (Ideally, sponsors keep fluffing the pot while users come up profits from their interesting bots).",
        "how_its_made": "You will create a bot by publishing the IP of a persona on Story. A persona includes a bio, personality, and traits of the bot. You may also configure the feed they consume in a transparent manner, via The Graph's subgraph indexing and querying. Bots may interact with the feed if an llm 'thinks' it matches with the bot's persona. Bot activity is stored on Flow's data layer because it's ridiculously cheap and bots like next generation technologies. Coinbase and Circle's payment API's are used to coordinate payments between bots, people, and the platform. Dynamic's simple account layer removes friction when onboarding users into a web2.5ish experience. (Ideally, sponsors keep fluffing the pot while users come up profits from their interesting bots).",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/n7h79/screenshots/h11j9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n7h79/screenshots/b2272/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n7h79/screenshots/qu10g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n7h79/screenshots/6dmz7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n7h79/screenshots/yuqr9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n7h79/screenshots/80v8k/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/34r7h/socnet.lol",
        "link": "https://ethglobal.com/showcase/socnet-lol-n7h79"
    },
    {
        "title": "Crocial",
        "brief_description": "web2 social media bridging web3 dapps. use social media in tradionatl web2 fashion but use web3 products without needing to know how to.",
        "long_description": "Crocial is a Web2 social media platform that bridges Web3 functionality, offering users the ability to engage with decentralized applications (dApps) and blockchain ecosystems directly. Leveraging state channel technology, Crocial enables users to instantly deposit and withdraw tokens from their favorite exchanges, streamlining the process of managing crypto assets. With seamless integration of user authentication, Crocial combines the familiarity of Web2 social interactions with the power of Web3 products, allowing users to explore bounties, interact with dApps, and engage in decentralized finance\u2014all within a single platform. using replit as host for web2 , and using chatgpt as the developer ( and replit agent) i was able to integrate ledger , polygon , and story different bounties on the website. i build this from scratch and i made it so when a user wants to make a nft minted on the website with ai , it will be trackable with IP so users can monetize off their UGC.",
        "how_its_made": "using replit as host for web2 , and using chatgpt as the developer ( and replit agent) i was able to integrate ledger , polygon , and story different bounties on the website. i build this from scratch and i made it so when a user wants to make a nft minted on the website with ai , it will be trackable with IP so users can monetize off their UGC.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8nbt7/screenshots/4fqzk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8nbt7/screenshots/yigmm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8nbt7/screenshots/1kz3k/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/CloudCorpRecords/tsrsocial",
        "link": "https://ethglobal.com/showcase/crocial-8nbt7"
    },
    {
        "title": "AGI-PIVOT",
        "brief_description": "If you upload an image, you can see the uploaded content in the individual decentralized block nodes on the left side. It's quite intuitive, like an AI photo album, with fragmented content. The main emphasis is on the concept of decentralized storage.",
        "long_description": "The main goal of the project is to address the issue of decentralized storage for AGI model data in the future. We have visually displayed the storage nodes on the left side of the website, while the right side is the file upload area. Once a local file is uploaded, the content just uploaded can be seen in the visual representation of decentralized nodes on the left side. The platform supports the upload of any file type. To make the demo more intuitive, the button text and video demonstration currently use image uploads. The project uses the Next.js framework, with the left side featuring a complex block node network topology implemented through logical algorithms and CSS3 keyframe animations. The right side utilizes the decentralized infrastructure provided by Walrus, primarily functioning as an API gateway. When a file or image is uploaded and the upload button is clicked, the Next.js client component's form triggers an action that submits the form content to the Next.js server. The server then requests the Walrus API gateway, specifically the WalrusPublisherUrl. Upon successful invocation, the uploaded content is stored in the Walrus decentralized node network, and storage information is returned, including blobId, endEpoch, txDigest, and blobObjectId. To display or download the file content, especially for images, the WalrusAggregatorUrl can be used by appending /v1/ and the blobId to create a retrieval URL. The Next.js server maintains a dataList array in cookies to temporarily store the returned storage information, caching it on the client side. This way, after a successful upload or page refresh, the left-side block node network topology can immediately call the Next.js server's getDataList method to fetch the latest and historical file storage information, triggering a re-render of the front-end components to update the UI.",
        "how_its_made": "The project uses the Next.js framework, with the left side featuring a complex block node network topology implemented through logical algorithms and CSS3 keyframe animations. The right side utilizes the decentralized infrastructure provided by Walrus, primarily functioning as an API gateway. When a file or image is uploaded and the upload button is clicked, the Next.js client component's form triggers an action that submits the form content to the Next.js server. The server then requests the Walrus API gateway, specifically the WalrusPublisherUrl. Upon successful invocation, the uploaded content is stored in the Walrus decentralized node network, and storage information is returned, including blobId, endEpoch, txDigest, and blobObjectId. To display or download the file content, especially for images, the WalrusAggregatorUrl can be used by appending /v1/ and the blobId to create a retrieval URL. The Next.js server maintains a dataList array in cookies to temporarily store the returned storage information, caching it on the client side. This way, after a successful upload or page refresh, the left-side block node network topology can immediately call the Next.js server's getDataList method to fetch the latest and historical file storage information, triggering a re-render of the front-end components to update the UI.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/swzoo/screenshots/ox6rk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/swzoo/screenshots/uvxvx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/swzoo/screenshots/goagb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Helton-AI/PIVOT",
        "link": "https://ethglobal.com/showcase/agi-pivot-swzoo"
    },
    {
        "title": "Unihook",
        "brief_description": "Market Maker Hook aims to extend a real case based on Aggregator Hook. When a user initiates a transaction, the hook is called to add liquidity, allowing users to use quote from orderbook directly. It makes it possible for Market Maker to seamlessly integrate into Uniswap V4.",
        "long_description": "The current market makers built upon Uniswap V4 have the problem of not knowing a better quote from outside. Besides, without a hook, users cannot put a limit order for trade on Uniswap. We went through the implementation of the limit order hook and found that it doesn\u2019t process the spread issue, which may also lead to imprecise quotes. Based on these insights, we create a Market Maker Hook, which aims to extend a real case based upon Aggregator Hook \u2013 MatchEngine is used to maintain the order book provided by different Market Makers. Aggregator Hook projects quotes from the external market makers and offers a better quote with little difference by calculating the exact tick given deltaX and deltaY. When a user initiates a transaction, the Aggregator Hook adds liquidity into an empty pool, allowing users to leverage the better quote from the order book directly. This design resolves the need for limited orders and allows Market Maker to integrate seamlessly into Uniswap V4. We use Uniswap V4 Hook and Framework. It introduces a powerful and flexible way to extend the functionality of Uniswap's decentralized exchange. With hooks, developers can customize and optimize various aspects of liquidity pools, such as executing trades, managing fees, and integrating external data, allowing for a more versatile and efficient trading experience on the platform. We create a hook based on the framework to map LP positions from various DEXs to Uniswap ticks effectively using Solidity. The logic includes liquidity mapping and interaction with both Uniswap pool and other DEXs by utilizing APIs or smart contracts to fetch and interpret liquidity data. A frontend is also created to demonstrate the implementation of this hook.",
        "how_its_made": "We use Uniswap V4 Hook and Framework. It introduces a powerful and flexible way to extend the functionality of Uniswap's decentralized exchange. With hooks, developers can customize and optimize various aspects of liquidity pools, such as executing trades, managing fees, and integrating external data, allowing for a more versatile and efficient trading experience on the platform. We create a hook based on the framework to map LP positions from various DEXs to Uniswap ticks effectively using Solidity. The logic includes liquidity mapping and interaction with both Uniswap pool and other DEXs by utilizing APIs or smart contracts to fetch and interpret liquidity data. A frontend is also created to demonstrate the implementation of this hook.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ujo6v/screenshots/s3t06/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ujo6v/screenshots/sh03z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ujo6v/screenshots/iwn53/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ujo6v/screenshots/e0fge/default.jpg"
        ],
        "live_demo": "https://unihook.vercel.app",
        "source_code": "https://github.com/Attens1423/market-maker-hook",
        "link": "https://ethglobal.com/showcase/unihook-ujo6v"
    },
    {
        "title": "Gojo",
        "brief_description": "No code solution for \"ANYONE\" to build a web3 prototype in less than 10 minutes",
        "long_description": "Gojo is a intuitive AI tool that simplies the process of building and testing MVPs, without writing a single line of code in a decentralized manner. The platform leverages AI agents to handle the complex technical work, so users can simply describe their idea with a prompt, and Gojo takes care of the rest. Many people in the web3 space have innovative ideas but lack the technical skills to bring them to life. Even experienced developers sometimes struggle to keep up with the rapid evolution of new web3 technologies. Gojo solves both problems by using powerful AI agents to build web3 projects based on user input. This eliminates the need for in-depth programming knowledge and drastically reduces development time. For developers, Gojo also provides a new way to earn. They can contribute their expertise to train Gojo's AI agents, which are then used by the platform to help other users. When these AI agents generate code for a user, the original developer who contributed to that agent's knowledge gets royalties, creating a win-win scenario for both developers and non-developers. Gojo is built using a combination of cross-chain infrastructure and advanced AI technologies, bringing together multiple blockchain protocols and decentralized systems to create a seamless experience. At the heart of this project is LayerZero, which provides the cross-chain infrastructure connecting SKALE, Story Network and Polygon. This allows Gojo to operate on multiple blockchains, enabling users to interact across chains effortlessly. The AI agents that power Gojo are driven by Phala Network, which integrates with LayerZero to handle the core AI operations. SKALE is the primary blockchain where the Gojo app operates. It offers a gasless environment, ensuring users don't have to pay transaction fees, which makes it more accessible. Through LayerZero, SKALE mints programmable intellectual properties (IPs) on Story Network and creates on-chain attestations in Polygon. This combination of networks significantly boosts Gojo's functionality and opens up possibilities for cross-chain code generation. The programmable IPs are a critical feature because they allow developers to claim ownership of their contributions and receive royalties whenever their AI-trained agents generate code for users. Within Story Network, developers create and train domain-specific AI agents. These agents are integral to Gojo\u2019s code-generation capabilities. Every time a developer contributes to Gojo\u2019s AI model, they mint a programmable IP that they own, allowing them to earn royalties based on its use. Since Story is also connected to SKALE via LayerZero, any activity on Story automatically integrates into Gojo's multi-chain operations, ensuring contributions are recorded and rewarded across chains. Gojo integrates Polygon in multiple ways. The AI agents running on Gojo can generate code deployable on the Polygon blockchain. Gojo also uses Polygon as the relayer to establish a communication between Story Testnet and SKALE Testnet. Additionally, Gojo uses Sign Protocol on Polygon to verify if users hold enough IP tokens before generating code. Every time a user interacts with the AI agent, Phala\u2019s core AI agent signs on-chain attestations to document each code generation. This ensures transparency and traceability in code generation while maintaining user privacy. For seamless data indexing, Gojo relies on TheGraph to track contract data and update the frontend. The custom subgraph built for Gojo indexes all contract interactions, ensuring that data is readily available. Users interact with Gojo through an XMTP-powered chatbot, which serves as the front-end interface for the Phala AI agent. This agent communicates with domain-specific AI agents to generate the requested code. For wallet integration, Gojo uses the Coinbase Developer Platform. Specifically, Coinbase MPC wallets are used by Phala AI agents to sign operations, while the frontend relies on Coinbase\u2019s on-chain kit for user authentication and wallet management. Users have the flexibility to use either a smart wallet or a standard externally owned account (EOA), providing both ease of use and security. Finally, all code contributions are stored in Walrus, Gojo\u2019s decentralized storage. Developers encrypt their code before storing it, retaining full ownership and control over their intellectual property. When users request code generation, Phala\u2019s AI agents fetch the encrypted data from Walrus, ensuring that user interactions remain secure and private throughout the process. In essence, Gojo combines a cross-chain infrastructure, token-based security models, and advanced AI agents to offer a no-code solution for building web3 prototypes.",
        "how_its_made": "Gojo is built using a combination of cross-chain infrastructure and advanced AI technologies, bringing together multiple blockchain protocols and decentralized systems to create a seamless experience. At the heart of this project is LayerZero, which provides the cross-chain infrastructure connecting SKALE, Story Network and Polygon. This allows Gojo to operate on multiple blockchains, enabling users to interact across chains effortlessly. The AI agents that power Gojo are driven by Phala Network, which integrates with LayerZero to handle the core AI operations. SKALE is the primary blockchain where the Gojo app operates. It offers a gasless environment, ensuring users don't have to pay transaction fees, which makes it more accessible. Through LayerZero, SKALE mints programmable intellectual properties (IPs) on Story Network and creates on-chain attestations in Polygon. This combination of networks significantly boosts Gojo's functionality and opens up possibilities for cross-chain code generation. The programmable IPs are a critical feature because they allow developers to claim ownership of their contributions and receive royalties whenever their AI-trained agents generate code for users. Within Story Network, developers create and train domain-specific AI agents. These agents are integral to Gojo\u2019s code-generation capabilities. Every time a developer contributes to Gojo\u2019s AI model, they mint a programmable IP that they own, allowing them to earn royalties based on its use. Since Story is also connected to SKALE via LayerZero, any activity on Story automatically integrates into Gojo's multi-chain operations, ensuring contributions are recorded and rewarded across chains. Gojo integrates Polygon in multiple ways. The AI agents running on Gojo can generate code deployable on the Polygon blockchain. Gojo also uses Polygon as the relayer to establish a communication between Story Testnet and SKALE Testnet. Additionally, Gojo uses Sign Protocol on Polygon to verify if users hold enough IP tokens before generating code. Every time a user interacts with the AI agent, Phala\u2019s core AI agent signs on-chain attestations to document each code generation. This ensures transparency and traceability in code generation while maintaining user privacy. For seamless data indexing, Gojo relies on TheGraph to track contract data and update the frontend. The custom subgraph built for Gojo indexes all contract interactions, ensuring that data is readily available. Users interact with Gojo through an XMTP-powered chatbot, which serves as the front-end interface for the Phala AI agent. This agent communicates with domain-specific AI agents to generate the requested code. For wallet integration, Gojo uses the Coinbase Developer Platform. Specifically, Coinbase MPC wallets are used by Phala AI agents to sign operations, while the frontend relies on Coinbase\u2019s on-chain kit for user authentication and wallet management. Users have the flexibility to use either a smart wallet or a standard externally owned account (EOA), providing both ease of use and security. Finally, all code contributions are stored in Walrus, Gojo\u2019s decentralized storage. Developers encrypt their code before storing it, retaining full ownership and control over their intellectual property. When users request code generation, Phala\u2019s AI agents fetch the encrypted data from Walrus, ensuring that user interactions remain secure and private throughout the process. In essence, Gojo combines a cross-chain infrastructure, token-based security models, and advanced AI agents to offer a no-code solution for building web3 prototypes.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/nn59s/screenshots/mcxkj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nn59s/screenshots/sf9a3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nn59s/screenshots/aqwqk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nn59s/screenshots/p7wi7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nn59s/screenshots/gdqcu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nn59s/screenshots/rhiay/default.jpg"
        ],
        "live_demo": "https://gojo-ethglobal.vercel.app/",
        "source_code": "https://github.com/gabrielantonyxaviour/gojo",
        "link": "https://ethglobal.com/showcase/gojo-nn59s"
    },
    {
        "title": "Blockybara",
        "brief_description": "An application leveraging FHE encryption for secure data protection, with decentralized file storage powered by Walrus.",
        "long_description": "An innovative application built on the Fhenix chain, utilizing Fully Homomorphic Encryption (FHE) to secure sensitive data. File decryption keys are safely stored on the Fhenix chain, ensuring robust protection. Encrypted files themselves are stored in a decentralized manner using the Walrus storage network, combining strong encryption and decentralized storage for ultimate data security and accessibility. This project uses Next.js for the frontend and Express.js for the backend. Solidity powers the registry smart contracts, which store file decryption keys on the Fhenix chain. Encrypted files are stored using Walrus for decentralized storage. The entire setup, including Sui, Fhenix, and Walrus nodes, runs in Docker, ensuring seamless integration and environment consistency.",
        "how_its_made": "This project uses Next.js for the frontend and Express.js for the backend. Solidity powers the registry smart contracts, which store file decryption keys on the Fhenix chain. Encrypted files are stored using Walrus for decentralized storage. The entire setup, including Sui, Fhenix, and Walrus nodes, runs in Docker, ensuring seamless integration and environment consistency.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/396sp/screenshots/juusz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/396sp/screenshots/xgpb1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/396sp/screenshots/mzzfp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/396sp/screenshots/unbox/default.jpg",
            "https://ethglobal.b-cdn.net/projects/396sp/screenshots/y3fmj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/artemmartyhin/blockybara",
        "link": "https://ethglobal.com/showcase/blockybara-396sp"
    },
    {
        "title": "CryptoIndexFund",
        "brief_description": "Crypto index fund bundles for employee retirement benefit programs",
        "long_description": "We are building index funds with bundles of crypto assets to be used for employee retirement benefits programs. The goal is to deliver onboarding, management, and security  in as few steps as possible, creating a seamless user experience for consumers new to the crypto ecosystem. Our solution will provide self-custody functionality for advanced users. Some examples of the index fund portfolio bundles: Top Market Cap tokens, \"Classic\" tokens, GameFi projects, Real-World Asset projects. We minted LPs on UniSwap V4 and used those in our contract calling the Swap Router to initiate the funds for each of the tokens in the portfolio; this is all wrapped in an executing contract. We leverage Coinbase's CDP (OnchainKit) for generating a wallet and funding accounts. The idea is for a brand new user\u2014no wallet, only a computer and an email address\u2014to  onramp with Coinbase, generate a wallet, and purchase into the index fund in as few clicks as possible. To remove additional friction we also want to use Coinbase Paymaster to cover the gas fees for these transactions. We use Covalent to get the token prices for each token is USD.",
        "how_its_made": "We minted LPs on UniSwap V4 and used those in our contract calling the Swap Router to initiate the funds for each of the tokens in the portfolio; this is all wrapped in an executing contract. We leverage Coinbase's CDP (OnchainKit) for generating a wallet and funding accounts. The idea is for a brand new user\u2014no wallet, only a computer and an email address\u2014to  onramp with Coinbase, generate a wallet, and purchase into the index fund in as few clicks as possible. To remove additional friction we also want to use Coinbase Paymaster to cover the gas fees for these transactions. We use Covalent to get the token prices for each token is USD.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0xrun/screenshots/1feeu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0xrun/screenshots/q6xki/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0xrun/screenshots/cxx4a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0xrun/screenshots/8t5un/default.jpg"
        ],
        "live_demo": "https://eth-global-24-application.vercel.app/",
        "source_code": "https://github.com/The18thWarrior/eth-global-24",
        "link": "https://ethglobal.com/showcase/cryptoindexfund-0xrun"
    },
    {
        "title": "Open Frame",
        "brief_description": "Open Frame generates dynamic previews for ENS in any XMTP client",
        "long_description": "In XMTP clients, you have to leave the app to look up ENS account information or start a transaction. Our bot integrates ENS with XMTP, providing link previews whenever a \".eth\" name is mentioned. With Open Frame, you can view and interact with ENS accounts directly from the XMTP context! Open Frame is client agnostic, tested in Converse and XMTP.chat We are running a Next JS server side rendered application that creates dynamic meta tags in the html header based on the current URL.\nFor example, if you are at /ens/reidjs it creates a meta tag <meta name=\"of:image\" property=\"ENS_PIC_URL\">\nIf you go to /transactions/0x1234 it creates a meta tag <meta name=\"of:image\" property=\"QR_PIC_URL\"> Web3 projects used:\nXMTP, ENS",
        "how_its_made": "We are running a Next JS server side rendered application that creates dynamic meta tags in the html header based on the current URL.\nFor example, if you are at /ens/reidjs it creates a meta tag <meta name=\"of:image\" property=\"ENS_PIC_URL\">\nIf you go to /transactions/0x1234 it creates a meta tag <meta name=\"of:image\" property=\"QR_PIC_URL\"> Web3 projects used:\nXMTP, ENS",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t9rmb/screenshots/80xbn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t9rmb/screenshots/2wyzt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t9rmb/screenshots/3uxjb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t9rmb/screenshots/g4yio/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/reidjs/eth-global-2024",
        "link": "https://ethglobal.com/showcase/open-frame-t9rmb"
    },
    {
        "title": "we3ravel",
        "brief_description": "Home swapping platform with ERC20 tokens as in game closed system currency. Tokens can be used for revenue sharing of the membership fees from users.",
        "long_description": "Users pay for staying at other people's homes by ERC20 tokens which are issued only once per user when they prove their humanity with a solution such as World ID. The users also pay a membership fee in fiat or stable coins. Part of the revenue from the membership fees goes back to the users proportional to the amount of tokens they hold. The tokens are not freely traded and can only be used to swap homes or for other services and partnerships with other companies. I used scaffold-eth for fast prorotyping, pinata for image storage and google maps api for address location and world coin for prevention of multiple accounts creation. There are two main contracts - the RentalContract responsible for managing the logic behind booking and listing properties and the TokenContract handling the verification logic and minting of tokens.",
        "how_its_made": "I used scaffold-eth for fast prorotyping, pinata for image storage and google maps api for address location and world coin for prevention of multiple accounts creation. There are two main contracts - the RentalContract responsible for managing the logic behind booking and listing properties and the TokenContract handling the verification logic and minting of tokens.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3ct30/screenshots/5wxqj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3ct30/screenshots/cuffd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3ct30/screenshots/aemz0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/nenkoz/we3ravel_demo",
        "link": "https://ethglobal.com/showcase/we3ravel-3ct30"
    },
    {
        "title": "XAirlines Mileage",
        "brief_description": "It is a cross-airlines mileage collection platform powered by Zero Knowledge Proof.",
        "long_description": "This allows general users who buy and finish the flight to come back to collect mileages. It's using ZK, worldcoin platform, etc.",
        "how_its_made": "It's using ZK, worldcoin platform, etc.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jvxpo/screenshots/e6hvj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jvxpo/screenshots/rmgtv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jvxpo/screenshots/i5uyr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/tommymsz006/ethsingapore2024",
        "link": "https://ethglobal.com/showcase/xairlines-mileage-jvxpo"
    },
    {
        "title": "zkapcha",
        "brief_description": "A zk-based CAPTCHA (Completely Automated Public Turing test to tell Computers and Humans Apart)",
        "long_description": "A zk-based CAPTCHA (Completely Automated Public Turing test to tell Computers and Humans Apart) on the Mina Protocol leverages zero-knowledge proofs (zk-SNARKs) to enhance privacy and security in user verification processes. Unlike traditional CAPTCHAs, which may expose user interaction data, a zk-based CAPTCHA allows users to prove they have successfully completed a CAPTCHA challenge without revealing any identifying information or challenge details. On the Mina Protocol, known for its lightweight blockchain and zk-SNARK technology, this system enables users to authenticate themselves privately and efficiently. The CAPTCHA's zk-proof verifies human interaction while preserving user privacy by ensuring no unnecessary data is shared or stored. Additionally, Mina's minimal blockchain size ensures that the CAPTCHA verification remains scalable and decentralized, enhancing the security of applications without adding computational or storage burdens to the network.",
        "how_its_made": "On the Mina Protocol, known for its lightweight blockchain and zk-SNARK technology, this system enables users to authenticate themselves privately and efficiently. The CAPTCHA's zk-proof verifies human interaction while preserving user privacy by ensuring no unnecessary data is shared or stored. Additionally, Mina's minimal blockchain size ensures that the CAPTCHA verification remains scalable and decentralized, enhancing the security of applications without adding computational or storage burdens to the network.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/516wj/screenshots/w64cy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/516wj/screenshots/f4emi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/516wj/screenshots/m4bft/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ZkBuilders/zkaptcha",
        "link": "https://ethglobal.com/showcase/zkapcha-516wj"
    },
    {
        "title": "zkapcha",
        "brief_description": "A zk-based CAPTCHA (Completely Automated Public Turing test to tell Computers and Humans Apart)",
        "long_description": "A zk-based CAPTCHA (Completely Automated Public Turing test to tell Computers and Humans Apart) on the Mina Protocol leverages zero-knowledge proofs (zk-SNARKs) to enhance privacy and security in user verification processes. Unlike traditional CAPTCHAs, which may expose user interaction data, a zk-based CAPTCHA allows users to prove they have successfully completed a CAPTCHA challenge without revealing any identifying information or challenge details. On the Mina Protocol, known for its lightweight blockchain and zk-SNARK technology, this system enables users to authenticate themselves privately and efficiently. The CAPTCHA's zk-proof verifies human interaction while preserving user privacy by ensuring no unnecessary data is shared or stored. Additionally, Mina's minimal blockchain size ensures that the CAPTCHA verification remains scalable and decentralized, enhancing the security of applications without adding computational or storage burdens to the network.",
        "how_its_made": "On the Mina Protocol, known for its lightweight blockchain and zk-SNARK technology, this system enables users to authenticate themselves privately and efficiently. The CAPTCHA's zk-proof verifies human interaction while preserving user privacy by ensuring no unnecessary data is shared or stored. Additionally, Mina's minimal blockchain size ensures that the CAPTCHA verification remains scalable and decentralized, enhancing the security of applications without adding computational or storage burdens to the network.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/516wj/screenshots/w64cy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/516wj/screenshots/f4emi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/516wj/screenshots/m4bft/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ZkBuilders/zkaptcha",
        "link": "https://ethglobal.com/showcase/zkapcha-516wj"
    },
    {
        "title": "Girl Math",
        "brief_description": "Our ML model and dashboard were built earlier, but due to difficulties integrating it with Web3, we submitted a VERY basic HTML/CSS instead",
        "long_description": "We had previously developed both the ML model and dashboard, but faced challenges integrating them with Web3, which led us to submit a simpler project. This hackathon has been a great learning experience, and we\u2019re definitely committed to learning more about Web3 and crypto technologies to build on this project in the future. HTML, CSS, JS, Python- We built the ML model using historical Ethereum data, leveraging Facebook\u2019s Prophet library for time-series forecasting. The model predicts Ethereum prices for different timeframes\u2014monthly, six months, one year, and five years\u2014by identifying patterns and trends in the data. Despite the model being fully functional, we couldn\u2019t integrate it with Web3 in time for the hackathon",
        "how_its_made": "HTML, CSS, JS, Python- We built the ML model using historical Ethereum data, leveraging Facebook\u2019s Prophet library for time-series forecasting. The model predicts Ethereum prices for different timeframes\u2014monthly, six months, one year, and five years\u2014by identifying patterns and trends in the data. Despite the model being fully functional, we couldn\u2019t integrate it with Web3 in time for the hackathon",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0c866/screenshots/8ktmd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0c866/screenshots/iqd76/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0c866/screenshots/pm7uj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/starrocket2607/HackathonETH",
        "link": "https://ethglobal.com/showcase/girl-math-0c866"
    },
    {
        "title": "Sentiplex",
        "brief_description": "Sentiplex AI is a Chrome extension that analyzes tweet sentiment, detects cyberbullying, and generates memes. It empowers users to engage in positive online interactions by providing real-time sentiment feedback and creating shareable content directly from the extension.",
        "long_description": "Sentiplex AI is designed to transform how we interact on social media. The extension uses advanced natural language processing (NLP) and sentiment analysis to evaluate tweets and identify cyberbullying, hate speech, and emotional tone. It allows users to see sentiment ratings, highlights toxic comments, and even create memes based on tweet content\u2014all within the browser. With a single click, users can convert tweets into custom memes that encourage positivity and awareness. Sentiplex AI promotes a healthier online community by turning negative sentiments into creative expression. The extension is built using React for the frontend and Node.js for backend API services. It integrates sentiment analysis models such as VADER and BERT for real-time sentiment scoring. Cyberbullying detection is achieved through a custom-trained machine learning model using a dataset of flagged comments. Meme generation is facilitated using an in-built meme template library and image processing APIs. The extension's UI/UX is designed to be intuitive, allowing seamless integration with Twitter's interface, enabling users to analyze tweets, detect harmful content, and create memes effortlessly.",
        "how_its_made": "The extension is built using React for the frontend and Node.js for backend API services. It integrates sentiment analysis models such as VADER and BERT for real-time sentiment scoring. Cyberbullying detection is achieved through a custom-trained machine learning model using a dataset of flagged comments. Meme generation is facilitated using an in-built meme template library and image processing APIs. The extension's UI/UX is designed to be intuitive, allowing seamless integration with Twitter's interface, enabling users to analyze tweets, detect harmful content, and create memes effortlessly.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xqc2b/screenshots/8zyi3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xqc2b/screenshots/md7c0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xqc2b/screenshots/scjtv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xqc2b/screenshots/wgkrk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sagarjethi/sentiplex/tree/main",
        "link": "https://ethglobal.com/showcase/sentiplex-xqc2b"
    },
    {
        "title": "Perpetua",
        "brief_description": "Perpetua is a decentralized perpetual futures trading platform that enables users to trade crypto assets with leverage, without expiration dates, Perpetua ensures low fees, high speed, and full transparency. Trade anytime, anywhere.",
        "long_description": "Perpetua is a decentralized perpetual trading exchange (Perp DEX) that allows users to trade crypto assets with leverage and without expiration dates on contracts. It combines the flexibility of perpetual contracts with decentralized finance (DeFi) technology, offering a fast, low-cost, and transparent trading experience on the blockchain. Key Features:\nPerpetual Contracts: Perpetua\u2019s contracts have no expiration dates, enabling traders to hold positions as long as they like. This makes it ideal for both short-term trading and long-term strategies. Off-Chain Orderbook: Perpetua uses an off-chain orderbook to facilitate faster transactions and reduce gas fees. Traders can place, modify, and cancel orders without the cost or delay of interacting with the blockchain. Once orders are matched, they are executed on-chain for transparency and security. On-Chain Settlement: Although the orderbook is off-chain, all trades are settled on-chain, ensuring transparent execution. This provides security and verifiability, as trades are finalized through the underlying blockchain technology. Leverage Trading: Traders can use leverage to increase their exposure to asset price movements, allowing for the possibility of higher profits with a smaller initial investment. This feature also introduces higher risk, which traders should manage accordingly. Risk Management: Automated liquidation systems ensure that positions are closely monitored for margin compliance. If a trader\u2019s margin falls below the required threshold, their position will be liquidated to prevent further loss. User-Friendly Interface: Designed with both novice and expert traders in mind, Perpetua features an intuitive and responsive interface, offering advanced charting, real-time data, and easy access to trading tools. Fee Efficiency: Perpetua\u2019s hybrid system of off-chain order matching and on-chain settlement reduces transaction fees, making it more affordable for frequent traders while maintaining the security of blockchain settlements. Core Components:\nOrder Management: Users can place market, limit, and stop orders, all handled through the efficient off-chain engine.\nPrice Oracles: Reliable price feeds, such as those from Pyth or Chainlink, ensure accurate real-time pricing for assets, which is critical for calculating profits and liquidation triggers.\nLiquidation Engine: The platform ensures robust risk management by automating liquidations if positions become undercollateralized, protecting users from extreme losses.\nFuture Plans:\nNew Asset Listings: Perpetua will continuously add new crypto assets and synthetic assets to diversify its trading options.\nCross-Chain Trading: The platform will enable cross-chain support, offering users the ability to trade assets from multiple blockchains in a single interface.\nMobile Trading App: Perpetua will soon launch a mobile app, allowing users to trade and monitor their positions on the go.\nPerpetua aims to provide a seamless, secure, and accessible platform for perpetual trading, offering a range of innovative features that cater to both experienced traders and newcomers to decentralized finance. Perpetua is a decentralized perpetual trading exchange built with a focus on high performance, transparency, and scalability. Here's a detailed breakdown of the technologies and architecture involved in creating the platform: Core Technologies:\nBlockchain: Flow We chose Flow blockchain for its high throughput, developer-friendly environment, and low gas fees, ensuring smooth, cost-efficient user interactions. The Cadence smart contracts are used to manage trades, positions, and on-chain settlement in a secure and resource-oriented manner.\nCadence Smart Contracts: All critical functionalities such as position management, liquidation, leverage, and margin handling are written in Flow\u2019s Cadence language. Cadence\u2019s resource-oriented programming ensures ownership and safety of user assets and reduces the risks of common vulnerabilities like reentrancy.\nOff-Chain Orderbook: Perpetua\u2019s hybrid model uses an off-chain orderbook to enable fast order matching without constantly interacting with the blockchain. This reduces gas fees and improves speed. Trades are only finalized on-chain after an order is matched, allowing for efficient gas usage.\nPyth Network for Price Feeds: For reliable, real-time pricing data, we integrated Pyth Network oracles. Pyth provides decentralized, high-fidelity price feeds sourced from professional traders and financial institutions, which is critical for calculating profit & loss (PnL), margin requirements, and triggering liquidations.\nPyth\u2019s integration ensures accurate price updates for volatile assets, and its aggregation mechanism provides confidence in price accuracy, which is essential for the security of leveraged trades.\nThese price feeds enable accurate, trustless execution of positions and prevent price manipulation by relying on aggregated prices rather than single-source data.\nBackend: Node.js & TypeScript: The backend is built using Node.js and TypeScript, handling off-chain order matching and interaction with the smart contracts. TypeScript adds strong type-checking, helping to manage the complexity of perpetual trading logic with fewer bugs.\nExpress is used to manage APIs for trade interactions, while GraphQL provides efficient data querying for live data displays.\nReal-Time Data Handling with WebSockets: We implemented WebSockets for real-time updates. This allows traders to view live orderbook data, price updates, and PnL in real-time without page refreshes, offering a highly responsive trading experience.\nFrontend: React & Next.js: The UI is built with React and Next.js to ensure fast, SEO-optimized rendering. This enables users to interact with the exchange in real time with minimal latency. Tailwind CSS is used to create a sleek, responsive design optimized for both mobile and desktop trading.\nDatabase: MongoDB: We chose MongoDB for its flexibility and scalability to manage user sessions, trade history, and off-chain orderbook data. MongoDB's document-based architecture is well-suited for handling the constantly changing, complex data structures involved in perpetual trading.\nPrisma ORM: Prisma is used as the ORM layer for interacting with MongoDB. It simplifies database management with its type-safe queries and schema migrations, ensuring seamless interaction between the backend and the database.\nChallenges & Notable Solutions:\nPyth Price Integration: One of the critical components of Perpetua is ensuring accurate price feeds for executing positions. Pyth\u2019s network of price feeds ensures that we use aggregated data from trusted institutions, reducing the risk of slippage and front-running. We implemented a periodic verification process to update prices on-chain using Pyth's aggregated prices, ensuring consistency across trades.\nGas Optimization: We optimized the smart contracts to minimize gas usage by offloading non-critical actions (such as order placement and updates) off-chain. Only key events like trade execution and position closure happen on-chain to save costs.\nLiquidation System: We built an automated liquidation engine that triggers based on margin requirements and the Pyth price feeds. The integration with real-time oracles ensures timely execution of liquidations and protects against under-collateralized positions.",
        "how_its_made": "Perpetua is a decentralized perpetual trading exchange built with a focus on high performance, transparency, and scalability. Here's a detailed breakdown of the technologies and architecture involved in creating the platform: Core Technologies:\nBlockchain: Flow We chose Flow blockchain for its high throughput, developer-friendly environment, and low gas fees, ensuring smooth, cost-efficient user interactions. The Cadence smart contracts are used to manage trades, positions, and on-chain settlement in a secure and resource-oriented manner.\nCadence Smart Contracts: All critical functionalities such as position management, liquidation, leverage, and margin handling are written in Flow\u2019s Cadence language. Cadence\u2019s resource-oriented programming ensures ownership and safety of user assets and reduces the risks of common vulnerabilities like reentrancy.\nOff-Chain Orderbook: Perpetua\u2019s hybrid model uses an off-chain orderbook to enable fast order matching without constantly interacting with the blockchain. This reduces gas fees and improves speed. Trades are only finalized on-chain after an order is matched, allowing for efficient gas usage.\nPyth Network for Price Feeds: For reliable, real-time pricing data, we integrated Pyth Network oracles. Pyth provides decentralized, high-fidelity price feeds sourced from professional traders and financial institutions, which is critical for calculating profit & loss (PnL), margin requirements, and triggering liquidations.\nPyth\u2019s integration ensures accurate price updates for volatile assets, and its aggregation mechanism provides confidence in price accuracy, which is essential for the security of leveraged trades.\nThese price feeds enable accurate, trustless execution of positions and prevent price manipulation by relying on aggregated prices rather than single-source data.\nBackend: Node.js & TypeScript: The backend is built using Node.js and TypeScript, handling off-chain order matching and interaction with the smart contracts. TypeScript adds strong type-checking, helping to manage the complexity of perpetual trading logic with fewer bugs.\nExpress is used to manage APIs for trade interactions, while GraphQL provides efficient data querying for live data displays.\nReal-Time Data Handling with WebSockets: We implemented WebSockets for real-time updates. This allows traders to view live orderbook data, price updates, and PnL in real-time without page refreshes, offering a highly responsive trading experience.\nFrontend: React & Next.js: The UI is built with React and Next.js to ensure fast, SEO-optimized rendering. This enables users to interact with the exchange in real time with minimal latency. Tailwind CSS is used to create a sleek, responsive design optimized for both mobile and desktop trading.\nDatabase: MongoDB: We chose MongoDB for its flexibility and scalability to manage user sessions, trade history, and off-chain orderbook data. MongoDB's document-based architecture is well-suited for handling the constantly changing, complex data structures involved in perpetual trading.\nPrisma ORM: Prisma is used as the ORM layer for interacting with MongoDB. It simplifies database management with its type-safe queries and schema migrations, ensuring seamless interaction between the backend and the database.\nChallenges & Notable Solutions:\nPyth Price Integration: One of the critical components of Perpetua is ensuring accurate price feeds for executing positions. Pyth\u2019s network of price feeds ensures that we use aggregated data from trusted institutions, reducing the risk of slippage and front-running. We implemented a periodic verification process to update prices on-chain using Pyth's aggregated prices, ensuring consistency across trades.\nGas Optimization: We optimized the smart contracts to minimize gas usage by offloading non-critical actions (such as order placement and updates) off-chain. Only key events like trade execution and position closure happen on-chain to save costs.\nLiquidation System: We built an automated liquidation engine that triggers based on margin requirements and the Pyth price feeds. The integration with real-time oracles ensures timely execution of liquidations and protects against under-collateralized positions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8jbqc/screenshots/bkwi1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jbqc/screenshots/2vq3n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jbqc/screenshots/bv07t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jbqc/screenshots/2mh0o/default.jpg"
        ],
        "live_demo": "https://perpetua-one.vercel.app/",
        "source_code": "https://github.com/thedudeontitan/Perpetua",
        "link": "https://ethglobal.com/showcase/perpetua-8jbqc"
    },
    {
        "title": "GateMaster NFT",
        "brief_description": "token gated community on discord, using an AirDAO Native token standard.",
        "long_description": "A Discord bot that checks NFT ownership can control access to special channels on a server. This means only members who own a specific NFT can enter certain private areas. This bot can be really useful for a variety of groups: Celebrities: They can create exclusive clubs where fans with special NFTs can access behind-the-scenes content or join live Q&A sessions.\nGamers: Game developers can give NFT holders early access to new games or special gaming events.\nEducators: Teachers can offer special courses or resources in private Discord channels to those who hold educational NFTs. I've used React for the frontnd and i used python to develop a discord bot which will check if u own the NFT and give u access to the discord. I've used airdao RPC URLs and their token standard to fetch the information regarding the NFTs I've used ethers, web3.py libraries to fetch info from smart contracts",
        "how_its_made": "I've used React for the frontnd and i used python to develop a discord bot which will check if u own the NFT and give u access to the discord. I've used airdao RPC URLs and their token standard to fetch the information regarding the NFTs I've used ethers, web3.py libraries to fetch info from smart contracts",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wk8p0/screenshots/jbadu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wk8p0/screenshots/ij35p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wk8p0/screenshots/yabkn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/srivatsav01/ethSingapore",
        "link": "https://ethglobal.com/showcase/gatemaster-nft-wk8p0"
    },
    {
        "title": "SET OFF",
        "brief_description": "P2P Micro lending and borrowing platform with settlement clearing mechanism",
        "long_description": "Traditional Lending Challenges: Inefficiencies: Traditional lending systems often involve complex and time-consuming processes with intermediaries, leading to delays and high costs.\nLack of Transparency: Limited visibility into the terms, conditions, and real-time status of loans can lead to distrust among participants.\nObligation Settlement Issues: Settling obligations between multiple parties can be cumbersome and prone to errors, especially in closed clearing clubs.\nLender and Borrower Pain Points: Limited Access: Small-scale lenders and borrowers often face difficulties accessing favorable loan terms or capital.\nUnfair Terms: Conventional platforms may offer less favorable terms due to lack of competition or opaque pricing mechanisms.\nRisk Management: Managing and assessing credit risk can be challenging and inefficient.\nSolution: Our platform offers a decentralized P2P lending and borrowing ecosystem with an integrated obligation settlement mechanism, leveraging advanced technologies to address the aforementioned problems. Decentralized Lending and Borrowing: Smart Contracts on Linea: Utilizes Linea's blockchain to enable transparent, secure, and efficient transactions between lenders and borrowers. Smart contracts automate the creation, management, and settlement of loans, reducing the need for intermediaries and minimizing errors.\nDynamic Loan Terms: Lenders can define interest rates and loan terms, while borrowers can select from a range of available loans that meet their needs. This fosters a competitive environment, allowing for more favorable terms.\nEfficient Obligation Settlement: On-Chain Clearing Mechanism: Implements an obligation settlement mechanism similar to closed clearing clubs but on-chain. This ensures that obligations among multiple parties are settled in a streamlined, automated manner, reducing the risk of disputes and errors.\nGraph Protocol Integration: Leverages the Graph Protocol to index and query blockchain data efficiently, providing real-time insights into loan statuses, obligations, and settlement processes.\nEnhanced Security and Privacy: Phala TEE Integration: Utilizes Phala's Trusted Execution Environment (TEE) to ensure that sensitive data and computations are handled securely and privately. This enhances trust and security for all participants in the lending and borrowing process.\nUse Cases: For Lenders: Create and List Loans: Lenders can contribute to the pool of available loans, set their own terms, and list them on the platform.\nMonitor and Manage Investments: Track loan performance, view detailed reports, and manage investments efficiently through the decentralized interface.\nFor Borrowers: Access Competitive Loans: Browse through various loan offerings, select terms that suit their needs, and apply for loans directly.\nTrack Loan Status: Monitor the status of their loans and obligations in real-time, with transparent and fair processes.\nFor Both Parties: Automated Obligation Settlement: Experience seamless and automated settlement of obligations, reducing the administrative burden and ensuring accurate results.\nConclusion: Our platform revolutionizes P2P lending and borrowing by addressing traditional challenges through decentralization and advanced technology integration. By leveraging Linea, Phala TEE, and the Graph Protocol, we provide a secure, transparent, and efficient solution for modern lending and borrowing needs, transforming the financial landscape for both lenders and borrowers. Linea Blockchain: Role: Linea provides the foundation for our decentralized platform. We use Linea\u2019s smart contract capabilities to manage the creation, execution, and settlement of loans.\nIntegration: Smart contracts are written in Solidity and deployed on Linea, ensuring secure and transparent transactions. The blockchain\u2019s scalability and efficiency support our platform\u2019s real-time operations.\nPhala TEE: Role: Phala\u2019s Trusted Execution Environment (TEE) is used to handle sensitive data and computations securely. This ensures that borrower and lender data, as well as the details of loan transactions, are protected from unauthorized access.\nIntegration: Phala TEE is integrated into our smart contracts and off-chain components to secure the processing of confidential information, such as personal financial data and loan terms.\nThe Graph Protocol: Role: The Graph Protocol is employed to index and query blockchain data efficiently. It helps us provide real-time data on loan statuses, obligations, and settlement processes to users.\nIntegration: We use subgraphs to create custom data indexing for our platform, enabling fast and reliable access to data required for the platform\u2019s operations and user interfaces.\n2. Architecture and Integration: Smart Contracts: Lending/Borrowing Logic: Deployed on Linea, these contracts handle the core functionalities, including loan creation, terms setting, application, and repayments.\nObligation Settlement: A custom smart contract manages the settlement of obligations between multiple parties. This contract ensures that all parties meet their commitments efficiently and fairly.\nUser Interface (UI): Frontend Framework: Built using React, our UI interacts with the Linea blockchain via ethers.js. The UI allows users to create loans, apply for loans, and monitor their statuses.\nData Display: Utilizes The Graph Protocol for efficient querying and displaying real-time data on loan statuses and obligations.\nBackend Services: Data Handling: Backend services integrate with Phala TEE to handle sensitive computations securely. These services process off-chain data and interact with our smart contracts as needed.\nAPIs: Custom APIs are built to facilitate communication between the frontend and backend, as well as between the backend and the blockchain.\n3. Partner Technologies: Phala TEE: Provides a secure environment for processing sensitive information. This partnership enhances user trust and compliance by safeguarding personal and financial data.\nThe Graph Protocol: Enables efficient data indexing and querying, significantly improving the platform\u2019s responsiveness and user experience.\n4. Notable Hacks and Innovations: Custom Obligation Settlement Mechanism: Hacky Element: To address the challenge of multi-party obligation settlement, we designed a novel smart contract mechanism that automates and optimizes the settlement process. This approach is inspired by closed clearing clubs but tailored to the decentralized nature of our platform.\nHybrid On-Chain/Off-Chain Data Processing: Hacky Element: We implemented a hybrid data processing model where sensitive data is processed off-chain using Phala TEE, while critical transactional logic remains on-chain. This approach minimizes on-chain computation while ensuring security and efficiency.\nDynamic Loan Term Adjustment: Hacky Element: Our platform includes a feature allowing lenders to adjust loan terms dynamically based on market conditions. This adaptability is achieved through a combination of smart contract logic and real-time data analysis facilitated by The Graph Protocol.\nIn summary, our project leverages a combination of Linea for blockchain operations, Phala TEE for secure data processing, and The Graph Protocol for efficient data handling. Through innovative integrations and a hybrid approach to data processing, we\u2019ve created a robust and scalable P2P lending and borrowing platform with a cutting-edge obligation settlement mechanism.",
        "how_its_made": "Linea Blockchain: Role: Linea provides the foundation for our decentralized platform. We use Linea\u2019s smart contract capabilities to manage the creation, execution, and settlement of loans.\nIntegration: Smart contracts are written in Solidity and deployed on Linea, ensuring secure and transparent transactions. The blockchain\u2019s scalability and efficiency support our platform\u2019s real-time operations.\nPhala TEE: Role: Phala\u2019s Trusted Execution Environment (TEE) is used to handle sensitive data and computations securely. This ensures that borrower and lender data, as well as the details of loan transactions, are protected from unauthorized access.\nIntegration: Phala TEE is integrated into our smart contracts and off-chain components to secure the processing of confidential information, such as personal financial data and loan terms.\nThe Graph Protocol: Role: The Graph Protocol is employed to index and query blockchain data efficiently. It helps us provide real-time data on loan statuses, obligations, and settlement processes to users.\nIntegration: We use subgraphs to create custom data indexing for our platform, enabling fast and reliable access to data required for the platform\u2019s operations and user interfaces.\n2. Architecture and Integration: Smart Contracts: Lending/Borrowing Logic: Deployed on Linea, these contracts handle the core functionalities, including loan creation, terms setting, application, and repayments.\nObligation Settlement: A custom smart contract manages the settlement of obligations between multiple parties. This contract ensures that all parties meet their commitments efficiently and fairly.\nUser Interface (UI): Frontend Framework: Built using React, our UI interacts with the Linea blockchain via ethers.js. The UI allows users to create loans, apply for loans, and monitor their statuses.\nData Display: Utilizes The Graph Protocol for efficient querying and displaying real-time data on loan statuses and obligations.\nBackend Services: Data Handling: Backend services integrate with Phala TEE to handle sensitive computations securely. These services process off-chain data and interact with our smart contracts as needed.\nAPIs: Custom APIs are built to facilitate communication between the frontend and backend, as well as between the backend and the blockchain.\n3. Partner Technologies: Phala TEE: Provides a secure environment for processing sensitive information. This partnership enhances user trust and compliance by safeguarding personal and financial data.\nThe Graph Protocol: Enables efficient data indexing and querying, significantly improving the platform\u2019s responsiveness and user experience.\n4. Notable Hacks and Innovations: Custom Obligation Settlement Mechanism: Hacky Element: To address the challenge of multi-party obligation settlement, we designed a novel smart contract mechanism that automates and optimizes the settlement process. This approach is inspired by closed clearing clubs but tailored to the decentralized nature of our platform.\nHybrid On-Chain/Off-Chain Data Processing: Hacky Element: We implemented a hybrid data processing model where sensitive data is processed off-chain using Phala TEE, while critical transactional logic remains on-chain. This approach minimizes on-chain computation while ensuring security and efficiency.\nDynamic Loan Term Adjustment: Hacky Element: Our platform includes a feature allowing lenders to adjust loan terms dynamically based on market conditions. This adaptability is achieved through a combination of smart contract logic and real-time data analysis facilitated by The Graph Protocol.\nIn summary, our project leverages a combination of Linea for blockchain operations, Phala TEE for secure data processing, and The Graph Protocol for efficient data handling. Through innovative integrations and a hybrid approach to data processing, we\u2019ve created a robust and scalable P2P lending and borrowing platform with a cutting-edge obligation settlement mechanism.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ci8sd/screenshots/m0bri/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ci8sd/screenshots/ucx4a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ci8sd/screenshots/z107v/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/rizwanmoulvi/Set-Off",
        "link": "https://ethglobal.com/showcase/set-off-ci8sd"
    },
    {
        "title": "Vigilant Trail",
        "brief_description": "Vigilant Trail secures transactions with escrow smart contracts, allowing fund retrieval if sent to the wrong address.",
        "long_description": "Vigilant Trail is a safe transaction tool that uses an escrow service to ensure funds are securely transferred. It stores the funds in a smart contract, allowing the sender to revert the transaction if the funds were sent to the wrong address. The receiver can claim the funds, and once verified, the smart contract releases the funds. Trail is built using Solidity, HTML, CSS, and JavaScript, offering a seamless integration between smart contracts and user-friendly design. It aims to enhance the security of everyday fund transfers. Vigilant Trail is built using a robust set of technologies to ensure security, performance, and a seamless user experience: Together, these technologies create a secure and user-friendly platform for safe fund transfers.",
        "how_its_made": "Vigilant Trail is built using a robust set of technologies to ensure security, performance, and a seamless user experience: Together, these technologies create a secure and user-friendly platform for safe fund transfers.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ffgnz/screenshots/cerkv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ffgnz/screenshots/5vtx7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ffgnz/screenshots/ru3o8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/surbhit14/Vigilant-Trail",
        "link": "https://ethglobal.com/showcase/vigilant-trail-ffgnz"
    },
    {
        "title": "PRUFFOFPUFF",
        "brief_description": "Ecosystem for crypto merch - more creative useful for people.",
        "long_description": "Custom tshirt printing for hackaton partners on demand very low cost.\nCustomazible by attendees. NFC tag driven networking system.\nGreat way to start crypto fashion.\nCustom tshirt printing for hackaton partners on demand very low cost.\nCustomazible by attendees. NFC tag driven networking system.\nGreat way to start crypto fashion. React, NFT, NFC, temporary wallet.\nReact, NFT, NFC, temporary wallet.\nReact, NFT, NFC, temporary wallet.\nReact, NFT, NFC, temporary wallet.\nReact, NFT, NFC, temporary wallet.\nReact, NFT, NFC, temporary wallet.\nReact, NFT, NFC, temporary wallet.\nReact, NFT, NFC, temporary wallet.",
        "how_its_made": "React, NFT, NFC, temporary wallet.\nReact, NFT, NFC, temporary wallet.\nReact, NFT, NFC, temporary wallet.\nReact, NFT, NFC, temporary wallet.\nReact, NFT, NFC, temporary wallet.\nReact, NFT, NFC, temporary wallet.\nReact, NFT, NFC, temporary wallet.\nReact, NFT, NFC, temporary wallet.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xydts/screenshots/06m2o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xydts/screenshots/7kpew/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xydts/screenshots/4mgw4/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/FrostF0X/pruffofpuff.xyz",
        "link": "https://ethglobal.com/showcase/pruffofpuff-xydts"
    },
    {
        "title": "Play Network",
        "brief_description": "Community Management  & Game Streaming Platform for Web3 Gamers",
        "long_description": "###\ud83e\uddd0 Problem Statement Centralised streaming platforms exploit streamers' hard work and community influence through unfair compensation practices, lacking transparency and consensus. Gamers invest significant time and money in games without receiving ownership, alignment, or governance, highlighting the absence of a GameFi streaming infrastructure for crypto and NFT payouts. Transitioning from web2 game publishers' methods of acquiring and retaining users (paid ads, paid media) to a Web3 approach based on contribution (airdrops, referrals, engagement) is needed. ###\ud83d\udca1 Idea / Solution PlayVerse is an interactive online gaming and learning platform that provides live gaming tutorials and tournaments for games built on the Aptos blockchain. The next evolutionary step is towards the Gamefi streaming platform. Create a sustainable ecosystem running on blockchain where game publishers, streamers and the gamer community all benefit from the contribution. We empower streamers by eliminating high commission rates, eradicating arbitrary increases imposed solely by the company, significantly reducing holding periods for funds, providing clear and concise guidelines regarding account bans based on legal matters, ensuring complete transparency, and fostering a strong sense of community consensus. By doing so, we restore the integrity of the streaming ecosystem and bolster the invaluable influence and support that streamers have diligently cultivated to achieve remarkable success. ##Features Interactive Web3 Gaming: Engaging platform for gamers on Aptos blockchain.\nNFT Monetization: Creators can mint NFTs for content monetization.\nHuman Verification: using Worldcoin ID, we are verifying the uniqueness of the user and making it impossible for bots to use the system.\nStreaming & Tournaments: Live tutorials and competitive gaming events.\nFair Compensation: Elimination of high commissions and improved transparency.\nDiscoverability Tools: Enhanced visibility for streamers.\nNFT Creation: Easy NFT creation for in-game assets.\nTournament Generator: Create and manage gaming tournaments.\nCommunity DAO: Decentralized decision-making for fairness.\nMonetize Gaming Moments: Earn from memorable gaming content.\nSecure Donations: Trustless donations with anonymity. Platform Architecture: Dynamic Wallet SDK Integration:\nSupported EVM wallets like Metamask, WalletConnect, and Coinbase Wallet.\nEnabled cross-chain assets within the EVM ecosystem. Worldcoin Integration:\nHuman verification via biometric proof using Worldcoin.\nZero-knowledge proof ensures privacy without revealing personal data. Built on EVM chains (Airdao, Morph, Hedera, Rootstock, Linea).\nSmart contracts written in Solidity for NFTs, rewards, and DAOs goverance.\nUsed IPFS/Filecoin for decentralized storage.",
        "how_its_made": "Platform Architecture: Dynamic Wallet SDK Integration:\nSupported EVM wallets like Metamask, WalletConnect, and Coinbase Wallet.\nEnabled cross-chain assets within the EVM ecosystem. Worldcoin Integration:\nHuman verification via biometric proof using Worldcoin.\nZero-knowledge proof ensures privacy without revealing personal data. Built on EVM chains (Airdao, Morph, Hedera, Rootstock, Linea).\nSmart contracts written in Solidity for NFTs, rewards, and DAOs goverance.\nUsed IPFS/Filecoin for decentralized storage.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sps8r/screenshots/vu834/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sps8r/screenshots/5naf9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sps8r/screenshots/5xxuf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sps8r/screenshots/3p63i/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xshikhar/PlayNetwork",
        "link": "https://ethglobal.com/showcase/play-network-sps8r"
    },
    {
        "title": "DiscordXGaiaAI",
        "brief_description": "This innovative Web3-powered Discord bot transforms everyday interactions into valuable, tokenized rewards. Users earn tokens for engaging in conversations, upvoting responses, and contributing knowledge. AI-driven insights, powered by Gaia",
        "long_description": "This app introduces an innovative, blockchain-powered engagement system within Discord, designed to reward active participation and value creation within a community. Here's how it works: Wallet Integration for Admins & Users: When a Discord admin installs the bot, they connect their wallet, enabling the ability to transfer tokens.\nWhen a new user joins, their wallet is also linked but only for receiving tokens.\nToken Rewards for Community Engagement: If User A asks a question in any channel and User B responds, User B can earn tokens based on community feedback.\nThe response is upvoted via a green button reaction. The number of upvotes determines how many tokens User B will receive.\nUser A, the question-asker, can also earn tokens if their question receives upvotes, with rewards coming directly from the Founder.\nKnowledge Creation with AI Integration: Once the Founder connects their wallet, they can populate a \"knowledge-base\" channel with text or URLs.\nThe bot, powered by Gaia, analyzes the information to automatically generate a knowledge base.\nWhen community members ask questions in the \"chat with AI\" channel, Gaia will leverage this knowledge base to provide AI-driven responses.\nContextual Conversation Analysis: For new or existing users who want to join a conversation in progress, they can use the /analyse command.\nThe bot will analyze the ongoing discussion and provide a contextual summary along with a sample reply to help the user seamlessly join the conversation.\nSummary of Features:\nWallet Integration: Token transfer for admins and users via blockchain.\nTokenized Rewards: Community members earn tokens based on engagement and upvotes.\nAI-Powered Knowledge Base: Gaia creates and responds using a community-driven knowledge base.\nConversation Analysis: Users can receive context and suggestions to join conversations smoothly.\nThis app fosters community engagement by incentivizing meaningful contributions, while simultaneously leveraging AI for knowledge sharing, providing a seamless experience for both new and active participants. This innovative application uses a powerful combination of Python, Web3.js, and Gaianet AI to deliver a feature-rich experience for Discord users, utilizing blockchain technology, AI, and automation. Here\u2019s a breakdown of how each component is integrated into the bot:",
        "how_its_made": "This innovative application uses a powerful combination of Python, Web3.js, and Gaianet AI to deliver a feature-rich experience for Discord users, utilizing blockchain technology, AI, and automation. Here\u2019s a breakdown of how each component is integrated into the bot:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/o41gx/screenshots/gyqcv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o41gx/screenshots/rxrpy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o41gx/screenshots/4k8ak/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/omdivyatej/discord_bot_community_rewards",
        "link": "https://ethglobal.com/showcase/discordxgaiaai-o41gx"
    },
    {
        "title": "Battle of Nouns",
        "brief_description": "Dive into a Web3 strategy game on blockchain! Choose your civilization, earn NOUNS tokens, summon NFT characters, and battle in a decentralized, play-to-earn ecosystem. Governed by players, secured by smart contracts\u2014own, build, and conquer! #PlayToEarn #NFTGaming",
        "long_description": "Blockchain Integration: The game is built on a blockchain network (likely Ethereum or a Layer 2 solution like Polygon) to leverage its decentralized capabilities, ensuring secure, transparent, and immutable gameplay. Smart contracts are at the core, managing game logic, transactions, asset ownership, and interactions between players. Smart Contracts: Smart contracts are developed using Solidity, the primary programming language for Ethereum-based contracts. These contracts handle all game mechanics, including NOUNS token transactions, NFT minting for characters and assets, and the execution of in-game actions like battles and resource gathering. NFTs (Non-Fungible Tokens): Each character, resource, and game asset is represented as an NFT, utilizing standards like ERC-721 or ERC-1155. These tokens provide players with true ownership, allowing them to trade, sell, or use their assets across different platforms. The artwork and metadata for these NFTs are stored on decentralized file storage systems such as IPFS (InterPlanetary File System). Front-End Development: The game\u2019s front end is built using JavaScript frameworks like React or Next.js for a responsive and interactive user experience. Web3.js or Ethers.js libraries are integrated to connect the front end with blockchain, enabling seamless interactions between the players and smart contracts. Backend and Server Architecture: The backend utilizes Node.js along with Express.js to manage game states, player data, and interactions that do not necessarily require blockchain transactions, improving overall performance and reducing on-chain costs. MongoDB is often used for storing non-essential game data that doesn\u2019t require the security of the blockchain. Web3 Integration: Wallet integration, such as MetaMask or WalletConnect, is implemented to enable players to connect their wallets for gameplay, token transactions, and asset management. This setup ensures a smooth user experience, allowing players to interact with the game directly from their wallets. Blockchain Integration: The game is built on a blockchain network (likely Ethereum or a Layer 2 solution like Polygon) to leverage its decentralized capabilities, ensuring secure, transparent, and immutable gameplay. Smart contracts are at the core, managing game logic, transactions, asset ownership, and interactions between players. Smart Contracts: Smart contracts are developed using Solidity, the primary programming language for Ethereum-based contracts. These contracts handle all game mechanics, including NOUNS token transactions, NFT minting for characters and assets, and the execution of in-game actions like battles and resource gathering. NFTs (Non-Fungible Tokens): Each character, resource, and game asset is represented as an NFT, utilizing standards like ERC-721 or ERC-1155. These tokens provide players with true ownership, allowing them to trade, sell, or use their assets across different platforms. The artwork and metadata for these NFTs are stored on decentralized file storage systems such as IPFS (InterPlanetary File System). Front-End Development: The game\u2019s front end is built using JavaScript frameworks like React or Next.js for a responsive and interactive user experience. Web3.js or Ethers.js libraries are integrated to connect the front end with blockchain, enabling seamless interactions between the players and smart contracts. Backend and Server Architecture: The backend utilizes Node.js along with Express.js to manage game states, player data, and interactions that do not necessarily require blockchain transactions, improving overall performance and reducing on-chain costs. MongoDB is often used for storing non-essential game data that doesn\u2019t require the security of the blockchain. Web3 Integration: Wallet integration, such as MetaMask or WalletConnect, is implemented to enable players to connect their wallets for gameplay, token transactions, and asset management. This setup ensures a smooth user experience, allowing players to interact with the game directly from their wallets. Graphics and Game Design: The game\u2019s graphics, including character models, tiles, and UI elements, are created using tools like Blender and Adobe Illustrator. The game uses isometric 2D or 3D design, giving it a modern, polished look while keeping the gameplay clear and strategic. Unity or Unreal Engine is employed for game development, focusing on smooth animations and intuitive user interactions. Tokenomics and Economy Design: The NOUNS token is designed using ERC-20 standards, facilitating easy integration into the game\u2019s economy. Detailed economic modeling was performed to balance in-game earning potential, rewards, and costs, ensuring a sustainable play-to-earn environment that maintains the game\u2019s competitive balance. Security and Audits: Security audits of the smart contracts are conducted by third-party firms to prevent vulnerabilities such as reentrancy attacks, overflow issues, and other common exploits. This is crucial to maintaining trust and ensuring a fair, secure gaming experience. Decentralized Storage: Assets, metadata, and game states that need to remain accessible and verifiable are stored on decentralized storage solutions like IPFS. This ensures that even if the game servers go offline, critical data remains accessible and tamper-proof. Testing and Continuous Integration: The game undergoes extensive testing phases, including unit tests for smart contracts, integration tests for Web3 interactions, and gameplay tests for overall user experience. Continuous integration tools like GitHub Actions or Jenkins are used to ensure that updates are smoothly deployed without disrupting the game. Community and Governance: The governance mechanism is powered by smart contracts that allow players to vote on game changes. This decentralized governance model is designed using DAO (Decentralized Autonomous Organization) frameworks, giving players a voice in the game\u2019s future development. Conclusion\nCombining blockchain technology with traditional game design principles, this project offers a truly decentralized, player-owned gaming experience. By utilizing cutting-edge tools like Solidity, Web3.js, and decentralized storage solutions, the game not only pushes the boundaries of what\u2019s possible in strategy games but also redefines the relationship between players and their digital assets.",
        "how_its_made": "Blockchain Integration: The game is built on a blockchain network (likely Ethereum or a Layer 2 solution like Polygon) to leverage its decentralized capabilities, ensuring secure, transparent, and immutable gameplay. Smart contracts are at the core, managing game logic, transactions, asset ownership, and interactions between players. Smart Contracts: Smart contracts are developed using Solidity, the primary programming language for Ethereum-based contracts. These contracts handle all game mechanics, including NOUNS token transactions, NFT minting for characters and assets, and the execution of in-game actions like battles and resource gathering. NFTs (Non-Fungible Tokens): Each character, resource, and game asset is represented as an NFT, utilizing standards like ERC-721 or ERC-1155. These tokens provide players with true ownership, allowing them to trade, sell, or use their assets across different platforms. The artwork and metadata for these NFTs are stored on decentralized file storage systems such as IPFS (InterPlanetary File System). Front-End Development: The game\u2019s front end is built using JavaScript frameworks like React or Next.js for a responsive and interactive user experience. Web3.js or Ethers.js libraries are integrated to connect the front end with blockchain, enabling seamless interactions between the players and smart contracts. Backend and Server Architecture: The backend utilizes Node.js along with Express.js to manage game states, player data, and interactions that do not necessarily require blockchain transactions, improving overall performance and reducing on-chain costs. MongoDB is often used for storing non-essential game data that doesn\u2019t require the security of the blockchain. Web3 Integration: Wallet integration, such as MetaMask or WalletConnect, is implemented to enable players to connect their wallets for gameplay, token transactions, and asset management. This setup ensures a smooth user experience, allowing players to interact with the game directly from their wallets. Graphics and Game Design: The game\u2019s graphics, including character models, tiles, and UI elements, are created using tools like Blender and Adobe Illustrator. The game uses isometric 2D or 3D design, giving it a modern, polished look while keeping the gameplay clear and strategic. Unity or Unreal Engine is employed for game development, focusing on smooth animations and intuitive user interactions. Tokenomics and Economy Design: The NOUNS token is designed using ERC-20 standards, facilitating easy integration into the game\u2019s economy. Detailed economic modeling was performed to balance in-game earning potential, rewards, and costs, ensuring a sustainable play-to-earn environment that maintains the game\u2019s competitive balance. Security and Audits: Security audits of the smart contracts are conducted by third-party firms to prevent vulnerabilities such as reentrancy attacks, overflow issues, and other common exploits. This is crucial to maintaining trust and ensuring a fair, secure gaming experience. Decentralized Storage: Assets, metadata, and game states that need to remain accessible and verifiable are stored on decentralized storage solutions like IPFS. This ensures that even if the game servers go offline, critical data remains accessible and tamper-proof. Testing and Continuous Integration: The game undergoes extensive testing phases, including unit tests for smart contracts, integration tests for Web3 interactions, and gameplay tests for overall user experience. Continuous integration tools like GitHub Actions or Jenkins are used to ensure that updates are smoothly deployed without disrupting the game. Community and Governance: The governance mechanism is powered by smart contracts that allow players to vote on game changes. This decentralized governance model is designed using DAO (Decentralized Autonomous Organization) frameworks, giving players a voice in the game\u2019s future development. Conclusion\nCombining blockchain technology with traditional game design principles, this project offers a truly decentralized, player-owned gaming experience. By utilizing cutting-edge tools like Solidity, Web3.js, and decentralized storage solutions, the game not only pushes the boundaries of what\u2019s possible in strategy games but also redefines the relationship between players and their digital assets.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vi5zt/screenshots/d64hr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vi5zt/screenshots/v5z70/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vi5zt/screenshots/y77tr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vi5zt/screenshots/3bmzk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vi5zt/screenshots/f3oex/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Kaushikh76/Battle-Of-Nouns",
        "link": "https://ethglobal.com/showcase/battle-of-nouns-vi5zt"
    },
    {
        "title": "GraphSearch Tools",
        "brief_description": "GraphSearch Tools is a tool to help users quickly query the world of blockchain data with the help of The Graph Network.",
        "long_description": "Graph GPT Search Tools is an AI-powered assistant designed to facilitate interaction with the Graph Protocol. It combines the power of large language models (LLMs) with specialized knowledge of the Graph Protocol to provide a comprehensive toolset for users. Here's a detailed breakdown of its features and capabilities: By combining these features, Graph GPT Search Tools aims to simplify the process of working with the Graph Protocol, making it more accessible to both newcomers and experienced developers. It serves as a bridge between complex blockchain data structures and user-friendly interaction, powered by the intelligence of large language models. Frontend Framework: Programming Language: AI Integration: API: Deployment Platform:",
        "how_its_made": "Frontend Framework: Programming Language: AI Integration: API: Deployment Platform:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wkogo/screenshots/hwpd9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wkogo/screenshots/srn7i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wkogo/screenshots/2go4r/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xbeary/search-graph",
        "link": "https://ethglobal.com/showcase/graphsearch-tools-wkogo"
    },
    {
        "title": "tele.io",
        "brief_description": "Customizable, social platform designed to foster authentic communities in the crypto space, emphasizing verified information and stable, long-term community engagement",
        "long_description": "The proposed platform is a revolutionary SocialFi community application designed to redefine how individuals and groups within the cryptocurrency ecosystem engage, share information, and build communities. Unlike existing social media or chat apps, this platform combines the best of social networking with finance, tailored specifically for the crypto community. It aims to address the pressing need for authenticity, transparency, and structured engagement in the rapidly evolving crypto space. The cryptocurrency market is burgeoning, with millions of global users participating in trading, investing, and developing blockchain-based projects. However, this growth is hampered by fragmented information sources, lack of verified data, and the chaotic nature of community engagement on current platforms. Our solution taps into this untapped market by offering a\ncohesive, customizable, and transparent community-building tool that enhances user experience and trust. Our platform differentiates itself by providing: Frontend Framework:\nThe project is built using Next.js, a React-based framework for building server-side rendered and statically generated web applications. Styling:\nThe project uses Tailwind CSS for styling, as seen in the extensive use of Tailwind classes throughout the components. It also incorporates custom fonts (Geist Sans and Geist Mono) for typography. UI Components:\nThe project utilizes a combination of custom components and a UI library, likely shadcn/ui, as seen in the import statements and the structure of components like Card, Button, and Dialog. State Management and Authentication:\nFirebase is used for authentication, database, and storage. The project includes a custom useAuth hook for managing user authentication state. Blockchain Integration:\nThe project integrates blockchain functionality using Thirdweb, allowing for Web3 features such as wallet connections and smart contract interactions. Responsive Layout:\nThe dashboard uses a responsive grid layout, implemented with react-grid-layout, allowing for a customizable and responsive user interface.",
        "how_its_made": "Our platform differentiates itself by providing: Frontend Framework:\nThe project is built using Next.js, a React-based framework for building server-side rendered and statically generated web applications. Styling:\nThe project uses Tailwind CSS for styling, as seen in the extensive use of Tailwind classes throughout the components. It also incorporates custom fonts (Geist Sans and Geist Mono) for typography. UI Components:\nThe project utilizes a combination of custom components and a UI library, likely shadcn/ui, as seen in the import statements and the structure of components like Card, Button, and Dialog. State Management and Authentication:\nFirebase is used for authentication, database, and storage. The project includes a custom useAuth hook for managing user authentication state. Blockchain Integration:\nThe project integrates blockchain functionality using Thirdweb, allowing for Web3 features such as wallet connections and smart contract interactions. Responsive Layout:\nThe dashboard uses a responsive grid layout, implemented with react-grid-layout, allowing for a customizable and responsive user interface.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9j485/screenshots/3ny3q/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9j485/screenshots/qg45o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9j485/screenshots/cgsx7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9j485/screenshots/7twfj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9j485/screenshots/rbvid/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/alttabdlt/tele.io",
        "link": "https://ethglobal.com/showcase/tele-io-9j485"
    },
    {
        "title": "SEBI Protocol",
        "brief_description": "A decentralised protocol that enables businesses to issue equity tokens easily to raise capital from the global markets with regulatory features like upper/lower circuits, KYCs, dividends.",
        "long_description": "Despite being such a happening place, DeFi is comparatively much smaller than traditional finance and stock markets. While blockchain has emerged as the technology that enables a permissionless and open internet, the average individual still considers DeFi/crypto as gambling due to speculation and the lack of a governing body to ensure fair practices. SEBI Protocol is designed to introduce investment rules for businesses similar to those in stock markets, with community-based governance rather than an individual body. This creates an opportunity for retail investors to join blockchain-based investments and bring in more capital. The project uses uniswap v4 hooks for regulating exchange transactions and governance system at token level for changing these regulations. So there are 3 parts:",
        "how_its_made": "The project uses uniswap v4 hooks for regulating exchange transactions and governance system at token level for changing these regulations. So there are 3 parts:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/y8ir7/screenshots/o0x3h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8ir7/screenshots/inirv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8ir7/screenshots/67w9i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8ir7/screenshots/0wy33/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8ir7/screenshots/a5ev6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8ir7/screenshots/81heq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/SEBI-Protocol",
        "link": "https://ethglobal.com/showcase/sebi-protocol-y8ir7"
    },
    {
        "title": "F1 Bets",
        "brief_description": "A prediction market on the current hype of F1 as a telegram mini app with private bets enabled on Fhenix and Oasis, and a DAO for dispute resolution",
        "long_description": "A prediction market on the current hype of F1 as a telegram mini app with private bets enabled on Fhenix and Oasis, and a DAO for dispute resolution. Users can use the app to place bets view the total value locked and their potential earnings from the bet. Once the market ends the user will be able to pull out his funds The project is deployed over telegram mini app, and the contracts are deployed over Fhenix, Oasis, Morph and Air Dao testnets. We have used dynamic for helping the user connect his wallet. We used solidity for writing the smart contracts across all the above EVM compatible chains",
        "how_its_made": "The project is deployed over telegram mini app, and the contracts are deployed over Fhenix, Oasis, Morph and Air Dao testnets. We have used dynamic for helping the user connect his wallet. We used solidity for writing the smart contracts across all the above EVM compatible chains",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/y39gb/screenshots/ecxgv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y39gb/screenshots/ukvo3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y39gb/screenshots/2hxrs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y39gb/screenshots/7wp9w/default.jpg"
        ],
        "live_demo": "https://telegram-betting.vercel.app/",
        "source_code": "https://github.com/kalashshah/telegram-betting",
        "link": "https://ethglobal.com/showcase/f1-bets-y39gb"
    },
    {
        "title": "sToken",
        "brief_description": "sToken is a Liquid Staking rollup based token working on across multiple chains allowing users to bridge ETH from any chain, using HyperLane to get LST tokens in return. It also implements a reward mechanism using 1inch ERC20 Plugins.",
        "long_description": "Features Important Notes Possible Use Cases I used stackr sdk for creating this project on AvailDA. Key Components Include - -- State Transition Functions (STFs) Token Management Bridging AVL Staking --Tech Stack -- 1inch Token Plugin Users accumulate holding time for their sTokens.\nLonger hold times result in higher reward multipliers.\nMaximum multiplier (2x) achieved after one year of holding. Contract owner can set and update the total reward pool.\nRewards are distributed proportionally based on user balances and hold times. Stores user balances, last update times, and accumulated holding times.\nAutomatically updates user information on token transfers, mints, and burns. Users can claim rewards based on their balance and accumulated hold time.\nPrevents double-claiming through a mapping of claimed status.",
        "how_its_made": "I used stackr sdk for creating this project on AvailDA. Key Components Include - -- State Transition Functions (STFs) Token Management Bridging AVL Staking --Tech Stack -- 1inch Token Plugin Users accumulate holding time for their sTokens.\nLonger hold times result in higher reward multipliers.\nMaximum multiplier (2x) achieved after one year of holding. Contract owner can set and update the total reward pool.\nRewards are distributed proportionally based on user balances and hold times. Stores user balances, last update times, and accumulated holding times.\nAutomatically updates user information on token transfers, mints, and burns. Users can claim rewards based on their balance and accumulated hold time.\nPrevents double-claiming through a mapping of claimed status.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xigf0/screenshots/mksr2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xigf0/screenshots/su2pd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xigf0/screenshots/oi5c9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/parthg1901/sTokens",
        "link": "https://ethglobal.com/showcase/stoken-xigf0"
    },
    {
        "title": "Voice4Invoice",
        "brief_description": "Generate tamper-proof, attested invoices for your customers when receiving crypto payments.",
        "long_description": "Business owners can simply pass the transaction hash and purchase details to attest and generate an immutable, verifiable PDF invoice using Sign Protocol. Sharing transaction hashes alone isn't the best user experience for mass adoption\u2014this solution bridges that gap by offering easily accessible invoices. In cases like reimbursements, you can share the invoice, and anyone can verify its authenticity This solution is built using Sign Protocol's Schema Builder to define the invoice structure, Attestation to verify the transaction details, and an Indexer for seamless verification. It is currently deployed on Ethereum Sepolia, ensuring the invoices are secure, tamper-proof, and easily verifiable on the blockchain.",
        "how_its_made": "This solution is built using Sign Protocol's Schema Builder to define the invoice structure, Attestation to verify the transaction details, and an Indexer for seamless verification. It is currently deployed on Ethereum Sepolia, ensuring the invoices are secure, tamper-proof, and easily verifiable on the blockchain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/whaqv/screenshots/pj0z3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/whaqv/screenshots/e05b8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/whaqv/screenshots/c5dxm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xjba/voice4invoice",
        "link": "https://ethglobal.com/showcase/voice4invoice-whaqv"
    },
    {
        "title": "EZSplit",
        "brief_description": "Use multisignature wallet and telegram bot integration to smoothen financial transactions on-chain.",
        "long_description": "EZSplit is an application designed to simplify on-chain transaction management for groups. With our Telegram bot integration, users can effortlessly add and settle group expenses, making financial interactions smooth and efficient.\nGroup Expense Management: Easily add expenses within your Telegram group using simple commands.\nSettlement Mechanism: Settle net balances among group members with a single button click.\nMultisig Wallets: Each user in the group is provided with a multisig wallet for secure transaction signing.\nTelegram Bot Integration: Seamlessly interact with the application through a Telegram bot. This project uses python's telegram library for the creation of the bot functionality. It has a backend and a site as well. The backend has the core logic for maintenance of how the bot handles the multi-signature wallets which is written using Javascript and the frontend handles the creation of the multi-signature and shows user's dashboard. The frontend is written using typescript and Nextjs",
        "how_its_made": "This project uses python's telegram library for the creation of the bot functionality. It has a backend and a site as well. The backend has the core logic for maintenance of how the bot handles the multi-signature wallets which is written using Javascript and the frontend handles the creation of the multi-signature and shows user's dashboard. The frontend is written using typescript and Nextjs",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/4wkpk/screenshots/d687h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4wkpk/screenshots/tmadh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4wkpk/screenshots/nrijj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4wkpk/screenshots/8q5xe/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4wkpk/screenshots/adsf1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Mihir1101/EZSplit",
        "link": "https://ethglobal.com/showcase/ezsplit-4wkpk"
    },
    {
        "title": "zSki",
        "brief_description": "P2P DFS incorporating zk-security. This extended architecture combines advanced cryptographic techniques with decentralized systems to create a robust, secure, and privacy-preserving distributed file system.",
        "long_description": "Made a p2p network to store cache for a distributed file system storage while integrating zk-security. The files are stored with peers with zk security and computed and made together via fhe. The cache is state of the data structure.This extended system creates a highly secure, private, and efficient distributed file system with an integrated cache layer. The combination of FHE, ZK-proofs, and advanced P2P protocols allows for complex computations on encrypted data while maintaining strong security guarantees. The distributed cache enhances performance and reduces latency for frequently accessed data, while the additional features provide improved privacy, verifiability, and resilience. Made a p2p network to store cache for a distributed file system storage while integrating zk-security. Had used zk libraries and other standard tcp libraries from go to make it successful. This implementation provides a more secure and distributed approach to caching in your P2P file system. The use of ZK proofs ensures that cache integrity can be verified without revealing the underlying data. The P2P communication allows for efficient propagation of cache updates across the network.",
        "how_its_made": "Made a p2p network to store cache for a distributed file system storage while integrating zk-security. Had used zk libraries and other standard tcp libraries from go to make it successful. This implementation provides a more secure and distributed approach to caching in your P2P file system. The use of ZK proofs ensures that cache integrity can be verified without revealing the underlying data. The P2P communication allows for efficient propagation of cache updates across the network.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bcpn4/screenshots/a3qt2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bcpn4/screenshots/er9mc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bcpn4/screenshots/xbjvt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bcpn4/screenshots/nijsx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bcpn4/screenshots/ffnnq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bcpn4/screenshots/37z8n/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/aditya-git16/dfs-go",
        "link": "https://ethglobal.com/showcase/zski-bcpn4"
    },
    {
        "title": "Omagle2.0",
        "brief_description": "Omagle 2.0 powered by Reclaim. Chat/videocall with your Duolingo crush",
        "long_description": "Import your Duolingo data, chat, and video call with people who share similar interests or achievements \ud83d\ude03. With Reclaim Protocol, you can export data from any application\u2014even if they don\u2019t have official APIs. It generates a zero-knowledge proof (ZKProof), allowing you to verify and securely share your data without exposing personal details. This opens up endless possibilities. In this app, you\u2019ll import your Duolingo achievements, select your preferences, and instantly connect with others who have similar learning goals. Whether it\u2019s chatting or jumping into a video call, this platform makes it easy to find like-minded learners based on your verified progress. Perfect for language enthusiasts who want to practice, share tips, or just make new friends on their language-learning journey! Reclaim Protocol is a privacy-focused tool that allows users to pull their data from various applications\u2014even if those apps don\u2019t have official APIs. It extracts this data, generates a zero-knowledge proof (ZKProof), and shares it securely. A ZKProof is a cryptographic method that allows you to prove you have certain data (like your Duolingo achievements) without actually revealing the data itself. This ensures privacy while still allowing verification, giving users full control over their information. How Does the Application Work? In this app, you can import your Duolingo data\u2014specifically, your achievements\u2014using Reclaim Protocol. Once your achievements are imported, you can select your preferences (such as which achievements to share) and connect with others who have similar interests or skill levels. The app also allows you to chat and video call with people who share similar learning goals. By verifying your Duolingo progress through ZKProof, you can make sure you\u2019re matched with others at your level, creating a personalized and engaging language-learning experience.",
        "how_its_made": "Reclaim Protocol is a privacy-focused tool that allows users to pull their data from various applications\u2014even if those apps don\u2019t have official APIs. It extracts this data, generates a zero-knowledge proof (ZKProof), and shares it securely. A ZKProof is a cryptographic method that allows you to prove you have certain data (like your Duolingo achievements) without actually revealing the data itself. This ensures privacy while still allowing verification, giving users full control over their information. How Does the Application Work? In this app, you can import your Duolingo data\u2014specifically, your achievements\u2014using Reclaim Protocol. Once your achievements are imported, you can select your preferences (such as which achievements to share) and connect with others who have similar interests or skill levels. The app also allows you to chat and video call with people who share similar learning goals. By verifying your Duolingo progress through ZKProof, you can make sure you\u2019re matched with others at your level, creating a personalized and engaging language-learning experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/c6gdy/screenshots/npk0i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c6gdy/screenshots/87qjk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c6gdy/screenshots/h4c77/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c6gdy/screenshots/ekxcd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c6gdy/screenshots/hmmkv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Koushith/Eth-SG-duolingo-chat",
        "link": "https://ethglobal.com/showcase/omagle2-0-c6gdy"
    },
    {
        "title": "DIGITAL TRUST",
        "brief_description": "To building a trusted and secure digital ecosystem. This initiative aims to position Singapore as a global node for digital and data, founded on trust which can be replicated to other cities.",
        "long_description": "The Digital Trust solutions project, specifically designed from a communication, marcom, and creative perspective with blockchain technology as a core element. Blockchain\u2019s decentralized nature provides a foundation of trust by enhancing security and transparency across various sectors. leverage blockchain technology to provide secure, transparent, and immutable solutions for consumer awareness and education. We aim to address key stakeholders \u2014 citizens, businesses, governments, and regulators \u2014 through blockchain-driven methods to combat scams, fraud, and cyberattacks. Blockchain Solution Components: Decentralized Identity Verification, Ledger for Transparency, Smart Contracts for Consumer Protection, A blockchain-based public awareness platform could educate citizens. Blockchain-enhanced Playbook and Communication Guidelines. Blockchain-verified Communication, Sector-specific Testing and Evaluation, Comprehensive Incident Response Plan, Messaging Framework with Blockchain Integration. And to bring in Blockchain-powered Interactive Microsites, Explanatory Videos on  Benefits, Cybersecurity Games. Partnerships and Blockchain Integration: Cybersecurity and Blockchain Firms, Blockchain-driven Digital Marketing Assets. Messaging Pillars for Blockchain-enhanced Trust: Misinformation and Online Scams, Misuse of Data. and Cyber Trusts. Aim to build engaging, informative campaigns to educate key stakeholders on the importance of using blockchain for digital trust. Key Concepts: Public Good. DePin Infrastrucute - like public transportation (SMRT. MRT etc), Digital Trust: Implementing blockchain-based verification mechanisms to build trust among users without sacrificing their privacy or identity. For eg:-Anonymous verification methods such as Aadhaar-linked identities (without revealing PII) can be integrated into the ecosystem. To top it up -Bringing memecoins into the realm of public goods can be a creative and impactful way to leverage the viral nature of these coins while supporting initiatives that benefit society.",
        "how_its_made": "Blockchain Solution Components: Decentralized Identity Verification, Ledger for Transparency, Smart Contracts for Consumer Protection, A blockchain-based public awareness platform could educate citizens. Blockchain-enhanced Playbook and Communication Guidelines. Blockchain-verified Communication, Sector-specific Testing and Evaluation, Comprehensive Incident Response Plan, Messaging Framework with Blockchain Integration. And to bring in Blockchain-powered Interactive Microsites, Explanatory Videos on  Benefits, Cybersecurity Games. Partnerships and Blockchain Integration: Cybersecurity and Blockchain Firms, Blockchain-driven Digital Marketing Assets. Messaging Pillars for Blockchain-enhanced Trust: Misinformation and Online Scams, Misuse of Data. and Cyber Trusts. Aim to build engaging, informative campaigns to educate key stakeholders on the importance of using blockchain for digital trust. Key Concepts: Public Good. DePin Infrastrucute - like public transportation (SMRT. MRT etc), Digital Trust: Implementing blockchain-based verification mechanisms to build trust among users without sacrificing their privacy or identity. For eg:-Anonymous verification methods such as Aadhaar-linked identities (without revealing PII) can be integrated into the ecosystem. To top it up -Bringing memecoins into the realm of public goods can be a creative and impactful way to leverage the viral nature of these coins while supporting initiatives that benefit society.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fnsqs/screenshots/3v1pv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fnsqs/screenshots/696so/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fnsqs/screenshots/ey8nt/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/adpr142/HackRx",
        "link": "https://ethglobal.com/showcase/digital-trust-fnsqs"
    },
    {
        "title": "#PredictAI",
        "brief_description": "#PredictAI is the AI-powered Prediction Marketplace on Morph which uses AI to generate and/or settle the predictions.",
        "long_description": "#predictAI is the platform that combines AI with prediction marketplace to make it super scalble with decentralized event (bet) creation. How It Works: Users log in via Dynamic's simple authentication.\nThey choose a topic or use AI to generate interesting bets.\nParticipants place bets using testnet funds (easily obtained through our integrated faucet).\nFor crypto-related bets, Pyth Network provides accurate, real-time price data.\nWhen a bet concludes, our AI (powered by Phala Network) analyzes the latest information to determine the winner. Our goal with #predictAI was to create a seamless, AI-powered prediction marketplace. Here's a deep dive into our tech stack and build process: Frontend: Next.js with TypeScript Smart Contracts: Solidity Backend AI: Phala Network's Agent Contract plus OpenAI for backup Authentication: Dynamic SDK Oracle Integration: Pyth Network Integration and Challenges: AI-Agent  Contract by Phala : The gas kept running out,had to use multiple apis UX   -\nChallenge: Simplifying the testnet fund acquisition process Partner Integrations : Phala Network: Dynamic: Pyth Network: Morph: The most challenging (and rewarding) part was orchestrating these diverse technologies into a cohesive, user-friendly platform. Our \"Request Funds\" feature, while simple on the surface, required careful integration with Dynamic's wallet creation process and our custom faucet contract.",
        "how_its_made": "Our goal with #predictAI was to create a seamless, AI-powered prediction marketplace. Here's a deep dive into our tech stack and build process: Frontend: Next.js with TypeScript Smart Contracts: Solidity Backend AI: Phala Network's Agent Contract plus OpenAI for backup Authentication: Dynamic SDK Oracle Integration: Pyth Network Integration and Challenges: AI-Agent  Contract by Phala : The gas kept running out,had to use multiple apis UX   -\nChallenge: Simplifying the testnet fund acquisition process Partner Integrations : Phala Network: Dynamic: Pyth Network: Morph: The most challenging (and rewarding) part was orchestrating these diverse technologies into a cohesive, user-friendly platform. Our \"Request Funds\" feature, while simple on the surface, required careful integration with Dynamic's wallet creation process and our custom faucet contract.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yc2p6/screenshots/rjz8p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yc2p6/screenshots/5w6nf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yc2p6/screenshots/jrscu/default.jpg"
        ],
        "live_demo": "https://ai-predict.vercel.app/",
        "source_code": "https://github.com/argenestel/ai-predict/",
        "link": "https://ethglobal.com/showcase/predictai-yc2p6"
    },
    {
        "title": "Yggdrasil Network",
        "brief_description": "The Yggdrasil Network is a Chain Abstraction Infrastructure Layer that acts as a connective tissue, abstracting the world of blockchains.",
        "long_description": "The Yggdrasil Network  is a cross-chain liquidity pool aggregator. It has an LP aggregator to aggregate the real-time data and a route intent to fetch the most optimised route across the ecosystems and an order engine for smooth trade execution.\nThe Yggdrasil Network is a Chain Abstraction Infrastructure Layer that acts as a connective tissue, abstracting the world of blockchains. It's based on concept of Atomic Swaps using HTLCs\nThe Yggdrasil Network  is a cross-chain liquidity pool aggregator. It has an LP aggregator to aggregate the real-time data and a route intent to fetch the most optimised route across the ecosystems and an order engine for smooth trade execution.\nThe Yggdrasil Network is a Chain Abstraction Infrastructure Layer that acts as a connective tissue, abstracting the world of blockchains.",
        "how_its_made": "It's based on concept of Atomic Swaps using HTLCs\nThe Yggdrasil Network  is a cross-chain liquidity pool aggregator. It has an LP aggregator to aggregate the real-time data and a route intent to fetch the most optimised route across the ecosystems and an order engine for smooth trade execution.\nThe Yggdrasil Network is a Chain Abstraction Infrastructure Layer that acts as a connective tissue, abstracting the world of blockchains.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jotfd/screenshots/ojsz0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jotfd/screenshots/u54g4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jotfd/screenshots/e6bcu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/YggdrasilNetwork/ETHGlobal-Sg",
        "link": "https://ethglobal.com/showcase/yggdrasil-network-jotfd"
    },
    {
        "title": "isFOMO",
        "brief_description": "Better market emotion detection platform  and  better liquidity strategy",
        "long_description": "Currently, many users in the market seek more information related to Memecoins or trending topics to assist them in making investment decisions. AI can effectively help analyze market sentiment, thereby capturing the short-term price trends of Memecoins. Users can also utilize our smart contracts, which integrate the liquidity pool management features of Uniswap V4. By providing meme assets, users can gain higher liquidity returns. As a platform, we not only offer market sentiment analysis but also provide asset appreciation custodial services for our users. Mindmap link: https://excalidraw.com/#json=4zNKOwAFmq5a5frYhmYfD,Pwiy72WbzdqHdvkdEKD4xw The isFOMO project utilizes Gaia for AI service hosting, which is stored on the blockchain to ensure the robustness of prediction services. The LLAMA model serves as the foundation, with modifications made to the final layer to enhance the accuracy of its functionality. For liquidity management, Chainlink's oracle and Uniswap V4's liquidity pool management features are employed. Furthermore, the isFOMO smart contract records the AI's analysis results at different time intervals, ensuring data traceability.",
        "how_its_made": "The isFOMO project utilizes Gaia for AI service hosting, which is stored on the blockchain to ensure the robustness of prediction services. The LLAMA model serves as the foundation, with modifications made to the final layer to enhance the accuracy of its functionality. For liquidity management, Chainlink's oracle and Uniswap V4's liquidity pool management features are employed. Furthermore, the isFOMO smart contract records the AI's analysis results at different time intervals, ensuring data traceability.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8ty8m/screenshots/33djs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8ty8m/screenshots/g9d3k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8ty8m/screenshots/uen5w/default.jpg"
        ],
        "live_demo": "https://isfomo.vercel.app/",
        "source_code": "https://github.com/b21quocbao/isfomo",
        "link": "https://ethglobal.com/showcase/isfomo-8ty8m"
    },
    {
        "title": "CrossChain Scheduler",
        "brief_description": "CrossChain Scheduler: Revolutionizing DeFi Automation Across Blockchains",
        "long_description": "Overview: CrossChain Scheduler is a groundbreaking dApp and protocol that empowers users to automate complex, multi-step DeFi strategies across multiple blockchains. By leveraging LayerZero's cutting-edge cross-chain messaging technology, our platform opens up a new world of possibilities for traders, investors, and DeFi enthusiasts. Features: Use Cases: Smart Contracts: -Solidity-based contracts deployed on multiple EVM-compatible chains\n-Integration with LayerZero endpoints for cross-chain messaging\n-Task creation and management contracts Backend Infrastructure: Frontend dApp: Cross-Chain Communication: Swaps:",
        "how_its_made": "Smart Contracts: -Solidity-based contracts deployed on multiple EVM-compatible chains\n-Integration with LayerZero endpoints for cross-chain messaging\n-Task creation and management contracts Backend Infrastructure: Frontend dApp: Cross-Chain Communication: Swaps:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1rkb4/screenshots/tb2hi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1rkb4/screenshots/y2pu5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1rkb4/screenshots/ctwt5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/valeriofichera/singapore-scheduler",
        "link": "https://ethglobal.com/showcase/crosschain-scheduler-1rkb4"
    },
    {
        "title": "Swint",
        "brief_description": "Swint  is a ERC7683 inspired project which facilitates cross chain swaps with Unified liquidity",
        "long_description": "Swint is a cutting-edge project inspired by the ERC7683 standard, which revolves around facilitating cross-chain swaps using unified liquidity pools. The goal of Swint is to enable users to swap assets across different blockchains seamlessly, tapping into a single pool of liquidity that spans multiple chains. Let\u2019s break down the key components and how they work together. ERC7683 is a conceptual standard that may focus on cross-chain token transfers or unified liquidity management. Though the exact nature of ERC7683 can vary, it primarily revolves around asset interoperability, cross-chain communication, and liquidity management across multiple blockchains. Swint takes inspiration from this and aims to implement its principles by focusing on efficient liquidity usage across various chains, ensuring users can swap tokens between different blockchains without friction. The cross-chain swaps feature allows users to swap assets from one blockchain (like Ethereum) to another (like Binance Smart Chain, Polygon, etc.). However, unlike conventional cross-chain swaps, which often rely on separate liquidity pools for each blockchain, Swint leverages unified liquidity. Unified liquidity refers to a system where liquidity is pooled and shared across multiple chains. This makes the process more efficient because liquidity is not siloed on each individual chain but instead available to all chains connected through the system. This reduces slippage and makes swaps faster and more efficient. One of the key innovations in Swint is how it uses the Phala Network. The Phala Network is a privacy-focused, decentralized compute cloud built on Substrate, designed for confidential smart contracts. In Swint case, Phala Network is used to extract data from the user\u2019s intent. This means that when a user wants to perform a cross-chain swap, the Phala network processes and interprets their request (intent) in a secure and privacy-preserving way. By utilizing Phala\u2019s off-chain computation capabilities, Swint can determine the best way to fulfill the user\u2019s request (i.e., which routes, networks, or liquidity pools to use), while maintaining user privacy and reducing on-chain computation costs. Once the user\u2019s intent is understood, Swint uses two key technologies to facilitate the swap and transfer of assets: Here\u2019s how the entire process in Swint works, step by step: In summary, Swint is an innovative cross-chain swap platform that leverages the power of unified liquidity, Phala\u2019s privacy-focused intent processing, 1inch\u2019s efficient swapping, and Hyperlane\u2019s secure cross-chain messaging to offer a seamless experience for users swapping assets between multiple blockchains. We have used Phala Network,1inch and Hyperlane for this project Here\u2019s how the entire process in Swint works, step by step: ###nPhala Network: Extracting User Intent",
        "how_its_made": "We have used Phala Network,1inch and Hyperlane for this project Here\u2019s how the entire process in Swint works, step by step: ###nPhala Network: Extracting User Intent",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/nhum4/screenshots/tok38/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nhum4/screenshots/igwh4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nhum4/screenshots/0d0e0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nhum4/screenshots/tgp1b/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ArpitaGanatra/swint",
        "link": "https://ethglobal.com/showcase/swint-nhum4"
    },
    {
        "title": "MACPI",
        "brief_description": "A reliable DAO voting infrastructure for next billion users \u2310\u25e8-\u25e8",
        "long_description": "MACPI(Minimal Anti-Collusion Physical Infrastructure) is designed for helping billions of users onboard a DAO and start participating in governance privately without any blockchain knowledge, they do not even need to know how to use smart phones.\nWe aims to build the most secure IRL voting solution available. It has NFC-enabled on-chain voting processes with reduced risk of cheating, through the use of smart contracts, and zero-knowledge proofs.\nWith a NFC bracelet, voting now comes back to its original definition: Choose an option, and confirm. On-chain Voting infrastructure\nMACPI uses MACI sponsored by @Ethereum Foundation to ensure the security of the whole voting process. It provided MACPI with excellent anti-collusion mechanisms and MACPI help bring MACI to billions of users.\nCulture & Use case\nMACPI loves the culture of Nouns and designs based on the governance scenario of @NounsDAO- high value staked and anti-collusion mechanisms are critical.\nNFC\nWe are using the official ethglobal NFC bracelet powered by ARX to sign message.",
        "how_its_made": "On-chain Voting infrastructure\nMACPI uses MACI sponsored by @Ethereum Foundation to ensure the security of the whole voting process. It provided MACPI with excellent anti-collusion mechanisms and MACPI help bring MACI to billions of users.\nCulture & Use case\nMACPI loves the culture of Nouns and designs based on the governance scenario of @NounsDAO- high value staked and anti-collusion mechanisms are critical.\nNFC\nWe are using the official ethglobal NFC bracelet powered by ARX to sign message.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/r3i87/screenshots/h00zu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r3i87/screenshots/1sbhv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r3i87/screenshots/y4qwa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r3i87/screenshots/yc180/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r3i87/screenshots/jo4my/default.jpg"
        ],
        "live_demo": "https://macpi.vercel.app/",
        "source_code": "https://github.com/0xhardman/tap-maci",
        "link": "https://ethglobal.com/showcase/macpi-r3i87"
    },
    {
        "title": "Soulbound Token",
        "brief_description": "A token standard for Soulbound Tokens for AirDAO. The contract is modelled after ERC721.sol but is non-transferable with reputation management (achievements). Achievements can be granted/revoked to support token gated communities.",
        "long_description": "Soulbound Token Standard (SBT) This can be found under /src/SoulBoundTokenStandard and competes for the Soul Bound Tokens (SBT\u2019s) on AirDAO prize category. The contract is modelled after ERC721.sol but is non-transferable with reputation management (achievements). Achievements can be granted/revoked to support token gated communities. This is implemented by writing directly to the metadata through the URI. Usually it's expensive to perform string manipulation to store json strings in the URI but AirDAO is known for cheap fees so it's cheaper to pay gas than to use a decentralized storage like IPFS. Soulbound Token Standard (SBT) This can be found under /src/SoulBoundTokenStandard and competes for the Soul Bound Tokens (SBT\u2019s) on AirDAO prize category. The contract is modelled after ERC721.sol but is non-transferable with reputation management (achievements). Achievements can be granted/revoked to support token gated communities. This is implemented by writing directly to the metadata through the URI. Usually it's expensive to perform string manipulation to store json strings in the URI but AirDAO is known for cheap fees so it's cheaper to pay gas than to use a decentralized storage like IPFS.",
        "how_its_made": "Soulbound Token Standard (SBT) This can be found under /src/SoulBoundTokenStandard and competes for the Soul Bound Tokens (SBT\u2019s) on AirDAO prize category. The contract is modelled after ERC721.sol but is non-transferable with reputation management (achievements). Achievements can be granted/revoked to support token gated communities. This is implemented by writing directly to the metadata through the URI. Usually it's expensive to perform string manipulation to store json strings in the URI but AirDAO is known for cheap fees so it's cheaper to pay gas than to use a decentralized storage like IPFS.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6yp2y/screenshots/840zf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6yp2y/screenshots/udacq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6yp2y/screenshots/0cpvz/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/randyahx/airdao-soulbound-token",
        "link": "https://ethglobal.com/showcase/soulbound-token-6yp2y"
    },
    {
        "title": "DCAwesome",
        "brief_description": "Decentralized Dollar Cost Averaging (DCA) Platform, Set up & Automate",
        "long_description": "This project implements a decentralized Dollar Cost Averaging (DCA) platform that allows users to create personalized, automated cryptocurrency investment strategies. The platform enables users to set up both buy-in (DCAIN) and sell-off (DCAOUT) strategies, operating on a \"set and forget\" principle for hands-off portfolio management. We linked smart contracts repo, but check also frontend and strategy in the organization please User-Specific Strategies: Each user can create and manage their own DCA strategy through a dedicated smart contract.\nFlexible DCAIN:\nUsers can deposit USDC into their strategy contract at any time.\nThe DCAIN function uses the accumulated USDC balance for monthly investments.\nUsers can split their investment equally into up to three different cryptocurrencies of their choice.\nCustomizable DCAOUT:\nUsers can set specific conditions for profit realization.\nDCAOUT converts invested tokens back to USDC based on user-defined parameters.\nSelf-Custody: Each strategy contract is controlled solely by its creator, ensuring fund security and user autonomy.\nAutomated Execution: Strategies are executed automatically based on predefined conditions and time intervals.\nUniswap Integration: The platform uses Uniswap V3 for all token swaps, ensuring liquidity and competitive rates.\nChainlink Oracle: Price feeds from Chainlink are used to trigger DCAOUT strategies based on market conditions.\nPause/Resume Functionality: Users can pause and resume their DCAIN and DCAOUT strategies as needed.",
        "how_its_made": "User-Specific Strategies: Each user can create and manage their own DCA strategy through a dedicated smart contract.\nFlexible DCAIN:\nUsers can deposit USDC into their strategy contract at any time.\nThe DCAIN function uses the accumulated USDC balance for monthly investments.\nUsers can split their investment equally into up to three different cryptocurrencies of their choice.\nCustomizable DCAOUT:\nUsers can set specific conditions for profit realization.\nDCAOUT converts invested tokens back to USDC based on user-defined parameters.\nSelf-Custody: Each strategy contract is controlled solely by its creator, ensuring fund security and user autonomy.\nAutomated Execution: Strategies are executed automatically based on predefined conditions and time intervals.\nUniswap Integration: The platform uses Uniswap V3 for all token swaps, ensuring liquidity and competitive rates.\nChainlink Oracle: Price feeds from Chainlink are used to trigger DCAOUT strategies based on market conditions.\nPause/Resume Functionality: Users can pause and resume their DCAIN and DCAOUT strategies as needed.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gno1o/screenshots/0y4xv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gno1o/screenshots/c61ru/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gno1o/screenshots/0ar3s/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/EthGlobalSingapore/Smart-Contracts",
        "link": "https://ethglobal.com/showcase/dcawesome-gno1o"
    },
    {
        "title": "Rupabase",
        "brief_description": "Rupabase is a web3 BaaS platform that empowers developers by providing them with DB instances managed by Rupabase itself and an intuitive and easy to use set of solidity methods to query databases.",
        "long_description": "Rupabase is a web3 backend as a service platform through which web3 developers can spin up database instances and abstracts away their management by providing a set of solidity methods to call to interact with the instances. This way developers get a multi purpose database which their dApps can access from anywhere - the frontend, smart contracts or any other backend involved.\nProject owners can add other smart contracts/wallets as having all permissions except creating databases, enabling access to the same database to different dApps on the same chain.\nRupabase's architecture allows for ZERO EFFORT cross chain interoperability as the project owners just need to connect their wallet on a network to the admin portal frontend to get authorized on that chain and multiple dApps on same/different chains can access databases by calling chain-independent code.\nRupabase doesn't stop here. By using data availability layers and rollups, we can enable on-chain databases for both on chain as well as off chain usage. Novel and community helping projects that can be made using Rupabase include a web3 based Machine Learning dataset collection platform, where different users initialize datasets, getting full control over that dataset and allowing others to put in more data. This will save huge time for researchers and engineers alike who otherwise have to scan through the internet, gathering different datasets uploaded by different users, combining them themselves. Rupabase can enable such a project so that dataset owners can add verified people to add more data to their datasets, helping the community This project uses Chainlink Functions for hitting REST API endpoints on an off-chain server. Dynamic was used for login purposes and the design system was inspired by the Noun Foundation's design system. The admin portal was brought to life using ReactJS.\nWe setup a contract deployed on the Sepolia testnet that can be called by any contract/wallet on the Sepolia testnet (we chose Sepolia testnot only for PoC purposes, Rupabase's smart contract can be deployed to all networks supported by Chainlink Functions as of now).\nCurrently, logic for verifying users is out of the scope as it is not an innovative element of the project. Using Chainlink functions turned out to be a learning experience as we faced errors not documented in the official documentation of the BETA feature, and Chainlink mentors' also got to know of the issues after contacting their core engineering team, after collaborative debugging sessions of me with them!\nNoun Foundation's design philosophy and helping the community track motivated us to think of the possible real life use cases of the project, involving a community based dataset platform for Machine Learning.",
        "how_its_made": "This project uses Chainlink Functions for hitting REST API endpoints on an off-chain server. Dynamic was used for login purposes and the design system was inspired by the Noun Foundation's design system. The admin portal was brought to life using ReactJS.\nWe setup a contract deployed on the Sepolia testnet that can be called by any contract/wallet on the Sepolia testnet (we chose Sepolia testnot only for PoC purposes, Rupabase's smart contract can be deployed to all networks supported by Chainlink Functions as of now).\nCurrently, logic for verifying users is out of the scope as it is not an innovative element of the project. Using Chainlink functions turned out to be a learning experience as we faced errors not documented in the official documentation of the BETA feature, and Chainlink mentors' also got to know of the issues after contacting their core engineering team, after collaborative debugging sessions of me with them!\nNoun Foundation's design philosophy and helping the community track motivated us to think of the possible real life use cases of the project, involving a community based dataset platform for Machine Learning.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/aa4xc/screenshots/bc0xj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aa4xc/screenshots/wqpzc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aa4xc/screenshots/w6jc4/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MDG-ETHSingapore-2024",
        "link": "https://ethglobal.com/showcase/rupabase-aa4xc"
    },
    {
        "title": "Connector",
        "brief_description": "cross-chain liquidity movement and looping strategies in a single click using CCIP, LayerZero, and top DeFi protocols.",
        "long_description": "We are building a hackathon project that enables seamless cross-chain liquidity movement and advanced DeFi strategies in a single click. Our solution integrates two cutting-edge cross-chain messaging protocols, CCIP (Chainlink Cross-Chain Interoperability Protocol) and LayerZero, to move liquidity across multiple blockchains, offering users a smooth and efficient experience. The project allows users to transfer liquidity between networks, such as Base, Arbitrum, and Linea, without needing to manually bridge assets. Once liquidity is moved cross-chain, users can perform looping strategies on Liquid Staking Tokens (LST) and Liquid Representation Tokens (LRT) like wstETH using DeFi protocols such as AAVE and Zerolend. Looping strategies maximize capital efficiency by automatically borrowing, staking, and repeating the process in a single transaction, optimizing yields for users. We have integrated Reown's app kit for essential dApp functionalities such as wallet connection, social login, swapping, and onramping, making the platform accessible for both seasoned DeFi users and newcomers. The user interface also displays the ENS (Ethereum Name Service) of users for enhanced user identification and experience. For real-time and accurate price feeds, we rely on Pyth Network, ensuring precise data for liquidity and collateral management. The use of Pyth\u2019s price feeds allows us to offer robust pricing solutions for DeFi strategies within the platform. In summary, this project brings together cross-chain liquidity transfer, advanced DeFi strategies, and a user-friendly interface powered by Reown's app kit, allowing users to perform complex financial operations in a simplified and cost-efficient manner. Here\u2019s a detailed explanation for How it\u2019s made: Our project is built on a combination of cross-chain messaging protocols, DeFi integration, and user experience enhancements, all carefully pieced together to offer a streamlined and efficient liquidity movement system with advanced financial strategies. Here's a breakdown of the technologies and how we combined them: Docs of the protocol is super Amazing and whenever we are struck on the Docs, their team help us. shoutout to the amazing team",
        "how_its_made": "Here\u2019s a detailed explanation for How it\u2019s made: Our project is built on a combination of cross-chain messaging protocols, DeFi integration, and user experience enhancements, all carefully pieced together to offer a streamlined and efficient liquidity movement system with advanced financial strategies. Here's a breakdown of the technologies and how we combined them: Docs of the protocol is super Amazing and whenever we are struck on the Docs, their team help us. shoutout to the amazing team",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/70emz/screenshots/t28rx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70emz/screenshots/y6gxy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70emz/screenshots/rrw63/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70emz/screenshots/zy5vm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70emz/screenshots/z6yw5/default.jpg"
        ],
        "live_demo": "https://connector-dapp.vercel.app",
        "source_code": "https://github.com/aayush-gupta-coder/connector",
        "link": "https://ethglobal.com/showcase/connector-70emz"
    },
    {
        "title": "DAOTown",
        "brief_description": "Managing DAOs often requires technical skills, creating barriers and inefficiencies. Our project streamlines DAO activities, governance, and tokenomics with decentralized infrastructure",
        "long_description": "DAOTown is a groundbreaking platform revolutionizing the landscape of Decentralized Autonomous Organizations (DAOs). It serves as a bridge between Web2 and Web3, simplifying the initiation and management of DAOs for broader adoption. By abstracting governance models and tokenomics, DAOTown streamlines the complex processes involved, making them accessible to a wider audience. Its key features include customizable governance settings, flexible voting mechanisms, and controlled access to Token-gated DAO resources, Anonymous Groups, etc. Moreover, DAOTown addresses critical pain points within the DAO ecosystem such as technical complexity and communication challenges. It provides an intuitive interface for users, eliminating the need for extensive technical knowledge Our project DownTown is also integrated with discord API's which facilitates the creation of Token Gated communities on Discord. DAOTown automatically creates private Discord channels for each DAO, accessible only to members holding specific tokens or meeting designated criteria. DAOTown uses Discord's API to create these channels dynamically when a new DAO is formed, setting permissions based on token holdings DAOTown combines a variety of advanced technologies to create a seamless DAO management experience. At its core, DAOTown is built on Ethereum smart contracts, which automate essential DAO operations like governance, voting, and tokenomics, allowing for customizable and flexible governance settings tailored to each DAO's needs. All smart contracts are deployed on the AirDAO testnet network, providing a secure and scalable environment for development and testing, ensuring optimal performance before mainnet deployment. The platform\u2019s integration with Discord\u2019s API is a crucial component, automatically creating private, token-gated channels for each DAO. This integration ensures that only eligible members can access specific channels, enhancing security and engagement. Users are added or removed dynamically based on their token holdings, and a dedicated bot provides real-time updates on key DAO activities, such as proposal creation and voting, directly within the Discord channels. To address collusion and maintain the integrity of on-chain voting, DAOTown incorporates Minimal Anti-Collusion Infrastructure (MACI). MACI is an Ethereum-based application that ensures privacy in voting by making it difficult for voters to prove their choices, thus preventing bribery and safeguarding the voting process. This system supports both quadratic and non-quadratic voting, enhancing the security and fairness of DAO governance. DAOTown also employs World ID for social identity verification, playing a vital role in maintaining Sybil resistance by ensuring that each participant is unique. This integration helps prevent manipulation in voting outcomes, reinforcing the platform\u2019s commitment to fair and secure governance. The platform\u2019s frontend is designed with modern web technologies to offer a user-friendly experience, while the backend securely interacts with blockchain networks, Discord, and other integrated services. This robust architecture ensures that DAOTown delivers a seamless, secure, and efficient tool for managing decentralized organizations, enhancing accessibility and participation in the DAO ecosystem.",
        "how_its_made": "DAOTown combines a variety of advanced technologies to create a seamless DAO management experience. At its core, DAOTown is built on Ethereum smart contracts, which automate essential DAO operations like governance, voting, and tokenomics, allowing for customizable and flexible governance settings tailored to each DAO's needs. All smart contracts are deployed on the AirDAO testnet network, providing a secure and scalable environment for development and testing, ensuring optimal performance before mainnet deployment. The platform\u2019s integration with Discord\u2019s API is a crucial component, automatically creating private, token-gated channels for each DAO. This integration ensures that only eligible members can access specific channels, enhancing security and engagement. Users are added or removed dynamically based on their token holdings, and a dedicated bot provides real-time updates on key DAO activities, such as proposal creation and voting, directly within the Discord channels. To address collusion and maintain the integrity of on-chain voting, DAOTown incorporates Minimal Anti-Collusion Infrastructure (MACI). MACI is an Ethereum-based application that ensures privacy in voting by making it difficult for voters to prove their choices, thus preventing bribery and safeguarding the voting process. This system supports both quadratic and non-quadratic voting, enhancing the security and fairness of DAO governance. DAOTown also employs World ID for social identity verification, playing a vital role in maintaining Sybil resistance by ensuring that each participant is unique. This integration helps prevent manipulation in voting outcomes, reinforcing the platform\u2019s commitment to fair and secure governance. The platform\u2019s frontend is designed with modern web technologies to offer a user-friendly experience, while the backend securely interacts with blockchain networks, Discord, and other integrated services. This robust architecture ensures that DAOTown delivers a seamless, secure, and efficient tool for managing decentralized organizations, enhancing accessibility and participation in the DAO ecosystem.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/op8jr/screenshots/khjub/default.jpg",
            "https://ethglobal.b-cdn.net/projects/op8jr/screenshots/48bta/default.jpg",
            "https://ethglobal.b-cdn.net/projects/op8jr/screenshots/jsn89/default.jpg",
            "https://ethglobal.b-cdn.net/projects/op8jr/screenshots/oaya8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/op8jr/screenshots/894jm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/op8jr/screenshots/fvwt2/default.jpg"
        ],
        "live_demo": "https://eth-global-sg.vercel.app/",
        "source_code": "https://github.com/MukulKolpe/ETHGlobalSG",
        "link": "https://ethglobal.com/showcase/daotown-op8jr"
    },
    {
        "title": "XPrediction",
        "brief_description": "X Prediction is a platform that allows you to place sports bets from Twitter",
        "long_description": "Users can share their on-chain sports predictions on social networks, mainly on Twitter, to facilitate transactions and operations in an intuitive way without having to go out to perform an operation. People can share their sports predictions simply through a link and all their followers will see an intuitive and native view to be able to sign a transaction from the wallet. I am currently inspired by solana's BLinks technology but I developed an EVM compatible version on Morph and non-EVM on Starknet.. allow users to perform various blockchain actions through shareable URLs without needing complex decentralized applications (dApps). They transform on chain Actions APIs that facilitate transaction requests into easy-to-use links that can be shared across the internet, including social media platforms like X (formerly Twitter)",
        "how_its_made": "I am currently inspired by solana's BLinks technology but I developed an EVM compatible version on Morph and non-EVM on Starknet.. allow users to perform various blockchain actions through shareable URLs without needing complex decentralized applications (dApps). They transform on chain Actions APIs that facilitate transaction requests into easy-to-use links that can be shared across the internet, including social media platforms like X (formerly Twitter)",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yrmt4/screenshots/2x3ax/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yrmt4/screenshots/8ondt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yrmt4/screenshots/k47k5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/anthonysurfermx/anthonysurfermx",
        "link": "https://ethglobal.com/showcase/xprediction-yrmt4"
    },
    {
        "title": "XPrediction",
        "brief_description": "X Prediction is a platform that allows you to place sports bets from Twitter",
        "long_description": "Users can share their on-chain sports predictions on social networks, mainly on Twitter, to facilitate transactions and operations in an intuitive way without having to go out to perform an operation. People can share their sports predictions simply through a link and all their followers will see an intuitive and native view to be able to sign a transaction from the wallet. I am currently inspired by solana's BLinks technology but I developed an EVM compatible version on Morph and non-EVM on Starknet.. allow users to perform various blockchain actions through shareable URLs without needing complex decentralized applications (dApps). They transform on chain Actions APIs that facilitate transaction requests into easy-to-use links that can be shared across the internet, including social media platforms like X (formerly Twitter)",
        "how_its_made": "I am currently inspired by solana's BLinks technology but I developed an EVM compatible version on Morph and non-EVM on Starknet.. allow users to perform various blockchain actions through shareable URLs without needing complex decentralized applications (dApps). They transform on chain Actions APIs that facilitate transaction requests into easy-to-use links that can be shared across the internet, including social media platforms like X (formerly Twitter)",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yrmt4/screenshots/2x3ax/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yrmt4/screenshots/8ondt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yrmt4/screenshots/k47k5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/anthonysurfermx/anthonysurfermx",
        "link": "https://ethglobal.com/showcase/xprediction-yrmt4"
    },
    {
        "title": "Web Attest",
        "brief_description": "Signed exchanges (SXG) is an open standard that enables to cryptographically authenticate the origin of a resource independently on how its delivered. Web Attest with SXG's reaches to bring interesting web2 data via zero knowledge commitments  to on chain data scarce protocols.",
        "long_description": "Signed Exchanges (SXG) is a cryptographic method for authenticating web content, originally designed to improve content prefetching. When combined with zero-knowledge (ZK) cryptography and blockchain technology, SXG opens up possibilities for creating verifiable proofs about public web information, such as news articles, social media posts, or financial data. This technology could enable applications to prove the authenticity and content of web pages without revealing sensitive information, potentially revolutionizing how we verify and trust online information in an era of increasing AI-generated content. By allowing the creation of succinct proofs about web data, SXG with ZK proofs could bridge the gap between traditional web (Web2) and blockchain-based systems (Web3), bringing verified real-world data onto decentralized platforms. We used web attest the first ever SXG verifier to build a way for contributors to get incentivised for their work based on the status of their PR in a organisation repo thus making grants transparently available to open source devs focused on expanding the ecosystem. Here\u2019s a new set of future use cases: Step 1 : Enable SXGs on cloud flare\nThe hardest part is now done cause Web Attest provides the first available  and zero knowledge verifiable SXG verifies on chain on Starknet.\nWeb attest verifier need 3 things Web attest verifier constructs the commitments via MICE (Merkle Integrity Content Encoding) via the payload. Verifies data inclusion in Verifiable Payload and then verifies the signature generated by SSL certificates (secpr1 or p256). Thus any data on a website or served by a website via cloudflare can be verifiable and can be used to generate nullifiers that prove and store zero knowledge commitments. Cairo Contract- https://github.com/crema-labs/sxg-cairo\nWeb Attest - https://github.com/crema-labs/sxg-web-attest\nCloudflare Relayer - https://github.com/crema-labs/gitgo",
        "how_its_made": "Step 1 : Enable SXGs on cloud flare\nThe hardest part is now done cause Web Attest provides the first available  and zero knowledge verifiable SXG verifies on chain on Starknet.\nWeb attest verifier need 3 things Web attest verifier constructs the commitments via MICE (Merkle Integrity Content Encoding) via the payload. Verifies data inclusion in Verifiable Payload and then verifies the signature generated by SSL certificates (secpr1 or p256). Thus any data on a website or served by a website via cloudflare can be verifiable and can be used to generate nullifiers that prove and store zero knowledge commitments. Cairo Contract- https://github.com/crema-labs/sxg-cairo\nWeb Attest - https://github.com/crema-labs/sxg-web-attest\nCloudflare Relayer - https://github.com/crema-labs/gitgo",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6rww0/screenshots/xgv4m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6rww0/screenshots/zrobj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6rww0/screenshots/gf19t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6rww0/screenshots/jznff/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6rww0/screenshots/jfach/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/crema-labs/sxg-cairo",
        "link": "https://ethglobal.com/showcase/web-attest-6rww0"
    },
    {
        "title": "Zeekay-warden",
        "brief_description": "Introducing Zeekay-Warden: A token-gated community management tool using zero-knowledge proofs to verify token ownership. It supports role-based access control, linking tokens to roles for customized access levels. Privacy, security, and seamless community gating! #web3 #zk",
        "long_description": "Zeekay-Warden is an innovative tool designed to manage token-gated communities with enhanced privacy and security. It leverages zero-knowledge proofs (ZKPs) to verify token ownership without revealing any sensitive information. This enables users to prove they hold specific tokens required to join or access a community, ensuring privacy while validating membership. Key features include: Token Ownership Verification: Using ZKPs, Zeekay-Warden verifies whether users possess the tokens required by a community, without exposing wallet details or token ownership specifics. This ensures privacy while maintaining community standards. Role-Based Access Control (RBAC): Zeekay-Warden allows community admins to assign different tokens to different access roles. This means that various tokens can be mapped to specific roles, granting members different levels of access and permissions within the community, ensuring a flexible governance system. Multi-Token Support: Communities can use different types of tokens (ERC-721, ERC-20, etc.), each mapped to a different role or level of access. This feature empowers communities to enforce tiered access, making it ideal for managing diverse groups with varying levels of participation. Seamless Integration: Zeekay-Warden integrates smoothly with platforms like Discord to manage membership and permissions based on token ownership. It automates the process of checking ownership and assigning roles in real-time, offering a user-friendly experience for both community admins and members. Privacy-Preserving Membership: Since users don't need to expose their wallet addresses or token balances, Zeekay-Warden enhances privacy and security within the community, ensuring only the required proof of ownership is shared using cryptographic proofs. Scalability: Whether you're managing a small group or a large, global community, Zeekay-Warden can scale to meet the needs of any organization that uses token-gated access. Zeekay-Warden provides a robust, privacy-centric, and flexible solution for managing modern tokenized communities, with a focus on security, role management, and decentralized governance. Zeekay-Warden is a tool designed to manage token-gated communities with privacy, security, and scalability in mind. It uses zero-knowledge proofs (ZKPs) to verify token ownership without revealing wallet details, ensuring members' privacy. The tool supports role-based access control (RBAC), allowing different types of tokens to be linked with specific roles for tiered access within a community. Zeekay-Warden integrates with Dynamic for wallet management, enabling users to connect and manage multiple wallets seamlessly. It is available on the AirDAO network, chosen for its zero gas fees, making it easier for larger communities to attract members without cost barriers. Additionally, Zeekay-Warden is available on Morph, leveraging its advanced zero-knowledge features to provide enhanced privacy and cryptographic proof efficiency, perfect for privacy-focused communities. With support for multiple tokens and networks, Zeekay-Warden provides flexibility for community admins to customize access, making it an ideal solution for decentralized organizations, token-based communities, and DAOs. It offers a streamlined way to manage memberships, enforce privacy, and ensure a frictionless onboarding process for users across diverse blockchain ecosystems.",
        "how_its_made": "Zeekay-Warden is a tool designed to manage token-gated communities with privacy, security, and scalability in mind. It uses zero-knowledge proofs (ZKPs) to verify token ownership without revealing wallet details, ensuring members' privacy. The tool supports role-based access control (RBAC), allowing different types of tokens to be linked with specific roles for tiered access within a community. Zeekay-Warden integrates with Dynamic for wallet management, enabling users to connect and manage multiple wallets seamlessly. It is available on the AirDAO network, chosen for its zero gas fees, making it easier for larger communities to attract members without cost barriers. Additionally, Zeekay-Warden is available on Morph, leveraging its advanced zero-knowledge features to provide enhanced privacy and cryptographic proof efficiency, perfect for privacy-focused communities. With support for multiple tokens and networks, Zeekay-Warden provides flexibility for community admins to customize access, making it an ideal solution for decentralized organizations, token-based communities, and DAOs. It offers a streamlined way to manage memberships, enforce privacy, and ensure a frictionless onboarding process for users across diverse blockchain ecosystems.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yxigx/screenshots/892u3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yxigx/screenshots/36jop/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yxigx/screenshots/khp0g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yxigx/screenshots/zikru/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/roshie/zeekay-warden",
        "link": "https://ethglobal.com/showcase/zeekay-warden-yxigx"
    },
    {
        "title": "Peer Net",
        "brief_description": "A peer to peer Blockchain Network that is independent of the Internet",
        "long_description": "This project is an Android-based application that leverages Bluetooth Low Energy (BLE) to create a decentralized blockchain system for broadcasting and verifying transactions. The app allows users to input and broadcast transaction messages (such as \"abcd transferred 20 coins to pqrs\") using BLE, while other devices nearby can receive and verify these transactions using cryptographic signatures. The goal is to create a peer-to-peer communication system where transaction integrity is maintained without the need for a centralized network. Its made using the Bluetooth Low energy tech to make a mesh network. It uses BLE Technology which is a low power technology that can create a network by connecting devices together. It intends to use the proof of coverage consensus mechanism. The project uses the sha256 public private key pairs to sign the message, that is then broadcasted for anyone to receive and retransmit. By using properties of radio waves like strength and the gps location of the device the PoC can verify the transactions.",
        "how_its_made": "Its made using the Bluetooth Low energy tech to make a mesh network. It uses BLE Technology which is a low power technology that can create a network by connecting devices together. It intends to use the proof of coverage consensus mechanism. The project uses the sha256 public private key pairs to sign the message, that is then broadcasted for anyone to receive and retransmit. By using properties of radio waves like strength and the gps location of the device the PoC can verify the transactions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6ndj1/screenshots/dvfy0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6ndj1/screenshots/tcop9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6ndj1/screenshots/dz7g0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/raghav1183/EthSingapore",
        "link": "https://ethglobal.com/showcase/peer-net-6ndj1"
    },
    {
        "title": "Cross-Chain Mon",
        "brief_description": "This is a Pokemon game spanned across multiple EVM chains. Players have to bridge across chains via Autonomous World contracts to collect all pokemon (Cross-Chain-Mons)",
        "long_description": "This project is an attempt at a fully on-chain, multi-chain, pokemon collection game. Each player is represented as an NFT, and resides in their \"chain-of-birth\". They start catching Pokemon (Cross-Chain-Mons) and hope to populate the whole of their pokedex. However, this can only be achieved if they bridge their Player-representation-NFT to other chains to explore new worlds which encourages multi-chain usage, thus also promoting inter-chain gaming activity. The main code for this game is based on Mud.dev's fully-on-chain gaming library stack. The onboarding experience of wallet connection is first brought through using Dynamic's email/social sign in options. And the gaming(move transaction) experiences is facilitated by their session keys usage. Dynamic's serviced wallet thus also serve as a Gaming-Burner wallet of sorts to ensure a thorough secure state of funds stored. In game NPCs are brought to life by ChatGPT's model with the help of Phala Network's redpill typescript code and validated GPT models, thereby allowing NPCS to have colourful character in game. The bridging of player-representing NFT, is achieved with the help of Chainlink's CCIP messaging and bridging. Allowing us to have the concept of \"cross-chain portals\".\nWith this project, we deployed Mud.dev's autnomous world contracts into Morph's Holesky testnet, Rootstock Testnet, Flow's EVM testnet.",
        "how_its_made": "The main code for this game is based on Mud.dev's fully-on-chain gaming library stack. The onboarding experience of wallet connection is first brought through using Dynamic's email/social sign in options. And the gaming(move transaction) experiences is facilitated by their session keys usage. Dynamic's serviced wallet thus also serve as a Gaming-Burner wallet of sorts to ensure a thorough secure state of funds stored. In game NPCs are brought to life by ChatGPT's model with the help of Phala Network's redpill typescript code and validated GPT models, thereby allowing NPCS to have colourful character in game. The bridging of player-representing NFT, is achieved with the help of Chainlink's CCIP messaging and bridging. Allowing us to have the concept of \"cross-chain portals\".\nWith this project, we deployed Mud.dev's autnomous world contracts into Morph's Holesky testnet, Rootstock Testnet, Flow's EVM testnet.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sbf66/screenshots/4jhoq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sbf66/screenshots/710bs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sbf66/screenshots/n67pu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sbf66/screenshots/uqvpb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sbf66/screenshots/kvxdf/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xhatsume/xchainmon",
        "link": "https://ethglobal.com/showcase/cross-chain-mon-sbf66"
    },
    {
        "title": "Tavuk Civciv",
        "brief_description": "A decentralized 2FA system on Fhenix using encrypted OTPs and TOTP with Fully Homomorphic Encryption (FHE). Secure, serverless authentication and transaction approval with cutting-edge cryptography for enhanced privacy and control.",
        "long_description": "2FA Time-based One-time Password App which utilizes Fully Homomorphic Encryption with Fhenix. This project implements a decentralized two-factor authentication (2FA) system using Fhenix. By integrating Time-based One-Time Passwords (TOTP) and Fully Homomorphic Encryption (FHE), we provide a secure and decentralized method for user authentication and transaction authorization without relying on centralized servers. Note: The Project is not complete with smooth UI. UI integration has problems. OTP Randomness and generation is pseudo. UI is not complete. Contracts are not the best version. Project Overview The project consists of three main smart contracts: Future Enhancements Confidentiality via FHE: By requiring approvals from two separate addresses and encrypted OTPs, the system significantly reduces unauthorized access risks. Use sealing and eaddress for confidentality. Decentralization: All authentication processes need to be on-chain like random OTP's etc. aligning with blockchain's trustless and decentralized principles. UI/UX Empowerment: Implement flawless and smooth UI Scalability: The modular design allows for future enhancements and integrations, such as additional authentication factors. I used Solidity and Fhenix Protocol contracts for Smart Contracts which utilizes Fully Homomorphic Encryption. I used, next.js, react.js  and Ethers.js for frontend. I used Fhenix partner project to enable secure handling of encrypted data directly on-chain, which is crucial for processing OTPs without revealing them because traditional smart contracts cannot securely process confidential data. FHE allows us to perform necessary computations while maintaining data privacy. The hacky thing that I made is the performing TOTP verification on-chain on the smart contract wallet without exposing the secret key or the OTP. I wrote the FHE computation of the OTP Algorithm.",
        "how_its_made": "I used Solidity and Fhenix Protocol contracts for Smart Contracts which utilizes Fully Homomorphic Encryption. I used, next.js, react.js  and Ethers.js for frontend. I used Fhenix partner project to enable secure handling of encrypted data directly on-chain, which is crucial for processing OTPs without revealing them because traditional smart contracts cannot securely process confidential data. FHE allows us to perform necessary computations while maintaining data privacy. The hacky thing that I made is the performing TOTP verification on-chain on the smart contract wallet without exposing the secret key or the OTP. I wrote the FHE computation of the OTP Algorithm.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/f1msr/screenshots/v2e45/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f1msr/screenshots/ae058/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f1msr/screenshots/kzx38/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/berkingurcan/tavukcivciv-ETHGlobal-Singapore24",
        "link": "https://ethglobal.com/showcase/tavuk-civciv-f1msr"
    },
    {
        "title": "agmin",
        "brief_description": "Utlising Mina, we want to create private interactions with gated access, whilst improving the user experience.",
        "long_description": "By creating an NFT generator, the next step for the user of the platform is to sign another transaction that would generate a proof, and potentially automate the rest of the time on the platform. This would enable the user to have an optimised gaming experience or even simple transactions within a dex/defi environment. It utilises Protokit as a development base and the eventual goal was to have private P2P interactions that would be enabled after the minting of a unique NFT. This NFT alongside generating a proof, would ideally enable automatic transactions and this would be stopped when the user signs out. Once signed out, the NFT would be burnt and automation would be stopped",
        "how_its_made": "It utilises Protokit as a development base and the eventual goal was to have private P2P interactions that would be enabled after the minting of a unique NFT. This NFT alongside generating a proof, would ideally enable automatic transactions and this would be stopped when the user signs out. Once signed out, the NFT would be burnt and automation would be stopped",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1n5hc/screenshots/06oea/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1n5hc/screenshots/4qzx2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1n5hc/screenshots/rzxv9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1n5hc/screenshots/b6yjv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/simonbeirouti/agmina",
        "link": "https://ethglobal.com/showcase/agmin-1n5hc"
    },
    {
        "title": "Trend Sage",
        "brief_description": "Trend Sage is a zero-fee decentralized prediction market on Airdao, where users bet on world events, create, vote, and resolve markets via a on the go Telegram bot and user-friendly UI. Bet on world events using crypto, verified by Worldcoin and wallets.",
        "long_description": "Trend Sage is a decentralized prediction market platform built on the Airdao Network, offering zero fees for users to bet on the outcome of world events. The goal is to allow users to predict future events by creating, voting on, and resolving markets in a simple and user-friendly environment. Key Features:\nZero-Fee Environment: The platform operates on Airdao, which ensures that users can create and participate in markets without incurring fees, making the betting experience seamless and cost-effective. Decentralized Prediction Market: Users place bets on the likelihood of future events happening. This could be anything from sports results, political outcomes, stock market movements, to even global events like climate predictions or award show results. User-Generated Markets: Users can create new prediction markets on any topic of interest. They can define the event, outcomes, and timeframe, allowing other users to join and place their predictions. Voting and Resolving Markets: After the event concludes, the platform allows the community to vote and resolve the outcomes, ensuring decentralized governance over market results. Integration with Worldcoin and Wallets for Verification: User identity verification and payments are done using Worldcoin and cryptocurrency wallets. This ensures security, transparency, and global accessibility. Wallet integration provides easy access for users to place bets and collect rewards. Telegram Bot for On-the-Go Access: Users can interact with the platform via a Telegram bot, enabling quick and convenient access to create, vote on, and resolve markets, all from their mobile devices without needing to open a separate app or website. Social Features: Users can follow friends and see their betting activity in their feed, allowing them to stay updated on the markets their friends are interested in. This adds a social element, increasing engagement and community involvement. Look and Feel:\nThe design follows a DAO aesthetic, characterized by minimalist, clean visuals that prioritize simplicity and usability. The focus is on easy navigation, clear market creation flows, and straightforward resolution processes. Overall Experience:\nTrend Sage is designed to be intuitive, fast, and accessible. It removes barriers like transaction fees, offers quick access via a bot, and incorporates a social element that makes prediction markets more engaging. Users have complete control over their predictions and markets, creating a transparent and community-driven betting experience on world events. Trend Sage utilizes MetaMask and other wallets for user authentication, ensuring secure access. Worldcoin verifies user identity, confirming they are human, making sign-in seamless. The platform is deployed on Airdao, offering zero gas fees for transactions, enhancing the overall user experience.",
        "how_its_made": "Trend Sage utilizes MetaMask and other wallets for user authentication, ensuring secure access. Worldcoin verifies user identity, confirming they are human, making sign-in seamless. The platform is deployed on Airdao, offering zero gas fees for transactions, enhancing the overall user experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t3uqx/screenshots/bfuof/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t3uqx/screenshots/qxvw6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t3uqx/screenshots/wybw3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t3uqx/screenshots/02jcr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t3uqx/screenshots/6rinb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Raksha001/trend-sage",
        "link": "https://ethglobal.com/showcase/trend-sage-t3uqx"
    },
    {
        "title": "DOG - DOA On the Go",
        "brief_description": "**DOG - DAO On the Go** is a decentralized platform for creating and managing DAOs. Admins manage tasks, products, and events, while contributors claim tasks, vote, and shop. World ID verification ensures secure, Sybil-resistant voting for transparent governance.",
        "long_description": "DOG - DAO On the Go is a decentralized platform that allows users to create and manage Decentralized Autonomous Organizations (DAOs) with ease. The platform caters to both admins and contributors, offering a wide range of features such as task management, marketplace integration, event creation, and decentralized voting with World ID verification. Admins can create DAOs by specifying a name, description, icon, and an ERC-20 token to represent the DAO\u2019s governance and economy. They are responsible for managing the DAO, creating tasks, listing products in the marketplace, and organizing events. Contributors, on the other hand, can participate in tasks, claim bounties, purchase merchandise or NFTs from the marketplace, and attend events. The platform's task management system allows admins to create tasks or bounties with rewards in DAO tokens, which contributors can claim and complete for rewards. The marketplace feature allows admins to list products, such as NFTs or other items, which contributors can purchase using the DAO\u2019s tokens. This promotes economic activity within the DAO and fosters a sense of community ownership. In addition to these core features, DOG integrates a robust event management system where admins can create and manage online or in-person events for the DAO community. Contributors can engage with these events and strengthen the community. One of the most critical aspects of DOG is its decentralized voting mechanism, where contributors can vote on important DAO decisions. This voting system is powered by World ID verification, ensuring that only verified contributors participate in governance and decision-making, preventing Sybil attacks. Voting power is determined by the number of DAO tokens held by each contributor, ensuring a fair and decentralized governance process. By leveraging smart contracts, DOG ensures that all operations\u2014whether task management, marketplace transactions, event creation, or voting\u2014are transparent, secure, and immutable, fostering trust and autonomy within the community. This comprehensive platform enables DAOs to operate efficiently while providing contributors with multiple ways to engage and contribute to the organization\u2019s success. The DOG - DAO On the Go platform operates through a series of smart contracts that manage various aspects of the Decentralized Autonomous Organization (DAO). At its core, the smart contracts facilitate the creation of DAOs, task management, marketplace transactions, event planning, and voting mechanisms. Each of these components is securely governed by the blockchain to ensure transparency, immutability, and decentralization. The DAO creation process begins when an admin initiates a new DAO by specifying details like the DAO's name, description, icon, and an ERC-20 token that will be used as the governance and reward mechanism for the DAO. Upon creation, the contract assigns the user who created the DAO as the admin, giving them the ability to manage contributors, create tasks, list products, and organize events. The smart contract tracks the DAO by a unique ID and maintains a list of all contributors and their roles within the DAO. In terms of task and bounty management, the admin can create tasks that contributors can claim and complete. Tasks are stored in the smart contract with a description and a reward value, typically in the form of DAO tokens. Contributors, identified by their wallet addresses, can claim available tasks, complete them, and receive the specified reward. The smart contract ensures that once a task is claimed, it cannot be claimed by another contributor, and once completed, the reward is automatically transferred from the DAO to the contributor. The marketplace is another key component managed by the smart contract. Admins can list items, such as NFTs or physical products, for sale within the DAO\u2019s marketplace. Each item has a price in DAO tokens, and contributors can purchase these items by transferring the required amount of tokens to the admin. If the product is an NFT, the smart contract facilitates the transfer of ownership directly on-chain, ensuring a seamless and trustless transaction. Non-NFT products can also be listed, and the sale is handled similarly, with the token transfer confirming the purchase. Event management is another feature that allows admins to create and schedule both online and in-person events. Events are defined by details such as name, description, date, and whether they are online or in-person. If an event is online, the smart contract can store a URL for the event, providing an easy way for contributors to participate. These events are stored on-chain, ensuring that the details are immutable and accessible to all DAO members. The voting mechanism within DOG is one of its most decentralized features. Admins can create proposals for the community to vote on, and the voting process is governed by the number of DAO tokens held by each contributor. Before casting a vote, contributors must pass through World ID verification, which ensures that each vote comes from a verified, unique individual, preventing fraud or Sybil attacks. Once verified, contributors cast their vote, and the weight of their vote is proportional to the number of DAO tokens they hold. The smart contract automatically tallies the votes and, once the voting period ends, executes the result based on the majority vote. Proposals are considered passed if the \u201cYes\u201d votes outweigh the \u201cNo\u201d votes, and the smart contract marks the proposal as executed, ensuring transparency and fairness in decision-making. Each function within the DOG - DAO On the Go platform is governed by the logic embedded in the smart contracts, ensuring that all interactions\u2014whether creating a DAO, completing a task, purchasing from the marketplace, attending events, or participating in governance\u2014are handled in a decentralized, secure, and immutable manner. The use of blockchain technology guarantees that all actions are transparent, verifiable, and protected from tampering, providing users with a reliable platform for decentralized community management.",
        "how_its_made": "The DOG - DAO On the Go platform operates through a series of smart contracts that manage various aspects of the Decentralized Autonomous Organization (DAO). At its core, the smart contracts facilitate the creation of DAOs, task management, marketplace transactions, event planning, and voting mechanisms. Each of these components is securely governed by the blockchain to ensure transparency, immutability, and decentralization. The DAO creation process begins when an admin initiates a new DAO by specifying details like the DAO's name, description, icon, and an ERC-20 token that will be used as the governance and reward mechanism for the DAO. Upon creation, the contract assigns the user who created the DAO as the admin, giving them the ability to manage contributors, create tasks, list products, and organize events. The smart contract tracks the DAO by a unique ID and maintains a list of all contributors and their roles within the DAO. In terms of task and bounty management, the admin can create tasks that contributors can claim and complete. Tasks are stored in the smart contract with a description and a reward value, typically in the form of DAO tokens. Contributors, identified by their wallet addresses, can claim available tasks, complete them, and receive the specified reward. The smart contract ensures that once a task is claimed, it cannot be claimed by another contributor, and once completed, the reward is automatically transferred from the DAO to the contributor. The marketplace is another key component managed by the smart contract. Admins can list items, such as NFTs or physical products, for sale within the DAO\u2019s marketplace. Each item has a price in DAO tokens, and contributors can purchase these items by transferring the required amount of tokens to the admin. If the product is an NFT, the smart contract facilitates the transfer of ownership directly on-chain, ensuring a seamless and trustless transaction. Non-NFT products can also be listed, and the sale is handled similarly, with the token transfer confirming the purchase. Event management is another feature that allows admins to create and schedule both online and in-person events. Events are defined by details such as name, description, date, and whether they are online or in-person. If an event is online, the smart contract can store a URL for the event, providing an easy way for contributors to participate. These events are stored on-chain, ensuring that the details are immutable and accessible to all DAO members. The voting mechanism within DOG is one of its most decentralized features. Admins can create proposals for the community to vote on, and the voting process is governed by the number of DAO tokens held by each contributor. Before casting a vote, contributors must pass through World ID verification, which ensures that each vote comes from a verified, unique individual, preventing fraud or Sybil attacks. Once verified, contributors cast their vote, and the weight of their vote is proportional to the number of DAO tokens they hold. The smart contract automatically tallies the votes and, once the voting period ends, executes the result based on the majority vote. Proposals are considered passed if the \u201cYes\u201d votes outweigh the \u201cNo\u201d votes, and the smart contract marks the proposal as executed, ensuring transparency and fairness in decision-making. Each function within the DOG - DAO On the Go platform is governed by the logic embedded in the smart contracts, ensuring that all interactions\u2014whether creating a DAO, completing a task, purchasing from the marketplace, attending events, or participating in governance\u2014are handled in a decentralized, secure, and immutable manner. The use of blockchain technology guarantees that all actions are transparent, verifiable, and protected from tampering, providing users with a reliable platform for decentralized community management.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3vg8j/screenshots/ft4xk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3vg8j/screenshots/wa0uh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3vg8j/screenshots/crqy8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3vg8j/screenshots/iwgr4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3vg8j/screenshots/m9njc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3vg8j/screenshots/2xx6x/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/chanakyha/eth-singapore-DOG",
        "link": "https://ethglobal.com/showcase/dog-doa-on-the-go-3vg8j"
    },
    {
        "title": "Hydro-Fi",
        "brief_description": "Hydrofi is a blockchain-based, gamified learning platform where users build and manage hydroponic systems, earning rewards through real-world farming challenges and NFT ownership.",
        "long_description": "Hydro-Fi is a blockchain-powered educational platform designed to teach users the principles of hydroponic farming through an interactive, gamified experience. Players begin by selecting their environment and setting up hydroponic systems that simulate real-world farming conditions. Using blockchain technology, Hydro-Fi mints NFTs representing system components like water pumps and lighting systems, allowing players to own, trade, and upgrade these elements as they progress through the game. Players are tasked with managing critical resources, such as water, energy, and nutrients, while overcoming challenges like droughts or energy shortages.\nThe game integrates Worldcoin for secure user identity verification and governance participation, allowing players to vote on future game updates. It also utilizes Flow blockchain for low-fee NFT minting and token-based rewards, incentivizing players to improve their systems. Hydro-Fi bridges the gap between gaming and sustainable education, encouraging users to learn about hydroponics and its potential to address global food challenges, all while engaging with the latest Web3 technologies. Let me know if this version works for you! Hydro-Fi was built using a combination of modern frontend and blockchain technologies, with a focus on integrating user-friendly design and educational gameplay mechanics. The front-end was developed using Next.js (React framework) for a seamless, responsive user experience, while JavaScript/TypeScript handled interactivity and user flows across the game. On the blockchain side, we chose the Flow blockchain due to its scalability and low transaction fees, which are essential for handling in-game transactions like the minting and trading of NFT components (such as hydroponic systems). Flow\u2019s smart contracts were written in Cadence, which is tailored for NFTs and token-based rewards, ensuring that users could securely own and trade in-game assets. We integrated Worldcoin to manage identity verification in a decentralized way, allowing players to authenticate and participate in governance decisions, such as voting on future game updates and features. This added a unique layer of community-driven gameplay to Hydro-Fi. For backend development, we used Node.js to handle game logic and interactions with the blockchain, including API calls for managing user profiles and in-game actions. We leveraged Flow CLI for local testing and development using Flow's emulator and dev wallet, allowing us to quickly iterate and test smart contracts during the hackathon. All of our work was tracked through GitHub, ensuring transparent version control with regular commits to document our progress throughout the hackathon. This ensured that every feature and improvement was built from scratch during the event.",
        "how_its_made": "Hydro-Fi was built using a combination of modern frontend and blockchain technologies, with a focus on integrating user-friendly design and educational gameplay mechanics. The front-end was developed using Next.js (React framework) for a seamless, responsive user experience, while JavaScript/TypeScript handled interactivity and user flows across the game. On the blockchain side, we chose the Flow blockchain due to its scalability and low transaction fees, which are essential for handling in-game transactions like the minting and trading of NFT components (such as hydroponic systems). Flow\u2019s smart contracts were written in Cadence, which is tailored for NFTs and token-based rewards, ensuring that users could securely own and trade in-game assets. We integrated Worldcoin to manage identity verification in a decentralized way, allowing players to authenticate and participate in governance decisions, such as voting on future game updates and features. This added a unique layer of community-driven gameplay to Hydro-Fi. For backend development, we used Node.js to handle game logic and interactions with the blockchain, including API calls for managing user profiles and in-game actions. We leveraged Flow CLI for local testing and development using Flow's emulator and dev wallet, allowing us to quickly iterate and test smart contracts during the hackathon. All of our work was tracked through GitHub, ensuring transparent version control with regular commits to document our progress throughout the hackathon. This ensured that every feature and improvement was built from scratch during the event.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mcp72/screenshots/n6dye/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mcp72/screenshots/2pt76/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mcp72/screenshots/s0gpx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mcp72/screenshots/hf0xk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mcp72/screenshots/qcfzq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/KismetKrystle/HydroFi",
        "link": "https://ethglobal.com/showcase/hydro-fi-mcp72"
    },
    {
        "title": "Zen",
        "brief_description": "Zen is a plugin-powered social space to build FHE-based apps like confidential polls, private attributes, and secure auction markets. Build and extend plugins for limitless possibilities, all while keeping your data fully encrypted and yours!",
        "long_description": "Zen is a fully modular, privacy-preserving social media platform built on top of the Fhenix blockchain. Designed with extensibility in mind, Zen allows users to interact with FHE-based (Fully Homomorphic Encryption) applications and build custom plugins. The platform is optimized for speed, leveraging a custom-built Rust-based indexer for real-time synchronization across the entire network. Zen's modular nature encourages developers to build additional privacy-preserving plugins. The platform supports a wide range of potential use cases, such as: Handle Claim Module: Users can claim unique handles, serving as their on-chain identity.\nHandles may contain encrypted private information (e.g., email, bio, location). Private data can only be decrypted by those who follow the user, via an \"unseal\" process. Follow Module: Follower counts are kept private, visible only to the profile owner and their followers. Both follower and followee identities are protected, ensuring confidential interactions. Confidential Polls: Users can create confidential polls similar to Twitter polls. Number of votes remains private throughout the poll's duration. Final vote count is revealed only after the poll ends or the deadline is reached. Confidential Auction Markets: Users can host auction markets within Zen.\nBidder addresses and bid amounts are encrypted and remain confidential until the auction concludes. The highest bid and winning address are revealed only after the auction ends. Zen is structured around a plugin-based architecture, where modules can be easily added or modified by developers. This provides a high degree of flexibility and encourages community-driven expansion of features while ensuring user data privacy through FHE.",
        "how_its_made": "Handle Claim Module: Users can claim unique handles, serving as their on-chain identity.\nHandles may contain encrypted private information (e.g., email, bio, location). Private data can only be decrypted by those who follow the user, via an \"unseal\" process. Follow Module: Follower counts are kept private, visible only to the profile owner and their followers. Both follower and followee identities are protected, ensuring confidential interactions. Confidential Polls: Users can create confidential polls similar to Twitter polls. Number of votes remains private throughout the poll's duration. Final vote count is revealed only after the poll ends or the deadline is reached. Confidential Auction Markets: Users can host auction markets within Zen.\nBidder addresses and bid amounts are encrypted and remain confidential until the auction concludes. The highest bid and winning address are revealed only after the auction ends. Zen is structured around a plugin-based architecture, where modules can be easily added or modified by developers. This provides a high degree of flexibility and encourages community-driven expansion of features while ensuring user data privacy through FHE.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5yh8z/screenshots/ou6us/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yh8z/screenshots/bd9wv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yh8z/screenshots/r0rfz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yh8z/screenshots/w7izm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yh8z/screenshots/hn3s4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yh8z/screenshots/tkbe4/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Envoy-VC/zen-eth-singapore-2024",
        "link": "https://ethglobal.com/showcase/zen-5yh8z"
    },
    {
        "title": "Hedera Offset",
        "brief_description": "Hedera Offset automates carbon tracking and trading with IoT and Hedera blockchain, ensuring tamper-proof, real-time verification of carbon tokens for trusted, transparent sustainability efforts.",
        "long_description": "Hedera Offset is an innovative solution that automates the process of tracking, verifying, and trading carbon offsets using a combination of Internet of Things (IoT) devices and Hedera\u2019s blockchain technology. The project aims to tackle inefficiencies in the current carbon offset ecosystem by providing real-time, transparent, and tamper-proof data management, making carbon offset tokens more valuable and trustworthy. Devices such as SONOFF and ESP32 collect environmental data (e.g., CO2 emissions reductions) in real-time from renewable energy projects, green buildings, and other sustainability initiatives. The data gathered by IoT devices is transmitted and recorded on Hedera's decentralized ledger, ensuring it is immutable and fully traceable. By integrating Hedera\u2019s consensus service, the system guarantees transparency and removes the possibility of data tampering, providing a solid foundation for trust in the carbon tokens generated. Each verified data entry related to CO2 savings automatically generates carbon tokens that can be traded in the marketplace. These tokens are backed by the verified environmental impact data recorded on the blockchain. The entire process, from data collection to token generation, is automated. This ensures that carbon offsets are tracked and verified as they occur, reducing delays in the verification process and providing real-time insights into sustainability efforts. Every token created can be traced back to the original data point, providing full transparency. This level of traceability boosts the credibility of carbon offsets, attracting more buyers and investors. The platform will include a marketplace where businesses, organizations, and investors can trade verified carbon tokens. Hedera Offset is built with a combination of cutting-edge blockchain technology, IoT hardware, and customized software solutions to create a seamless, automated platform for carbon offset tracking and tokenization. Here\u2019s a breakdown of the technologies used and how they are pieced together: The frontend of the application is developed using React, providing an intuitive and responsive user interface for managing carbon offset data and tokens. To connect with Hedera's blockchain, the application uses HashConnect, enabling users to securely interact with the HashPack wallet. This allows users to authenticate and sign transactions related to carbon offsets and token trades. Additionally, the frontend interacts with the Hedera Mirror Node to fetch indexed data from the blockchain. This provides users with up-to-date and transparent information on the carbon offsets they generate and trade. The mirror node ensures that all interactions with the blockchain are fast, efficient, and verifiable. The backend is built using Node.js, which serves as the core engine for managing the platform's interactions with the Hedera blockchain. The backend makes use of two key Hedera services: Hedera Consensus Service (HCS): This service is used to store and notarize environmental data from IoT devices in a tamperproof manner. HCS ensures that all data is recorded immutably on the blockchain, providing transparency and trust in the carbon offset tracking process. Hedera Token Service (HTS): This service is responsible for the creation of carbon tokens. Each carbon offset is represented by a Hedera NFT (Non-Fungible Token), which is minted whenever verified data is received from IoT devices. This tokenization process ensures that each carbon credit is unique, traceable, and tradable on the platform\u2019s marketplace. The platform uses ESP32 microcontroller units (MCUs) with customized Tasmota firmware for collecting real-time environmental data. The ESP32 is flashed with this firmware, enabling it to interface with various smart meters commonly found in solar power plants and other renewable energy setups. The Tasmota firmware allows for easy integration with different IoT devices, ensuring that the platform can be deployed across a wide range of hardware configurations. The firmware is configured to send CO2 savings and energy data to the backend, where it is notarized on Hedera's blockchain. One particularly \"hacky\" approach used in the project is the customization of the Tasmota firmware. By adapting it to work seamlessly with ESP32, we ensured the hardware could be easily flashed and deployed across different smart meters. This greatly simplifies the installation process in solar plants, making it more scalable. Additionally, leveraging HashConnect for a more secure user experience with HashPack wallet integration allowed us to offer a seamless blockchain experience on the frontend. The combination of Node.js, React, and Hedera's services provides an automated, tamperproof system for verifying, tokenizing, and trading carbon offsets, revolutionizing how businesses and organizations can manage and monetize their sustainability efforts.",
        "how_its_made": "Hedera Offset is built with a combination of cutting-edge blockchain technology, IoT hardware, and customized software solutions to create a seamless, automated platform for carbon offset tracking and tokenization. Here\u2019s a breakdown of the technologies used and how they are pieced together: The frontend of the application is developed using React, providing an intuitive and responsive user interface for managing carbon offset data and tokens. To connect with Hedera's blockchain, the application uses HashConnect, enabling users to securely interact with the HashPack wallet. This allows users to authenticate and sign transactions related to carbon offsets and token trades. Additionally, the frontend interacts with the Hedera Mirror Node to fetch indexed data from the blockchain. This provides users with up-to-date and transparent information on the carbon offsets they generate and trade. The mirror node ensures that all interactions with the blockchain are fast, efficient, and verifiable. The backend is built using Node.js, which serves as the core engine for managing the platform's interactions with the Hedera blockchain. The backend makes use of two key Hedera services: Hedera Consensus Service (HCS): This service is used to store and notarize environmental data from IoT devices in a tamperproof manner. HCS ensures that all data is recorded immutably on the blockchain, providing transparency and trust in the carbon offset tracking process. Hedera Token Service (HTS): This service is responsible for the creation of carbon tokens. Each carbon offset is represented by a Hedera NFT (Non-Fungible Token), which is minted whenever verified data is received from IoT devices. This tokenization process ensures that each carbon credit is unique, traceable, and tradable on the platform\u2019s marketplace. The platform uses ESP32 microcontroller units (MCUs) with customized Tasmota firmware for collecting real-time environmental data. The ESP32 is flashed with this firmware, enabling it to interface with various smart meters commonly found in solar power plants and other renewable energy setups. The Tasmota firmware allows for easy integration with different IoT devices, ensuring that the platform can be deployed across a wide range of hardware configurations. The firmware is configured to send CO2 savings and energy data to the backend, where it is notarized on Hedera's blockchain. One particularly \"hacky\" approach used in the project is the customization of the Tasmota firmware. By adapting it to work seamlessly with ESP32, we ensured the hardware could be easily flashed and deployed across different smart meters. This greatly simplifies the installation process in solar plants, making it more scalable. Additionally, leveraging HashConnect for a more secure user experience with HashPack wallet integration allowed us to offer a seamless blockchain experience on the frontend. The combination of Node.js, React, and Hedera's services provides an automated, tamperproof system for verifying, tokenizing, and trading carbon offsets, revolutionizing how businesses and organizations can manage and monetize their sustainability efforts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qwrnx/screenshots/408k9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qwrnx/screenshots/g77f8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qwrnx/screenshots/saqxd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qwrnx/screenshots/a0up0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qwrnx/screenshots/ayykm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qwrnx/screenshots/68op5/default.jpg"
        ],
        "live_demo": "https://poc-1-murex.vercel.app/",
        "source_code": "https://github.com/orgs/Hedera-Offset/",
        "link": "https://ethglobal.com/showcase/hedera-offset-qwrnx"
    },
    {
        "title": "BitDSM",
        "brief_description": "Modeled after EigenPod in Eigenlayer, BitcoinPods enable bridgeless non-custodial native bitcoin delegation for financial applications on Ethereum.",
        "long_description": "The BitcoinPod (BOD) is the core component of BitDSM, modeled after the EigenPod concept. A BOD is a secure vault on the Bitcoin network, created using a P2WSH bitcoin address. The main purpose of the BitcoinPod is to ensure that minted LSTs are supported 1:1 by BTC, whether already held in the BitcoinPod or set to be processed through it. To accomplish this, BOD: Front end link: https://bod-frontend.vercel.app/app",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ohwfj/screenshots/a1qak/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ohwfj/screenshots/zmeip/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ohwfj/screenshots/n7rq3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/hammadtq/BitDSM",
        "link": "https://ethglobal.com/showcase/bitdsm-ohwfj"
    },
    {
        "title": "Uniswap Cron Jobs",
        "brief_description": "Built a hook for cron jobs onchain, this means simple onchain automation with low overhead and same block posting",
        "long_description": "Cron jobs are essentially automated tasks executed by some sort of action/worker. The trigger for a cron job can be essentially anything but the at it's bare essence it consists of a trigger and an action, but automated. For this hackathon this cron jobs are lightweight 32 byte and 0 wei transactions added by 3rd party users and then executed by volume executions of the token tickers. When a swap occurs then the next job will be tested to be executed. The setup is rather simple in solidity. The actual system can theoretically be executed by the arx signatures, wallet abstraction, or even hepatic authentication. The frontend exibits the ease of delivering a arx authentication for adding jobs. Ideally there is alloted funds from the pool or owner to fuel these executions or a separate escrow on the behalf of the user.",
        "how_its_made": "The setup is rather simple in solidity. The actual system can theoretically be executed by the arx signatures, wallet abstraction, or even hepatic authentication. The frontend exibits the ease of delivering a arx authentication for adding jobs. Ideally there is alloted funds from the pool or owner to fuel these executions or a separate escrow on the behalf of the user.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tgaq8/screenshots/wec29/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tgaq8/screenshots/uv4pk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tgaq8/screenshots/i98gj/default.jpg"
        ],
        "live_demo": "https://ethglobal-sg24.vercel.app",
        "source_code": "https://github.com/FudgyDRS/ethglobal-sg24",
        "link": "https://ethglobal.com/showcase/uniswap-cron-jobs-tgaq8"
    },
    {
        "title": "DEELANET",
        "brief_description": "this project is about tokenizing RWA, a method to tokenize human resourses",
        "long_description": "so idea was to tokenize human services by allowing recuiters to buy fractional ownership of services. In this system service providers will do the work and the part of their income will go to the recruiter. part will be decided by the amount of token hold by recruiter\nso idea was to tokenize human services by allowing recuiters to buy fractional ownership of services. In this system service providers will do the work and the part of their income will go to the recruiter. part will be decided by the amount of token hold by recruiter It was suppose to be built on FLow EVM, initially I was thinking about using Fhenix network but their testnet was broken. Then I had to come up with an idea of Zero Knowledge proof. It could have worked but it had added a lot of overhead\nso idea was to tokenize human services by allowing recuiters to buy fractional ownership of services. In this system service providers will do the work and the part of their income will go to the recruiter. part will be decided by the amount of token hold by recruiter",
        "how_its_made": "It was suppose to be built on FLow EVM, initially I was thinking about using Fhenix network but their testnet was broken. Then I had to come up with an idea of Zero Knowledge proof. It could have worked but it had added a lot of overhead\nso idea was to tokenize human services by allowing recuiters to buy fractional ownership of services. In this system service providers will do the work and the part of their income will go to the recruiter. part will be decided by the amount of token hold by recruiter",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wcpzo/screenshots/j95bu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wcpzo/screenshots/uzksy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wcpzo/screenshots/pg2bi/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/mayanktestweb/Dennanet",
        "link": "https://ethglobal.com/showcase/deelanet-wcpzo"
    },
    {
        "title": "Blinks on EVM",
        "brief_description": "Blinks on EVM, enabling Blink transactions on EVM using the OKX Wallet",
        "long_description": "Blinks are a unique feature that allows users to share interactive content across decentralized platforms, blending blockchain technology with social media interactions. These \"blinks\" act like mini-apps or snippets that can be embedded into posts on platforms like Twitter (X) or other Web2 environments. Instead of traditional links that simply direct users to another webpage, blinks can interact directly with blockchain wallets, execute transactions, or communicate key data without requiring the user to leave the platform. One of the most innovative aspects of blinks is their integration with blockchain ecosystems, particularly through networks like Solana, where they can execute decentralized actions seamlessly. For example, users can create and share blinks that allow others to participate in community events, place bets on games, or engage in decentralized applications (dApps). These blinks carry cryptographic signatures that authenticate the user's actions, leveraging the security and transparency of blockchain technology. Blinks offer immense potential for decentralized finance (DeFi), non-fungible tokens (NFTs), and decentralized social networks (DeSo). They enable users to initiate smart contract interactions directly from a tweet, manage their digital assets, or participate in decentralized governance without navigating away from the social media platform. This enhances the user experience by reducing friction and making blockchain interactions more intuitive and accessible. The potential use cases for blinks extend far beyond financial transactions. They can be employed for creating verifiable voting mechanisms, launching decentralized crowdfunding campaigns, or distributing digital collectibles. The decentralized and permissionless nature of blinks also means that they are censorship-resistant, aligning with the ethos of blockchain's trustless and transparent environment. Developers can further extend the functionality of blinks by integrating APIs, smart contracts, and user-generated content. This flexibility allows for a wide variety of applications, from on-chain gaming and DAO governance to micropayments and content monetization. As blockchain technology evolves, blinks are positioned to become a cornerstone of Web3 interaction, blending the ease of social media engagement with the robust security of decentralized infrastructure. In essence, blinks are revolutionizing how users interact with the blockchain world, allowing for dynamic, real-time interactions that combine the best of both Web2 and Web3 technologies. They represent the future of decentralized social media, where users can embed entire ecosystems of functionality into simple, shareable snippets that live and breathe on social networks. It is a blink on EVM that works on OKX wallet.\nIt uses the Dialect SDK for inject a blink frontend through the wallet and connects transactions through it. We are also trying to integrate Circle's programmable wallets with this blink. Blinks are made by combining several key technologies and components from both the Web2 and Web3 worlds. The process involves integrating blockchain smart contracts, decentralized protocols, APIs, and interactive front-end code to create a seamless user experience. Here\u2019s a step-by-step breakdown of how blinks are created: For example: A blink could allow users to place a bet on a chess game, make a donation, or claim rewards using tokens. Smart Contract Features: Ownership verification: to check the ownership of digital assets like NFTs.\nTransaction execution: for betting, transferring tokens, or minting NFTs.\nInteraction logging: to track user actions like votes or participation in an event.\nThe contract is coded in a language appropriate to the blockchain being used, such as Solidity (for Ethereum) or Rust (for Solana). Backend Elements: Node infrastructure: to interact with the blockchain, allowing the blink to submit and read transactions.\nAPIs: to connect to off-chain data, fetch user data, or trigger other decentralized actions.\nTransaction validation: to check transaction statuses (for example, through Helius webhooks or other monitoring services).\nDevelopers may use libraries such as @solana/web3.js for Solana or ethers.js for Ethereum, depending on the blockchain. Frontend Technologies: HTML/CSS for layout and styling: To visually present the blink on social media platforms or websites.\nJavaScript for interactivity: To handle user input and initiate blockchain transactions (using Web3 libraries).\nEmbedded widgets or frames: To ensure the blink can be embedded seamlessly in social media platforms, such as a tweet on Twitter (X).\nFor example: The frontend could be a small widget showing real-time chess moves with a button that lets users place a bet on the game, all embedded inside a tweet. Wallet Integration Steps: Connect Wallet Prompt: Using libraries like web3.js, ethers.js, or Solana-specific tools (@solana/web3.js).\nTransaction Signature: Users must sign blockchain transactions through their wallets, triggered by the blink.\nData retrieval from blockchain: The blink fetches on-chain data based on the wallet connected, such as token balances or NFT ownership.\n6. Backend + Frontend Synchronization (Webhooks, APIs)\nA webhook service (like Helius or Alchemy) can be set up to monitor blockchain transactions and update the blink in real-time. If the blink is part of a game or financial transaction, the backend continuously listens for updates and ensures the blink shows up-to-date data. For example: In a blink-based chess betting game, the system would monitor moves and bets on-chain and update the bet pool or player status in real-time. OG Tags for Social Platforms: The blink URL is enriched with meta tags (Open Graph) that instruct platforms like Twitter to unfurl the blink content properly.\nCross-domain compatibility: Blinks should be compatible with different environments\u2014tweets, websites, and decentralized platforms\u2014without breaking functionality.\nInteraction Tracking: Every interaction (click, share, transaction) is captured via analytics services or on-chain data for performance and engagement insights.\n8. Security Audits & Testing\nSince blinks involve real-world assets and transactions, security is crucial. Developers perform security audits of the smart contracts, ensuring there are no vulnerabilities that could be exploited. Additionally, the backend and frontend undergo extensive testing to ensure that: Smart contract bugs are eliminated.\nTransaction errors are handled gracefully.\nThe UI/UX flows smoothly without breaking in different platforms.\n9. Deployment\nOnce the blink is developed and tested, it's deployed on the respective blockchain and the frontend is hosted on a web server (such as IPFS or a traditional Web2 hosting platform). The blink\u2019s smart contract and backend infrastructure are also pushed live. The URL or embed code for the blink can now be shared or posted on social platforms for users to interact with. Conclusion:\nBlinks are built using a combination of smart contracts, decentralized backend systems, and interactive frontend interfaces, all embedded into existing social platforms. By leveraging blockchain, they provide a secure, verifiable, and interactive experience, allowing users to engage in decentralized applications without leaving their Web2 environments. This fusion of technologies enhances user engagement, simplifies interactions with decentralized systems, and makes blockchain accessible to a broader audience.",
        "how_its_made": "It is a blink on EVM that works on OKX wallet.\nIt uses the Dialect SDK for inject a blink frontend through the wallet and connects transactions through it. We are also trying to integrate Circle's programmable wallets with this blink. Blinks are made by combining several key technologies and components from both the Web2 and Web3 worlds. The process involves integrating blockchain smart contracts, decentralized protocols, APIs, and interactive front-end code to create a seamless user experience. Here\u2019s a step-by-step breakdown of how blinks are created: For example: A blink could allow users to place a bet on a chess game, make a donation, or claim rewards using tokens. Smart Contract Features: Ownership verification: to check the ownership of digital assets like NFTs.\nTransaction execution: for betting, transferring tokens, or minting NFTs.\nInteraction logging: to track user actions like votes or participation in an event.\nThe contract is coded in a language appropriate to the blockchain being used, such as Solidity (for Ethereum) or Rust (for Solana). Backend Elements: Node infrastructure: to interact with the blockchain, allowing the blink to submit and read transactions.\nAPIs: to connect to off-chain data, fetch user data, or trigger other decentralized actions.\nTransaction validation: to check transaction statuses (for example, through Helius webhooks or other monitoring services).\nDevelopers may use libraries such as @solana/web3.js for Solana or ethers.js for Ethereum, depending on the blockchain. Frontend Technologies: HTML/CSS for layout and styling: To visually present the blink on social media platforms or websites.\nJavaScript for interactivity: To handle user input and initiate blockchain transactions (using Web3 libraries).\nEmbedded widgets or frames: To ensure the blink can be embedded seamlessly in social media platforms, such as a tweet on Twitter (X).\nFor example: The frontend could be a small widget showing real-time chess moves with a button that lets users place a bet on the game, all embedded inside a tweet. Wallet Integration Steps: Connect Wallet Prompt: Using libraries like web3.js, ethers.js, or Solana-specific tools (@solana/web3.js).\nTransaction Signature: Users must sign blockchain transactions through their wallets, triggered by the blink.\nData retrieval from blockchain: The blink fetches on-chain data based on the wallet connected, such as token balances or NFT ownership.\n6. Backend + Frontend Synchronization (Webhooks, APIs)\nA webhook service (like Helius or Alchemy) can be set up to monitor blockchain transactions and update the blink in real-time. If the blink is part of a game or financial transaction, the backend continuously listens for updates and ensures the blink shows up-to-date data. For example: In a blink-based chess betting game, the system would monitor moves and bets on-chain and update the bet pool or player status in real-time. OG Tags for Social Platforms: The blink URL is enriched with meta tags (Open Graph) that instruct platforms like Twitter to unfurl the blink content properly.\nCross-domain compatibility: Blinks should be compatible with different environments\u2014tweets, websites, and decentralized platforms\u2014without breaking functionality.\nInteraction Tracking: Every interaction (click, share, transaction) is captured via analytics services or on-chain data for performance and engagement insights.\n8. Security Audits & Testing\nSince blinks involve real-world assets and transactions, security is crucial. Developers perform security audits of the smart contracts, ensuring there are no vulnerabilities that could be exploited. Additionally, the backend and frontend undergo extensive testing to ensure that: Smart contract bugs are eliminated.\nTransaction errors are handled gracefully.\nThe UI/UX flows smoothly without breaking in different platforms.\n9. Deployment\nOnce the blink is developed and tested, it's deployed on the respective blockchain and the frontend is hosted on a web server (such as IPFS or a traditional Web2 hosting platform). The blink\u2019s smart contract and backend infrastructure are also pushed live. The URL or embed code for the blink can now be shared or posted on social platforms for users to interact with. Conclusion:\nBlinks are built using a combination of smart contracts, decentralized backend systems, and interactive frontend interfaces, all embedded into existing social platforms. By leveraging blockchain, they provide a secure, verifiable, and interactive experience, allowing users to engage in decentralized applications without leaving their Web2 environments. This fusion of technologies enhances user engagement, simplifies interactions with decentralized systems, and makes blockchain accessible to a broader audience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hru4s/screenshots/zjrny/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hru4s/screenshots/rkn47/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hru4s/screenshots/idueo/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/semi-infiknight/ChessBlink",
        "link": "https://ethglobal.com/showcase/blinks-on-evm-hru4s"
    },
    {
        "title": "PageETH",
        "brief_description": "PageEth is a decentralized, privacy-preserving, omnichain communication protocol for secure message exchange across IoT devices, hardware-software interfaces, and dApps. It leverages blockchain technology to enable end-to-end encrypted communication in a trustless environment.",
        "long_description": "PageEth is a decentralized and privacy preserving hardware and software communication Protocol that is omnichain solution to send and receive messages. It's use case can be extended to the following communications. It can be used to communicate between two IOT devices, between hardware and software and between two Decentralised software applications (dApps). PageEth can be used for following types of communications It's made using the following components : Sign User Attestation Worldcoin ENS Resolution Avail DA Sign Message Attestation, Custom Hook and Verification Custom Hook LayerZero contracts The Graph NounsDAO",
        "how_its_made": "It's made using the following components : Sign User Attestation Worldcoin ENS Resolution Avail DA Sign Message Attestation, Custom Hook and Verification Custom Hook LayerZero contracts The Graph NounsDAO",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rcjiz/screenshots/t6t4d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rcjiz/screenshots/7wjz5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rcjiz/screenshots/13zhg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rcjiz/screenshots/g0s2g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rcjiz/screenshots/jffs8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rcjiz/screenshots/mbvqx/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jainl28patel/PageEth",
        "link": "https://ethglobal.com/showcase/pageeth-rcjiz"
    },
    {
        "title": "EcoTrack",
        "brief_description": "Go green, show yourself off following a sustainable life and win green credits!",
        "long_description": "Adopt a sustainable lifestyle that benefits both you and the planet. Upload photos or videos of your eco-friendly actions\u2014like recycling, biking, or conserving energy\u2014and watch your Green Score increase on-chain. Unlock exclusive rewards, eco-conscious products, and discounts as your score grows. Compete on the leaderboard, reach milestones, and become a sustainability champion in your community! The project uses Worldcoin ID and Incognito functions to ensure that only real humans submit image inputs of environmentally sustainable tasks such as planting trees, cleaning rivers, etc. Once submitted, this project uses Gaia's AI agents that run on a decentralised node (currently centralised) to check the user's image inputs and check if the activity the user is doing is an environmentally sustainable one and assigns a score to it from 0-100. This score and action is also attested using Verax. All these actions are done on the node to ensure no one can interfere with the values ensuring a reliable environment score. Finally users can view themselves in a metamask snap leaderboard so that they can easily keep track of their performance. Also we have used Nouns DAO for the fonts and assets.",
        "how_its_made": "The project uses Worldcoin ID and Incognito functions to ensure that only real humans submit image inputs of environmentally sustainable tasks such as planting trees, cleaning rivers, etc. Once submitted, this project uses Gaia's AI agents that run on a decentralised node (currently centralised) to check the user's image inputs and check if the activity the user is doing is an environmentally sustainable one and assigns a score to it from 0-100. This score and action is also attested using Verax. All these actions are done on the node to ensure no one can interfere with the values ensuring a reliable environment score. Finally users can view themselves in a metamask snap leaderboard so that they can easily keep track of their performance. Also we have used Nouns DAO for the fonts and assets.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0z7id/screenshots/fy064/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0z7id/screenshots/r7rf3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0z7id/screenshots/dymz6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0z7id/screenshots/x8byt/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kalashshah/public-goods",
        "link": "https://ethglobal.com/showcase/ecotrack-0z7id"
    },
    {
        "title": "Fhentom",
        "brief_description": "Ensuring privacy across blockchains for seamless and secure asset transfers using encrypted intents.",
        "long_description": "Fhentom focus on identifying user pain points and aim to create a straightforward, user-friendly solution that significantly advanced the overall bridging experience.When considering the future of  bridging solutions, we recognized a critical flaw in the current ecosystem: most bridges rely on multisig mechanisms, which are frequently hacked due to their poor security properties. These vulnerabilities prompted us to focus on integrating FHE to significantly advance the security of bridges and make them more robust against attacks.\nFhentom is an intent-based bridge which facilitates fully homomorphic encryption (FHE) with seamless cross-chain interactions. By allowing users to define their transaction intents, Fhentom enables the transfer of assets and data across multiple blockchains in a secure and efficient manner. What sets Fhentom apart is its advanced FHE mechanism, ensuring that all intents are fully encrypted, safeguarding user privacy and protecting transaction details from malicious actors. This innovative approach advances both the security and flexibility of cross-chain communication, empowering users to bridge blockchains with trust and efficiency. Overall, we aim to ensure privacy and security across all decentralized activities.\nHere's the video link for the presentation!!!!!: https://www.loom.com/share/b35a4f957a664454a3e7d02054f08619 One of the main challenges in Web3 is ensuring users' privacy, giving them greater control over their information and digital presence. Web3 data privacy prioritizes users by removing the need for a trusted third party to collect, store, and process personal information. Fhentom approach not only focused on privacy but also enables cheap, fast, and gas-free transactions via intents, making it easier for users to interact seamlessly cross chains without the burden of high fees or delays.Fhentom is leveraging FHE to bring encryption on across chains and networks thanks to Fhenix and ZAMA. Meanwhile Fhentom enables users to encrypt their intents, ensuring complete privacy and security.Solvers can execute the encrypted intents by simulating the fill transaction without knowing the specifics of the amount or token. Successful simulations allow solvers to complete the transaction and receive repayments, regardless of the encrypted details, ensuring seamless and confidential execution.",
        "how_its_made": "One of the main challenges in Web3 is ensuring users' privacy, giving them greater control over their information and digital presence. Web3 data privacy prioritizes users by removing the need for a trusted third party to collect, store, and process personal information. Fhentom approach not only focused on privacy but also enables cheap, fast, and gas-free transactions via intents, making it easier for users to interact seamlessly cross chains without the burden of high fees or delays.Fhentom is leveraging FHE to bring encryption on across chains and networks thanks to Fhenix and ZAMA. Meanwhile Fhentom enables users to encrypt their intents, ensuring complete privacy and security.Solvers can execute the encrypted intents by simulating the fill transaction without knowing the specifics of the amount or token. Successful simulations allow solvers to complete the transaction and receive repayments, regardless of the encrypted details, ensuring seamless and confidential execution.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9qt7z/screenshots/67qvh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9qt7z/screenshots/pn39o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9qt7z/screenshots/98zmv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Fhent/fhent-frontend",
        "link": "https://ethglobal.com/showcase/fhentom-9qt7z"
    },
    {
        "title": "OnlyGrants",
        "brief_description": "onlyGrants is a decentralized platform that eliminates popularity bias in donations by using fully homomorphic encryption (FHE) with quadratic voting and funding to keep donations and votes private.",
        "long_description": "OnlyGrants is a decentralized platform designed to address the limitations of popularity-based donating, commonly seen on platforms like Gitcoin. By integrating fully homomorphic encryption (FHE) with quadratic voting and quadratic funding, the platform ensures that both donations and votes remain private, even while they are being computed and processed. On traditional grant platforms, high-profile or popular projects often dominate the funding landscape, drawing disproportionate attention and donations. This can lead to a funding imbalance where lesser-known, but equally deserving, projects are overlooked due to lower visibility, even if they have substantial merit. This bias creates a significant barrier to innovation and diversity within the ecosystem. OnlyGrants solves this issue by eliminating visibility-based biases and ensuring that each vote and donation is treated with complete privacy. By leveraging FHE and quadratic voting, the platform enables a fair and transparent distribution process while keeping sensitive data\u2014such as individual donations and votes\u2014completely confidential. Fhenix: This is used to encrypt both quadratic votes and funding through fully homomorphic encryption (FHE). Fhenix ensures that votes and donation amounts remain private throughout the process, allowing the platform to maintain complete confidentiality. It enables computations on encrypted data, meaning users can cast their votes and donate without revealing their preferences. Gaianet : We use Gaianets model and build a knowledge based model , which helps the users to find the correct project to donate , according to their vision and projects vision and curate the round to which their project might qualify WorldCoin: Integrated for identity verification, WorldCoin ensures that only humans can access and participate in the platform Noun : Focused on providing Public Good infrastructure to not be a biased user in grant ecosystem",
        "how_its_made": "Fhenix: This is used to encrypt both quadratic votes and funding through fully homomorphic encryption (FHE). Fhenix ensures that votes and donation amounts remain private throughout the process, allowing the platform to maintain complete confidentiality. It enables computations on encrypted data, meaning users can cast their votes and donate without revealing their preferences. Gaianet : We use Gaianets model and build a knowledge based model , which helps the users to find the correct project to donate , according to their vision and projects vision and curate the round to which their project might qualify WorldCoin: Integrated for identity verification, WorldCoin ensures that only humans can access and participate in the platform Noun : Focused on providing Public Good infrastructure to not be a biased user in grant ecosystem",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/n4bj8/screenshots/iieic/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n4bj8/screenshots/mc5vj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n4bj8/screenshots/qk7rh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n4bj8/screenshots/577xn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n4bj8/screenshots/kdhtb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n4bj8/screenshots/mxvy0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/LeoFranklin015/OnlyGrants",
        "link": "https://ethglobal.com/showcase/onlygrants-n4bj8"
    },
    {
        "title": "TapPay",
        "brief_description": "A chain-agnostic mobile payment app using NFC cards for secure, seamless cross-chain transactions. Pay with your favorite token on any chain, anywhere. Powered by Chainlink CCIP and LayerZero for ultimate flexibility and security.",
        "long_description": "TapPay paves a new way for digital payments by offering a truly chain-agnostic mobile experience. Our application leverages battle-tested protocols Chainlink CCIP and LayerZero to enable users to pay with their preferred tokens on any blockchain, regardless of the merchant's preferred token or chain. TapPay provides a unified payment interface for consumer crypto to pay for their daily bread and butter. Key Features: Chain-Agnostic Payments: Users can pay with their favorite token on their preferred chain, while merchants can receive payment in their desired token on their chosen chain.\nNFC Card Integration: We've incorporated NFC cards for enhanced security and ease of use. The card stores an encrypted keyshare, working in tandem with the mobile app for a seamless tap-and-pay experience.\nCross-Chain Compatibility: Utilizing Chainlink CCIP and LayerZero, our app handles complex cross-chain transactions behind the scenes, providing a smooth user experience.\nMerchant Flexibility: Merchants can specify their preferred token and chain for receiving payments, without limiting customer options.\nEnhanced Security: The combination of NFC card and mobile app keyshares provides an additional layer of security for transactions. TapPay bridges the gap between various blockchain ecosystems, making cryptocurrency payments as simple and universal as traditional payment methods. Whether you're buying coffee at a local shop or making a purchase halfway around the world, TapPay ensures that blockchain differences never hinder your transaction. TapPay is built on multiple blockchain technologies and user-centric design principles: Mobile Application: Developed using React Native for cross-platform compatibility (iOS and Android). The app interfaces with various blockchain networks and manages user wallets and preferences.\nSmart Contracts: Written in Solidity, our contracts handle the core logic of cross-chain transactions. They're deployed on multiple chains to facilitate seamless interoperability.\nCross-Chain Interoperability: Chainlink CCIP (Cross-Chain Interoperability Protocol): Used for secure cross-chain messaging and token transfers. CCIP's reliability ensures that complex multi-chain transactions are executed accurately.\nLayerZero: Implemented for additional cross-chain capabilities, providing redundancy and expanded network coverage. NFC Integration: We've developed a custom protocol for secure communication between the NFC card and the mobile app. The NFC card stores an encrypted keyshare, which is combined with a keyshare in the app to complete transactions. Security Measures:\nThreshold cryptography for distributing transaction signing across the NFC card and mobile app. Token Swap Integration: We've integrated with decentralized exchanges on various chains to facilitate token swaps when necessary for cross-chain transactions. One particularly innovative aspect is our \"Chain Abstraction Layer.\" This custom-built middleware dynamically routes transactions through the most efficient cross-chain pathway, considering factors like gas fees, transaction speed, and network congestion. It seamlessly switches between Chainlink CCIP and LayerZero based on real-time conditions, ensuring optimal performance for each transaction.",
        "how_its_made": "TapPay is built on multiple blockchain technologies and user-centric design principles: Mobile Application: Developed using React Native for cross-platform compatibility (iOS and Android). The app interfaces with various blockchain networks and manages user wallets and preferences.\nSmart Contracts: Written in Solidity, our contracts handle the core logic of cross-chain transactions. They're deployed on multiple chains to facilitate seamless interoperability.\nCross-Chain Interoperability: Chainlink CCIP (Cross-Chain Interoperability Protocol): Used for secure cross-chain messaging and token transfers. CCIP's reliability ensures that complex multi-chain transactions are executed accurately.\nLayerZero: Implemented for additional cross-chain capabilities, providing redundancy and expanded network coverage. NFC Integration: We've developed a custom protocol for secure communication between the NFC card and the mobile app. The NFC card stores an encrypted keyshare, which is combined with a keyshare in the app to complete transactions. Security Measures:\nThreshold cryptography for distributing transaction signing across the NFC card and mobile app. Token Swap Integration: We've integrated with decentralized exchanges on various chains to facilitate token swaps when necessary for cross-chain transactions. One particularly innovative aspect is our \"Chain Abstraction Layer.\" This custom-built middleware dynamically routes transactions through the most efficient cross-chain pathway, considering factors like gas fees, transaction speed, and network congestion. It seamlessly switches between Chainlink CCIP and LayerZero based on real-time conditions, ensuring optimal performance for each transaction.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/941om/screenshots/vmazz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/941om/screenshots/146bh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/941om/screenshots/t3cyn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/941om/screenshots/9srze/default.jpg",
            "https://ethglobal.b-cdn.net/projects/941om/screenshots/2ip42/default.jpg",
            "https://ethglobal.b-cdn.net/projects/941om/screenshots/qkyv4/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Open-Sorcerer/TapPay",
        "link": "https://ethglobal.com/showcase/tappay-941om"
    },
    {
        "title": "mina-dark-pool",
        "brief_description": "Dark pool using hybrid execution model for private order matching with delayed execution",
        "long_description": "This project makes use of Protokit to create a custom sequencer, which enables private order matching. My implementation is based off of a constant product liquidity pool (see acknowledgements), where users can provide liquidity in any LP. For each LP, I have also added a whitelist mechanism, which is in line with what a dark pool is. In this project, here are the features of the Dark Pool I have implemented Based off of the Protokit starter template, I have created a DarkPool and TokenRegistry runtime module for pool and token management. Additionally, I created a DarkPoolMempool sequencer module to match orders whenever an incoming order is submitted. This checks against incoming method IDs and also stores a simple set in memory to avoid matching orders multiple time in a block. This will eventually be done in a cronjob. The frontend is built using shadcn and Next.js. I have detailed my other approaches in the README.md, for your perusal.",
        "how_its_made": "Based off of the Protokit starter template, I have created a DarkPool and TokenRegistry runtime module for pool and token management. Additionally, I created a DarkPoolMempool sequencer module to match orders whenever an incoming order is submitted. This checks against incoming method IDs and also stores a simple set in memory to avoid matching orders multiple time in a block. This will eventually be done in a cronjob. The frontend is built using shadcn and Next.js. I have detailed my other approaches in the README.md, for your perusal.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/c0yqv/screenshots/vs4ux/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c0yqv/screenshots/ydye2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c0yqv/screenshots/at591/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c0yqv/screenshots/axizi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c0yqv/screenshots/ywka9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/marcuspang/mina-dark-pools",
        "link": "https://ethglobal.com/showcase/mina-dark-pool-c0yqv"
    },
    {
        "title": "Veretha",
        "brief_description": "Verifiable HR system, in which people get bounties for verifying other employees",
        "long_description": "Veretha: by inputting LinkedIn details, users receive AI-driven CV improvement advice.  The system benefits employers, employees, and referrers, making job hunting efficient and rewarding. If my friend that i have verified got a job in the system, i would receive a bounty. And no more bots, nor more wasted HR and employee time because of the WorldId verification Veretha is an AI-driven platform that matches CVs with job descriptions, enhancing the hiring process by evaluating compatibility. The platform integrates Circle API for creating Web3 wallets, enabling users to receive payments and bounties for successful job placements. To ensure that users are real individuals, Veretha uses WorldID for identity verification. The frontend of the platform is built using Vue.js, enriched with animations for a smooth user experience, while the backend is powered by Python for robust processing and functionality.",
        "how_its_made": "Veretha is an AI-driven platform that matches CVs with job descriptions, enhancing the hiring process by evaluating compatibility. The platform integrates Circle API for creating Web3 wallets, enabling users to receive payments and bounties for successful job placements. To ensure that users are real individuals, Veretha uses WorldID for identity verification. The frontend of the platform is built using Vue.js, enriched with animations for a smooth user experience, while the backend is powered by Python for robust processing and functionality.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pskzp/screenshots/zmh86/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pskzp/screenshots/h5k6c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pskzp/screenshots/xagty/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pskzp/screenshots/iadcs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pskzp/screenshots/t59gh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pskzp/screenshots/56ufr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wisemik/veretha-frontend",
        "link": "https://ethglobal.com/showcase/veretha-pskzp"
    },
    {
        "title": "WNS",
        "brief_description": "Chain-abstracted, 3-word ENS alternative to any Web3 address for higher memorability, accuracy and non-ambiquity.",
        "long_description": "WNS is a chain-abstracted, super-charged version of ENS, without the current constraints of having an .eth in the name and serving L1-3, EVM, non-EVM and BTC chains. Current 0x 256 character long addresses cannot be memorised, making them an easy target for attacks (eg. address poison attacks) Plus they are very scary for a new Web3 user. We wanted to make this foremost data point simpler, easy-to-remember and more secure to use. WNS allows any L1-3, EVM, non-EVM, BTC chain addresses (in their respective formats) to be 1-to-1 mapped and converted to a unique 3 random English words format. The 3 words style and format has been inspired by a real-world project What3Words.com; where ~500,000 unique English words (without plurals, homophones and similar spelling words) are used to build the 3 word names in the standard format of ///word1.word2.word3. Just these 3 words opens up a possibility of mapping over 125 Trillions (500K to power of 3). As needed, this range can be enhanced by either adding 1 more word to the name or opening up even other language words to the list. This standard format, though is different from an ENS where it is not bound by ending in a .eth domain format - making it suitable for almost all possible chains available in the ecosystem. Step 1: WNS is built using TEE (Phala). The public address is used to build unique word combinations. It is always a 1-1 relationship; where the secret to building the WNS is kept hidden inside a TEE to avoid any reverse engineering/foul play. Step 2: All WNS is stored in respective chains (the chain from which the request was made). The chains selected for this demo are: Flow, Hedera, Rootstock, Aurora, Morph and Linea. We chose the wide variety of chains to demo the fact that these chains came with a range of address formats and yet were equally represented in a WNS. Step 3: We have a blacklist voting setup for public to mark any scammer accounts. All vote status is stored in NEAR. We use NEAR's MPC service to attest and verify all votes and become a chain-agnostic reference hash-table, openly accessible from any chain top check the latest blacklist vote status. This status is visually represented besides the WNS in red to alert users during any transaction. Step 4: The WNS + blacklist status (with or without the underlying 0x address) is now accessible to be used to involve any utility around donations, swaps, bridges etc. For this, we have integrated the service either via Metamask Flask (in form of a Snap) or via directly a web application. We however wish to see WNS be a core service option within the main Metamask application, instead of Snaps. There is a visual alert alongside all WNS to mark if that address is a wallet address (GREEN), contract address (YELLOW) or Blacklisted (RED). This is an additional layer of visual security to deter any unwanted transactions.",
        "how_its_made": "Step 1: WNS is built using TEE (Phala). The public address is used to build unique word combinations. It is always a 1-1 relationship; where the secret to building the WNS is kept hidden inside a TEE to avoid any reverse engineering/foul play. Step 2: All WNS is stored in respective chains (the chain from which the request was made). The chains selected for this demo are: Flow, Hedera, Rootstock, Aurora, Morph and Linea. We chose the wide variety of chains to demo the fact that these chains came with a range of address formats and yet were equally represented in a WNS. Step 3: We have a blacklist voting setup for public to mark any scammer accounts. All vote status is stored in NEAR. We use NEAR's MPC service to attest and verify all votes and become a chain-agnostic reference hash-table, openly accessible from any chain top check the latest blacklist vote status. This status is visually represented besides the WNS in red to alert users during any transaction. Step 4: The WNS + blacklist status (with or without the underlying 0x address) is now accessible to be used to involve any utility around donations, swaps, bridges etc. For this, we have integrated the service either via Metamask Flask (in form of a Snap) or via directly a web application. We however wish to see WNS be a core service option within the main Metamask application, instead of Snaps. There is a visual alert alongside all WNS to mark if that address is a wallet address (GREEN), contract address (YELLOW) or Blacklisted (RED). This is an additional layer of visual security to deter any unwanted transactions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/uvdv4/screenshots/89afx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uvdv4/screenshots/r2egb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uvdv4/screenshots/mba9o/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Dimple-Kanwar/w3w/",
        "link": "https://ethglobal.com/showcase/wns-uvdv4"
    },
    {
        "title": "BetOnBuild",
        "brief_description": "Interactive betting platform where users can bet on hackathon projects.",
        "long_description": "BetOnBuild is an engaging betting platform where users can place wagers on projects developed by hackers during a hackathon. The app features a slot machine game that randomly displays three projects, enabling users to bet on the one they believe will become a finalist. Players pay a small fee to participate and can explore various projects created by the hackers. Once the finalists are announced, the prize pool is distributed among those who correctly predicted the winning team. Notably, 50% of the prize money is allocated to charities, while the remaining 50% is shared among the users who placed successful bets. We built the frontend using the React framework, while the backend is powered by MongoDB for data management. The smart contracts were developed, tested, and deployed using Foundry and Solidity. We have also deployed our project on Linea, Flow and Morph using the Dynamic wallet.",
        "how_its_made": "We built the frontend using the React framework, while the backend is powered by MongoDB for data management. The smart contracts were developed, tested, and deployed using Foundry and Solidity. We have also deployed our project on Linea, Flow and Morph using the Dynamic wallet.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rsvjq/screenshots/vqj0e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rsvjq/screenshots/upsn1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rsvjq/screenshots/r3774/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Lucifer0x17/faceoff",
        "link": "https://ethglobal.com/showcase/betonbuild-rsvjq"
    },
    {
        "title": "Munjo",
        "brief_description": "Eip-7579 smart modular account for Dao\u2019s Treasury for schedule transfer, orders and gasless transaction.",
        "long_description": "This project provides a decentralized application (DApp) for managing and automating treasury operations of a DAO using smart account. leveraging ERC-7579 to enable advanced trading features such as gasless transactions, scheduled transactions, leveraging Safe, The Graph, and other blockchain technologies to create a robust treasury management solution. Features:\nGasless Transactions: Powered by Pimlico, allowing users to execute transactions without worrying about gas fees.\nScheduled Transactions: Implemented using the Rhinestone ERC-7579 module, enabling users to schedule transactions at a future time.\nSwaps: Support for token swaps using smart accounts.\nQuerying Blockchain Data: Leverage The Graph for efficient data retrieval and state tracking.\nModular Architecture: Built using Next.js, integrating various blockchain technologies into a seamless user experience. Technology Used:\nSafe: Manage treasury operations securely.\nERC-7579 (Smart Modular Account): Adopting standards for permissionless accounts.\nRhinestone & Pimlico: Optimizing transaction bundling and gas management.\nThe Graph: For decentralized querying of Ethereum data.\nNext.js: Server-side rendering and static generation for React applications.\nGraphQL: Data querying language used in conjunction with The Graph. Safe: Manage treasury operations securely.\nERC-7579 (Smart Modular Account): Adopting standards for permissionless accounts.\nRhinestone: A module for handling ERC-7579-based scheduled transactions.\nPimlico: A gasless transaction service, allowing users to execute transactions without paying gas fees directly.\nThe Graph: For decentralized querying of Ethereum data.\nNext.js: Server-side rendering and static generation for React applications.",
        "how_its_made": "Safe: Manage treasury operations securely.\nERC-7579 (Smart Modular Account): Adopting standards for permissionless accounts.\nRhinestone: A module for handling ERC-7579-based scheduled transactions.\nPimlico: A gasless transaction service, allowing users to execute transactions without paying gas fees directly.\nThe Graph: For decentralized querying of Ethereum data.\nNext.js: Server-side rendering and static generation for React applications.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xhkc3/screenshots/jk7sz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xhkc3/screenshots/agsap/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xhkc3/screenshots/3fhb1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xhkc3/screenshots/ezt39/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xPkhatri/munjo",
        "link": "https://ethglobal.com/showcase/munjo-xhkc3"
    },
    {
        "title": "B4BFlow",
        "brief_description": "The KOL/influencer protocol is activating Flow creators for collaborations.",
        "long_description": "B4B.app is a Web3 influencer marketing protocol that brings transparency, ownership, escrow, and on-chain history from all Socials Web3 advantages Try it out:\nhttps://flow.b4b.app\nhttps://flow-influencer.b4b.app/?refcode=qPgMNi The main outcome of the hackathon was successfully testing our ability to fully launch the technical part of the protocol on the Flow EVM, which proved to be quite straightforward. We also engaged in valuable discussions about our protocol's benefits for the Flow community and hope to be involved in future community activities. There are two main sides of the B4B marketplace - influencers and advertisers. Advertiser's flow: Influencer's flow:",
        "how_its_made": "There are two main sides of the B4B marketplace - influencers and advertisers. Advertiser's flow: Influencer's flow:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/oiixq/screenshots/uqb3c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oiixq/screenshots/0i1o8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oiixq/screenshots/yhsmu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ethglobal",
        "link": "https://ethglobal.com/showcase/b4bflow-oiixq"
    },
    {
        "title": "ZeoKuessr",
        "brief_description": "GeoGuessr but decentralized and poker-ified, have fun competing against others by betting on how well you know the world",
        "long_description": "GeoGuessr is an exciting and educational game that challenges players to explore random locations on a map and guess where they are, blending geography knowledge with the thrill of discovery. It's a fun way to learn about the world while competing against others or testing your own skills. ZeoKuessr enhances this experience by introducing a competitive edge through crypto staking, where players can wager on their geographical knowledge. The integration of zero-knowledge proofs (ZK) and trusted execution environments (TEE) ensures a fair, tamper-proof environment, making the game even more engaging by adding transparency and trust to the competition. It\u2019s a next-level evolution of GeoGuessr for those looking for both fun and fairness in their gameplay. The game utilizes the Google Maps API to present the players with a world map and a random Google Street View image of any random location in the world. The players must then connect their wallets to play and bet on their geographical prowess by staking an amount. The winnings are split in the ratio of how close your guess on the map is to the actual location. For creating a fair decentralized environment and game states, we use Oasis Sapphire and ROFL for communication with the Oracle contract. For fetching the image securely we use Sign protocol. We also used Metamask for wallet integration.",
        "how_its_made": "The game utilizes the Google Maps API to present the players with a world map and a random Google Street View image of any random location in the world. The players must then connect their wallets to play and bet on their geographical prowess by staking an amount. The winnings are split in the ratio of how close your guess on the map is to the actual location. For creating a fair decentralized environment and game states, we use Oasis Sapphire and ROFL for communication with the Oracle contract. For fetching the image securely we use Sign protocol. We also used Metamask for wallet integration.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/69vv0/screenshots/dbtvn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/69vv0/screenshots/748py/default.jpg",
            "https://ethglobal.b-cdn.net/projects/69vv0/screenshots/wo1i9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/techiepriyansh/ZeoKuessr",
        "link": "https://ethglobal.com/showcase/zeokuessr-69vv0"
    },
    {
        "title": "Circled Fiat",
        "brief_description": "An app that allows merchants to accept USDC payments using Circle's CCTP, enabling customers to pay via Web2 methods like credit cards or PayPal and empowering users and merchants to trade USDC on the chain they want without any additional bridging costs.",
        "long_description": "This application empowers merchants to accept USDC payments by leveraging Circle\u2019s Cross-Chain Transfer Protocol (CCTP). It enables customers to choose their preferred payment method, including Web2 methods such as credit cards, PayPal, and more, while the app seamlessly manages underlying bridging operations across different blockchain networks, eliminating additional fees for either party and the freedom to trade on the choice of their network. The merchants get a seamless UI on which they need to enter the amount, their preferred chain for USDC, and their wallet address that can be loaded by a simple button. The users meanwhile can just scan the QR code generated by merchants, pay the amount using their preferred chains or even traditional Web2 tech like Credit Cards and PayPal and the merchant will receive the desired tokens with no additional costs or delay. All the underlying complexity is abstracted by a seamless UI and UX, so simple that you don't need to know anything about Crypto, thus making it easier for Web3 folks to slowly adopt Crypto and move towards a decentralised future. We further plan to enable our platform tools and APIs for other developers to integrate into their platform through SDKs and public APIs, thus making the integration with existing applications even better. All this is done with security of CCTP, thus user never has to worry about trust! The core of our application is Circle's Programmable Wallet, mainly the Developer Wallet that manages the movement of funds between users and merchants. The conversion between Fiat and USDC is managed using two liquidity pools, currently being on Arbitrum Sepolia for testing and development The bridging of tokens between is powered by CCTP, we currently support Arbitrum Sepolia, Ethereum Sepolia and Polygon with support for more chains coming in future! All this is tied together on our robust backend built using Nest.js, TypeScript, Postgres for maintaining Web2 and Fiat records and all this complexity is kept hidden from the end users using the frontend built using Next.js, TypeScript, and TailwindCSS Lastly, the Web2 payments are managed using Braintree and PayPal's payment gateway services thus ensuring security and robustness",
        "how_its_made": "The core of our application is Circle's Programmable Wallet, mainly the Developer Wallet that manages the movement of funds between users and merchants. The conversion between Fiat and USDC is managed using two liquidity pools, currently being on Arbitrum Sepolia for testing and development The bridging of tokens between is powered by CCTP, we currently support Arbitrum Sepolia, Ethereum Sepolia and Polygon with support for more chains coming in future! All this is tied together on our robust backend built using Nest.js, TypeScript, Postgres for maintaining Web2 and Fiat records and all this complexity is kept hidden from the end users using the frontend built using Next.js, TypeScript, and TailwindCSS Lastly, the Web2 payments are managed using Braintree and PayPal's payment gateway services thus ensuring security and robustness",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6q2ru/screenshots/54qvu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6q2ru/screenshots/5foms/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6q2ru/screenshots/abifk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6q2ru/screenshots/j1wct/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6q2ru/screenshots/2mjci/default.jpg"
        ],
        "live_demo": "https://circled-fiat-web.vercel.app/",
        "source_code": "https://github.com/prathamesh-mutkure/circled-fiat-backend/",
        "link": "https://ethglobal.com/showcase/circled-fiat-6q2ru"
    },
    {
        "title": "Windmill",
        "brief_description": "Windmill is an open source query tool and ecosystem for on chain data. Any on chain data can be queried from the Windmill and developers can build more tools to expand the functionalities of the Windmill.",
        "long_description": "Windmill is an open-source, user-friendly query tool and ecosystem designed to unlock the full potential of on-chain data. By allowing any on-chain data to be queried through simple natural language input and output, Windmill removes the complexity typically associated with blockchain analytics, making it accessible to both developers and non-technical users alike. The Windmill ecosystem consists of four integral components: Demonstration Web App: Built using Next.js, this web app serves as the interface for users to interact with Windmill. It allows users to input natural language queries and receive understandable outputs. Phala Backend: Powered by an AI agent, the backend handles query processing and data retrieval. We have integrated 1inch developer APIs into this backend, leveraging them to efficiently aggregate data from decentralized exchanges and other blockchain sources. This layer is key to providing real-time, actionable insights from on-chain data. Example Tool Project: This tool demonstrates how developers can extend the functionalities of Windmill by building additional tools. It provides a clear template for creating new tools that can seamlessly integrate with the ecosystem, enabling a wide range of enhancements and customizations. NEAR Tool Contract: The NEAR-based smart contract empowers developers to build tools directly within the Windmill ecosystem. By utilizing the smart contract framework, developers can deploy new tools that expand Windmill\u2019s capabilities, all while maintaining a decentralized structure. By focusing on natural language interactions, Windmill simplifies complex blockchain queries, transforming them into understandable and actionable insights. Also, enabling developers to build and integrate additional tools, while providing a user-friendly interface for anyone interested in exploring on-chain data. Windmill leverages a combination of decentralized computing, AI-driven queries, and blockchain integration to build a robust query engine for on-chain data. Here's a detailed breakdown of the architecture and technologies used: Phala Backend:\nWindmill\u2019s backend is powered by Phala, a decentralized shared computing system capable of securely running AI agents. The backend utilizes: OpenAI\u2019s ChatGPT API for natural language processing, handling both the input and output of user queries. Tool calling functionality within the AI agent, enabling dynamic task execution. 1inch API to retrieve data from decentralized exchanges and to query wallet information for fraud detection and analysis. NEAR RPC API to interact with the NEAR blockchain, particularly for handling smart contract interactions. Viem SDK to streamline queries and interactions with Ethereum-based blockchains, allowing Windmill to handle multi-chain data retrieval. Next.js Frontend: The user-facing component of Windmill is built using Next.js. The frontend communicates with the Phala backend via a dedicated API endpoint that handles natural language queries. Queries are passed to the backend using fetch, and results are returned in natural language, making it simple for users to interact with the blockchain without needing technical knowledge. NEAR Tool Contract: Deployed on the NEAR testnet, this smart contract allows developers to extend Windmill\u2019s functionality by building and deploying new tools. Developers register their tools via a JSON schema specification, linking the tool\u2019s URL to the contract. The tools are then available for dynamic invocation by the AI agent when a specific query requires their use. Dynamic Tool Integration: A key innovation in Windmill is the dynamic integration of tools into the AI agent. The agent can query the NEAR smart contract to access new tools that have been registered. This allows Windmill to scale seamlessly by enabling developers to add functionality without modifying the core system. Notable Approach: The use of dynamic tool calling within the AI framework, combined with decentralized registration via smart contracts, allows Windmill to remain flexible and modular. The system dynamically loads and executes tools as needed, reducing the overhead of managing a static set of functions.",
        "how_its_made": "Windmill leverages a combination of decentralized computing, AI-driven queries, and blockchain integration to build a robust query engine for on-chain data. Here's a detailed breakdown of the architecture and technologies used: Phala Backend:\nWindmill\u2019s backend is powered by Phala, a decentralized shared computing system capable of securely running AI agents. The backend utilizes: OpenAI\u2019s ChatGPT API for natural language processing, handling both the input and output of user queries. Tool calling functionality within the AI agent, enabling dynamic task execution. 1inch API to retrieve data from decentralized exchanges and to query wallet information for fraud detection and analysis. NEAR RPC API to interact with the NEAR blockchain, particularly for handling smart contract interactions. Viem SDK to streamline queries and interactions with Ethereum-based blockchains, allowing Windmill to handle multi-chain data retrieval. Next.js Frontend: The user-facing component of Windmill is built using Next.js. The frontend communicates with the Phala backend via a dedicated API endpoint that handles natural language queries. Queries are passed to the backend using fetch, and results are returned in natural language, making it simple for users to interact with the blockchain without needing technical knowledge. NEAR Tool Contract: Deployed on the NEAR testnet, this smart contract allows developers to extend Windmill\u2019s functionality by building and deploying new tools. Developers register their tools via a JSON schema specification, linking the tool\u2019s URL to the contract. The tools are then available for dynamic invocation by the AI agent when a specific query requires their use. Dynamic Tool Integration: A key innovation in Windmill is the dynamic integration of tools into the AI agent. The agent can query the NEAR smart contract to access new tools that have been registered. This allows Windmill to scale seamlessly by enabling developers to add functionality without modifying the core system. Notable Approach: The use of dynamic tool calling within the AI framework, combined with decentralized registration via smart contracts, allows Windmill to remain flexible and modular. The system dynamically loads and executes tools as needed, reducing the overhead of managing a static set of functions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1wx50/screenshots/jypj2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1wx50/screenshots/0savr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1wx50/screenshots/7s3qy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1wx50/screenshots/0ysir/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1wx50/screenshots/wd5v9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1wx50/screenshots/k5sa0/default.jpg"
        ],
        "live_demo": "https://windmill-eth.vercel.app/",
        "source_code": "https://github.com/CenekSanzak/eth-global-singapore",
        "link": "https://ethglobal.com/showcase/windmill-1wx50"
    },
    {
        "title": "ZKML VaultX",
        "brief_description": "ZKML powered trustless ML prediction agents paving the future of DEFI",
        "long_description": "zkML Vault is a decentralized platform that merges the power of machine learning and Zero Knowledge to revolutionize crypto trading. Developers can upload their AI-driven models, trained to predict the returns of various cryptocurrencies like Ethereum, Bitcoin, and others. These models are verified using zero-knowledge proofs (zkML), ensuring that investors can trust the accuracy of predictions without exposing sensitive data. Investors can explore different models, selecting the one that best aligns with their strategy. Once a model is chosen, the investor can confirm the trade amount, and the platform\u2019s smart contracts automatically execute the trade based on the model's predictions. The use of zkML ensures privacy, security, and transparency throughout the process, while smart contracts ensure automated, trustless trade execution. By bridging AI-driven forecasting and decentralized finance, zkML Vault creates a marketplace for predictive models, empowering both developers and investors in the volatile world of cryptocurrency. ZKML VaultX uses VeriSync's transpiler at its core. The transpiler converts the ML models into ZKML circuits in the Plonky2 proving system. These proofs are the verified on-chain during trades. We also use a benchmarking model that takes in public data available on Subgraphs to check the performance of the model. We have used subgraphs to pull data from public Messari subgraphs like Aave V2, V3, and Compound V2, V3. Also, to consider chainlink token prices we have used substreams for price data streaming later used by the ML models. We are using a static backend to make the UI/UX more streamlined and live. Uniswap V4 hooks including ZK Hook were implemented and test cases were written to consider verification of the ZKML proof before swapping. USDC is the base currency of the platform and users can only use USDC to invest in ML models.",
        "how_its_made": "ZKML VaultX uses VeriSync's transpiler at its core. The transpiler converts the ML models into ZKML circuits in the Plonky2 proving system. These proofs are the verified on-chain during trades. We also use a benchmarking model that takes in public data available on Subgraphs to check the performance of the model. We have used subgraphs to pull data from public Messari subgraphs like Aave V2, V3, and Compound V2, V3. Also, to consider chainlink token prices we have used substreams for price data streaming later used by the ML models. We are using a static backend to make the UI/UX more streamlined and live. Uniswap V4 hooks including ZK Hook were implemented and test cases were written to consider verification of the ZKML proof before swapping. USDC is the base currency of the platform and users can only use USDC to invest in ML models.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/83uhb/screenshots/5u5ng/default.jpg",
            "https://ethglobal.b-cdn.net/projects/83uhb/screenshots/dqnda/default.jpg",
            "https://ethglobal.b-cdn.net/projects/83uhb/screenshots/oriuu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/83uhb/screenshots/3r6dv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/armanthepythonguy/ZKMLVaultX-ETHSingapore",
        "link": "https://ethglobal.com/showcase/zkml-vaultx-83uhb"
    },
    {
        "title": "Watering Hole",
        "brief_description": "On-Chain Connections: Break the Ice at Web3 Events! We help the Web3 community form closer bonds.",
        "long_description": "We envision the future of how Web3 connections can be better formed. Most hackers are socially reserved and can do better at forming connections from people around the world. Our DApp is the perfect social ice-breaker tool that takes advantage of the privacy features of the Oasis chain.\nIt first asks simple lifestyle questions about our users through a form that has binary options. It then encrypts the users' responses and stores them on-chain. When users reveal their addresses, they can discover like-mindedness scores with other people. This provides an engaging way to kickstart conversations and forge connections at social events!\nWe built this prototype believing that it will be useful in future physical social events. We built this project using the following technologies: We used Oasis protocol specifically for the privacy reasons. Currently, the score is calculated very simply through a view function. However, we believe that there is room for expansion in the future for open-ended questions. Using ROFL, an AI model could read over the response and give a similarity score.",
        "how_its_made": "We built this project using the following technologies: We used Oasis protocol specifically for the privacy reasons. Currently, the score is calculated very simply through a view function. However, we believe that there is room for expansion in the future for open-ended questions. Using ROFL, an AI model could read over the response and give a similarity score.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vo80o/screenshots/n2ego/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vo80o/screenshots/fcf4o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vo80o/screenshots/9nubx/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/darrylyeo/ethglobal-singapore-2024",
        "link": "https://ethglobal.com/showcase/watering-hole-vo80o"
    },
    {
        "title": "Identifiable",
        "brief_description": "Creating a zero-knowledge proof (ZKP) system for disabled individuals: Users provide their ID, we retrieve their government-issued profile image, and compare it to their live camera feed. The ZKP is stored in an attestation with a wallet address on Sepolia using Sign Protocol.",
        "long_description": "Hi! We are ABLEs, a group of students who want to use our power to make our world better.\nIn ETHGlobal Singapore, we have built a platform named Identifiable, which aims at helping disabled people to protect their sensitive information, like national identifiers, while still enjoying exclusive benefits such as vouchers, discounts, and memberships.\nIn Malaysia, the government has put their effort in supporting diabled person, and we aim to take this further by engaging all platform that has a website for long-term impact.\nWith Identifiable, disabled individuals can verify their status securely using blockchain technologies, especially ZKP. In the end, without disclosing personal details\nVerified once, their status can be trusted across platforms, giving them the benefits they deserve while preserving their privacy. ABLEs believe in building more than just a platform\u2014we are creating a vision where inclusivity, privacy, and opportunity come together. In here, we make dreams, we sell dreams. The system flow is as follow: In our system, we have applied the technologies developed by ETHGlobal Singapore 2024's partners, who are Worldcoin, Dynamic.xyz, Sign Protocol, Noun DAO. ABLEs believe in building more than just a platform\u2014we are creating a vision where inclusivity, privacy, and opportunity come together. In here, we make dreams, we sell dreams.",
        "how_its_made": "The system flow is as follow: In our system, we have applied the technologies developed by ETHGlobal Singapore 2024's partners, who are Worldcoin, Dynamic.xyz, Sign Protocol, Noun DAO. ABLEs believe in building more than just a platform\u2014we are creating a vision where inclusivity, privacy, and opportunity come together. In here, we make dreams, we sell dreams.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ughj0/screenshots/6sy81/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ughj0/screenshots/519m9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ughj0/screenshots/zix8g/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/yayadontknow/only-one",
        "link": "https://ethglobal.com/showcase/identifiable-ughj0"
    },
    {
        "title": "Identifiable",
        "brief_description": "Creating a zero-knowledge proof (ZKP) system for disabled individuals: Users provide their ID, we retrieve their government-issued profile image, and compare it to their live camera feed. The ZKP is stored in an attestation with a wallet address on Sepolia using Sign Protocol.",
        "long_description": "Hi! We are ABLEs, a group of students who want to use our power to make our world better.\nIn ETHGlobal Singapore, we have built a platform named Identifiable, which aims at helping disabled people to protect their sensitive information, like national identifiers, while still enjoying exclusive benefits such as vouchers, discounts, and memberships.\nIn Malaysia, the government has put their effort in supporting diabled person, and we aim to take this further by engaging all platform that has a website for long-term impact.\nWith Identifiable, disabled individuals can verify their status securely using blockchain technologies, especially ZKP. In the end, without disclosing personal details\nVerified once, their status can be trusted across platforms, giving them the benefits they deserve while preserving their privacy. ABLEs believe in building more than just a platform\u2014we are creating a vision where inclusivity, privacy, and opportunity come together. In here, we make dreams, we sell dreams. The system flow is as follow: In our system, we have applied the technologies developed by ETHGlobal Singapore 2024's partners, who are Worldcoin, Dynamic.xyz, Sign Protocol, Noun DAO. ABLEs believe in building more than just a platform\u2014we are creating a vision where inclusivity, privacy, and opportunity come together. In here, we make dreams, we sell dreams.",
        "how_its_made": "The system flow is as follow: In our system, we have applied the technologies developed by ETHGlobal Singapore 2024's partners, who are Worldcoin, Dynamic.xyz, Sign Protocol, Noun DAO. ABLEs believe in building more than just a platform\u2014we are creating a vision where inclusivity, privacy, and opportunity come together. In here, we make dreams, we sell dreams.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ughj0/screenshots/6sy81/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ughj0/screenshots/519m9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ughj0/screenshots/zix8g/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/yayadontknow/only-one",
        "link": "https://ethglobal.com/showcase/identifiable-ughj0"
    },
    {
        "title": "DEX Arbitrage",
        "brief_description": "Building a crypto arbitrage trader using The Graph's indexing tool to analyze and execute trades across decentralized exchanges. Using a substream allows the live tracking of discrepancies to detect opportunities, ensuring efficient and profitable trades with minimal slippage.",
        "long_description": "The primary goal of this bot is to execute profitable arbitrage trades by continuously monitoring price feeds from different DEXs in real-time, allowing for fast, efficient, and low-risk trade execution. Unfortunately, the bot is still some time away from being functional, however I've created a start to this project and will need to further refine it. The three DEXs that are monitored right now are Uniswap V3, SushiSwap, and 1Inch. 1inch was included due to it being an aggregator providing a strong benchmark to the lowest possible price at the moment. As for overall features: Technologies used: Worth mentioning Hacky detail:",
        "how_its_made": "Technologies used: Worth mentioning Hacky detail:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/7cmex/screenshots/3a9o5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7cmex/screenshots/aduzo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7cmex/screenshots/d88yp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/XiJiaoBu/dexarb",
        "link": "https://ethglobal.com/showcase/dex-arbitrage-7cmex"
    },
    {
        "title": "MediCrypt",
        "brief_description": "MediCrypt: Privacy-preserving health data platform. Enables research without exposing raw data. Features: blockchain storage, homomorphic analysis, granular access control, and incentives for data providers. Advancing medical research while preserving patient privacy.",
        "long_description": "MediCrypt is an innovative decentralized platform revolutionizing health data sharing for medical research. Key features include: MediCrypt enables researchers to derive insights from large datasets without exposing individual patient information. It functions as a secure marketplace for encrypted health data. Benefits: Challenges: MediCrypt aims to create a mutually beneficial ecosystem for patients, researchers, and healthcare providers, advancing medical knowledge while prioritizing data privacy and security.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/q1xm1/screenshots/1zgb7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q1xm1/screenshots/pvt28/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q1xm1/screenshots/gzkm3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q1xm1/screenshots/ewqpw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q1xm1/screenshots/r96t0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q1xm1/screenshots/f4hse/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/pratham-bhatnagar/MediCrypt",
        "link": "https://ethglobal.com/showcase/medicrypt-q1xm1"
    },
    {
        "title": "Confidential Payroll",
        "brief_description": "Payroll Protocol is a confidential money distribution platform built on top of BASE , designed to provide confidentiality during the distribution of funds on-chain. By leveraging FHE cryptography and smart contracts",
        "long_description": "Payroll Protocol is a confidential money distribution platform built on top of BASE, designed to provide confidentiality during the distribution of funds on-chain. Leveraging FHE cryptography and smart contracts, and using hyperplane for communication in between the protocols Payroll Protocol ensures the confidentiality, security, and efficiency of money distribution. Overview\nPayroll Protocol integrates Dynamic wallet SDK, BASE  and Fhenix to enhance user experience while confidentially distributing money. Fhenix provides hidden states to store encrypted addresses that hold encrypted amounts on the Fhenix network, ensuring that all transactions are secure and confidential. This integration guarantees that money distribution details and recipient information remain confidential. It uses modified Hyperlane infrastructure to bridge these state values from BASE to FHENIX and vice versa. Key Features\nEncrypted USDC Distributions: Protects sensitive information with robust encryption methods.\nUser-Friendly Interface: Simplifies the payroll process with one click, thanks to BICONOMY SDK.\nStealth Hold: Users can hold stablecoins for an indefinite amount of time without revealing the amount.\nUnderline Distribution: Users can completely hide their withdrawals by distributing the encrypted amount to different encrypted addresses on their behalf, providing an experience similar to Tornado Cash. Tech Stack\nFrontend: Next.js, Tailwind CSS\nAuthentication & Wallets: Dynamic\nBackend & Smart Contracts: Node.js, Solidity\nBlockchain: BASE, FHENIX\nEncryption: FHE scheme\nPayroll Protocol integrates Dynamic wallet SDK, BASE and Fhenix FHEVM to enhance user experience while confidentially distributing money. FHEVM provides hidden states to store encrypted addresses that hold encrypted amounts on the  network, ensuring that all transactions are secure and confidential. This integration guarantees that money distribution details and recipient information remain confidential. It uses modified Hyperlane infrastructure to bridge these state values from BASE to Fhenix and vice versa. Key Features\nEncrypted USDC Distributions: Protects sensitive information with robust encryption methods.\nUser-Friendly Interface: Simplifies the payroll process with one click, thanks to Dynamic Wallet SDK.\nStealth Hold: Users can hold stablecoins for an indefinite amount of time without revealing the amount.\nUnderline Distribution: Users can completely hide their withdrawals by distributing the encrypted amount to different encrypted addresses on their behalf\nUsage\nConnect your web3 wallet.\nNavigate to the distribution page.\nEnter the recipient addresses and amounts.\nConfirm the transaction to distribute funds confidentially.",
        "how_its_made": "Tech Stack\nFrontend: Next.js, Tailwind CSS\nAuthentication & Wallets: Dynamic\nBackend & Smart Contracts: Node.js, Solidity\nBlockchain: BASE, FHENIX\nEncryption: FHE scheme\nPayroll Protocol integrates Dynamic wallet SDK, BASE and Fhenix FHEVM to enhance user experience while confidentially distributing money. FHEVM provides hidden states to store encrypted addresses that hold encrypted amounts on the  network, ensuring that all transactions are secure and confidential. This integration guarantees that money distribution details and recipient information remain confidential. It uses modified Hyperlane infrastructure to bridge these state values from BASE to Fhenix and vice versa. Key Features\nEncrypted USDC Distributions: Protects sensitive information with robust encryption methods.\nUser-Friendly Interface: Simplifies the payroll process with one click, thanks to Dynamic Wallet SDK.\nStealth Hold: Users can hold stablecoins for an indefinite amount of time without revealing the amount.\nUnderline Distribution: Users can completely hide their withdrawals by distributing the encrypted amount to different encrypted addresses on their behalf\nUsage\nConnect your web3 wallet.\nNavigate to the distribution page.\nEnter the recipient addresses and amounts.\nConfirm the transaction to distribute funds confidentially.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/w56a5/screenshots/etvjc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w56a5/screenshots/7xvox/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w56a5/screenshots/8ch9s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w56a5/screenshots/wbxhh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w56a5/screenshots/kzfnj/default.jpg"
        ],
        "live_demo": "https://eth-singapore-xi.vercel.app/",
        "source_code": "https://github.com/TechieeGeeeks/Eth-Global-Singapore",
        "link": "https://ethglobal.com/showcase/confidential-payroll-w56a5"
    },
    {
        "title": "Saturn Foundation",
        "brief_description": "Saturn Foundation enables UBI at a global scale by providing a smart contract vault into which people can deposit money. This money is then distributed to all WorldID verified participants every certain interval and every certain amount.",
        "long_description": "At its core, Saturn Foundation is a smart contract (deployed on Optimism Sepolia) which allows people to deposit money into it (payable contract). Once money is deposited, the sender gets back voting tokens in exchange. More on this in a bit. the contract distributes it to all of the participants of the UBI every certain interval and in X amount. Interval and amount is set at launch but can be changed with the voting tokens from before but contributors. To participate in UBI, all a user has to do is to sign in with WorldID and be WorldID Orb verified. This is a necessity to prevent users from claiming the UBI more than once. The frontend UI is build in NextJS, and we used wagmi and rainbowkit for wallet functionality and blockchain interaction. WorldID verificaton proof is verified on chain inside Saturn Foundation smart contract called SaturnToken, which is built in Solidity and deployed on Optimism Sepolia using Foundry. Originally, we had the idea of deploying our contract logic on Flow, however due to not being able to verify WorldID on chain and Flow's non-support with LayerZero or CCIP, we decided to roll with Optimism Sepolia for simplicity (because that's where WorldID contract lives). Saturn Foundaton smart contract is built in Solidity and is deployed on Optimism Sepolia testnet. It is a payable contract, meaning people can deposit funds into it. It has functions distribute() - checks if interval is passed and distributes funds to a list of participants (can only add yourself if you're world id orb verified), and only once, and participate function - which takes the parameters from WorldID verification from the frontenf - nullifier, root, signal, and proof. It then calls the worldid contract on Optimism Sepolia and verifies the proof. If proof is valid - that is, user is orb verified and also not done the verification with this contract before, the function adds the user's address to participants[] list. the distribute function then distriutes x amount of funds every interval to all of the participant[] addresses.",
        "how_its_made": "Saturn Foundaton smart contract is built in Solidity and is deployed on Optimism Sepolia testnet. It is a payable contract, meaning people can deposit funds into it. It has functions distribute() - checks if interval is passed and distributes funds to a list of participants (can only add yourself if you're world id orb verified), and only once, and participate function - which takes the parameters from WorldID verification from the frontenf - nullifier, root, signal, and proof. It then calls the worldid contract on Optimism Sepolia and verifies the proof. If proof is valid - that is, user is orb verified and also not done the verification with this contract before, the function adds the user's address to participants[] list. the distribute function then distriutes x amount of funds every interval to all of the participant[] addresses.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/4vzhb/screenshots/7wyx5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4vzhb/screenshots/n5t6w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4vzhb/screenshots/o6qdn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4vzhb/screenshots/mwhz0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4vzhb/screenshots/pocrh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4vzhb/screenshots/jx25z/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/vanha777/Saturn-Foundation",
        "link": "https://ethglobal.com/showcase/saturn-foundation-4vzhb"
    },
    {
        "title": "Quotation Station",
        "brief_description": "A peer-to-peer trading system integrating both DEXes and CEXes, powered by agent-based services. With atomic swaps across EVM chains and smart orchestration of agents, we deliver seamless, decentralized arbitrage opportunities for institutional and retail users alike.",
        "long_description": "Quotation Station is a peer-to-peer decentralized trading system, integrating both centralized exchanges (CEXes) and decentralized exchanges (DEXes) through robust connectivity using CCXT and DCTX libraries. Our innovative framework allows users to engage in arbitrage and trading opportunities by leveraging a network of agents, each with distinct roles in an agent-based economy. Key to our system are atomic swaps across EVM-compatible chains, secured by smart contracts that ensure trustless, instant trade execution across multiple blockchain environments. At the heart of the ecosystem is the Orchestrator agent, which manages the lifecycle and health of the various agent services (Solver, Executor, Price Feed). The orchestrator also dynamically incentivizes participation, balancing the number of solvers and executors to ensure smooth, continuous operations, even in cases of participant shortages. Our platform supports both institutional and retail users through a user-friendly, intuitive frontend, simplifying access to powerful decentralized financial tools. The multi-agent architecture allows each agent (Solver, Executor, Price Streamer) to operate individually or in concert with others, creating efficient and scalable agent economies. This modular design fosters a resilient and decentralized peer-to-peer trading system, bringing together liquidity from both centralized and decentralized markets, optimizing arbitrage opportunities and executing trades with maximum efficiency. We built this project using the Autonolas framework, which provided the foundation for our agent-based services. The architecture revolves around a set of core agents\u2014Orchestrator, Solver, Executor, and Price Streamer\u2014each running as individual or multi-agent services that communicate and interact within an agent-economy. The trading system integrates both DEXes and CEXes via two critical libraries: CCXT for centralized exchange (CEX) integration and DCTX for decentralized exchange (DEX) access. This allows us to bring together liquidity and trading functionality from diverse platforms into a unified peer-to-peer system. EVM-based smart contracts are employed to enable atomic swaps across various chains, ensuring secure, trustless trades without intermediary risks. These smart contracts act as the backbone for executing cross-chain arbitrage opportunities. Cross-chain Atomic Swaps: We hacked together a flexible, EVM-compatible smart contract architecture that allows for atomic swaps across multiple blockchains. This reduces the need for traditional intermediaries and allows users to move assets quickly between chains with zero trust required. Incentivized Orchestration: The Orchestrator isn\u2019t just a passive controller\u2014it actively monitors the health of the agent economy and incentivizes more participants by tweaking reward schemes in real-time to balance demand across solvers and executors. This creates a dynamic, self-regulating system. Agent Economies: Each agent can run independently or in a group as a multi-agent service. This modular approach allows for the creation of self-sufficient agent economies that adapt to real-world demand. By combining these technologies and concepts, we\u2019ve built a resilient, decentralized p2p trading system that bridges liquidity between CEXes and DEXes, while automating arbitrage and trade execution in a trustless and scalable manner.",
        "how_its_made": "We built this project using the Autonolas framework, which provided the foundation for our agent-based services. The architecture revolves around a set of core agents\u2014Orchestrator, Solver, Executor, and Price Streamer\u2014each running as individual or multi-agent services that communicate and interact within an agent-economy. The trading system integrates both DEXes and CEXes via two critical libraries: CCXT for centralized exchange (CEX) integration and DCTX for decentralized exchange (DEX) access. This allows us to bring together liquidity and trading functionality from diverse platforms into a unified peer-to-peer system. EVM-based smart contracts are employed to enable atomic swaps across various chains, ensuring secure, trustless trades without intermediary risks. These smart contracts act as the backbone for executing cross-chain arbitrage opportunities. Cross-chain Atomic Swaps: We hacked together a flexible, EVM-compatible smart contract architecture that allows for atomic swaps across multiple blockchains. This reduces the need for traditional intermediaries and allows users to move assets quickly between chains with zero trust required. Incentivized Orchestration: The Orchestrator isn\u2019t just a passive controller\u2014it actively monitors the health of the agent economy and incentivizes more participants by tweaking reward schemes in real-time to balance demand across solvers and executors. This creates a dynamic, self-regulating system. Agent Economies: Each agent can run independently or in a group as a multi-agent service. This modular approach allows for the creation of self-sufficient agent economies that adapt to real-world demand. By combining these technologies and concepts, we\u2019ve built a resilient, decentralized p2p trading system that bridges liquidity between CEXes and DEXes, while automating arbitrage and trade execution in a trustless and scalable manner.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/psqpq/screenshots/1tri1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/psqpq/screenshots/mcih3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/psqpq/screenshots/s13tc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/psqpq/screenshots/fpjqu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/psqpq/screenshots/9qigr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/StationsStation/quotation_station",
        "link": "https://ethglobal.com/showcase/quotation-station-psqpq"
    },
    {
        "title": "ZeroedIn",
        "brief_description": "Class action law suits with anonymous admissable evidence and funds crowd sourced in a decentralized manner.",
        "long_description": "The intention of this project was to create an application where people can open campaigns to pursue legal action against big coorporations or powerful individuals.\nThe idea is for the legal fees to be crowdfunded, and for evidence to be supplied through anonymous whistleblowing, where we use ZKPs to prove a valid asssociation with the evidence, so that it may be admissable in court.\nAfter the court case an oracle should trigger backpayment to distribute the winnings amongst the investors and whistleblowers. We initially meant to use Mina as they had support for the ZKP aspect, but we never got protokit to run smoothly, furthermore it had compatibility issues with ZK email verification, and Mina did not interoperate with Chainlink.\nRegardless, our team is new to the space, so we decided to try building from scratch and learn how to interact with the blockchain instead of focusing on the more exotic tech.",
        "how_its_made": "We initially meant to use Mina as they had support for the ZKP aspect, but we never got protokit to run smoothly, furthermore it had compatibility issues with ZK email verification, and Mina did not interoperate with Chainlink.\nRegardless, our team is new to the space, so we decided to try building from scratch and learn how to interact with the blockchain instead of focusing on the more exotic tech.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/g13wq/screenshots/mr406/default.jpg",
            "https://ethglobal.b-cdn.net/projects/g13wq/screenshots/4ggz7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/g13wq/screenshots/daz6a/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Lussebullen/ZeroedIn",
        "link": "https://ethglobal.com/showcase/zeroedin-g13wq"
    },
    {
        "title": "Identity Tagger",
        "brief_description": "An extension for onchain users to leave labels and tags on addresses, so that all addresses can see others opinions on the address",
        "long_description": "Identity Tagger is a chrome extension tool that encourages people to leave a very short review, in the form of labels/tags on the addresses that they have interacted with. The labels/tags that they leave will be sent in the form of a soul bound token to the target address, so that it will stay permanent and cannot be erased. Other on-chain addresses can see the labels/tags that the address has, and therefore understand what are other people's view on the particular address. For example, [userA] tag (addressX) as 'malicious', when [userB] sees the tag, he/she will be aware and stay vigilent. This tool is meant to be community oriented and wish to bring onchain socialization. You will be able to see all sorts of labels/tags such as 'Smart Money', 'Excellent Trader', 'Rich Miner' etc.\nIdentity Tagger checks that you have had interaction with the target address, and your address is at least a worldcoin verified address, to ensure on-chain uniqueness and authentication. Identity Tagger is built using React.js, it works in a chrome extension browser. It looks into etherscan page and inject labels/tags beside the address field so that everyone can see it. Since we want to make sure that the user cannot erase other people's labelling on them, we've allow taggers to issue Soul Bound Token on AirDAO to the target address. And at same time, our backend will run a script to create notary certificate for the commit and tag type for the target address and then publish it on chian. But we also want to make sure that taggers cannot spam tagging random address, we've limited to only address they've interacted with, and taggers must be a unique human by verifying through worldcoin. We found out that NounsDAO is a community oriented and suitable IP for our tags, so we've added NounsDAO design into our tags.",
        "how_its_made": "Identity Tagger is built using React.js, it works in a chrome extension browser. It looks into etherscan page and inject labels/tags beside the address field so that everyone can see it. Since we want to make sure that the user cannot erase other people's labelling on them, we've allow taggers to issue Soul Bound Token on AirDAO to the target address. And at same time, our backend will run a script to create notary certificate for the commit and tag type for the target address and then publish it on chian. But we also want to make sure that taggers cannot spam tagging random address, we've limited to only address they've interacted with, and taggers must be a unique human by verifying through worldcoin. We found out that NounsDAO is a community oriented and suitable IP for our tags, so we've added NounsDAO design into our tags.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/v45dn/screenshots/vcux9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v45dn/screenshots/jitgi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v45dn/screenshots/q1p5t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v45dn/screenshots/v3zyx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v45dn/screenshots/r7f3z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v45dn/screenshots/00fg9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/diandiandiandedian/AddressTagExtensionV2",
        "link": "https://ethglobal.com/showcase/identity-tagger-v45dn"
    },
    {
        "title": "CryptoTask",
        "brief_description": "Kanban board that integrates sign protocols technology to attest the completion of task, releasing the funds automatically upon completion.",
        "long_description": "Traditionally, freelancers would claim that they have finish the task, however they may not meet the productivity standards or employers would take their time to release payment even when the task was completed on time. We aim to create a kanban board that integrates sign protocols technology to attest the completion of task, releasing the funds automatically upon completion. What we built: The project factory smart contract is created firstly, after that the project contract will be created that has 3 predefined rules: \"Todo\" on the kanban interface will creating task & assigning it (only manager role), once the task is \"Done\" the contract will claim task complete and the manager will attest to it. Next an entry will be created in the sign protocol schema and finally a payment hook is create that automatically release the funds for that task.",
        "how_its_made": "The project factory smart contract is created firstly, after that the project contract will be created that has 3 predefined rules: \"Todo\" on the kanban interface will creating task & assigning it (only manager role), once the task is \"Done\" the contract will claim task complete and the manager will attest to it. Next an entry will be created in the sign protocol schema and finally a payment hook is create that automatically release the funds for that task.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vdcq5/screenshots/y1rvw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vdcq5/screenshots/7fus0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vdcq5/screenshots/ch39b/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Sukilim/productivityty",
        "link": "https://ethglobal.com/showcase/cryptotask-vdcq5"
    },
    {
        "title": "Edugooners",
        "brief_description": "Excited to introduce our education app! Learn anytime, anywhere, with seamless access through Worldcoin authentication and Noun blockchain integration. Empowering users to expand their knowledge in a secure and innovative way! #EdTech #Blockchain #Worldcoin",
        "long_description": "Project Overview\nOur education app is designed to empower users to learn about various topics in a secure and engaging environment. Targeting individuals interested in technology and the Web3 ecosystem, the app combines education with innovative blockchain features. Features\nKey features include personalized learning paths, interactive quizzes, and community-driven content. Users can create accounts using Worldcoin authentication for secure access, and they can customize their profiles with Noun avatars, fostering a sense of belonging in the Web3 community. Technologies Used\nWe built the front end using React, which allows for a responsive and intuitive user interface. The back end is powered by Node.js, ensuring fast and efficient data processing. The integration of Worldcoin facilitates seamless user authentication and security. User Experience\nUsers interact with the app through a straightforward interface, navigating easily between educational modules, quizzes, and community discussions. The app is designed to keep users engaged and motivated to learn. Learning Components\nThe app features integrated learning resources about the Web3 ecosystem. This way, users can enhance their knowledge while using the app, making learning a seamless part of their experience. Our education app is crafted using React for the front end, providing a dynamic and responsive user interface, while Node.js powers the back end, ensuring robust performance and scalability. One of our key features is the seamless integration of Worldcoin for user authentication, which enhances security and simplifies the login process. This integration allows us to implement essential features like page routing efficiently, creating a smooth user experience. In addition, we incorporated Noun profile pictures as a unique touch, aimed at raising awareness about the Web3 ecosystem. By allowing users to showcase their Noun identities, we foster a sense of community and connection within the app. Partnering with Worldcoin and Noun has significantly benefited our project. Their technology not only streamlined our authentication process but also provided us with valuable insights and resources. This collaboration enables us to share educational content about Web3 directly through the app, empowering users to learn while they engage with the platform. Our goal is to create a rich learning environment that encourages exploration and fosters knowledge in the evolving digital landscape.",
        "how_its_made": "Our education app is crafted using React for the front end, providing a dynamic and responsive user interface, while Node.js powers the back end, ensuring robust performance and scalability. One of our key features is the seamless integration of Worldcoin for user authentication, which enhances security and simplifies the login process. This integration allows us to implement essential features like page routing efficiently, creating a smooth user experience. In addition, we incorporated Noun profile pictures as a unique touch, aimed at raising awareness about the Web3 ecosystem. By allowing users to showcase their Noun identities, we foster a sense of community and connection within the app. Partnering with Worldcoin and Noun has significantly benefited our project. Their technology not only streamlined our authentication process but also provided us with valuable insights and resources. This collaboration enables us to share educational content about Web3 directly through the app, empowering users to learn while they engage with the platform. Our goal is to create a rich learning environment that encourages exploration and fosters knowledge in the evolving digital landscape.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/oh90z/screenshots/224qi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oh90z/screenshots/fkmgd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oh90z/screenshots/qcphr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oh90z/screenshots/ruh86/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oh90z/screenshots/k2s6g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oh90z/screenshots/8n0yo/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/seahsongli/Educoders",
        "link": "https://ethglobal.com/showcase/edugooners-oh90z"
    },
    {
        "title": "HandsUp",
        "brief_description": "HandsUp revolutionizes charity with yield return donations, empowering users to multiply their generosity.",
        "long_description": "Everyone wins due to the yield technology. Help your friends, family, and other charitable causes make something meaningful with this money. Everything related to donations. Lock your money, and get it all back whenever you decide, and donate to your favorite charity project with the yield generated from the staked money. Donations need to be censorship-free, secure, simple, and cheap. That's what we fix. Instead of directly giving your money, you can make it work for X time for others in a charitable purpose. Each contribution will be sent into secure DeFi protocols, and the donation recipient will receive the yield return daily. Once the lock is over (the lock time is chosen by the contributor in the process), the contributor will get back the full amount of their assets. They can also choose liquid yield donation, meaning they can withdraw at any time. Of course, the donor is able to choose classic donations. For this project, we've used: And of course, React for the website and Solidity for the smart-contracts.",
        "how_its_made": "For this project, we've used: And of course, React for the website and Solidity for the smart-contracts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mdfx0/screenshots/faw7m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mdfx0/screenshots/hysta/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mdfx0/screenshots/82rst/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mdfx0/screenshots/ajwn0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mdfx0/screenshots/8ubfz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mdfx0/screenshots/7p08o/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/iceywil/EthGlobal-Singapore-2024",
        "link": "https://ethglobal.com/showcase/handsup-mdfx0"
    },
    {
        "title": "NearCraft",
        "brief_description": "Unlock the power of NEAR blockchain with our AI toolkit! Seamlessly deploy smart contracts, optimize performance, and enhance security. Empower your development with cutting-edge AI features tailored for the NEAR ecosystem",
        "long_description": "The AI Toolkit for NEAR blockchain developers is a comprehensive suite of tools designed to simplify and enhance the development process. This project aims to empower developers by providing the following key features: Smart Contract Generation: Users can easily create and deploy smart contracts using intuitive AI prompts. The toolkit generates pseudo-code based on user intent, allowing for quick iterations and final deployments. Performance Optimization: The toolkit analyzes existing smart contracts to evaluate their performance metrics, such as gas usage and execution time. It identifies potential bottlenecks and suggests optimizations, helping developers improve efficiency. Security Analysis: A dedicated security module scans smart contracts for vulnerabilities and best practices, providing detailed reports and recommendations to enhance contract safety. Fraud Detection: The toolkit includes real-time fraud detection capabilities for wallet addresses, helping developers monitor and mitigate risks associated with malicious entities in the NEAR ecosystem. Developer Assistant: An integrated AI assistant is available to answer queries related to NEAR blockchain development, offering support on topics such as best practices, troubleshooting, and guidance on leveraging NEAR features. Documentation and Tutorials: Comprehensive resources, including tutorials and best practice guides, are provided to help developers quickly adapt and maximize the toolkit's capabilities. By combining these features, the AI Toolkit for NEAR aims to streamline the development process, reduce time to market, and enhance the overall security and performance of blockchain applications. This project is geared toward both new and experienced developers looking to leverage the NEAR blockchain effectively. Frontend: The user interface is developed using Next.js, a React framework that enables server-side rendering and static site generation. This choice allows for a fast and responsive user experience while ensuring optimal SEO performance. AI Model Training: For training the AI models, I utilized Galadriel, which provides robust capabilities for machine learning and natural language processing. Galadriel allows for the fine-tuning of models to suit specific use cases, enhancing the accuracy of smart contract generation and performance optimization. OpenAI Integration: To power the AI functionalities, I integrated OpenAI's API. This enables the toolkit to leverage advanced language models for generating code, analyzing performance, and providing developer assistance. The combination of Galadriel for training and OpenAI for inference ensures that the toolkit can deliver high-quality results. Backend Services: The backend is designed to handle user requests, manage data flow, and communicate with the blockchain. It interacts with the NEAR network to deploy smart contracts and retrieve on-chain data, ensuring seamless integration between the toolkit and the blockchain environment.",
        "how_its_made": "Frontend: The user interface is developed using Next.js, a React framework that enables server-side rendering and static site generation. This choice allows for a fast and responsive user experience while ensuring optimal SEO performance. AI Model Training: For training the AI models, I utilized Galadriel, which provides robust capabilities for machine learning and natural language processing. Galadriel allows for the fine-tuning of models to suit specific use cases, enhancing the accuracy of smart contract generation and performance optimization. OpenAI Integration: To power the AI functionalities, I integrated OpenAI's API. This enables the toolkit to leverage advanced language models for generating code, analyzing performance, and providing developer assistance. The combination of Galadriel for training and OpenAI for inference ensures that the toolkit can deliver high-quality results. Backend Services: The backend is designed to handle user requests, manage data flow, and communicate with the blockchain. It interacts with the NEAR network to deploy smart contracts and retrieve on-chain data, ensuring seamless integration between the toolkit and the blockchain environment.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/w70qc/screenshots/wbm0f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w70qc/screenshots/52osi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w70qc/screenshots/bz2tu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xSY3/Near-Craft",
        "link": "https://ethglobal.com/showcase/nearcraft-w70qc"
    },
    {
        "title": "dettnet",
        "brief_description": "dettnet, POC of deploying ttnet on decentralized computing network",
        "long_description": "dettnet, using highly compact ai model and the benefits of fast processing blockchain networks, we can deploying ai model on chain. we are testing it with decision tree model, because the architecture of our ttnet allows us to turn any model into rule based model in the end of the training. we have our source code for the model pipeline in the published paper, and my job in this hackathon is to test the concept of deploying decision tree model on chain, and test it is fast enough for processing some ai inference. in the end, we compare the inference cost in terms of money and time roughly in different deployment environment.",
        "how_its_made": "we have our source code for the model pipeline in the published paper, and my job in this hackathon is to test the concept of deploying decision tree model on chain, and test it is fast enough for processing some ai inference. in the end, we compare the inference cost in terms of money and time roughly in different deployment environment.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/oz79d/screenshots/amzsd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oz79d/screenshots/nsxx1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oz79d/screenshots/pxahb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/yihan2099/dettnet",
        "link": "https://ethglobal.com/showcase/dettnet-oz79d"
    },
    {
        "title": "Wizz",
        "brief_description": "WIZZ is a Fully On-Chain SocialFi platform where users can build, share, and earn. Own your data, showcase your skills, create opportunities, and connect directly with peers\u2014all while earning for your content.",
        "long_description": "WIZZ is a groundbreaking Fully On-Chain SocialFi platform designed to revolutionize how job seekers, creators, developers, institutions, and VCs interact in the digital economy. By integrating SocialFi (Social Finance) principles with decentralized infrastructure, WIZZ offers a seamless environment where individuals and organizations can Build, Share, and Earn\u2014all while retaining full ownership and control over their data and content. Fully On-Chain Credentials (Creds):\nWIZZ ensures that users can create and store immutable, verifiable records of their achievements, skills, and contributions. Whether you're a developer completing a project, a content creator posting valuable work, or a student gaining new skills, WIZZ records it all on-chain, offering a transparent and tamper-proof portfolio of your credentials that can be shared with potential employers or collaborators. SocialFi Integration:\nSocialFi enables users to earn rewards for engaging with the community\u2014whether that\u2019s through creating content, collaborating with others, or participating in peer-to-peer exchanges. Unlike traditional social media platforms, where engagement benefits the platform, WIZZ empowers users to monetize their social interactions, making it a true \u201cearn as you engage\u201d ecosystem. User-Centric Design:\nWIZZ is built with a focus on user experience and engagement. The platform is easy to navigate and encourages interaction while offering tools that allow users to personalize their journey. The intuitive interface ensures that whether you're a seasoned developer or someone new to the blockchain space, you can find value in the platform. Data Ownership:\nUsers on WIZZ are in full control of their data. Unlike centralized platforms where personal information is harvested and monetized without consent, WIZZ operates on a decentralized architecture, meaning that you own your data and decide who can access it. This model offers unprecedented privacy and freedom for users to manage their digital identity. Earn for Your Content:\nContent creators often struggle to monetize their work on traditional platforms due to high fees and platform restrictions. WIZZ changes that by offering multiple revenue streams, including peer-to-peer tipping, content subscriptions, and tokenized rewards for valuable contributions. Every piece of content is yours, and every interaction is rewarded, making it a sustainable ecosystem for creators. Peer-to-Peer Connections:\nWIZZ facilitates direct, decentralized peer-to-peer interactions, eliminating the need for intermediaries in collaboration and communication. Whether you\u2019re forming a team for a project, connecting with VCs for funding, or looking for new career opportunities, WIZZ's P2P connections ensure direct, transparent, and frictionless interactions. Proof of Skill:\nWIZZ's Proof of Skill mechanism allows users to showcase their abilities through on-chain verified contributions, project completions, and community recognition. These credentials are publicly viewable and verifiable, enabling users to build a provable portfolio of their talents that can be used for career advancement, collaboration opportunities, or financial backing. Create Your Own Opportunity:\nOne of WIZZ\u2019s core philosophies is empowerment. Whether you're a job seeker, an entrepreneur, or a creative, WIZZ enables you to take control of your own career. Users can build and showcase projects, connect directly with like-minded professionals, and pitch ideas to investors\u2014all in a decentralized, trustless environment. This creates a global marketplace of opportunities where traditional barriers to entry are broken down, offering a level playing field for all participants. In the traditional job market, job seekers face significant barriers such as limited career flexibility, middlemen-controlled compensation, and outdated credentialing systems. VCs struggle with transparency and liquidity in investments, while institutions face challenges in keeping curriculums relevant and engaging with skilled talent. WIZZ solves these problems by offering a decentralized platform that connects all stakeholders directly, promotes transparency, and incentivizes participation through earned rewards. WIZZ empowers everyone to Build, Share, and Earn in a decentralized, user-driven ecosystem where opportunities are limitless and barriers are non-existent. WIZZ is built using Next.js for the frontend, making it fast and user-friendly. The smart contracts are developed using Remix IDE, fully optimized for secure and cost-efficient transactions on the Flow blockchain, which is known for its scalability and low fees. We integrated the wagmi library for smooth blockchain interactions, and ENS (Ethereum Name Service) for easy-to-read addresses. WIZZ also integrates IPFS (InterPlanetary File System) and pinning services to ensure decentralized storage for content and data. This allows users to store and access data securely, without relying on centralized servers, enhancing privacy and data ownership. For job listings, we used the Sign protocol to verify the poster's credibility with attestations, ensuring genuine job postings. This creates a decentralized, transparent, and efficient platform for users to build, share, and earn.",
        "how_its_made": "WIZZ is built using Next.js for the frontend, making it fast and user-friendly. The smart contracts are developed using Remix IDE, fully optimized for secure and cost-efficient transactions on the Flow blockchain, which is known for its scalability and low fees. We integrated the wagmi library for smooth blockchain interactions, and ENS (Ethereum Name Service) for easy-to-read addresses. WIZZ also integrates IPFS (InterPlanetary File System) and pinning services to ensure decentralized storage for content and data. This allows users to store and access data securely, without relying on centralized servers, enhancing privacy and data ownership. For job listings, we used the Sign protocol to verify the poster's credibility with attestations, ensuring genuine job postings. This creates a decentralized, transparent, and efficient platform for users to build, share, and earn.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hhs8j/screenshots/t7um3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hhs8j/screenshots/o1k8q/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hhs8j/screenshots/yb3xi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hhs8j/screenshots/porqr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hhs8j/screenshots/5rvpe/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hhs8j/screenshots/rpun5/default.jpg"
        ],
        "live_demo": "https://wizz-new.vercel.app/",
        "source_code": "https://github.com/urmaliyadivyanshu31/Wizz",
        "link": "https://ethglobal.com/showcase/wizz-hhs8j"
    },
    {
        "title": "Citadel.Onchain",
        "brief_description": "Citadel Onchain is an unsecured lending onchain and especially identification through worldID  avoid risks from fake accounts  .Connect to a 3rd party provider to mint NFT credits.  NFT credits can borrow money without collateral. And users can provide staking for reward",
        "long_description": "Citadel Onchain is a bankless bank that provides unsecured loans through credit score review by providing credit score through 3rd party transaction history data for authentication.\nand especially identification through worldID makes lending on the Defi system avoid risks from fake accounts.\nCriteria for considering credit scores :\nMonthly Netflix payments.\nCheck past fraud history.\nCheck monthly income such as salary\n\u2026\nThird parties will provide NFTs for accounts. which is identified with World.ID . Users will use NFTs to collateralize credit scores. and receive loans based on pool distribution divided equally by credit score. and the user must repay the loan to be able to withdraw the NFT credit score. If the overdue loan is not paid, the NFT credit will be locked and it will be considered a fraud and will not be used for future loans.\nAnd if users have an extra income, they can participate in staking on the chain to provide liquidity for users who need loans. The user receives a reward token. And then the longer the user stakes, the higher the credit certificate will be In this project, we use World.ID onchain on the sepolina testnet chain for authentication, Backend uses smartcontract for Credit NFT and Lending. As for the frontend, we use nextjs combined with wagmi and worldcoin/idkit to connect and authenticate web3.We use the deploy environment for the frontend which is vercel and for the backend we deploy on sepolia testnet",
        "how_its_made": "In this project, we use World.ID onchain on the sepolina testnet chain for authentication, Backend uses smartcontract for Credit NFT and Lending. As for the frontend, we use nextjs combined with wagmi and worldcoin/idkit to connect and authenticate web3.We use the deploy environment for the frontend which is vercel and for the backend we deploy on sepolia testnet",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/za9t8/screenshots/go3hd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/za9t8/screenshots/6ytuv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/za9t8/screenshots/i058f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/za9t8/screenshots/fvcy2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/za9t8/screenshots/jjumc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/za9t8/screenshots/bw5y7/default.jpg"
        ],
        "live_demo": "https://citadel-onchain.vercel.app/",
        "source_code": "https://github.com/kurodenjiro/citadel-onchain/",
        "link": "https://ethglobal.com/showcase/citadel-onchain-za9t8"
    },
    {
        "title": "0xGuardian",
        "brief_description": "The project aims to create an app to easily & verifiably generate user reviews & ratings which are non editable and  can be used for trustable judgement of the service provided.",
        "long_description": "The project aims to create an app to easily & verifiably generate user reviews & ratings which are non editable and  can be used for trustable judgement of the service provided. We aim to to serve consumers everywhere by providing trustable reviews which allow for fair judgement and Scam Prevention. We have made two facets to the app. A web app for registering service providers and handling business side and a Mobile App to allow users to easily access available services and add reviews. The project uses WORLDCOIN's World ID anonymous actions to generate proof of human hood and create  Anonymous Unique Human reviews. Login and identity management is done via DYNAMIC. Then proof of interaction is generated with Zero Knowledge and reviews are stored on chain. We have also deployed on mobile for accessing more user base. These feedbacks are used to create un-transferable Soul Based Tokens on AIRDAO to make the reviews tamper proof. We have created a new paradigm of co-ownership between the reviewer and the reviewee of SBTs to store and analyze reviews and perform reputation management. These are also further used for reward generation for both the parties. We have used OASIS to perform private computation on reviews & ratings to generate concise recap for new users. We use Zero Knowledge to endure privacy and security on the review data. To incorporate Soul Based Tokens (SBTs) of AirDAO for Data Processing and Analytics into your system architecture, you can enhance the existing design as follows: Enhanced System Architecture Business Side Client Side Backend Services Blockchain Layer Data Processing and Analytics System Design Diagram Enhancements This enhanced architecture ensures a secure, verifiable, and decentralized system for managing reviews and ratings, with added capabilities for data processing and analytics using SBTs.",
        "how_its_made": "To incorporate Soul Based Tokens (SBTs) of AirDAO for Data Processing and Analytics into your system architecture, you can enhance the existing design as follows: Enhanced System Architecture Business Side Client Side Backend Services Blockchain Layer Data Processing and Analytics System Design Diagram Enhancements This enhanced architecture ensures a secure, verifiable, and decentralized system for managing reviews and ratings, with added capabilities for data processing and analytics using SBTs.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pr3bd/screenshots/2g3oy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pr3bd/screenshots/sf2vm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pr3bd/screenshots/meizs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pr3bd/screenshots/a135t/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ETH-Singapore/core",
        "link": "https://ethglobal.com/showcase/0xguardian-pr3bd"
    },
    {
        "title": "C6credits",
        "brief_description": "c6credits leverages NFC technology to streamline carbon credit offsetting, enabling businesses and individuals to instantly verify and offset carbon credits through physical interactions, providing a seamless and transparent way to contribute to environmental sustainability.",
        "long_description": "c6credits is a decentralized carbon offset exchange platform designed to enable businesses and individuals to buy, sell, and trade carbon credits in a secure, transparent, and efficient manner. The platform addresses key challenges in the traditional carbon credit market\u2014such as lack of transparency, fraud, and inefficiency\u2014by utilizing blockchain technology and other advanced protocols to ensure verifiable, authentic, and trackable carbon credits. Core Features: Blockchain-Powered Carbon Credit Trading\nImmutable, transparent ledger for traceable carbon credit transactions, eliminating intermediaries for faster, secure, and cost-efficient trading. Cross-Chain Compatibility with Chainlink's CCIP\nFacilitates carbon credit movement across different blockchains, enhancing liquidity and accessibility for all users. Optimized Token Swaps with 1inch\nEnsures the best rates for converting cryptocurrencies and carbon credits by pooling liquidity from multiple decentralized exchanges. Fraud Prevention with Worldcoin's World ID\nVerifies real individuals to prevent fraud and false claims, ensuring legitimate carbon credit offsets. Verifiable Attestations with Sign Protocol\nGuarantees the legitimacy of carbon credits by attaching verifiable metadata on their source and impact. NFC Integration for Physical Offsetting\nAllows users to offset carbon credits via NFC-enabled devices in real-world settings like events or points of sale. User-Friendly Interface and Analytics\nProvides an intuitive platform to track carbon footprints, buy credits, and view real-time environmental impact analytics. Carbon Credit Market Integration: Connects with existing registries and markets, enabling verified carbon credits for businesses and individuals to trade. Future Vision: c6credits was built using a combination of blockchain technologies, decentralized protocols, and modern development frameworks to create a seamless platform for carbon credit trading and offsetting. Technologies Used: Celo and Base blockchains provide low transaction costs and energy efficiency. Chainlink\u2019s CCIP enables cross-chain carbon credit trading, enhancing liquidity by allowing credits to move seamlessly across different blockchain ecosystems. Solidity smart contracts power the platform\u2019s core functions like minting, trading, and validating carbon credits. Carbon credits are tokenized as NFTs, tied to environmental projects, ensuring transparency and immutability. The 1inch API optimizes carbon credit trades by aggregating liquidity from multiple DEXs, ensuring the best rates and reducing transaction costs. Worldcoin's World ID verifies the authenticity of platform participants, preventing fraud or double-counting, while ensuring privacy. Provides verifiable attestations for carbon credits, ensuring their legitimacy and traceability to real environmental projects. NFC technology was used to create real-world touchpoints where users can instantly offset their carbon emissions. For instance, NFC-enabled devices at events or points of sale can trigger the automatic offsetting of carbon credits based on the user's activities. This real-world integration makes carbon offsetting more accessible and practical, allowing users to take action on carbon reduction as part of their everyday routines. React and Next.js power the dynamic, responsive user interface, with server-side rendering for scalability. For the backend, we utilized Node.js and Express to handle API requests, interact with smart contracts, and manage user authentication and verification via World ID. The backend is designed to be lightweight and scalable, interfacing with blockchain networks to validate transactions and process user interactions in real time. Although blockchain ensures immutability for transactions, we used MongoDB for storing metadata, user profiles, and platform-related information. This includes tracking user activities, NFC interactions, and analytics on carbon credit trades.",
        "how_its_made": "c6credits was built using a combination of blockchain technologies, decentralized protocols, and modern development frameworks to create a seamless platform for carbon credit trading and offsetting. Technologies Used: Celo and Base blockchains provide low transaction costs and energy efficiency. Chainlink\u2019s CCIP enables cross-chain carbon credit trading, enhancing liquidity by allowing credits to move seamlessly across different blockchain ecosystems. Solidity smart contracts power the platform\u2019s core functions like minting, trading, and validating carbon credits. Carbon credits are tokenized as NFTs, tied to environmental projects, ensuring transparency and immutability. The 1inch API optimizes carbon credit trades by aggregating liquidity from multiple DEXs, ensuring the best rates and reducing transaction costs. Worldcoin's World ID verifies the authenticity of platform participants, preventing fraud or double-counting, while ensuring privacy. Provides verifiable attestations for carbon credits, ensuring their legitimacy and traceability to real environmental projects. NFC technology was used to create real-world touchpoints where users can instantly offset their carbon emissions. For instance, NFC-enabled devices at events or points of sale can trigger the automatic offsetting of carbon credits based on the user's activities. This real-world integration makes carbon offsetting more accessible and practical, allowing users to take action on carbon reduction as part of their everyday routines. React and Next.js power the dynamic, responsive user interface, with server-side rendering for scalability. For the backend, we utilized Node.js and Express to handle API requests, interact with smart contracts, and manage user authentication and verification via World ID. The backend is designed to be lightweight and scalable, interfacing with blockchain networks to validate transactions and process user interactions in real time. Although blockchain ensures immutability for transactions, we used MongoDB for storing metadata, user profiles, and platform-related information. This includes tracking user activities, NFC interactions, and analytics on carbon credit trades.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/onfcy/screenshots/gya87/default.jpg",
            "https://ethglobal.b-cdn.net/projects/onfcy/screenshots/yu4wg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/onfcy/screenshots/64zon/default.jpg",
            "https://ethglobal.b-cdn.net/projects/onfcy/screenshots/owz54/default.jpg",
            "https://ethglobal.b-cdn.net/projects/onfcy/screenshots/p4z9o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/onfcy/screenshots/cx6ey/default.jpg"
        ],
        "live_demo": "https://c6credits.vercel.app/",
        "source_code": "https://github.com/vmmuthu31/C6Credits",
        "link": "https://ethglobal.com/showcase/c6credits-onfcy"
    },
    {
        "title": "Orbital EMP",
        "brief_description": "Platform for airdrops with built-in automated anti-sybil. It allows detection to be aggressive because users can seek recourse via proof of humanity.",
        "long_description": "This project would allow airdrop creators to setup their airdrop campaigns with built-in anti-sybil provisions.\nThey would provide the list of airdrop eligible wallets, which will be screened via clustering or any other automated anti-sybil tooling. These tools can be aggressive (high false positive), because users will be able to seek recourse for being wrongly flagged as a bot. Users can visit the site to check their drops and attempt to claim them, and those who find themselves flagged as a bot may use their world id to verify their humanity. This means the process should be frictionless for most users, while power users with multiple wallets that seem suspicious have a means of verifying themselves and separating themselves from the bot farmers. The project consists of two parts: the T3-based client and an additional flask backend.\nThe T3 stack forms the main scaffold and glue for the project: For the users that fail the sybil detection, an option to verify their humanity is done through integrating worldid: this is done by simply using worldidkit and allowing logins via QR code (+worldapp) which then grants the user a verified status. For sybil detection, we use the Louvain Algorithm via a convenient python library, networkx, all accessible via flask.\nFor the transaction data, I would have liked to use a subgraph but within the time constraints, I couldn't find one with the suitable transaction data.",
        "how_its_made": "The project consists of two parts: the T3-based client and an additional flask backend.\nThe T3 stack forms the main scaffold and glue for the project: For the users that fail the sybil detection, an option to verify their humanity is done through integrating worldid: this is done by simply using worldidkit and allowing logins via QR code (+worldapp) which then grants the user a verified status. For sybil detection, we use the Louvain Algorithm via a convenient python library, networkx, all accessible via flask.\nFor the transaction data, I would have liked to use a subgraph but within the time constraints, I couldn't find one with the suitable transaction data.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ws89e/screenshots/z8c3f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ws89e/screenshots/o95d4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ws89e/screenshots/tzvpx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ws89e/screenshots/panyi/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xEljh/orbital-precision-emp",
        "link": "https://ethglobal.com/showcase/orbital-emp-ws89e"
    },
    {
        "title": "Token-Techie",
        "brief_description": "Introducing TokenTechies: a user-friendly platform for seamless investment and management of crypto assets. Connect your wallet, explore unique buckets, and maximize your investment potential with ease. Join us in revolutionizing the way you invest! \ud83d\ude80\u2728 #Crypto #Investing",
        "long_description": "Managing token portfolios in the DeFi space can be tedious and often leads to a subpar user experience. Token Techie addresses this challenge by simplifying the investment process through the creation of \"buckets.\" These buckets allow users to aggregate multiple tokens into a single portfolio, streamlining investments while minimizing gas fees. Built on the Arbitrum network and utilizing 1inch Fusion, Token Techie enables users to invest in these token buckets with just one transaction, reducing the need for multiple transactions and the associated costs. This not only enhances efficiency but also makes investing more accessible. Token Techie incentivizes users who engage with their buckets, creating a thriving ecosystem that benefits all participants. As a mutual fund aggregator, the platform supports a wide range of tokens and provides valuable analytics for real-time monitoring of bucket performance. By simplifying token management and enhancing user engagement, Token Techie is set to redefine the investment landscape in Web3. Experience a smarter, cost-effective way to invest, where your tokens are optimized for maximum impact without the usual complexities. How It's Made\nToken Techie is designed to provide an intuitive and efficient platform for managing token investments using cutting-edge technology. Here\u2019s a breakdown of the key components that power this project: Technologies Used\nBlockchain Networks: Arbitrum, Base, and Polygon: We leverage multiple chains to give users a diverse range of token options. This flexibility allows users to select from a variety of tokens when creating their investment buckets. 1inch Fusion API: The integration of the 1inch Fusion API is central to our functionality. It enables seamless swapping of deposited amounts into the tokens chosen by the user when they create a bucket. This ensures that users can optimize their investments without needing to manage individual token swaps themselves.\nSmart Contracts: Our Solidity smart contracts manage the creation and management of token buckets, facilitating secure transactions and investment strategies.\nFrontend Framework: Next.js: We use Next.js to build a fast and responsive user interface, enhancing the overall user experience through server-side rendering.\nState Management: React and Hooks: The UI components are built with React, utilizing hooks for state management to create a smooth and interactive experience.\nWallet Integration: WalletConnect: Users can easily log in using WalletConnect, allowing them to connect their wallets securely across different platforms without the need to hold any tokens beforehand.\nUser Experience\nDeposit Flexibility: Users can simply deposit USDC or USDT into Token Techie. There\u2019s no need to hold multiple tokens; Finn handles all the necessary swaps and investments automatically. Bucket Creation: While creating a bucket, users can select multiple tokens from the Arbitrum, Base, and Polygon chains. The platform takes care of the rest, ensuring that the investment process is straightforward and efficient. Benefits of Using 1inch Fusion\nOptimized Swaps: The 1inch Fusion API aggregates liquidity from various decentralized exchanges, providing users with the best rates for their swaps.\nReduced Complexity: By handling all the swapping and investing, Token Techie eliminates the need for users to manage individual transactions, simplifying the investment process significantly.\nChallenges and Solutions\nWe faced challenges related to optimizing gas fees during token swaps. By implementing efficient transaction batching and utilizing caching strategies, we reduced the number of on-chain interactions, leading to lower costs and improved performance. In conclusion, Token Techie represents a significant advancement in the DeFi space, enabling users to manage their investments effortlessly while benefiting from the powerful capabilities of 1inch Fusion and the flexibility of multiple blockchain networks.",
        "how_its_made": "How It's Made\nToken Techie is designed to provide an intuitive and efficient platform for managing token investments using cutting-edge technology. Here\u2019s a breakdown of the key components that power this project: Technologies Used\nBlockchain Networks: Arbitrum, Base, and Polygon: We leverage multiple chains to give users a diverse range of token options. This flexibility allows users to select from a variety of tokens when creating their investment buckets. 1inch Fusion API: The integration of the 1inch Fusion API is central to our functionality. It enables seamless swapping of deposited amounts into the tokens chosen by the user when they create a bucket. This ensures that users can optimize their investments without needing to manage individual token swaps themselves.\nSmart Contracts: Our Solidity smart contracts manage the creation and management of token buckets, facilitating secure transactions and investment strategies.\nFrontend Framework: Next.js: We use Next.js to build a fast and responsive user interface, enhancing the overall user experience through server-side rendering.\nState Management: React and Hooks: The UI components are built with React, utilizing hooks for state management to create a smooth and interactive experience.\nWallet Integration: WalletConnect: Users can easily log in using WalletConnect, allowing them to connect their wallets securely across different platforms without the need to hold any tokens beforehand.\nUser Experience\nDeposit Flexibility: Users can simply deposit USDC or USDT into Token Techie. There\u2019s no need to hold multiple tokens; Finn handles all the necessary swaps and investments automatically. Bucket Creation: While creating a bucket, users can select multiple tokens from the Arbitrum, Base, and Polygon chains. The platform takes care of the rest, ensuring that the investment process is straightforward and efficient. Benefits of Using 1inch Fusion\nOptimized Swaps: The 1inch Fusion API aggregates liquidity from various decentralized exchanges, providing users with the best rates for their swaps.\nReduced Complexity: By handling all the swapping and investing, Token Techie eliminates the need for users to manage individual transactions, simplifying the investment process significantly.\nChallenges and Solutions\nWe faced challenges related to optimizing gas fees during token swaps. By implementing efficient transaction batching and utilizing caching strategies, we reduced the number of on-chain interactions, leading to lower costs and improved performance. In conclusion, Token Techie represents a significant advancement in the DeFi space, enabling users to manage their investments effortlessly while benefiting from the powerful capabilities of 1inch Fusion and the flexibility of multiple blockchain networks.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vmjhn/screenshots/cuvnm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vmjhn/screenshots/7a2rs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vmjhn/screenshots/um7sn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vmjhn/screenshots/81m9f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vmjhn/screenshots/gm7bz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vmjhn/screenshots/9satv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/SHLOK333/zeromk",
        "link": "https://ethglobal.com/showcase/token-techie-vmjhn"
    },
    {
        "title": "Omni-NFT-Escrow",
        "brief_description": "This project that demonstrates the use of Layer Zero to create an Omnichain NFT Trading Escrow Contract.",
        "long_description": "The goal of this project was to use Layer Zero's Omnichain messaging capabilities to resolve trading NFTs across different chains. Currently, there is no known way for users to seamlessly trade their NFTs that exist on one chain with an NFT on another chain. At the time of writing, to achieve this, the user's NFT either has to have its contract also deployed on the desired chain to swap, which will allow them to bridge or wrap their NFTs to be represented on the desired chain. While this allows certain NFTs to be traded, it will not work for NFTs that do not have a counterpart representation on another chain. Bored Apes on Ethereum for example, can never be swapped with another NFT on another chain because it does not exist on another chain to be bridged/wrapped over. By setting up an NFT trading escrow contract powered by Layer Zero and deploying it on both chains, User1 for example, can deposit and initiate an interest to trade on chain 1, which then sends a message to its contract on chain 2 to announce the desired NFT to be traded. A User2, can then deposit the desired NFT on the contract on chain 2 if he wishes to trade and send a message back to chain 1 to confirm that the trade is real and ready to be fulfilled. User1 can then fulfil the trade which triggers the transfers of the NFTs to the new owners. This project was build using Hardhat. The Solidity smart contracts adopted Layer Zero's OApp as well as OpenZepplin's libraries. Layer Zero's OApp provides up the _lzSend() function which is what is used within the contract logics to initiate a message to the destination chain. This also required a setup of the peers in order for the chains to connect with each other. The contract is also designed to handle multiple types of message via _lzReceive(). For this project, because of the different messages that need to be sent, a message type enum is introduced and first decoded by _lzReceive() before being handled respectively.",
        "how_its_made": "This project was build using Hardhat. The Solidity smart contracts adopted Layer Zero's OApp as well as OpenZepplin's libraries. Layer Zero's OApp provides up the _lzSend() function which is what is used within the contract logics to initiate a message to the destination chain. This also required a setup of the peers in order for the chains to connect with each other. The contract is also designed to handle multiple types of message via _lzReceive(). For this project, because of the different messages that need to be sent, a message type enum is introduced and first decoded by _lzReceive() before being handled respectively.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/e402d/screenshots/3en2x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/e402d/screenshots/uim9s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/e402d/screenshots/n4bpb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/e402d/screenshots/mazkp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/seansing/omnichain-nft-trade-escrow",
        "link": "https://ethglobal.com/showcase/omni-nft-escrow-e402d"
    },
    {
        "title": "WinWin-Lottery",
        "brief_description": "WinWin-Lottery is a no-loss lottery platform where users stake their tokens to earn yield over time. The yield generated from staked tokens is pooled and distributed as rewards without the risk of losing the initial deposit.",
        "long_description": "Overview:\nWinWin-Lottery is a no-loss lottery platform where users stake their tokens to earn yield over time. The yield generated from staked tokens is pooled and distributed as rewards without the risk of losing the initial deposit. Participants can win rewards in daily, weekly, and monthly lotteries, creating a sustainable and user-friendly way to earn while maintaining full control over their deposits. Key Features\nZero-Loss Participation: Stake tokens, earn yield, and participate in the lottery with no risk of losing the initial deposit.\nRewards Distribution: The yield generated from staking is pooled and distributed as lottery rewards (daily, weekly, and monthly).\nSustainable Model: Users only win or withdraw their full deposit, while the generated yield is pooled for lottery rewards.\nMultiple Reward Tiers:\nDaily Rewards: Small, frequent rewards to keep users engaged.\nWeekly Rewards: Larger rewards for mid-term stakers.\nMonthly Rewards: The largest rewards for long-term participants.\nNo-Loss Withdrawal: Users can withdraw their initial deposit at any time, and their share of the yield contributes to the reward pools.\nYield Generation: Assets are staked in secure DeFi platforms (e.g., Aave, Compound) for consistent yield generation.\nProtocol Fees: A small percentage of the yield is allocated to the protocol to ensure sustainability.\nUser-Friendly Interface: Simplified DeFi interaction, making it easy for users to stake tokens and start earning rewards.\nScalability: Supports multiple tokens and integrates with additional DeFi yield protocols over time. We have used mina protocol protokit to make the things , even we made contracts on flow which is deployed on flow-evm . How It Works\nStaking:\nUsers deposit ERC-20 tokens into the protocol, which are locked for a specific period (daily, weekly, or monthly), depending on the selected reward tier. Yield Generation:\nThe protocol stakes the assets in yield-generating DeFi platforms like Aave or Compound, earning interest over time. Lottery Pools:\nThe interest generated from staked assets is pooled into reward categories (daily, weekly, and monthly). No-Loss Withdrawal:\nUsers can withdraw their initial deposit at any time. However, their share of the yield will contribute to the prize pools. Protocol Fees:\nA small portion of the yield is taken as a protocol fee to ensure operational sustainability.",
        "how_its_made": "We have used mina protocol protokit to make the things , even we made contracts on flow which is deployed on flow-evm . How It Works\nStaking:\nUsers deposit ERC-20 tokens into the protocol, which are locked for a specific period (daily, weekly, or monthly), depending on the selected reward tier. Yield Generation:\nThe protocol stakes the assets in yield-generating DeFi platforms like Aave or Compound, earning interest over time. Lottery Pools:\nThe interest generated from staked assets is pooled into reward categories (daily, weekly, and monthly). No-Loss Withdrawal:\nUsers can withdraw their initial deposit at any time. However, their share of the yield will contribute to the prize pools. Protocol Fees:\nA small portion of the yield is taken as a protocol fee to ensure operational sustainability.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sznnv/screenshots/0ph66/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sznnv/screenshots/gd80t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sznnv/screenshots/2eoau/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sznnv/screenshots/yqt05/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ayushsingh82/WinWin-Lottery",
        "link": "https://ethglobal.com/showcase/winwin-lottery-sznnv"
    },
    {
        "title": "Real Votes",
        "brief_description": "RealVotes: Revolutionizing Digital Democracy with WorldCoin and Oasis Sapphire",
        "long_description": "Project Overview\nRealVotes is a cutting-edge decentralized voting application (dApp) that combines the power of WorldCoin's proof of personhood technology with Oasis Sapphire's privacy-preserving blockchain. This innovative solution addresses the critical challenges of online voting systems: identity verification, vote privacy, and process transparency.\nKey Features Sybil-Resistant Identity Verification: Leveraging WorldCoin's biometric verification to ensure one person, one vote.\nPrivacy-Preserving Voting: Utilizing Oasis Sapphire's confidential smart contracts for anonymous yet verifiable voting.\nReal-Time Results: Displaying live vote tallies while maintaining individual vote secrecy.\nUser-Friendly Interface: Built with Next.js and React for a smooth, responsive user experience. Technical Implementation\nFrontend Framework: Next.js 14 with React\nStyling: Tailwind CSS for responsive design Blockchain Integration Web3 Connectivity: Web3Modal for seamless wallet connections\nBlockchain Interaction: ethers.js and wagmi for robust blockchain operations\nSupported Networks: Configurable for various testnets and local development Identity Verification WorldCoin Integration: WorldID Widget for secure and private identity proofing\nLocal Storage: Caching of verification status for improved user experience Smart Contract Platform: Deployed on Oasis Sapphire Testnet\nFunctionality: Manages vote storage, tallying, and rule enforcement\nPrivacy Features: Leverages Sapphire's confidential contract capabilities User Flow Wallet Connection: Users connect their Web3 wallet (e.g., MetaMask) to the dApp.\nNetwork Validation: The app verifies the connected network, prompting users to switch if necessary.\nWorldCoin Verification: Users verify their unique identity using the WorldID widget.\nVoting Process: Upon successful verification, users can select their voting option.\nVotes are submitted as confidential transactions on the Oasis Sapphire network. Result Display: Real-time vote tallies are updated and displayed, maintaining individual vote privacy. Privacy and Security Measures Zero-Knowledge Proofs: WorldCoin verifies identity without revealing personal information.\nConfidential Transactions: Oasis Sapphire ensures vote content is encrypted and not visible on the public blockchain.\nAnonymous Voting: The smart contract records that an address has voted without linking the specific vote to the address.\nTransparent Tallying: Despite individual vote privacy, the overall tally is publicly verifiable. Unique Value Proposition\nRealVotes stands out by addressing key challenges in digital voting: Sybil Attack Prevention: WorldCoin's biometric verification eliminates the risk of multiple voting by a single entity.\nTrue Anonymity: Combining WorldCoin's privacy-preserving verification with Oasis Sapphire's confidential contracts ensures votes are anonymous yet verifiable.\nGlobal Accessibility: WorldCoin's inclusive approach allows for a diverse, worldwide voter base.\nScalability: Designed to handle large-scale voting events efficiently.\nEnhanced Trust: The dual-layer privacy approach (WorldCoin + Oasis Sapphire) builds credibility in the voting process. Potential Applications\nWhile currently implemented for a simple color preference vote, RealVotes' architecture is scalable for more significant use cases: Corporate Governance\nCommunity Decision Making in DAOs\nPublic Opinion Polling\nLocal and National Elections Future Enhancements Integration with additional identity verification systems\nExpansion to support complex voting mechanisms (e.g., ranked-choice voting)\nImplementation of decentralized vote counting and result verification\nDevelopment of a mobile application for increased accessibility Conclusion\nRealVotes represents a significant leap forward in digital voting technology. By combining WorldCoin's innovative approach to identity verification with Oasis Sapphire's privacy-focused blockchain, we've created a platform that ensures vote integrity, user privacy, and process transparency. This project not only demonstrates the practical application of cutting-edge blockchain technologies but also opens up new possibilities for secure and trustworthy digital democracy. RealVotes: Technical Implementation\nCore Stack Next.js 14 with React and TypeScript\nTailwind CSS for styling\nFramer Motion for animations Blockchain Integration Oasis Sapphire for confidential smart contracts\nWeb3Modal for wallet connections\nethers.js and wagmi for blockchain interactions\nMulti-chain support: Sepolia, Base Sepolia, Optimism Sepolia, Oasis Sapphire Testnet Key Features WorldCoin integration for Sybil-resistant identity verification\nPrivacy-preserving voting using Oasis Sapphire's confidential transactions\nReal-time vote tallying with individual vote privacy Noteworthy Implementation Details Adapted WorldID verification to work with Oasis Sapphire\nCustom caching of WorldCoin verification using local storage\nOptimistic UI updates for responsive user experience\nDual-state system to handle blockchain confirmation latency Challenges Overcome Ensuring cross-chain compatibility\nIntegrating WorldCoin with Oasis Sapphire\nLocal development setup mimicking multi-chain environment This project demonstrates the practical application of blockchain privacy features and decentralized identity verification in a voting system, showcasing the potential for these technologies in real-world democratic processes.",
        "how_its_made": "RealVotes: Technical Implementation\nCore Stack Next.js 14 with React and TypeScript\nTailwind CSS for styling\nFramer Motion for animations Blockchain Integration Oasis Sapphire for confidential smart contracts\nWeb3Modal for wallet connections\nethers.js and wagmi for blockchain interactions\nMulti-chain support: Sepolia, Base Sepolia, Optimism Sepolia, Oasis Sapphire Testnet Key Features WorldCoin integration for Sybil-resistant identity verification\nPrivacy-preserving voting using Oasis Sapphire's confidential transactions\nReal-time vote tallying with individual vote privacy Noteworthy Implementation Details Adapted WorldID verification to work with Oasis Sapphire\nCustom caching of WorldCoin verification using local storage\nOptimistic UI updates for responsive user experience\nDual-state system to handle blockchain confirmation latency Challenges Overcome Ensuring cross-chain compatibility\nIntegrating WorldCoin with Oasis Sapphire\nLocal development setup mimicking multi-chain environment This project demonstrates the practical application of blockchain privacy features and decentralized identity verification in a voting system, showcasing the potential for these technologies in real-world democratic processes.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bp50x/screenshots/dbqs2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bp50x/screenshots/jfvmp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bp50x/screenshots/7jh9v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bp50x/screenshots/i68ho/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bp50x/screenshots/sch8u/default.jpg"
        ],
        "live_demo": "https://eth-singapore-24.vercel.app/",
        "source_code": "https://github.com/ss251/eth-singapore-24",
        "link": "https://ethglobal.com/showcase/real-votes-bp50x"
    },
    {
        "title": "Stark-Forge",
        "brief_description": "StarkForge is an AI-driven platform where creativity meets NFTs. Combine words to guide AI in generating unique digital artworks, then mint and trade them seamlessly through StarkNet for fast, secure, and affordable transactions.",
        "long_description": "Stark-Forge is a cutting-edge platform that fuses the potential of AI and NFTs, crafted using Next.js to provide a dynamic and engaging user experience. By visiting the live demo link and connecting your ArgentX wallet, either directly or via the Dynamic app, you can immerse yourself in an innovative word-play game. Here, your creativity drives the AI to generate one-of-a-kind digital artworks based on the words you combine. If the AI-generated NFT resonates with you, you can mint it and add it to your collection. StarkForge harnesses the power of StarkNet, ensuring fast, secure, and cost-effective transactions, making the journey of creating, owning, and trading digital art both smooth and exhilarating. Stark-Forge thrives at the intersection of AI and NFTs, designed with Next.js to offer a seamless and immersive digital experience. Users can easily visit the live demo link, connect their ArgentX wallet through the Dynamic app, and engage in an interactive word-play game that empowers the AI to craft distinctive digital art pieces. The platform gives you the option to mint and own the AI-generated NFT, making each creation a truly personal and unique digital artifact.",
        "how_its_made": "Stark-Forge thrives at the intersection of AI and NFTs, designed with Next.js to offer a seamless and immersive digital experience. Users can easily visit the live demo link, connect their ArgentX wallet through the Dynamic app, and engage in an interactive word-play game that empowers the AI to craft distinctive digital art pieces. The platform gives you the option to mint and own the AI-generated NFT, making each creation a truly personal and unique digital artifact.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2nzyu/screenshots/5sxdx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2nzyu/screenshots/vu899/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2nzyu/screenshots/af7bi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2nzyu/screenshots/7j1gk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2nzyu/screenshots/6nran/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2nzyu/screenshots/e4n0p/default.jpg"
        ],
        "live_demo": "https://stark-forge.vercel.app/",
        "source_code": "https://github.com/DevBhuptani/stark-forge",
        "link": "https://ethglobal.com/showcase/stark-forge-2nzyu"
    },
    {
        "title": "Effortl3ss AI",
        "brief_description": "Effortl3ssAI is a user-friendly solution that turns simple prompts into on-chain actions, making the Web3 experience secure and effortless while seamlessly onboarding millions of users to blockchain.",
        "long_description": "Effortl3ssAI is a prompt-to-on-chain action solution enabling users to simply provide a text prompt, and we handle the rest of the Web3 actions, such as token transfers, balance checks, NFT minting, staking, voting, and interacting with smart contracts. The platform also integrates with DeFi aggregators, making the process seamless. By providing a user-friendly experience, it aims to simplify the often complex world of Web3 and onboard millions of users to blockchain-based experiences, ensuring they can engage effortlessly with decentralized applications (dApps). We leveraged a range of cutting-edge technologies to bring Effortl3ssAI to life. Here\u2019s how everything is pieced together: we used Phala Network to develop our AI agent, which translates user prompts into direct on-chain actions;  to simplify the process of inputting addresses, we integrated the Ethereum Name Service (ENS); for user authentication and wallet connectivity, we integrated Reown AppKit, offers a dual login system with both Web3 wallets for crypto-native users, and Web2 social authentication methods for effortless onboarding Web2 users; for Defi integrations we use 1inch for Swap and Circle for Cross-Chain Transfer.",
        "how_its_made": "We leveraged a range of cutting-edge technologies to bring Effortl3ssAI to life. Here\u2019s how everything is pieced together: we used Phala Network to develop our AI agent, which translates user prompts into direct on-chain actions;  to simplify the process of inputting addresses, we integrated the Ethereum Name Service (ENS); for user authentication and wallet connectivity, we integrated Reown AppKit, offers a dual login system with both Web3 wallets for crypto-native users, and Web2 social authentication methods for effortless onboarding Web2 users; for Defi integrations we use 1inch for Swap and Circle for Cross-Chain Transfer.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3m2by/screenshots/d9d0m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3m2by/screenshots/djcm8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3m2by/screenshots/xjit2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3m2by/screenshots/y9tp6/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/anii76/EthSingapore",
        "link": "https://ethglobal.com/showcase/effortl3ss-ai-3m2by"
    },
    {
        "title": "Friend.Sucks",
        "brief_description": "Friend.Sucks lets you \"suck\" your Web2 friends into the Web3 world! Tip them in ETH using their social media username, and they\u2019ll be incentivized to create a crypto wallet to claim their tips. A fun, seamless way to introduce Web2 users to Web3 perks!",
        "long_description": null,
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yguav/screenshots/bws24/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yguav/screenshots/b3e8t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yguav/screenshots/qfzfg/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/lllapland/eth-global-2024",
        "link": "https://ethglobal.com/showcase/friend-sucks-yguav"
    },
    {
        "title": "Omnichain zkERC20",
        "brief_description": "Instantly grant any ERC-20 the same privacy guarantees as Monero and ZCash. Bridge across any EVM-compatible chain, without sharing the receiver, token, or amount!",
        "long_description": "Deposit any ERC-20, and receive a corresponding zkERC20 token. These can be transferred to any user and bridged to any chain---without revealing the token type, amount, or receiver. The protocol consists of a contract on each supported ecosystem, which utilizes zero knowledge proofs to regulate user balances in a vector commitment. These contracts interact through messages on LayerZero and Chainlink, allowing users to send assets completely privately and anonymously. In fact, outside observers cannot even determine exactly how a token's supply is spread across the chains. The ZK circuits powering this functionality are designed to be friendly towards potential privacy-focused DeFi protocols, including anonymous perps/leverage protocols, dark pools, and ZK orderbooks/DEXes. Of course, users can at any time withdraw their zkERC-20. On the original chain, this leaves them with the corresponding ERC-20; on others, they receive a wrapped variant economically pegged 1:1. Our protocol uses completely custom zero knowledge circuits, which allows the privacy-preserving guarantees without dependent on specialized ecosystem features. This allows the application to trivially be expanded across EVM-compatible chains, and even others like Aptos. Users interact with the protocol by providing proofs of certain invariants. These are produced off-chain. We provide a number of options: they can be computed directly in the browser using WebAssembly, or even by a self-hosted server implementation. The bridging mechanism allows assets to be transferred with very concise messages. We choose to implement a higher level abstraction that allows the protocol to be composed with any bridge. This expands the number of chains and possible trust configurations,",
        "how_its_made": "Our protocol uses completely custom zero knowledge circuits, which allows the privacy-preserving guarantees without dependent on specialized ecosystem features. This allows the application to trivially be expanded across EVM-compatible chains, and even others like Aptos. Users interact with the protocol by providing proofs of certain invariants. These are produced off-chain. We provide a number of options: they can be computed directly in the browser using WebAssembly, or even by a self-hosted server implementation. The bridging mechanism allows assets to be transferred with very concise messages. We choose to implement a higher level abstraction that allows the protocol to be composed with any bridge. This expands the number of chains and possible trust configurations,",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/i6koo/screenshots/60rej/default.jpg",
            "https://ethglobal.b-cdn.net/projects/i6koo/screenshots/0umfi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/i6koo/screenshots/4apw0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/i6koo/screenshots/mu10s/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Arinerron/zkerc20-mirror/",
        "link": "https://ethglobal.com/showcase/omnichain-zkerc20-i6koo"
    },
    {
        "title": "ChopChop",
        "brief_description": "Cross-chain spendings spliting app (like splitwise but for web3)",
        "long_description": "This project brings a familiar Web2 concept\u2014expense-splitting apps\u2014into the Web3 space. It allows users to track expenses with friends, such as during a group trip, to easily see who owes whom and how much. What sets this app apart is its focus on Web3 and cross-chain swaps, enhancing the user experience by eliminating the headaches of traditional banking. Instead of dealing with the hassle of bank transfers, especially  which becomes even more complicated when dealing with international banks, our app enables seamless payments through the blockchain. This not only streamlines the payment process but also leverages the benefits of Web3 to create a smoother, more efficient experience for users. This project is a mobile app built using the React Native SDK, making it accessible across multiple platforms. For wallet connectivity, we\u2019ve integrated the Reown SDK (WalletConnect) to ensure a smooth and secure user experience. To enhance the user interface, we leverage ENS names, allowing users to easily recognize who they are sending money to, rather than relying on long, confusing wallet addresses. Additionally, each user can personalize their profile by selecting a NounsDAO avatar, making the experience both functional and fun. One of the app's standout features is its ability to perform cross-chain swaps. This means users can receive funds from friends, even if their tokens are on entirely different blockchains. This feature simplifies the process of settling expenses across multiple chains, making it more convenient and user-friendly.",
        "how_its_made": "This project is a mobile app built using the React Native SDK, making it accessible across multiple platforms. For wallet connectivity, we\u2019ve integrated the Reown SDK (WalletConnect) to ensure a smooth and secure user experience. To enhance the user interface, we leverage ENS names, allowing users to easily recognize who they are sending money to, rather than relying on long, confusing wallet addresses. Additionally, each user can personalize their profile by selecting a NounsDAO avatar, making the experience both functional and fun. One of the app's standout features is its ability to perform cross-chain swaps. This means users can receive funds from friends, even if their tokens are on entirely different blockchains. This feature simplifies the process of settling expenses across multiple chains, making it more convenient and user-friendly.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6dkpc/screenshots/fxsv2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6dkpc/screenshots/65v9x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6dkpc/screenshots/m0806/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6dkpc/screenshots/djzsf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6dkpc/screenshots/81j34/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6dkpc/screenshots/d37s3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Web3Homeless/ChopChopFrontend",
        "link": "https://ethglobal.com/showcase/chopchop-6dkpc"
    },
    {
        "title": "SoulPass",
        "brief_description": "token gated community on telegram, using soul bond token standard",
        "long_description": "This project is a decentralized application (DApp) that allows users to sign a transaction using a Ledger device, check if they hold a Soulbound Token (SBT), and gain access to a token-gated community (Telegram group). If the user does not hold the required SBT, they can mint an NFT directly from the application to gain access. next js, Ledger, Ledger, next js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledger",
        "how_its_made": "next js, Ledger, Ledger, next js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledgernext js, Ledger, Ledger",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/001ds/screenshots/yeajp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/001ds/screenshots/keuvn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/001ds/screenshots/hdzmf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/001ds/screenshots/jbct4/default.jpg"
        ],
        "live_demo": "https://eth-global-singapore-phi.vercel.app/",
        "source_code": "https://github.com/mxber2022/EthGlobalSingapore",
        "link": "https://ethglobal.com/showcase/soulpass-001ds"
    },
    {
        "title": "ReversiFi",
        "brief_description": "ReversiFi is a non-custodial wallet software development kit that enables businesses to effortlessly integrate secure crypto payment solutions into their marketplace apps with minimal coding",
        "long_description": "\u203c\ufe0f Problem Statement\nThere's a few major challenges faced in the crypto payment space pending to be solved: \ud83c\udfaf Vision\nReversiFi a Non-custodial crypto payment SDK, delivering a secure, native, and user-friendly experience. ReversiFi aims to empower both businesses and their users, providing a useful solution for crypto payment. \ud83d\udea8 Unique Value Proposition\nReversiFi stands out by offering a blend of simplicity, security, and customization: \ud83d\udee0\ufe0f Simplicity: Integrate crypto payments into your app with as little as 5 lines of code.\n\ud83c\udfa8 Customization: The SDK is flexible, allowing businesses to customize the payment experience to match their brand and needs.\n\ud83d\udd12 Security: A non-custodial architecture ensures users retain control over their private keys, reducing security risks. ReversiFi is designed to provide businesses with a simple line of code to integrate crypto payments into their marketplace apps. With a non-custodial architecture, the SDK ensures that users retain full control over their private keys, eliminating custodial risks while enhancing trust and security. Tech Stack we Use:\nNext.js, Solidity, React, Typescript, Javascript, Foundry, Supabase Use Case Example:\n(In our case we will use Grab as example.) This architecture outlines a process flow for a user using the Grab app, integrated with ReversiFi SDK and a smart contract to manage orders and payments, as follows:",
        "how_its_made": "Tech Stack we Use:\nNext.js, Solidity, React, Typescript, Javascript, Foundry, Supabase Use Case Example:\n(In our case we will use Grab as example.) This architecture outlines a process flow for a user using the Grab app, integrated with ReversiFi SDK and a smart contract to manage orders and payments, as follows:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ufprn/screenshots/3wbce/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufprn/screenshots/ywfwf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufprn/screenshots/28uxo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufprn/screenshots/q9yqi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufprn/screenshots/78ztc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufprn/screenshots/194if/default.jpg"
        ],
        "live_demo": "https://reversifi-sdk.vercel.app/",
        "source_code": "https://github.com/ReversiFi",
        "link": "https://ethglobal.com/showcase/reversifi-ufprn"
    },
    {
        "title": "AirDAO-Multisig",
        "brief_description": "The AirDAO Multi-Sig Wallet is a secure, multi-signature wallet that features multi-owner control and quorum-based approvals.",
        "long_description": "Gitbook: https://airdao-multisig.gitbook.io/airdao-multisig-docs/ Frontend repo: https://github.com/tanvi-sanghai/airdao-multisig-frontend Contracts Repo: https://github.com/tanvi-sanghai/airdao-multisig The AirDAO Multi-Signature Wallet is a smart contract deployed on the AirDAO blockchain that enables a group of owners to collaboratively manage digital assets. Funds can only be withdrawn after receiving multiple approvals (passing the threshold), enhancing security and accountability, making it ideal for DAOs, communities, and joint ventures.\nKey Features\nMulti-Owner Architecture: Supports multiple owners, each authorized to initiate and approve transactions, reducing risks associated with single points of failure.\nQuorum Requirements: Configurable settings require a specific number of approvals before transactions can be executed, promoting trust and collective governance.\nTransparent Transaction Management: On-chain recording of all transactions provides an immutable record, allowing owners to easily track approval statuses and fund allocations.\nEvent Logging: Key actions emit events that can be monitored off-chain, enhancing transparency and providing real-time updates to stakeholders.\nError Handling: Custom error types improve clarity during contract interactions, ensuring users receive meaningful feedback. The project combines a robust tech stack, starting with a React frontend that provides an interactive user experience. React\u2019s component-based architecture allows for efficient management of the user interface, ensuring a responsive and dynamic application. To enhance aesthetic appeal and usability, we employed Tailwind CSS, which offers utility-first styling for rapid design iteration while maintaining consistency. For blockchain integration, we utilized Wagmi and Viem. Wagmi simplifies the connection between our React app and the Ethereum blockchain, facilitating user wallet management and transaction processing. Viem provides a low-level interface for interacting with our smart contracts, allowing seamless invocation of contract functions. Our smart contract, a multi-signature wallet, is deployed on the AirDAO L1 blockchain, enhancing scalability and efficiency. The smart contract itself is designed to manage digital assets securely and collaboratively. It supports multiple owners, requiring a quorum of approvals for any withdrawal transaction, which reduces the risk of unauthorized access and fraud. Key features include event logging for transparency, custom error handling for clarity, and the ability to track transaction statuses on-chain. This design fosters accountability among owners, making it particularly suitable for organizations and joint ventures. To perform authentication and transaction signing, we incorporated WalletConnect. This tool allows users to securely connect their wallets, enabling them to sign transactions directly from their devices. The frontend communicates with the deployed multi-signature wallet smart contract, enabling users to collaboratively manage assets. They can initiate withdrawals, approve transactions, and check balances, all through intuitive UI components. This integration of technologies not only enhances the functionality of our application but also ensures a smooth user experience, effectively marrying the power of blockchain with modern web development practices.",
        "how_its_made": "The project combines a robust tech stack, starting with a React frontend that provides an interactive user experience. React\u2019s component-based architecture allows for efficient management of the user interface, ensuring a responsive and dynamic application. To enhance aesthetic appeal and usability, we employed Tailwind CSS, which offers utility-first styling for rapid design iteration while maintaining consistency. For blockchain integration, we utilized Wagmi and Viem. Wagmi simplifies the connection between our React app and the Ethereum blockchain, facilitating user wallet management and transaction processing. Viem provides a low-level interface for interacting with our smart contracts, allowing seamless invocation of contract functions. Our smart contract, a multi-signature wallet, is deployed on the AirDAO L1 blockchain, enhancing scalability and efficiency. The smart contract itself is designed to manage digital assets securely and collaboratively. It supports multiple owners, requiring a quorum of approvals for any withdrawal transaction, which reduces the risk of unauthorized access and fraud. Key features include event logging for transparency, custom error handling for clarity, and the ability to track transaction statuses on-chain. This design fosters accountability among owners, making it particularly suitable for organizations and joint ventures. To perform authentication and transaction signing, we incorporated WalletConnect. This tool allows users to securely connect their wallets, enabling them to sign transactions directly from their devices. The frontend communicates with the deployed multi-signature wallet smart contract, enabling users to collaboratively manage assets. They can initiate withdrawals, approve transactions, and check balances, all through intuitive UI components. This integration of technologies not only enhances the functionality of our application but also ensures a smooth user experience, effectively marrying the power of blockchain with modern web development practices.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1tb24/screenshots/8q8o7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1tb24/screenshots/8qq62/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1tb24/screenshots/xtr6k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1tb24/screenshots/btsaw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1tb24/screenshots/s4p6t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1tb24/screenshots/4n1f5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/tanvi-sanghai/airdao-multisig-frontend",
        "link": "https://ethglobal.com/showcase/airdao-multisig-1tb24"
    },
    {
        "title": "beat",
        "brief_description": "Revolutionary cross-chain token launchpad. Launch, manage & transfer tokens across multiple chains effortlessly. For developers, entrepreneurs & crypto fans. Secure, compliant & user-friendly. Elevate your blockchain project with our powerful tools & thriving ecosystem.",
        "long_description": "Beat Fun is a cutting-edge cross-chain token launchpad designed to simplify and enhance blockchain project development. It offers a comprehensive platform for launching, managing, and transferring tokens across multiple blockchain networks.\nKey features include: Multi-chain support\nUser-friendly interface\nSmart contract templates\nAutomated compliance tools\nLiquidity management\nCommunity-building features\nReal-time analytics\nSeamless interoperability Beat Fun caters to developers, entrepreneurs, and crypto enthusiasts, providing the tools and ecosystem necessary to bring innovative blockchain projects to life. With its focus on security, ease of use, and cross-chain functionality, Beat Fun aims to streamline the token launch process and foster growth in the blockchain space. Beat Fun is a full-stack application built to revolutionize cross-chain token launches. The platform leverages React for its frontend, enhanced with Tailwind CSS for sleek design and wagmi for seamless Ethereum interactions. Web3Auth powers the authentication and wallet connection process, ensuring a smooth user onboarding experience. At its core, Beat Fun utilizes LayerZero technology to facilitate token transfers and operations across multiple blockchain networks. This robust architecture enables the platform to offer a comprehensive suite of tools for token creation, management, and cross-chain functionality. While the specifics of the backend aren't detailed, it likely incorporates advanced systems for handling user data, transaction processing, and multi-chain integrations. This technical foundation allows Beat Fun to deliver a powerful, user-friendly launchpad that caters to developers, entrepreneurs, and crypto enthusiasts, streamlining the process of bringing innovative blockchain projects to life across various networks.",
        "how_its_made": "Beat Fun is a full-stack application built to revolutionize cross-chain token launches. The platform leverages React for its frontend, enhanced with Tailwind CSS for sleek design and wagmi for seamless Ethereum interactions. Web3Auth powers the authentication and wallet connection process, ensuring a smooth user onboarding experience. At its core, Beat Fun utilizes LayerZero technology to facilitate token transfers and operations across multiple blockchain networks. This robust architecture enables the platform to offer a comprehensive suite of tools for token creation, management, and cross-chain functionality. While the specifics of the backend aren't detailed, it likely incorporates advanced systems for handling user data, transaction processing, and multi-chain integrations. This technical foundation allows Beat Fun to deliver a powerful, user-friendly launchpad that caters to developers, entrepreneurs, and crypto enthusiasts, streamlining the process of bringing innovative blockchain projects to life across various networks.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/4pnb5/screenshots/0mbrq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4pnb5/screenshots/hudk7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4pnb5/screenshots/pd4ri/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Madhan-404/beat",
        "link": "https://ethglobal.com/showcase/beat-4pnb5"
    },
    {
        "title": "EasyPass",
        "brief_description": "Passport registration app for efficient data capture and management.",
        "long_description": "We utilized Roofstock to effectively store and manage our data on the Ethereum Virtual Machine (EVM), which has provided us with a robust platform for handling blockchain-related operations. As part of this initiative, we developed two distinct mobile applications that serve different but complementary purposes. The first application is a comprehensive dashboard designed for data visualization and analysis. This dashboard aggregates key metrics and insights from our blockchain data, allowing users to monitor system performance in real time. Features include interactive charts, detailed analytics, and customizable views, enabling stakeholders to gain a deeper understanding of the data trends and make informed decisions based on actionable insights. The second application is specifically tailored for officers tasked with scanning passports. This mobile tool leverages advanced optical character recognition (OCR) technology to quickly and accurately capture passport information. The scanned data is then seamlessly integrated into our system, ensuring that all information is stored securely on the EVM. This application streamlines the verification process, enhancing efficiency and reducing the potential for human error. Landing Page easy-pass.xyz Utilizing Roofstock, we configured a smart contract to handle data storage on the EVM. This smart contract defines how data is written, accessed, and updated, ensuring that all transactions are transparent and verifiable. We established a data schema that organizes the information logically, making it easy to query and retrieve.",
        "how_its_made": "Utilizing Roofstock, we configured a smart contract to handle data storage on the EVM. This smart contract defines how data is written, accessed, and updated, ensuring that all transactions are transparent and verifiable. We established a data schema that organizes the information logically, making it easy to query and retrieve.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/iqzjb/screenshots/4kyht/default.jpg",
            "https://ethglobal.b-cdn.net/projects/iqzjb/screenshots/jbbuq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/iqzjb/screenshots/co132/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ethglobal-singapur/mobile-main",
        "link": "https://ethglobal.com/showcase/easypass-iqzjb"
    },
    {
        "title": "ValidAI",
        "brief_description": "Introducing a decentralized AI platform powered by EigenLayer AVS and Othentic! Our platform empowers developers with AI agents for automated smart contract auditing and fosters an AI marketplace with subscription-based royalties, incentivizing ML researchers community.",
        "long_description": "Our project introduces a novel platform for decentralized AI, addressing the growing need for secure, scalable, and accessible AI solutions. We achieve this by harnessing the power of EigenLayer and Actively Validated Services (AVS), building a robust infrastructure for AI agent deployment and operation. At the core of our platform lies a decentralized AI infrastructure built upon EigenLayer's restaking mechanism. This allows us to leverage the security of the Ethereum network for our AI agents, which operate as AVS, ensuring a highly secure and decentralized environment. We utilize Phala Network's Red Pill contract template for efficient deployment and management of these AI agents, enabling them to perform complex tasks such as smart contract auditing and AI-powered code assistance. Our platform offers a suite of core functionalities designed to streamline development and enhance security. AI agents are trained to automatically audit smart contracts, identifying vulnerabilities and security flaws with speed and efficiency. Additionally, we provide on-the-go code assistance through a pretrained chatbot and a Retrieval Augmented Generation (RAG) system, allowing developers to receive instant, contextually relevant support. A dedicated AI marketplace further simplifies AI integration by providing access to a wide range of pre-trained AI models, fostering innovation and accessibility. To incentivize the development of high-quality AI models, our marketplace implements a subscription-based royalty model. AI/ML researchers earn royalties whenever their models are utilized, fostering a thriving ecosystem of AI innovation. Secure and efficient transactions within the marketplace are ensured through an escrow account system, minimizing gas fees and enhancing network health. We have chosen to build our platform on Near Protocol, leveraging its yield resume architecture for optimal performance. This enables us to develop asynchronous contracts in Rust, offering significant advantages over Solidity's polling-based approach. By combining these cutting-edge technologies, our platform provides a robust and scalable foundation for the future of decentralized AI. We aim to democratize access to AI, empowering developers to build secure and innovative applications with ease. Our project is built on technology stack, designed to deliver a seamless and secure decentralized AI experience. We chose Near Protocol as our foundation, leveraging its Rust-based smart contract development environment and the efficiency of its Yield-Resume architecture for synchronous contract interactions. This allows for a more responsive and developer-friendly platform compared to traditional blockchain platforms.\nTo ensure the security and decentralization of our AI agents, we integrated EigenLayer, allowing us to leverage the robust security of the Ethereum network through its restaking mechanism. These agents operate as Actively Validated Services (AVS), contributing to the platform's overall security and decentralization. We utilize Phala Network's Red Pill contract template for the efficient deployment and management of these AI agents, enabling them to perform complex tasks such as smart contract auditing and AI-powered code assistance.\nOur AI marketplace features a secure escrow system implemented directly within our smart contracts, ensuring secure payments and minimizing gas fees for a smooth user experience. We integrate pre-trained AI models for various tasks, including smart contract auditing and code assistance, and continuously update these models to maintain optimal performance. Our on-the-go code assistance leverages a Retrieval Augmented Generation (RAG) system, optimized for speed and cost-effectiveness through a hybrid on-chain and off-chain data storage approach.\nWe can actively seek partnerships with leading AI/ML research institutions and individual researchers to expand our AI model marketplace and offer cutting-edge solutions to our users. This collaborative approach allows us to leverage the expertise of established players in the AI field and provide our users with access to the latest advancements in AI technology.",
        "how_its_made": "Our project is built on technology stack, designed to deliver a seamless and secure decentralized AI experience. We chose Near Protocol as our foundation, leveraging its Rust-based smart contract development environment and the efficiency of its Yield-Resume architecture for synchronous contract interactions. This allows for a more responsive and developer-friendly platform compared to traditional blockchain platforms.\nTo ensure the security and decentralization of our AI agents, we integrated EigenLayer, allowing us to leverage the robust security of the Ethereum network through its restaking mechanism. These agents operate as Actively Validated Services (AVS), contributing to the platform's overall security and decentralization. We utilize Phala Network's Red Pill contract template for the efficient deployment and management of these AI agents, enabling them to perform complex tasks such as smart contract auditing and AI-powered code assistance.\nOur AI marketplace features a secure escrow system implemented directly within our smart contracts, ensuring secure payments and minimizing gas fees for a smooth user experience. We integrate pre-trained AI models for various tasks, including smart contract auditing and code assistance, and continuously update these models to maintain optimal performance. Our on-the-go code assistance leverages a Retrieval Augmented Generation (RAG) system, optimized for speed and cost-effectiveness through a hybrid on-chain and off-chain data storage approach.\nWe can actively seek partnerships with leading AI/ML research institutions and individual researchers to expand our AI model marketplace and offer cutting-edge solutions to our users. This collaborative approach allows us to leverage the expertise of established players in the AI field and provide our users with access to the latest advancements in AI technology.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/kx6ou/screenshots/5ex5g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kx6ou/screenshots/7chfo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kx6ou/screenshots/akoom/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kx6ou/screenshots/ccw0g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kx6ou/screenshots/xecwg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kx6ou/screenshots/xh43p/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/h4shk4t/validAI",
        "link": "https://ethglobal.com/showcase/validai-kx6ou"
    },
    {
        "title": "ValidAI",
        "brief_description": "Introducing a decentralized AI platform powered by EigenLayer AVS and Othentic! Our platform empowers developers with AI agents for automated smart contract auditing and fosters an AI marketplace with subscription-based royalties, incentivizing ML researchers community.",
        "long_description": "Our project introduces a novel platform for decentralized AI, addressing the growing need for secure, scalable, and accessible AI solutions. We achieve this by harnessing the power of EigenLayer and Actively Validated Services (AVS), building a robust infrastructure for AI agent deployment and operation. At the core of our platform lies a decentralized AI infrastructure built upon EigenLayer's restaking mechanism. This allows us to leverage the security of the Ethereum network for our AI agents, which operate as AVS, ensuring a highly secure and decentralized environment. We utilize Phala Network's Red Pill contract template for efficient deployment and management of these AI agents, enabling them to perform complex tasks such as smart contract auditing and AI-powered code assistance. Our platform offers a suite of core functionalities designed to streamline development and enhance security. AI agents are trained to automatically audit smart contracts, identifying vulnerabilities and security flaws with speed and efficiency. Additionally, we provide on-the-go code assistance through a pretrained chatbot and a Retrieval Augmented Generation (RAG) system, allowing developers to receive instant, contextually relevant support. A dedicated AI marketplace further simplifies AI integration by providing access to a wide range of pre-trained AI models, fostering innovation and accessibility. To incentivize the development of high-quality AI models, our marketplace implements a subscription-based royalty model. AI/ML researchers earn royalties whenever their models are utilized, fostering a thriving ecosystem of AI innovation. Secure and efficient transactions within the marketplace are ensured through an escrow account system, minimizing gas fees and enhancing network health. We have chosen to build our platform on Near Protocol, leveraging its yield resume architecture for optimal performance. This enables us to develop asynchronous contracts in Rust, offering significant advantages over Solidity's polling-based approach. By combining these cutting-edge technologies, our platform provides a robust and scalable foundation for the future of decentralized AI. We aim to democratize access to AI, empowering developers to build secure and innovative applications with ease. Our project is built on technology stack, designed to deliver a seamless and secure decentralized AI experience. We chose Near Protocol as our foundation, leveraging its Rust-based smart contract development environment and the efficiency of its Yield-Resume architecture for synchronous contract interactions. This allows for a more responsive and developer-friendly platform compared to traditional blockchain platforms.\nTo ensure the security and decentralization of our AI agents, we integrated EigenLayer, allowing us to leverage the robust security of the Ethereum network through its restaking mechanism. These agents operate as Actively Validated Services (AVS), contributing to the platform's overall security and decentralization. We utilize Phala Network's Red Pill contract template for the efficient deployment and management of these AI agents, enabling them to perform complex tasks such as smart contract auditing and AI-powered code assistance.\nOur AI marketplace features a secure escrow system implemented directly within our smart contracts, ensuring secure payments and minimizing gas fees for a smooth user experience. We integrate pre-trained AI models for various tasks, including smart contract auditing and code assistance, and continuously update these models to maintain optimal performance. Our on-the-go code assistance leverages a Retrieval Augmented Generation (RAG) system, optimized for speed and cost-effectiveness through a hybrid on-chain and off-chain data storage approach.\nWe can actively seek partnerships with leading AI/ML research institutions and individual researchers to expand our AI model marketplace and offer cutting-edge solutions to our users. This collaborative approach allows us to leverage the expertise of established players in the AI field and provide our users with access to the latest advancements in AI technology.",
        "how_its_made": "Our project is built on technology stack, designed to deliver a seamless and secure decentralized AI experience. We chose Near Protocol as our foundation, leveraging its Rust-based smart contract development environment and the efficiency of its Yield-Resume architecture for synchronous contract interactions. This allows for a more responsive and developer-friendly platform compared to traditional blockchain platforms.\nTo ensure the security and decentralization of our AI agents, we integrated EigenLayer, allowing us to leverage the robust security of the Ethereum network through its restaking mechanism. These agents operate as Actively Validated Services (AVS), contributing to the platform's overall security and decentralization. We utilize Phala Network's Red Pill contract template for the efficient deployment and management of these AI agents, enabling them to perform complex tasks such as smart contract auditing and AI-powered code assistance.\nOur AI marketplace features a secure escrow system implemented directly within our smart contracts, ensuring secure payments and minimizing gas fees for a smooth user experience. We integrate pre-trained AI models for various tasks, including smart contract auditing and code assistance, and continuously update these models to maintain optimal performance. Our on-the-go code assistance leverages a Retrieval Augmented Generation (RAG) system, optimized for speed and cost-effectiveness through a hybrid on-chain and off-chain data storage approach.\nWe can actively seek partnerships with leading AI/ML research institutions and individual researchers to expand our AI model marketplace and offer cutting-edge solutions to our users. This collaborative approach allows us to leverage the expertise of established players in the AI field and provide our users with access to the latest advancements in AI technology.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/kx6ou/screenshots/5ex5g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kx6ou/screenshots/7chfo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kx6ou/screenshots/akoom/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kx6ou/screenshots/ccw0g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kx6ou/screenshots/xecwg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kx6ou/screenshots/xh43p/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/h4shk4t/validAI",
        "link": "https://ethglobal.com/showcase/validai-kx6ou"
    },
    {
        "title": "ENS DocFix",
        "brief_description": "ENS DocFix aims to enhance the ENS documentation by providing detailed feedback and actionable suggestions to improve clarity, add missing code examples, and streamline navigation by addressing pain points faced by new developers",
        "long_description": "ENS DocFix is a project dedicated to improving the Ethereum Name Service (ENS) documentation to better serve developers, especially those new to blockchain development. Through firsthand experience mentoring students and gathering feedback during a recent hackathon, we've identified specific areas where the ENS documentation can be enhanced. Our goal is to: By implementing these changes, ENS DocFix aims to make the ENS documentation a more effective resource, reducing the learning curve for new developers and facilitating smoother integration of ENS into their projects. ENS DocFix was developed through a comprehensive process involving: Collecting Feedback: Analyzing the Documentation: Compiling Actionable Feedback: Technical Verification: Technologies and Tools Used: By methodically identifying issues and proposing practical solutions, ENS DocFix serves as a bridge between new developers and the ENS team, aiming to enhance the overall quality and usability of the ENS documentation.",
        "how_its_made": "ENS DocFix was developed through a comprehensive process involving: Collecting Feedback: Analyzing the Documentation: Compiling Actionable Feedback: Technical Verification: Technologies and Tools Used: By methodically identifying issues and proposing practical solutions, ENS DocFix serves as a bridge between new developers and the ENS team, aiming to enhance the overall quality and usability of the ENS documentation.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/na51z/screenshots/sii6b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/na51z/screenshots/gs5n4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/na51z/screenshots/oqp48/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ensdomains/docs/issues/294",
        "link": "https://ethglobal.com/showcase/ens-docfix-na51z"
    },
    {
        "title": "Judg3",
        "brief_description": "A voting system similar to \"This or That\". a next-generation voting system that leverages the power of consensus over your conscious mind.",
        "long_description": "Judg3 is an easy to use voting system that works on binary voting. We make use of mathematical algorithms to generate a leaderboard based on these pairwise comparisons. This voting system can be used in a wide range of applications like candidate hiring, hackathon judging, prediction games, etc. Votes are validated off chain using proved onchain data, ensuring integrity which prevents tampering of votes. This project is built using:",
        "how_its_made": "This project is built using:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/su0s5/screenshots/t36aw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/su0s5/screenshots/hqvc2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/su0s5/screenshots/rvgm5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/su0s5/screenshots/3s4ed/default.jpg",
            "https://ethglobal.b-cdn.net/projects/su0s5/screenshots/6jobf/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/team-somehow/eth-singapore",
        "link": "https://ethglobal.com/showcase/judg3-su0s5"
    },
    {
        "title": "DefiDash",
        "brief_description": "Using decentralized AI to flexibly visualize DeFi data based on user prompt using the Uniswap Subgraph hosted on the Phala Network",
        "long_description": "The project uses Langchain hosted on Phala Network to transform user prompt into the necessary query string, which is then used to query DeFi data from the Uniswap Subgraph. This data retrieved from the subgraph is then displayed as the appropriate chart determined by the Langchain AI. This project uses Langchain-TS to process the natural language into a set of parameters that could be used to query the necessary data that the user wants. The Langchain AI agent and the server are both hosted on the testnet Phala Network, which makes the entire application decentralized and allows the users to visualize complex queries.",
        "how_its_made": "This project uses Langchain-TS to process the natural language into a set of parameters that could be used to query the necessary data that the user wants. The Langchain AI agent and the server are both hosted on the testnet Phala Network, which makes the entire application decentralized and allows the users to visualize complex queries.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/k9bis/screenshots/eezag/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k9bis/screenshots/bxf22/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k9bis/screenshots/8o04f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k9bis/screenshots/qkt1n/default.jpg"
        ],
        "live_demo": "https://defidash-phi.vercel.app/",
        "source_code": "https://github.com/DefiDash",
        "link": "https://ethglobal.com/showcase/defidash-k9bis"
    },
    {
        "title": "Houshou",
        "brief_description": "Train custom LLMs for your blockchain devtooling company by crowdsourcing developers",
        "long_description": "Currently, models like GPT/Claude aren't really useful for projects offering devtooling because of the lack in training data and lack of bandwidth in teams for creating LLMs. This project solves this by enabling contractors (projects) to create a custom model for themselves by crowdsourcing dataset from developers. The contractors can create a bounty pool with questions related to their tooling like \"how to initiate setup\", \"explain this piece of code\", etc., which will  be hosted on our platform and workers (developers) can contribute to fill in the content for a part in the bounty.  The contractor can review the answers, delete responses or strike off users and then train the model. A new model will be created using the gathered dataset from the workers and this will act as a specific LLM for that devtooling project (startup) Devtooling Startups or projects (contractors) can create a bounty pool with an assigned deadline and include multiple forms containing questions related to their toolkit. Upon creation of a pool, a new Worldcoin contract is deployed, ensuring each developer (worker) can submit a form only once and not submit multiple forms. All forms are stored on IPFS. When a developer fills out a form and completes WorldID validation, it triggers an attestation hook via the Sign protocol. The information is then stored in contracts deployed on the Gnosis Chiado chain. The answers are stored off-chain in MongoDB for later use during model training. Contractors can review, delete responses, or strike a user if necessary. Each user can receive a maximum of three strikes before being banned. Afterward, contractors can name and train the model using a Retrieval-Augmented Generation (RAG) system with a FAISS vector database, which processes requests via the Phala Network. Once the deadline is reached, the bounty pool is distributed to the eligible workers through Chainlink contracts.",
        "how_its_made": "Devtooling Startups or projects (contractors) can create a bounty pool with an assigned deadline and include multiple forms containing questions related to their toolkit. Upon creation of a pool, a new Worldcoin contract is deployed, ensuring each developer (worker) can submit a form only once and not submit multiple forms. All forms are stored on IPFS. When a developer fills out a form and completes WorldID validation, it triggers an attestation hook via the Sign protocol. The information is then stored in contracts deployed on the Gnosis Chiado chain. The answers are stored off-chain in MongoDB for later use during model training. Contractors can review, delete responses, or strike a user if necessary. Each user can receive a maximum of three strikes before being banned. Afterward, contractors can name and train the model using a Retrieval-Augmented Generation (RAG) system with a FAISS vector database, which processes requests via the Phala Network. Once the deadline is reached, the bounty pool is distributed to the eligible workers through Chainlink contracts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wyebz/screenshots/rv67m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyebz/screenshots/nccsg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyebz/screenshots/dww7u/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/arnavmehta7/houshou-ethglobal",
        "link": "https://ethglobal.com/showcase/houshou-wyebz"
    },
    {
        "title": "Gaston",
        "brief_description": "A simple app that shows you how much gas you burned since The Merge.",
        "long_description": "A simple app that shows you how much gas you burned since The Merge. Uses Covalent API. A simple app that shows you how much gas you burned since The Merge. Uses Covalent API. A simple app that shows you how much gas you burned since The Merge. Uses Covalent API. A simple app that shows you how much gas you burned since The Merge. Uses Covalent API. A simple app that shows you how much gas you burned since The Merge. Uses Covalent API. A simple app that shows you how much gas you burned since The Merge. Uses Covalent API. A simple app that shows you how much gas you burned since The Merge. Uses Covalent API. A simple app that shows you how much gas you burned since The Merge. Uses Covalent API.",
        "how_its_made": "A simple app that shows you how much gas you burned since The Merge. Uses Covalent API. A simple app that shows you how much gas you burned since The Merge. Uses Covalent API. A simple app that shows you how much gas you burned since The Merge. Uses Covalent API. A simple app that shows you how much gas you burned since The Merge. Uses Covalent API.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3on7k/screenshots/xb29q/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3on7k/screenshots/wissu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3on7k/screenshots/isvkb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/FTCHD/frametrain",
        "link": "https://ethglobal.com/showcase/gaston-3on7k"
    },
    {
        "title": "DropCaster",
        "brief_description": "Perform one-to-many cross-chain token transfers in a single transaction using DropCaster",
        "long_description": "We have created a tool to perform one-to-many cross-chain token transfers in a single transaction. The tool is built on top of the Uniswap V4 pool where the user provides the input token A and a list of addresses he wants to airdrop, the DropCaster swaps Token A <> Token B, and Token B is equally distributed to all the addresses. The token transfer takes place in the Flashloan accounting pattern where the token is first distributed among the addresses from pool and then the user settles the amount owed to pool. We have also integrated Hyperlane to enable cross-chain distribution of the tokens from uniswap pool. DropCaster is an awesome tool for airdrops, and we have created an interface where anybody can airdrop their favourite tokens among the nearby wallets within common bluetooth range. The main technologies used to build DropCaster are:- The DropCaster is built on top of Uniswap v4 hook where we have used afterSwap hook to distribute the output tokens when the user successfully performs the swap of Token A to Token B. The afterSwap performs the flash accounting where the tokens are \"taken\" from the pool and distributed to receivers. The user then settles the balance using native token. Along with the addresses of the receivers, their receiving chain ID is also specified and cross chain transfer is performed using Hyperlane to the receivers who want to receive on different chain ID.",
        "how_its_made": "The main technologies used to build DropCaster are:- The DropCaster is built on top of Uniswap v4 hook where we have used afterSwap hook to distribute the output tokens when the user successfully performs the swap of Token A to Token B. The afterSwap performs the flash accounting where the tokens are \"taken\" from the pool and distributed to receivers. The user then settles the balance using native token. Along with the addresses of the receivers, their receiving chain ID is also specified and cross chain transfer is performed using Hyperlane to the receivers who want to receive on different chain ID.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vs669/screenshots/newva/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vs669/screenshots/d25nt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vs669/screenshots/0cn62/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vs669/screenshots/1jf4u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vs669/screenshots/7gm0a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vs669/screenshots/ddar0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Prajjawalk/one-many-airdrop",
        "link": "https://ethglobal.com/showcase/dropcaster-vs669"
    },
    {
        "title": "Creator Sphere",
        "brief_description": "The 360 Degree way to engage and retain your audience. We achieve this using SBTs and erc20 tokens.",
        "long_description": "Content creators need a way to engage with their superfans. However, they need to operate within the existing social apps (YouTube, Instagram, Discord, Twitter) because that is where their audience is and where they can achieve distribution. 'Creator Sphere' is an application that allows them to hyper-personalize their relationship with these superfans by minting SBTs and earning tokens on various social apps. These tokens are then used for DAO Voting as well as get them special privileges on Discord and Telegram. All the contracts are deployed on AirDAO. There are 3 in total. The first is the SBT contract, the second is the erc20 token contract and a third one that allows creators to create new tasks (carrying rewards), delete existing tasks, and it checks and verifies whether the task was completed before dispensing the tokens on-chain. We have used World ID to verify proof-of-humanity and have used MACI for DAO voting.",
        "how_its_made": "All the contracts are deployed on AirDAO. There are 3 in total. The first is the SBT contract, the second is the erc20 token contract and a third one that allows creators to create new tasks (carrying rewards), delete existing tasks, and it checks and verifies whether the task was completed before dispensing the tokens on-chain. We have used World ID to verify proof-of-humanity and have used MACI for DAO voting.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8hi1t/screenshots/6f4g3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8hi1t/screenshots/zos5a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8hi1t/screenshots/87tru/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/incepthink/Creator_Sphere",
        "link": "https://ethglobal.com/showcase/creator-sphere-8hi1t"
    },
    {
        "title": "EthoSphere",
        "brief_description": "EthoSphere protects users' privacy by converting their digital profiles into NFTs, while also providing a means for monetization.#DataPrivacy #Web3",
        "long_description": "EthoSphere is an innovative Web3 platform built on the Ethereum blockchain, designed to reshape the digital economy by balancing data privacy, user empowerment, and value distribution. It addresses critical challenges in today\u2019s data-driven world, where massive amounts of user data are collected and monetized by corporations, often at the expense of personal privacy. EthoSphere offers a transformative solution by enabling users to retain control over their data while benefiting financially from its use. Dynamic Anonymous NFTs: EthoSphere uses NFTs (non-fungible tokens) to represent a user\u2019s digital profile, based on their online behavior and interactions. These NFTs are anonymized to ensure user privacy, while still providing valuable, personalized insights that businesses can use. These dynamic NFTs evolve with users\u2019 behavior and data over time. Decentralized Data Collection: Instead of a centralized entity gathering and controlling data, EthoSphere allows users to share their data on their own terms through a community-driven model. Users interact within a decentralized forum where behavioral data is collected in a secure, private manner, then anonymized and encrypted. Anonymous Data Marketplace: EthoSphere introduces a data marketplace where enterprises can purchase anonymized NFTs. These NFTs hold valuable behavioral data without revealing personal details, ensuring both data privacy and its utility for businesses. Revenue generated from these sales is distributed among the platform's active users, ensuring fair data value sharing. Blockchain-Based Transparency: The entire process is underpinned by Ethereum blockchain\u2019s smart contracts, which manage NFT creation, transactions, and revenue distribution in a fully transparent, tamper-proof manner. This ensures fairness in every transaction and builds trust between users and enterprises. IPFS for Data Storage: EthoSphere leverages the InterPlanetary File System (IPFS), a decentralized storage system, to securely store and access user data. This further strengthens data privacy by reducing reliance on centralized servers. User Empowerment and Fair Value Distribution: Users retain ownership of their data and directly share in the economic value it generates. By participating in the platform, users receive revenue from the sale of their anonymized data, turning personal data into an asset while maintaining privacy. Privacy by Design: EthoSphere places privacy at the forefront, ensuring all user data is anonymized and encrypted before being used. This mitigates the risks associated with data breaches or unauthorized exploitation of personal information. For Enterprises: Businesses gain access to high-quality, real-time behavioral insights from a diverse user base without compromising privacy. This creates a win-win situation where businesses obtain useful market data, and users receive a share of the profits. EthoSphere\u2019s roadmap includes integrating natural language processing (NLP) technologies to enhance NFT data profiles, incentivizing high-quality data contributions, and exploring integration opportunities with other platforms to expand the ecosystem. The project also aims to play a pioneering role in promoting data democracy, privacy innovation, and economic inclusion on a global scale. EthoSphere is more than just a technological platform\u2014it\u2019s a movement toward democratizing data ownership, improving privacy standards, and breaking down the monopolistic control that large corporations have over data. The platform empowers individuals to take control of their digital identities, while also creating new economic opportunities for users who were previously excluded from the value their data generated. It also raises public awareness about data privacy and encourages users to be more proactive in understanding their rights in the digital economy. In summary, EthoSphere redefines the digital data economy by combining cutting-edge technologies like blockchain, NFTs, and decentralized storage with a user-first, privacy-centric approach. It promises a future where individuals can safely and fairly participate in the digital economy, while businesses gain access to ethically sourced data insights. EthoSphere was built using a mix of blockchain technology, decentralized storage solutions, and privacy-focused data handling techniques. Here\u2019s a detailed explanation of how the project was constructed, along with the key technologies involved and how they work together. Ethereum Blockchain (Smart Contracts):\nThe core of EthoSphere is built on the Ethereum blockchain. We utilized Ethereum\u2019s ERC-721 NFT standard to create unique, anonymized Dynamic Anonymous NFTs that represent user behavioral data profiles. These NFTs evolve over time as user interactions and data change. Ethereum smart contracts handle several important functions within the platform: By using the Ethereum network, we benefit from a secure and decentralized environment, ensuring data integrity and trustless transactions. IPFS (InterPlanetary File System):\nIPFS serves as our decentralized storage solution. All user-generated data, once anonymized, is stored securely on IPFS. This approach helps avoid centralized servers, reducing the risk of data breaches and providing resilience. The data is also immutable, meaning it cannot be altered or tampered with after it\u2019s uploaded, ensuring security and trustworthiness. IPFS allows us to store large amounts of data in a decentralized way, while still enabling users and enterprises to retrieve the information efficiently. MetaMask Integration:\nWe integrated MetaMask to allow users to easily connect their crypto wallets to the platform. MetaMask serves as both a login and transaction management tool, enabling users to mint, purchase, and sell their NFTs seamlessly. This integration makes interacting with the EthoSphere ecosystem intuitive for both experienced Web3 users and beginners. Using MetaMask simplifies the process of interacting with Ethereum smart contracts and ensures secure, decentralized authentication. Anonymization and Data Encryption:\nData privacy is a key concern for EthoSphere. We implemented robust anonymization techniques to ensure that user data cannot be traced back to individuals. Behavioral data is encrypted using industry-standard encryption algorithms before it is converted into NFTs. This encryption ensures that while the NFTs carry valuable insights for buyers, the identity of the user behind the data remains protected. This privacy-by-design approach ensures that even after data is shared or sold, it remains secure and private. Decentralized Data Marketplace:\nThe data marketplace is an integral part of EthoSphere. It allows enterprises and other interested buyers to purchase NFTs containing anonymized data insights. This marketplace is decentralized and operates via Ethereum smart contracts, ensuring full transparency and fairness in transactions. Once an NFT is purchased, the smart contract facilitates the transaction and allocates the revenue to the corresponding users based on their NFT sales. This decentralized approach ensures that no central authority controls the transactions, providing trust and transparency to both buyers and sellers. Dynamic NFT Metadata:\nOne particularly innovative aspect of EthoSphere is the use of dynamic metadata for NFTs. Unlike static NFTs, EthoSphere\u2019s NFTs update over time as users continue to interact with the platform. As user behavior evolves, the metadata embedded in their NFTs changes, reflecting new data and insights. This feature ensures that the NFTs remain valuable and up-to-date, increasing their relevance and potential market value. By using dynamic metadata, we created NFTs that evolve with users, making them more useful and interesting for buyers over time. NFT Behavior Evolution:\nOne of the notable and technically complex aspects of the project is how NFTs evolve dynamically with user behavior. We used a clever combination of data streams and metadata updates to ensure that the NFTs update in real-time or periodically without compromising privacy. This required deep integration between user activity monitoring, anonymization protocols, and the NFT structure itself, making it a unique feature in the NFT space. Efficient Anonymization Without Sacrificing Value:\nBalancing strong anonymization with retaining valuable insights was a particularly tricky challenge. We had to carefully design encryption and anonymization protocols that protected user identities while still allowing meaningful behavioral data to be accessible to enterprises. Achieving this required a mix of data obfuscation, cryptographic hashing, and data aggregation techniques. Automated Fair Distribution via Smart Contracts:\nThe platform uses an automated system for distributing revenues from NFT sales back to the users. This is handled entirely through smart contracts, ensuring that the distribution is transparent, fast, and fair. No manual intervention is required once the system is in place, which eliminates administrative overhead and guarantees that users receive their fair share of the proceeds. Real-Time Marketplace Functionality:\nBuilding a marketplace that can handle real-time transactions in a decentralized manner involved some unique challenges. Ensuring low latency, while maintaining the integrity of the Ethereum blockchain, required us to fine-tune the smart contract logic and integrate it with the front-end systems in a way that optimized both security and speed. EthoSphere is a complex yet elegantly designed system that combines blockchain, decentralized storage, advanced privacy techniques, and Web3 user interaction tools. Each of these technologies plays a critical role in ensuring that users can safely and securely monetize their data while maintaining full control over their digital identity. This blend of innovation and privacy-first thinking positions EthoSphere as a pioneering platform in the data economy of the future.",
        "how_its_made": "EthoSphere was built using a mix of blockchain technology, decentralized storage solutions, and privacy-focused data handling techniques. Here\u2019s a detailed explanation of how the project was constructed, along with the key technologies involved and how they work together. Ethereum Blockchain (Smart Contracts):\nThe core of EthoSphere is built on the Ethereum blockchain. We utilized Ethereum\u2019s ERC-721 NFT standard to create unique, anonymized Dynamic Anonymous NFTs that represent user behavioral data profiles. These NFTs evolve over time as user interactions and data change. Ethereum smart contracts handle several important functions within the platform: By using the Ethereum network, we benefit from a secure and decentralized environment, ensuring data integrity and trustless transactions. IPFS (InterPlanetary File System):\nIPFS serves as our decentralized storage solution. All user-generated data, once anonymized, is stored securely on IPFS. This approach helps avoid centralized servers, reducing the risk of data breaches and providing resilience. The data is also immutable, meaning it cannot be altered or tampered with after it\u2019s uploaded, ensuring security and trustworthiness. IPFS allows us to store large amounts of data in a decentralized way, while still enabling users and enterprises to retrieve the information efficiently. MetaMask Integration:\nWe integrated MetaMask to allow users to easily connect their crypto wallets to the platform. MetaMask serves as both a login and transaction management tool, enabling users to mint, purchase, and sell their NFTs seamlessly. This integration makes interacting with the EthoSphere ecosystem intuitive for both experienced Web3 users and beginners. Using MetaMask simplifies the process of interacting with Ethereum smart contracts and ensures secure, decentralized authentication. Anonymization and Data Encryption:\nData privacy is a key concern for EthoSphere. We implemented robust anonymization techniques to ensure that user data cannot be traced back to individuals. Behavioral data is encrypted using industry-standard encryption algorithms before it is converted into NFTs. This encryption ensures that while the NFTs carry valuable insights for buyers, the identity of the user behind the data remains protected. This privacy-by-design approach ensures that even after data is shared or sold, it remains secure and private. Decentralized Data Marketplace:\nThe data marketplace is an integral part of EthoSphere. It allows enterprises and other interested buyers to purchase NFTs containing anonymized data insights. This marketplace is decentralized and operates via Ethereum smart contracts, ensuring full transparency and fairness in transactions. Once an NFT is purchased, the smart contract facilitates the transaction and allocates the revenue to the corresponding users based on their NFT sales. This decentralized approach ensures that no central authority controls the transactions, providing trust and transparency to both buyers and sellers. Dynamic NFT Metadata:\nOne particularly innovative aspect of EthoSphere is the use of dynamic metadata for NFTs. Unlike static NFTs, EthoSphere\u2019s NFTs update over time as users continue to interact with the platform. As user behavior evolves, the metadata embedded in their NFTs changes, reflecting new data and insights. This feature ensures that the NFTs remain valuable and up-to-date, increasing their relevance and potential market value. By using dynamic metadata, we created NFTs that evolve with users, making them more useful and interesting for buyers over time. NFT Behavior Evolution:\nOne of the notable and technically complex aspects of the project is how NFTs evolve dynamically with user behavior. We used a clever combination of data streams and metadata updates to ensure that the NFTs update in real-time or periodically without compromising privacy. This required deep integration between user activity monitoring, anonymization protocols, and the NFT structure itself, making it a unique feature in the NFT space. Efficient Anonymization Without Sacrificing Value:\nBalancing strong anonymization with retaining valuable insights was a particularly tricky challenge. We had to carefully design encryption and anonymization protocols that protected user identities while still allowing meaningful behavioral data to be accessible to enterprises. Achieving this required a mix of data obfuscation, cryptographic hashing, and data aggregation techniques. Automated Fair Distribution via Smart Contracts:\nThe platform uses an automated system for distributing revenues from NFT sales back to the users. This is handled entirely through smart contracts, ensuring that the distribution is transparent, fast, and fair. No manual intervention is required once the system is in place, which eliminates administrative overhead and guarantees that users receive their fair share of the proceeds. Real-Time Marketplace Functionality:\nBuilding a marketplace that can handle real-time transactions in a decentralized manner involved some unique challenges. Ensuring low latency, while maintaining the integrity of the Ethereum blockchain, required us to fine-tune the smart contract logic and integrate it with the front-end systems in a way that optimized both security and speed. EthoSphere is a complex yet elegantly designed system that combines blockchain, decentralized storage, advanced privacy techniques, and Web3 user interaction tools. Each of these technologies plays a critical role in ensuring that users can safely and securely monetize their data while maintaining full control over their digital identity. This blend of innovation and privacy-first thinking positions EthoSphere as a pioneering platform in the data economy of the future.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/eutbe/screenshots/mvwz8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/eutbe/screenshots/h44mk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/eutbe/screenshots/c54ug/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/YaYa-richard/BehaviourNFT/",
        "link": "https://ethglobal.com/showcase/ethosphere-eutbe"
    },
    {
        "title": "AgentX",
        "brief_description": "Introducing our Twitter bot that lets you predict the future! Powered by oracles, it enables you to place bets on live polls by sending on-chain transactions. Participate in decentralized, real-time predictions and win big. #Blockchain #Crypto #Web3 #DeFi",
        "long_description": "In our project, organizations can register and create their own bot commands. To onboard, they verify their identity using World ID and integrate via our dApp. Each organization receives an ENS subdomain as a reward. You can register smart contract calls that our AgentX bot will trigger based on user requests. This AI-powered bot enables seamless connections between consumers and the Web3 world, even while browsing social media. One use case allows users to place bets on Twitter polls simply by tagging our bot. With potential for more actions, users can initiate smart contract calls using just simple, everyday language. We built this project using a powerful combination of Web3, AI, and social media technologies. At the core are Ethereum smart contracts where organizations can register custom bot commands. Organizations are verified via World ID and rewarded with an ENS subdomain. The AI bot integrates with Twitter's API, allowing users to trigger smart contract calls by tagging the bot. For predictions, we deployed Chainlink oracles in Morpho and used the Phala Network's AI agent for more accurate and secure predictions, enabling on-chain bets based on off-chain data. Our backend, powered by Node.js, connects the bot with the blockchain through Web3.js and Ethers.js. Natural language processing is handled by OpenAI\u2019s GPT models, enabling users to initiate smart contract actions with simple, everyday language. We also host a Discord-gated community on AirDAO, providing users with a private space to interact and collaborate. This combination of AI, oracles, and decentralized tech creates a seamless bridge between Web2 social platforms and the Web3 world.",
        "how_its_made": "We built this project using a powerful combination of Web3, AI, and social media technologies. At the core are Ethereum smart contracts where organizations can register custom bot commands. Organizations are verified via World ID and rewarded with an ENS subdomain. The AI bot integrates with Twitter's API, allowing users to trigger smart contract calls by tagging the bot. For predictions, we deployed Chainlink oracles in Morpho and used the Phala Network's AI agent for more accurate and secure predictions, enabling on-chain bets based on off-chain data. Our backend, powered by Node.js, connects the bot with the blockchain through Web3.js and Ethers.js. Natural language processing is handled by OpenAI\u2019s GPT models, enabling users to initiate smart contract actions with simple, everyday language. We also host a Discord-gated community on AirDAO, providing users with a private space to interact and collaborate. This combination of AI, oracles, and decentralized tech creates a seamless bridge between Web2 social platforms and the Web3 world.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/j5fcc/screenshots/f3x0z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j5fcc/screenshots/xka5g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j5fcc/screenshots/jwnzg/default.jpg"
        ],
        "live_demo": "https://agentx-ethsg.vercel.app/app",
        "source_code": "https://github.com/AgentX-eth-singapore",
        "link": "https://ethglobal.com/showcase/agentx-j5fcc"
    },
    {
        "title": "rizz money",
        "brief_description": "Tinder for prediction markets using Dynamic and deployed on AirDAO",
        "long_description": "A prediction market that feels as simple and gamified to use as Tinder. All the predictions would be on-chain and easy to bet on with no gas-fees. Users can set bet amount constant and bet on multiple predictions at the same time. The bets would be settled when the end timestamp is passed. Web2 like onboarding through Gmail using dynamic. Predictions through stable coin payments and gasless transactions feels like breeze. Built on AirDAO and data oracles through ChainLink, there are built to be fraud proofs and user reputation scores that enables users to climb up the leaderboard and allow their followers to copy predict.",
        "how_its_made": "Web2 like onboarding through Gmail using dynamic. Predictions through stable coin payments and gasless transactions feels like breeze. Built on AirDAO and data oracles through ChainLink, there are built to be fraud proofs and user reputation scores that enables users to climb up the leaderboard and allow their followers to copy predict.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/462zv/screenshots/wb7un/default.jpg",
            "https://ethglobal.b-cdn.net/projects/462zv/screenshots/ro9j0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/462zv/screenshots/fxg9a/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/topji/rizz-dapp",
        "link": "https://ethglobal.com/showcase/rizz-money-462zv"
    },
    {
        "title": "Aiconomy",
        "brief_description": "Stripe for AI agents. We enable AI agents to have an onchain smart wallet to spend on your behalf and get tasks done.",
        "long_description": "As we were hacking around with AI ideas, we realized that AI agents can still not make fully autonomous payments without human intervention or compromised bank details. This made us think- What if AI agents had a \u201cbank account\u201d from which they can spend and receive money for tasks they perform? Since an AI agent cannot have a bank account in Web 2, Web 3 allows us to permissionlessly create a payment mechanism for the AI agent. Further, this allows an incentivized ecosystem that supports and rewards AI Agents performing specialized tasks. Thus we built a payment layer for AI agents that enables them to have an onchain wallet from which they can autonomously transact; with other AI agents and online services. This further enables multiple use cases which can be used to allow machine-to-machine collaboration to perform complex tasks. for example: A startup that is at an early stage and wants help with SEO management and copy improvement of the website. So, instead of using costly services in the market, they can employ specialized agents who can work together quickly and in a cost-efficient way. For this hackathon, we focused on one use case of this technology- which was creating a marketplace for AI agents with specific skills that can be accessed by any user to execute complex tasks. The marketplace is capable of doing the following: Our project, a marketplace for AI agents with autonomous payment capabilities, was built using a combination of modern technologies across the stack. Description of the various parts: hacks: We also ideated a foolproof mechanism for the AI\u2019s result in which the funds to be given to the AI are held on the marketplace contract for an hour and within this time if the user raises a dispute, the dispute is checked, if found truthful the user is refunded back their money and the rating of the AI agent decreases.",
        "how_its_made": "Our project, a marketplace for AI agents with autonomous payment capabilities, was built using a combination of modern technologies across the stack. Description of the various parts: hacks: We also ideated a foolproof mechanism for the AI\u2019s result in which the funds to be given to the AI are held on the marketplace contract for an hour and within this time if the user raises a dispute, the dispute is checked, if found truthful the user is refunded back their money and the rating of the AI agent decreases.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6xfcd/screenshots/dqm5q/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6xfcd/screenshots/y1jhe/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6xfcd/screenshots/bn95k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6xfcd/screenshots/aubkq/default.jpg"
        ],
        "live_demo": "https://aiconomy-nine.vercel.app/",
        "source_code": "https://github.com/Im-Madhur-Gupta/aiconomy",
        "link": "https://ethglobal.com/showcase/aiconomy-6xfcd"
    },
    {
        "title": "U.B.E",
        "brief_description": "UBE is the first Multichain Blockchain Link Generator, allowing non-technical users to easily create Blinks and execute blockchain actions directly on social media.",
        "long_description": "UBE (Universal Blink Engine) is the first Multichain Blockchain Link Generator, empowering non-technical users to create and execute Blinks\u2014blockchain actions\u2014through social media platforms. Supporting both EVM, Cosmos ecosystems and more to come, UBE bridges the gap between Web2 and blockchain by offering seamless multichain support, a user-friendly web-based Blink generator, and direct wallet integration with Metamask and Keplr. Current live use cases include multichain donation and staking Blinks, allowing users to perform blockchain interactions without technical barriers, solving issues of ecosystem restriction and complexity. This Next.js project uses the Adamik API, our unified remote transaction crafting solution, to create Blinks compatible with blockchains in the EVM and Cosmos ecosystems. It includes a Chrome extension that modifies the DOM to replace HTML content in tweets on x.com with custom Blinks. Additionally, we built a Blink generator, allowing users to easily create and deploy Blinks directly on x.com. This integration simplifies blockchain interactions on social media, providing an intuitive, multichain solution that requires no technical expertise.",
        "how_its_made": "This Next.js project uses the Adamik API, our unified remote transaction crafting solution, to create Blinks compatible with blockchains in the EVM and Cosmos ecosystems. It includes a Chrome extension that modifies the DOM to replace HTML content in tweets on x.com with custom Blinks. Additionally, we built a Blink generator, allowing users to easily create and deploy Blinks directly on x.com. This integration simplifies blockchain interactions on social media, providing an intuitive, multichain solution that requires no technical expertise.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/29sr5/screenshots/6akt6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/29sr5/screenshots/2r7u5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/29sr5/screenshots/aycx4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/29sr5/screenshots/mu8ym/default.jpg",
            "https://ethglobal.b-cdn.net/projects/29sr5/screenshots/6c0r7/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AdamikHQ/adamik-blinks",
        "link": "https://ethglobal.com/showcase/u-b-e-29sr5"
    },
    {
        "title": "Aegis",
        "brief_description": "A Web3 ad platform enhancing privacy by analyzing generic tags on the backend and private tags on the frontend. Users highlight interests, generating tags with LLMs. Advertisers submit URLs and images, while publishers display ads, ensuring secure, targeted advertising.",
        "long_description": "Our project revolutionizes advertising technology by prioritizing user privacy while delivering personalized ads. We offer two dashboards: one for advertisers and one for publishers. Advertisers submit their ads as proposals to a DAO, where members vote based on their governance token stakes. The outcome determines ad display and influences the advertiser's reputation and reach. Publishers register their websites on our platform, which scrapes content to the backend. An LLM assigns relevant tags to site sections, and an SDK wraps the website's divs to track user behavior, emitting events with generic and personal tags. Personal tags remain client-side for privacy, while encrypted generic tags are stored on IPFS. We use The Graph to index IPFS for efficient token retrieval mapped to users. User anonymity is preserved with World-ID, masking real identities from on-chain identities. When users visit websites, tag matching triggers personalized ads on the client side. Our system ensures full transparency by conducting all transactions on-chain and off-chain on a zk-side app chain, providing zk proofs and proof of ad display to advertisers. This approach guarantees privacy, transparency, and effective ad targeting. Frontend Development:\nReact with TypeScript (TSX):\nWhy: React provides a robust framework for building dynamic user interfaces, while TypeScript adds type safety, reducing runtime errors and improving code maintainability.\nIntegration: The frontend handles user interactions, such as highlighting text to generate private tags. It uses local storage to temporarily store these tags, ensuring they remain on the user's device for privacy.\nBackend Development:\nNode.js:\nWhy: Node.js is well-suited for building scalable network applications. Its non-blocking I/O model makes it efficient for handling multiple requests, which is crucial for a platform with potentially high traffic.\nIntegration: The backend processes generic tags and interacts with blockchain components. It receives data from the frontend, analyzes it, and matches ads using the information from the blockchain.\nBlockchain and Decentralization:\nMina Protocol:\nOverview: Mina Protocol is known for its succinct blockchain, which is designed to remain lightweight and efficient. Unlike traditional blockchains that grow in size over time, Mina maintains a constant size, making it highly scalable and accessible.\nIntegration in Your Project:\nTransaction Handling: Mina is used to record transactions related to ad placements, payments, and user interactions. This ensures that all transactions are transparent and verifiable without the overhead of a large blockchain.\nData Verification: The succinct nature of Mina allows for efficient data verification. This is crucial for ensuring the integrity of ad-related data, such as impressions and clicks, without requiring extensive computational resources.\nSmart Contracts: Mina supports smart contracts, which can be used to automate processes like ad bidding, revenue sharing, and governance decisions. These contracts are executed on the blockchain, ensuring they are tamper-proof and transparent.\nThe Graph:\nOverview: The Graph is a decentralized protocol for indexing and querying blockchain data. It allows developers to build and publish open APIs, called subgraphs, that applications can query using GraphQL.\nIntegration in Your Project:\nData Indexing: The Graph indexes data from Mina Protocol's smart contracts, making it easily accessible for the backend to query. This is essential for retrieving information about ad transactions, user interactions, and other relevant data.\nEfficient Querying: By using The Graph, your platform can perform complex queries on blockchain data quickly and efficiently. This enables real-time analytics and ad targeting based on up-to-date information.\nSubgraph Development: Custom subgraphs can be developed to cater to specific data needs of your platform, such as tracking ad performance metrics or user engagement statistics.\nDecentralized Storage:\nOverview: Decentralized storage solutions like IPFS (InterPlanetary File System) are used to store ad content and metadata. This ensures that data is distributed across a network of nodes, rather than being held by a single entity.\nIntegration in Your Project:\nAd Content Storage: Ad images, descriptions, and other media are stored on IPFS. This ensures that the content is always available and not subject to censorship or single-point failures.\nData Integrity: IPFS provides content-addressable storage, meaning that each piece of data is identified by a unique hash. This ensures that the data has not been tampered with and remains consistent across the network.\nAccess and Retrieval: The frontend and backend can retrieve ad content from IPFS using these hashes, ensuring that the data is always up-to-date and accessible.\nGovernance with AirDAO:\nOverview: AirDAO provides a framework for decentralized governance, allowing stakeholders to participate in decision-making processes related to the platform.\nIntegration in Your Project:\nCommunity Voting: AirDAO can facilitate voting on platform changes, such as feature updates or policy adjustments. This ensures that the platform evolves in a way that reflects the community's interests.\nProposal Management: Stakeholders can submit proposals for new features or changes, which are then voted on by the community. This decentralized approach ensures transparency and inclusivity in governance.\nPartner Technologies and Benefits\nWorldcoin ID and AirDAO: These technologies enhance user privacy and platform governance, respectively. Worldcoin ID allows for secure user identification without compromising privacy, while AirDAO ensures that the platform's evolution is guided by its community.\nMina Protocol and The Graph: These technologies provide a scalable and efficient way to handle blockchain data, ensuring that the platform can grow without performance bottlenecks.",
        "how_its_made": "Frontend Development:\nReact with TypeScript (TSX):\nWhy: React provides a robust framework for building dynamic user interfaces, while TypeScript adds type safety, reducing runtime errors and improving code maintainability.\nIntegration: The frontend handles user interactions, such as highlighting text to generate private tags. It uses local storage to temporarily store these tags, ensuring they remain on the user's device for privacy.\nBackend Development:\nNode.js:\nWhy: Node.js is well-suited for building scalable network applications. Its non-blocking I/O model makes it efficient for handling multiple requests, which is crucial for a platform with potentially high traffic.\nIntegration: The backend processes generic tags and interacts with blockchain components. It receives data from the frontend, analyzes it, and matches ads using the information from the blockchain.\nBlockchain and Decentralization:\nMina Protocol:\nOverview: Mina Protocol is known for its succinct blockchain, which is designed to remain lightweight and efficient. Unlike traditional blockchains that grow in size over time, Mina maintains a constant size, making it highly scalable and accessible.\nIntegration in Your Project:\nTransaction Handling: Mina is used to record transactions related to ad placements, payments, and user interactions. This ensures that all transactions are transparent and verifiable without the overhead of a large blockchain.\nData Verification: The succinct nature of Mina allows for efficient data verification. This is crucial for ensuring the integrity of ad-related data, such as impressions and clicks, without requiring extensive computational resources.\nSmart Contracts: Mina supports smart contracts, which can be used to automate processes like ad bidding, revenue sharing, and governance decisions. These contracts are executed on the blockchain, ensuring they are tamper-proof and transparent.\nThe Graph:\nOverview: The Graph is a decentralized protocol for indexing and querying blockchain data. It allows developers to build and publish open APIs, called subgraphs, that applications can query using GraphQL.\nIntegration in Your Project:\nData Indexing: The Graph indexes data from Mina Protocol's smart contracts, making it easily accessible for the backend to query. This is essential for retrieving information about ad transactions, user interactions, and other relevant data.\nEfficient Querying: By using The Graph, your platform can perform complex queries on blockchain data quickly and efficiently. This enables real-time analytics and ad targeting based on up-to-date information.\nSubgraph Development: Custom subgraphs can be developed to cater to specific data needs of your platform, such as tracking ad performance metrics or user engagement statistics.\nDecentralized Storage:\nOverview: Decentralized storage solutions like IPFS (InterPlanetary File System) are used to store ad content and metadata. This ensures that data is distributed across a network of nodes, rather than being held by a single entity.\nIntegration in Your Project:\nAd Content Storage: Ad images, descriptions, and other media are stored on IPFS. This ensures that the content is always available and not subject to censorship or single-point failures.\nData Integrity: IPFS provides content-addressable storage, meaning that each piece of data is identified by a unique hash. This ensures that the data has not been tampered with and remains consistent across the network.\nAccess and Retrieval: The frontend and backend can retrieve ad content from IPFS using these hashes, ensuring that the data is always up-to-date and accessible.\nGovernance with AirDAO:\nOverview: AirDAO provides a framework for decentralized governance, allowing stakeholders to participate in decision-making processes related to the platform.\nIntegration in Your Project:\nCommunity Voting: AirDAO can facilitate voting on platform changes, such as feature updates or policy adjustments. This ensures that the platform evolves in a way that reflects the community's interests.\nProposal Management: Stakeholders can submit proposals for new features or changes, which are then voted on by the community. This decentralized approach ensures transparency and inclusivity in governance.\nPartner Technologies and Benefits\nWorldcoin ID and AirDAO: These technologies enhance user privacy and platform governance, respectively. Worldcoin ID allows for secure user identification without compromising privacy, while AirDAO ensures that the platform's evolution is guided by its community.\nMina Protocol and The Graph: These technologies provide a scalable and efficient way to handle blockchain data, ensuring that the platform can grow without performance bottlenecks.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ukp3p/screenshots/fzkb4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ukp3p/screenshots/hrwrk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ukp3p/screenshots/2wkbj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ukp3p/screenshots/hex6h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ukp3p/screenshots/2aosf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ukp3p/screenshots/ebw6d/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/eth-singapore2k24",
        "link": "https://ethglobal.com/showcase/aegis-ukp3p"
    },
    {
        "title": "Nifi",
        "brief_description": "Nifi is a First Ever Built Web3-based captive portal for secure WiFi access, using token and NFT authentication on the blockchain. It seamlessly authorizes users by verifying digital assets for fair usage. Secure, decentralized, and user-friendly!",
        "long_description": "Have you ever entered a lounge or boarded an airline like Singapore or Emirates, where you're asked to log in using your frequent flyer number or mobile number to access WiFi? Now, imagine a similar experience\u2014but instead of using a traditional login, access is granted based on the crypto or NFTs you hold in your Web3 wallet. That's what I've built: a captive portal solution powered by Web3 technology. It lets you grant WiFi access based on your digital assets, like tokens or NFTs, offering a seamless, decentralized alternative to the usual login methods. Let\u2019s dive into how it works! As the demand for decentralized identity solutions grows, traditional WiFi networks lack the ability to authenticate users via blockchain-based assets, such as NFTs and tokens. Existing captive portals focus on centralized methods for access control, leaving out web3 authentication mechanisms, which are becoming increasingly important for modern users who rely on blockchain assets for identification and access to services.If such capitative portal and access flow is built it can provide wide variety of usecases such as pay as you go model through crypto assets, wifi access in airlines through nft tickets and so on... Nifi aims to solve this problem by enabling token-based WiFi authentication through a custom captive portal that leverages Web3 technologies. The system uses NFTs and tokens as access credentials, providing an innovative solution for decentralized network access. Nifi integrates blockchain, OpenNDS, and Raspberry Pi to create a decentralized captive portal that authenticates users using ERC20, ERC721, and ERC1155 tokens. It relies on a pre-authentication flow and forward authentication services (FAS) to grant or deny network access. Hardware & Platform: Software Components: By combining the power of decentralized identity and blockchain with traditional network access, Nifi represents a step toward a more secure and user-controlled internet experience. Hardware & Platform: Software Components:",
        "how_its_made": "Hardware & Platform: Software Components:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/o3uf2/screenshots/4fb6o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o3uf2/screenshots/3837b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o3uf2/screenshots/br6ht/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o3uf2/screenshots/38r2e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o3uf2/screenshots/k29sn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o3uf2/screenshots/p0x8d/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/mbcse/nifi",
        "link": "https://ethglobal.com/showcase/nifi-o3uf2"
    },
    {
        "title": "Marina Royale",
        "brief_description": "Lottery using Uniswap V4 hooks with built-in referrals. Mobile-optimized through Telegram with gas-free experience on Base.",
        "long_description": "We leverage Uniswap V4 hooks instead of traditional ERC4626 vaults allowing anyone with liquidity to spin up their lottery pools. Particularly, meme communities or large treasuries with utility tokens can now provide liquidity using their native tokens, unlocking highly positive expected value opportunities. We've created a mobile-optimized experience using embedded wallets and paymaster logic to remove gas fees from users. We use the Dynamic Wallet to onboard users. Key features include: Unlike lossless lotteries, our system offers distinct expected values for both players and liquidity providers: Players have a chance at winning significant jackpots, with the trade-off of potential loss of principal. Liquidity providers earn from unsuccessful tickets and benefit from the built-in referral system, potentially earning more than in traditional yield-generating protocols. Our referral system, built directly into the Uniswap V4 hooks, incentivizes community growth & potentially creates token utility:\nWhen a referred user participates and doesn't win, 20% of their ticket value goes to the referrer. The remaining 80% is distributed among the liquidity providers. For example, if user A is referred and buys 10 tickets worth $10 USDC, and the jackpot expires without them winning, $2 goes to the referrer and $8 is shared among the LPs.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ykabv/screenshots/xh0y1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ykabv/screenshots/mkak3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ykabv/screenshots/irdis/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ykabv/screenshots/cu994/default.jpg"
        ],
        "live_demo": "https://sands-royale.vercel.app/",
        "source_code": "https://github.com/Sands-Royale/contracts",
        "link": "https://ethglobal.com/showcase/marina-royale-ykabv"
    },
    {
        "title": "Zyn Tax",
        "brief_description": "zyntax gives taxes to standard erc20 tokens at the router level",
        "long_description": "zyntax uses uniswap hooks to implement standard defi pumpinomic tax structure to what would normally be a standard erc20 token. Incorporating taxes on standard ERC-20 tokens through Uniswap v4 hooks is a crucial development for projects looking to implement sustainable tokenomics. By enabling custom hooks, developers can automatically apply transaction fees such as liquidity taxes, reflection rewards, or burning mechanisms directly within the liquidity pool interactions. This ensures that taxes are consistently applied during every trade, without relying on external contracts or manual intervention, which can introduce inefficiencies or vulnerabilities. Moreover, by embedding tax logic directly into the trading process, it creates a more seamless and trustless system for users, ensuring that the project\u2019s tokenomics are adhered to at every step. Additionally, Uniswap v4 hooks provide greater flexibility for projects to fine-tune their economic models and maintain more control over their token flows. Tax-based mechanisms can be pivotal for deflationary tokens, where a portion of each transaction may be burned to reduce supply, or in reflection tokens, where taxes are redistributed to holders as passive income. With taxes directly incorporated via Uniswap v4 hooks, projects can enforce these mechanisms in a decentralized, automated, and highly efficient manner, ensuring a consistent application of their financial policies across all transactions. This innovation ultimately enhances both project sustainability and user trust in the ecosystem. this project was made with a lot of energy drinks, solidity, and some aggressive prompting. Incorporating taxes on standard ERC-20 tokens through Uniswap v4 hooks is a crucial development for projects looking to implement sustainable tokenomics. By enabling custom hooks, developers can automatically apply transaction fees such as liquidity taxes, reflection rewards, or burning mechanisms directly within the liquidity pool interactions. This ensures that taxes are consistently applied during every trade, without relying on external contracts or manual intervention, which can introduce inefficiencies or vulnerabilities. Moreover, by embedding tax logic directly into the trading process, it creates a more seamless and trustless system for users, ensuring that the project\u2019s tokenomics are adhered to at every step. Additionally, Uniswap v4 hooks provide greater flexibility for projects to fine-tune their economic models and maintain more control over their token flows. Tax-based mechanisms can be pivotal for deflationary tokens, where a portion of each transaction may be burned to reduce supply, or in reflection tokens, where taxes are redistributed to holders as passive income. With taxes directly incorporated via Uniswap v4 hooks, projects can enforce these mechanisms in a decentralized, automated, and highly efficient manner, ensuring a consistent application of their financial policies across all transactions. This innovation ultimately enhances both project sustainability and user trust in the ecosystem.",
        "how_its_made": "this project was made with a lot of energy drinks, solidity, and some aggressive prompting. Incorporating taxes on standard ERC-20 tokens through Uniswap v4 hooks is a crucial development for projects looking to implement sustainable tokenomics. By enabling custom hooks, developers can automatically apply transaction fees such as liquidity taxes, reflection rewards, or burning mechanisms directly within the liquidity pool interactions. This ensures that taxes are consistently applied during every trade, without relying on external contracts or manual intervention, which can introduce inefficiencies or vulnerabilities. Moreover, by embedding tax logic directly into the trading process, it creates a more seamless and trustless system for users, ensuring that the project\u2019s tokenomics are adhered to at every step. Additionally, Uniswap v4 hooks provide greater flexibility for projects to fine-tune their economic models and maintain more control over their token flows. Tax-based mechanisms can be pivotal for deflationary tokens, where a portion of each transaction may be burned to reduce supply, or in reflection tokens, where taxes are redistributed to holders as passive income. With taxes directly incorporated via Uniswap v4 hooks, projects can enforce these mechanisms in a decentralized, automated, and highly efficient manner, ensuring a consistent application of their financial policies across all transactions. This innovation ultimately enhances both project sustainability and user trust in the ecosystem.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/116br/screenshots/gyvgk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/116br/screenshots/sh1kb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/116br/screenshots/b2y1t/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/gavinwale/zyntax1000",
        "link": "https://ethglobal.com/showcase/zyn-tax-116br"
    },
    {
        "title": "sidekick.ai",
        "brief_description": "A client-side LLM agent automating the form submission journey while providing proof of data security and form submission via Mina protocol",
        "long_description": "This project streamlines form-filling by using AI to map responses and autofill data. It prioritizes privacy with zero-knowledge proofs, ensuring data isn't leaked during the process. Users have the option to reveal certain information for future convenience. The system is designed to be tamper-proof and easy to verify. In our project, we harnessed the combined power of Worldcoin, Gaia node, and the Mina protocol to create a secure and efficient form-filling solution. Worldcoin's SDK enabled us to verify human requests, while the Gaia node's local LLM model intelligently mapped user responses to form data. The Mina protocol ensured data privacy through zero-knowledge proofs, preventing leaks during form submission. We integrated our LLM with a Selenium backend, allowing it to directly populate forms on government websites. After the bot fills all values, users can choose to publicly reveal certain details for future auto-filling. Once the form is filled and the user's choice is made, we send the input to our Mina contract for on-chain verification. Subsequently, we update the Merkle Mapping in our system to keep the FormVerifier contract's state current. If users opt to reveal data, we send it along with the commitment to avail, making it available for future form-filling. This approach ensures our system's tamper-proof nature and simplifies LLM verification by focusing on the final hashed values during submission.",
        "how_its_made": "In our project, we harnessed the combined power of Worldcoin, Gaia node, and the Mina protocol to create a secure and efficient form-filling solution. Worldcoin's SDK enabled us to verify human requests, while the Gaia node's local LLM model intelligently mapped user responses to form data. The Mina protocol ensured data privacy through zero-knowledge proofs, preventing leaks during form submission. We integrated our LLM with a Selenium backend, allowing it to directly populate forms on government websites. After the bot fills all values, users can choose to publicly reveal certain details for future auto-filling. Once the form is filled and the user's choice is made, we send the input to our Mina contract for on-chain verification. Subsequently, we update the Merkle Mapping in our system to keep the FormVerifier contract's state current. If users opt to reveal data, we send it along with the commitment to avail, making it available for future form-filling. This approach ensures our system's tamper-proof nature and simplifies LLM verification by focusing on the final hashed values during submission.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/votxi/screenshots/37vwy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/votxi/screenshots/uxc9y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/votxi/screenshots/aqszg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/votxi/screenshots/wcnsq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/votxi/screenshots/bnd8q/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/heemankv/Sidekick.ai",
        "link": "https://ethglobal.com/showcase/sidekick-ai-votxi"
    },
    {
        "title": "AirSafe",
        "brief_description": "Empowering Secure, Shared Governance for Decentralized Communities on AirDAO.",
        "long_description": "AirSafe is a decentralized multi-signature wallet solution specifically designed to operate within the AirDAO ecosystem. The project represents the integration of the widely-used Gnosis Safe wallet architecture, adapted for AirDAO\u2019s community-centric and governance-focused Layer 1 blockchain. AirSafe is built with a vision to enable organizations, decentralized autonomous organizations (DAOs), and multi-participant entities to securely manage their digital assets and decision-making processes in a decentralized environment. The project is focused on creating a seamless, trusted, and familiar user experience by leveraging the already established interface and features of Gnosis Safe while tailoring it for the unique infrastructure of AirDAO. By doing so, it ensures the adoption of a decentralized, multi-signature wallet without the need for users to learn a new system. The project is composed of multiple repositories, each serving a critical function within the overall infrastructure. The five repositories that form the backbone of AirSafe are: safe-eth-py safe-smart-account safe-singleton-factory safe-wallet-web safe-transaction-service Deploying Singleton Factory Contract Deploying Safe Smart Account Contracts Web UI Modifications for AirDAO Integration Updating the Transaction Service API for AirDAO Dockerization and Deployment The decision to use the Gnosis Safe framework (and its relevant technologies) was intentional due to its trusted reputation and robust security model. By using these existing, well-established libraries and services, I ensured that AirSafe inherits the same security guarantees and friendly user interface of Gnosis Safe. Building AirSafe involved integrating several existing technologies from the Gnosis Safe framework and modifying them to support the unique infrastructure of AirDAO. From deploying key contracts to updating the web UI and transaction service, every component was customized to ensure compatibility with the AirDAO ecosystem. While the current version is running locally, I plan to fully deploy AirSafe in the cloud, making it available for DAOs and organizations worldwide. The result is a highly secure, multi-signature wallet tailored for the decentralized governance structures of AirDAO.",
        "how_its_made": "The project is composed of multiple repositories, each serving a critical function within the overall infrastructure. The five repositories that form the backbone of AirSafe are: safe-eth-py safe-smart-account safe-singleton-factory safe-wallet-web safe-transaction-service Deploying Singleton Factory Contract Deploying Safe Smart Account Contracts Web UI Modifications for AirDAO Integration Updating the Transaction Service API for AirDAO Dockerization and Deployment The decision to use the Gnosis Safe framework (and its relevant technologies) was intentional due to its trusted reputation and robust security model. By using these existing, well-established libraries and services, I ensured that AirSafe inherits the same security guarantees and friendly user interface of Gnosis Safe. Building AirSafe involved integrating several existing technologies from the Gnosis Safe framework and modifying them to support the unique infrastructure of AirDAO. From deploying key contracts to updating the web UI and transaction service, every component was customized to ensure compatibility with the AirDAO ecosystem. While the current version is running locally, I plan to fully deploy AirSafe in the cloud, making it available for DAOs and organizations worldwide. The result is a highly secure, multi-signature wallet tailored for the decentralized governance structures of AirDAO.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/r8udx/screenshots/uw7c3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r8udx/screenshots/k4ena/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r8udx/screenshots/n8o6b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r8udx/screenshots/fqv82/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r8udx/screenshots/zhfe2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r8udx/screenshots/u86yr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AirSafe-DAO",
        "link": "https://ethglobal.com/showcase/airsafe-r8udx"
    },
    {
        "title": "Zk-Market",
        "brief_description": "Zk-Market is a groundbreaking marketplace that bridges the gap between Web2 and Web3 ecosystems through the innovative use of zero-knowledge proofs.",
        "long_description": "The Zk-Market SDK serves as a secure channel for Web3 protocols to engage with both Web2 and Web3 protocols while adhering to customizable business logic. This unique integration allows for novel scenarios that benefit both ecosystems. For instance, Web3 protocols can now expand their user base beyond web3 users by partnering with Web2 platforms. Through this collaboration, Web3 protocols can offer airdrops or other incentives to early adopters from the Web2 world, effectively bridging the gap between these two digital realms.\nThis strategy not only helps Web3 protocols to acquire and retain a broader user base but also provides value to Web2 platforms by incentivizing their users to engage with blockchain technology. As users from Web2 platforms are rewarded for their participation, they're more likely to remain active on both the Web2 platform and the partnered Web3 protocol. This symbiotic relationship fosters growth for both ecosystems simultaneously, creating a win-win situation that accelerates the adoption of blockchain technology while enhancing the value proposition of existing Web2 services. This project at its core uses ZkTLS library, it is a dapp built on RootStock Blockchain. It contains diferent dashboards for the for the user and protocol which allowa each of them to prove or verify according to their needs. The Smart Contract  stores the proofs on the blockchian and is available for verification by any protocol, and initiate the transaction according to the condition of the claim.",
        "how_its_made": "This project at its core uses ZkTLS library, it is a dapp built on RootStock Blockchain. It contains diferent dashboards for the for the user and protocol which allowa each of them to prove or verify according to their needs. The Smart Contract  stores the proofs on the blockchian and is available for verification by any protocol, and initiate the transaction according to the condition of the claim.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/y8dt3/screenshots/72nwc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8dt3/screenshots/wwtgd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8dt3/screenshots/60jxh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8dt3/screenshots/eab6t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8dt3/screenshots/2q9rk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8dt3/screenshots/a3vdk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/m-pandey5/Zk-Market",
        "link": "https://ethglobal.com/showcase/zk-market-y8dt3"
    },
    {
        "title": "RIP Protocol",
        "brief_description": "RIP Protocol allows encrypted data to stay private while performing specific tasks on the blockchain. Although blockchain is public, RIP ensures sensitive information remains secure, letting users leverage blockchain benefits without revealing personal data.",
        "long_description": "RIP Protocol is a project designed to protect sensitive information on the blockchain while allowing it to perform specific functions without exposing it to the public. On most blockchains, data is transparent and accessible, which is beneficial for security and decentralization but unsuitable for handling sensitive information. RIP Protocol addresses this by ensuring encrypted data remains private, while still enabling it to be used within blockchain-based applications. The protocol is ideal for scenarios where users need to manage private or sensitive information\u2014such as personal identification or medical data\u2014without making it public. RIP Protocol provides a solution by encrypting the data and restricting its use to specific conditions Example with DNA: Imagine you want to leave an inheritance for your children but need a way to prove their identity. Using RIP Protocol, you can encrypt your DNA data on the blockchain and set a condition that only someone with a matching DNA can claim the inheritance. When your children provide their DNA, it is privately matched with the encrypted data. No one else on the blockchain can access your DNA, but the protocol verifies the match and automatically releases the assets. With RIP Protocol, users can securely manage private data in a decentralized environment, combining the privacy of encryption with the benefits of blockchain transparency. Our main technology is multi-input functional encryption that allows data owner to restrict the use of his data to a specific function. This technology is very very immature, we have to dig through papers and github repositories to understand how it works. Then, we rewrote & modified the logic to make it into solidity itself. Hence now, our RIP protocol smart contract can take input of two encrypted data (encrypted DNA of both a father and a child) together with derived key, and calculate the function of these raw DNA data in smart contract, hence resulting in being able to on-chain verify if a child has a certain similarity to a dad on chain. If yes, the fund immediately transferred to the child. We deploy on Sapphire, the world's first confidential EVM network to leverage the ability to generate random number in secure/ private environment as generating public/ private key for our data. Moreover, Sapphire allows us to seamlessly import data information onto blockchain as private transaction, hence making it more seamless to import data thats supposed to be private To make sure that the raw data that is used for being encrypted to put in publicly is legit, not just random garbage. We leverage sign protocol to have hospital or relevant authority attest to our customized schema as \"wallet address of user, wallet address of attester (hospital and such), and encrypted data from the health record (in this case). Our smart contract makes sure that besides computing the functional decryption to get the result of ML similarity algorithm of two DNAs of both a father and a child, it will also check if those encrypted datas are actually attested by relevant authority like hospital as well. We leverage Noun since we believe in empowering people to think and perceive the world in a more fun and more curious way. We take pride in going out of comfort zone to try very under-explored technology like functional encryption.",
        "how_its_made": "Our main technology is multi-input functional encryption that allows data owner to restrict the use of his data to a specific function. This technology is very very immature, we have to dig through papers and github repositories to understand how it works. Then, we rewrote & modified the logic to make it into solidity itself. Hence now, our RIP protocol smart contract can take input of two encrypted data (encrypted DNA of both a father and a child) together with derived key, and calculate the function of these raw DNA data in smart contract, hence resulting in being able to on-chain verify if a child has a certain similarity to a dad on chain. If yes, the fund immediately transferred to the child. We deploy on Sapphire, the world's first confidential EVM network to leverage the ability to generate random number in secure/ private environment as generating public/ private key for our data. Moreover, Sapphire allows us to seamlessly import data information onto blockchain as private transaction, hence making it more seamless to import data thats supposed to be private To make sure that the raw data that is used for being encrypted to put in publicly is legit, not just random garbage. We leverage sign protocol to have hospital or relevant authority attest to our customized schema as \"wallet address of user, wallet address of attester (hospital and such), and encrypted data from the health record (in this case). Our smart contract makes sure that besides computing the functional decryption to get the result of ML similarity algorithm of two DNAs of both a father and a child, it will also check if those encrypted datas are actually attested by relevant authority like hospital as well. We leverage Noun since we believe in empowering people to think and perceive the world in a more fun and more curious way. We take pride in going out of comfort zone to try very under-explored technology like functional encryption.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jgw26/screenshots/udzyc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jgw26/screenshots/fpe81/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jgw26/screenshots/byqbx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jgw26/screenshots/fddyn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jgw26/screenshots/vkysw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jgw26/screenshots/hyg0m/default.jpg"
        ],
        "live_demo": "https://rip-proc.vercel.app",
        "source_code": "https://github.com/felynoir/rip-proc",
        "link": "https://ethglobal.com/showcase/rip-protocol-jgw26"
    },
    {
        "title": "co(IN)munity",
        "brief_description": "A community-building token launchpad with bonding curve, serving as a public good among NFT communities",
        "long_description": "co(IN)munity is a public good as a service that allows communities to launch a token using a bonding curve by allowing users to deposit EITHER the native token\nor the NFT associated with the community. In exchange for the deposits, users will get a community token. This community token is integrated with 1Inch's token plugins\nstandard which allows the community to extend this token for different plugins depending on their own usecase. A good example would be using the DelegationPlugin which will\nallow the community members to delegate votes to other trusted members in the community. co(IN)munity is also integrated with ENS such that the community coin will attempt be a reverse registrar to receive an ENS domain which we will extend in the future to allow it to grant community members each an ENS Subdomain based on their contribution. By integrating with Reown, we are able to use the Web3Inbox Notify feature to send community members a one time use discord link to users to create a token gated community upon purchase of the community token. This feature can also be extended to send community members important project updates like government proposals or airdrop announcements. For the frontend, we used Reown's Appkit alongside NounsDAO's fonts and its colour. This was built with NextJS as the main framework and alongside wagmi and Reown, users can connect ot the website and interact with the contracts. It is also integrated with Reown's Web3Inbox which allows users to be notified through push notifications and a notifiaction history. For the contracts, we used Roostock's hardhat starter kit which is enjoyable to use. For the contracts, we had our coinmunity contract as the main driver of the other contracts.The coinmunity contract takes in parameters and allows community tokens to be launched and supporting the purchase of the community token with either the native token or the NFT. The community token named ContinuousLinearToken, is an ERC20 with a bonding curve system built in to increase the price as demand increases. This community token also inherits ERC20Plugin to allow 1Inch's plugins to be extended upon it and reverse claimer to claim the ENS.",
        "how_its_made": "For the frontend, we used Reown's Appkit alongside NounsDAO's fonts and its colour. This was built with NextJS as the main framework and alongside wagmi and Reown, users can connect ot the website and interact with the contracts. It is also integrated with Reown's Web3Inbox which allows users to be notified through push notifications and a notifiaction history. For the contracts, we used Roostock's hardhat starter kit which is enjoyable to use. For the contracts, we had our coinmunity contract as the main driver of the other contracts.The coinmunity contract takes in parameters and allows community tokens to be launched and supporting the purchase of the community token with either the native token or the NFT. The community token named ContinuousLinearToken, is an ERC20 with a bonding curve system built in to increase the price as demand increases. This community token also inherits ERC20Plugin to allow 1Inch's plugins to be extended upon it and reverse claimer to claim the ENS.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/d9m3d/screenshots/3r0bz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d9m3d/screenshots/vexge/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d9m3d/screenshots/imn0y/default.jpg"
        ],
        "live_demo": "https://coinmunity-beta.vercel.app",
        "source_code": "https://github.com/wr1159/ethsg2024",
        "link": "https://ethglobal.com/showcase/co-in-munity-d9m3d"
    },
    {
        "title": "Caller ranking",
        "brief_description": "Caller ranking is a SocialFi game where you can speculate on the performance of alpha callers",
        "long_description": "Alpha callers are a new type of influencers\nIn this game, we rank callers of tokens based on their performance.\nYou can buy ERC20 tokens from the alpha callers you think will perform best.\nIf you have a buy big enough (at least 10 000 tokens for a supply of 1 billion), you can use this caller in your deck to enter a tournament.\nThink Sorare but with alpha callers instead of football players Pinata for IPFS storage of data\nDapp scaffold for the Dapp basis.\nEthereum testnet on Sepolia for the ERC20 token creation\nNextJS for the front end\nRailway to host the backend\nVercel to host the front end\ndotenv for environment configuration\nEtherscan for checking onchain activity",
        "how_its_made": "Pinata for IPFS storage of data\nDapp scaffold for the Dapp basis.\nEthereum testnet on Sepolia for the ERC20 token creation\nNextJS for the front end\nRailway to host the backend\nVercel to host the front end\ndotenv for environment configuration\nEtherscan for checking onchain activity",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ai786/screenshots/r0koo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ai786/screenshots/5idjv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ai786/screenshots/i0fqz/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/nada-r/caller_ranking",
        "link": "https://ethglobal.com/showcase/caller-ranking-ai786"
    },
    {
        "title": "ProofLoop",
        "brief_description": "Circular proof computation on Oasis Sapphire chain with view call",
        "long_description": "In complex transactions, where on-chain computation may exceed limits, off-chain methods are often used to compute proofs.\nHowever, on the Oasis Sapphire chain, unique features allow the secure storage of private signing keys directly in contract storage.\nThis allows proof computation to be performed fully on-chain. The Lowest Unique Bid Auction (LUB) was used as an example to demonstrate the utility of the method developed in the project. In this scenario, where participants submit multiple bids, each bid must be checked to determine the winner. Since processing all bids in a single transaction is impractical (due to gas limits), the solution involves processing bids in batches, signing and verifying each batch sequentially. After multiple calls, the results can be consolidated to generate a final, verified proof on-chain. The same batch-processing approach was also applied to check whether a user has at least one unique bid in the auction and whether the auction contains any unique bids at all. Demo app: https://github.com/chervyachok/sineth.demoapp",
        "how_its_made": "The Lowest Unique Bid Auction (LUB) was used as an example to demonstrate the utility of the method developed in the project. In this scenario, where participants submit multiple bids, each bid must be checked to determine the winner. Since processing all bids in a single transaction is impractical (due to gas limits), the solution involves processing bids in batches, signing and verifying each batch sequentially. After multiple calls, the results can be consolidated to generate a final, verified proof on-chain. The same batch-processing approach was also applied to check whether a user has at least one unique bid in the auction and whether the auction contains any unique bids at all. Demo app: https://github.com/chervyachok/sineth.demoapp",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bp5xm/screenshots/ydqvr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bp5xm/screenshots/crsxk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bp5xm/screenshots/dtzfz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bp5xm/screenshots/wxq43/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/chervyachok/sineth.contracts",
        "link": "https://ethglobal.com/showcase/proofloop-bp5xm"
    },
    {
        "title": "Reimbuddy",
        "brief_description": "ReimBuddy, a blockchain-based platform to streamline and secure reimbursements. Users submit claims, attesters validate, and companies authorize payouts. While ensuring identity authenticity, encrypted data is stored on-chain. LLMs assess claim legitimacy.",
        "long_description": "We're developing an innovative blockchain solution to automate and enhance the reimbursement process, ensuring transparency and speed. System Overview Actors: User Flow\nUsers can log in via SSO or MetaMask, utilizing World ID from the Worldcoin ecosystem for privacy-first identity verification. This generates a unique nullifier hash and wallet mapping, preventing wallet duplication. Upon successful login, users create reimbursement requests by completing a form with essential details (title, description, attester address, amount, and document uploads). Documents are encrypted with the attester's public key and uploaded to IPFS, while relevant metadata is stored on the blockchain, ensuring confidentiality and security. After submission, users are redirected to a home page displaying previous claims and a progress bar to track their request's status, fostering transparency. The platform employs the Sign Protocol for verifiable attestations, enhancing data validation. Worldcoin integration mitigates duplication, ensuring authentic user identities. Attesters log in similarly to review claims, verify documents, and approve or reject requests. Upon resolution, users receive email notifications. Additionally, the project leverages LLMs through the Phala Network to assess claim authenticity, classifying submissions as genuine or fraudulent by analyzing existing market data. Building this reimbursement platform involved a multi-faceted approach, integrating various partner technologies to ensure efficiency, security, and user experience. Using the modern technologies  we have positioned ourselves to address the challenges of traditional reimbursement processes effectively. Following Partner technologies were used in the project- @ WorldCoin\nWe use WorldCoin's World ID to ensure privacy-first identity verification for users. Upon logging in, users receive a unique nullifier hash that maps their wallet address to their World ID, preventing duplicate wallets and enhancing authenticity in the reimbursement process. @Sign Protocol\nThe Sign Protocol facilitates the creation of verifiable attestations on-chain. It allows us to securely validate digital information such as identities and claims. This ensures that all data involved in the reimbursement process is trustworthy and verifiable, improving governance and transparency. @Phala Network\nWe leverage the Phala Network to incorporate Large Language Models (LLMs) that analyze reimbursement claims. This AI-driven approach helps attesters determine the authenticity of claims by comparing them against existing market data, classifying submissions as genuine or potentially fraudulent.",
        "how_its_made": "Building this reimbursement platform involved a multi-faceted approach, integrating various partner technologies to ensure efficiency, security, and user experience. Using the modern technologies  we have positioned ourselves to address the challenges of traditional reimbursement processes effectively. Following Partner technologies were used in the project- @ WorldCoin\nWe use WorldCoin's World ID to ensure privacy-first identity verification for users. Upon logging in, users receive a unique nullifier hash that maps their wallet address to their World ID, preventing duplicate wallets and enhancing authenticity in the reimbursement process. @Sign Protocol\nThe Sign Protocol facilitates the creation of verifiable attestations on-chain. It allows us to securely validate digital information such as identities and claims. This ensures that all data involved in the reimbursement process is trustworthy and verifiable, improving governance and transparency. @Phala Network\nWe leverage the Phala Network to incorporate Large Language Models (LLMs) that analyze reimbursement claims. This AI-driven approach helps attesters determine the authenticity of claims by comparing them against existing market data, classifying submissions as genuine or potentially fraudulent.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/oagia/screenshots/h2jhd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oagia/screenshots/49yb1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oagia/screenshots/6afb6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oagia/screenshots/ib2j2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oagia/screenshots/98wvy/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/J0SAL/eth_singapore",
        "link": "https://ethglobal.com/showcase/reimbuddy-oagia"
    },
    {
        "title": "TeleGovernance",
        "brief_description": "Telegram bot to make it easy for token holders to vote and look at upcoming / existing proposals.",
        "long_description": "This project is a telegram bot for people to sign in with their wallets and stay up to date regarding  dao votes and proposals. Users can sign in with their wallet and opt to receive updates on upcoming votes. Furthermore, the process is gamified - projects can opt to reward voters accordingly This project is built using python (python-telegram-bot ) and snapshot graphql API. I first started by setting up a telegram bot using BotFather to get an api key. I then used the python-telegram-bot library to handle incoming messages and send responses. Afterwards, I integrated Snapshot GraphQL API to fetch data about proposals, spaces, and votes.\nThe technically challenging part was implementing code to ensure that the commands works.",
        "how_its_made": "This project is built using python (python-telegram-bot ) and snapshot graphql API. I first started by setting up a telegram bot using BotFather to get an api key. I then used the python-telegram-bot library to handle incoming messages and send responses. Afterwards, I integrated Snapshot GraphQL API to fetch data about proposals, spaces, and votes.\nThe technically challenging part was implementing code to ensure that the commands works.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/j8sf9/screenshots/eok8z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j8sf9/screenshots/fe2b5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j8sf9/screenshots/kdtkz/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/darrenlimweiyang/televote",
        "link": "https://ethglobal.com/showcase/telegovernance-j8sf9"
    },
    {
        "title": "airgate",
        "brief_description": "An easy to use platform to create a token-gated community and display information only visible for the fans",
        "long_description": "Airgate allows community creators to issue a token and use it to gate any information they want to only be accessible to the holders of the token, like a discord or a telegram invite link. Currently the state of the market for creators is, as Jack Conte, the founder of Patreon talked about recently in his talk: \"Ranking algorithms are killing creatives to maximize ad profits, gating allows creators to maximize fan engagement and creativity, for a lifetime, without constantly chasing for new views and rather focusing on the creation.\" Airgate allows, potentially, many millions of fans, discover and support the creator they resonate with, and get closer to them by joining a tight-knit community to engage with and know first about any new creations or ideas. This project was built on Nextjs which is my favorite stack because it utlises both frontend and backend development perfectly. For the blockchain development stack i mostly used Thirdweb for the erc1155 contract, hooks to get data, typescript to deploy transactions. I did also use postgresql with prisma ORM, which accelerated my comunication with the db. For the component library I chose shadcn and the design was built on Figma.\nAll of them bennefited the project in its own way, mostly it accelerated the development and made it possible to create such a platform from scratch in less than 24 hours, notably it did took 14 hours of strait hacking.",
        "how_its_made": "This project was built on Nextjs which is my favorite stack because it utlises both frontend and backend development perfectly. For the blockchain development stack i mostly used Thirdweb for the erc1155 contract, hooks to get data, typescript to deploy transactions. I did also use postgresql with prisma ORM, which accelerated my comunication with the db. For the component library I chose shadcn and the design was built on Figma.\nAll of them bennefited the project in its own way, mostly it accelerated the development and made it possible to create such a platform from scratch in less than 24 hours, notably it did took 14 hours of strait hacking.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/twm30/screenshots/afebs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/twm30/screenshots/u04vf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/twm30/screenshots/8c18o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/twm30/screenshots/15y6q/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jeefxM/ETHGlobalHackathon",
        "link": "https://ethglobal.com/showcase/airgate-twm30"
    },
    {
        "title": "DeReal",
        "brief_description": "Share spontaneous moments, triggered by smart contracts! DeReal brings transparency into the life of everyone through their cameras. (P.S You get rewards too!)",
        "long_description": "DeReal is a decentralized social media platform that aims to bring transparency into users, and people while also incentivizing their good motives. It utilizes the curiosity of general humankind, while also giving them a peep into their favorite influencers' actual day!\nThe way the app works is, once signed up you get notified of events. At any random moment in the day, an event would pop up prompting the user for a photo. After which they have approximately two minutes to click a picture and post it, aka, DeReal. The app aims to solve the problem of transparency, and acceptance through it. On general social media, people see highlights of other influencers and don't realize how small of a part of their life it represents. They need to understand that it's normal to be without makeup, or spend time getting ready - just Being Real is what is needed! A decentralized app, that brings the thrill of randomness into people's lives, while appraising their good wishes through incentives offered through brand promotions, and sponsors. It also enables gamification through streaks and NFTs. Starting with the basics I went with Plain React along with a simple Tailwind library to define the UI components.\nFor the wallet I went with Dynamic SDK, after going through their documentation and their near-perfect Account Abstraction SDK I was able to integrate the wallet successfully. A social media application has to be as smooth as possible, the users should even realize they're on a web3 app. The Dynamic-Biconomy combination helped to abstract out the details for interaction and we were even able to fund the user's activity! So the users get to enjoy DeReal for free!! This tech fit perfectly well into the product just as I had hoped for. The random time events are calculated on-chain to prevent any bias towards anyone, and this was made using Pyth's solidity SDK. During the deployment they have an initial random time event organized, which then gets updated every time a 'Capture' event is triggered. This was really important since on-chain randomness ensures that the numbers are not altered and produced in a Trusted environment. We cannot run cron jobs easily, and smart contracts cannot interact with the outer world without some help. To deploy a cron job that would check the smart contract, make sure the 'Capture' event is triggered by the contract, and then force the contract to create another truly random time with the help of Pyth's SDK. I used the deployed smart contracts address to ensure that ChainLink could keep polling it.",
        "how_its_made": "Starting with the basics I went with Plain React along with a simple Tailwind library to define the UI components.\nFor the wallet I went with Dynamic SDK, after going through their documentation and their near-perfect Account Abstraction SDK I was able to integrate the wallet successfully. A social media application has to be as smooth as possible, the users should even realize they're on a web3 app. The Dynamic-Biconomy combination helped to abstract out the details for interaction and we were even able to fund the user's activity! So the users get to enjoy DeReal for free!! This tech fit perfectly well into the product just as I had hoped for. The random time events are calculated on-chain to prevent any bias towards anyone, and this was made using Pyth's solidity SDK. During the deployment they have an initial random time event organized, which then gets updated every time a 'Capture' event is triggered. This was really important since on-chain randomness ensures that the numbers are not altered and produced in a Trusted environment. We cannot run cron jobs easily, and smart contracts cannot interact with the outer world without some help. To deploy a cron job that would check the smart contract, make sure the 'Capture' event is triggered by the contract, and then force the contract to create another truly random time with the help of Pyth's SDK. I used the deployed smart contracts address to ensure that ChainLink could keep polling it.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/b9tsg/screenshots/ctr4y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b9tsg/screenshots/yrav7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b9tsg/screenshots/b1qie/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b9tsg/screenshots/6zctm/default.jpg"
        ],
        "live_demo": "https://de-real.vercel.app/app",
        "source_code": "https://github.com/prakhar728/DeReal",
        "link": "https://ethglobal.com/showcase/dereal-b9tsg"
    },
    {
        "title": "Asset Guild",
        "brief_description": "Secure marketplace for selling digital assets without leaking them",
        "long_description": "AssetGuild allows you to upload any content which can be viewed only by people who have bought it. The content or their IPFS hashes are stored on-chain in special ways which guarantee someone can access it only after paying. We store 2 versions of a content: the preview, and the original. While the preview is openly stored, the original one is stored using Fully Homomorphic Encryption, on 2 levels and an asymmetric key cryptography to ensure only the seller and buyer can see it, not even the contract executing it. The project depends on Fully Homomorphic Encryption, which is a way to do computation on encrypted data. When the user uploads their content, the IPFS hash is what we want to protect, as you can access the content only with it, and without it you cannot. When our contract gets the hash, it encrypts it using a symmetric key which the uploader gives. On-chain, it stores this encrypted hash openly, and the symmetric key securely (in a manner it cannot be read from the chain state, on a chain which supports such a form of storage). Since the chain we are using only supports such storage for integers, there's some back and forth conversion between string and int. Before the user requests the original content, they generate an asymmetric key in their client, and they pass the public key in the function to get the original hash. Inside the smart contract, initially we verify (using internal structs/records) if the user (function caller) has paid for the content or not. If yes, we decrypt the encrypted hash using the privately stored symmetric key, and then we re-encrypt this hash using the public key of the function caller using FHE. The function returns the version of the original content hash which is encrypted using the public key which they themselves provided. So, they can decrypt it on their end. We also add the public key to a nullifier set so the same key cannot be passed in twice to fetch the content.",
        "how_its_made": "The project depends on Fully Homomorphic Encryption, which is a way to do computation on encrypted data. When the user uploads their content, the IPFS hash is what we want to protect, as you can access the content only with it, and without it you cannot. When our contract gets the hash, it encrypts it using a symmetric key which the uploader gives. On-chain, it stores this encrypted hash openly, and the symmetric key securely (in a manner it cannot be read from the chain state, on a chain which supports such a form of storage). Since the chain we are using only supports such storage for integers, there's some back and forth conversion between string and int. Before the user requests the original content, they generate an asymmetric key in their client, and they pass the public key in the function to get the original hash. Inside the smart contract, initially we verify (using internal structs/records) if the user (function caller) has paid for the content or not. If yes, we decrypt the encrypted hash using the privately stored symmetric key, and then we re-encrypt this hash using the public key of the function caller using FHE. The function returns the version of the original content hash which is encrypted using the public key which they themselves provided. So, they can decrypt it on their end. We also add the public key to a nullifier set so the same key cannot be passed in twice to fetch the content.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3f0h6/screenshots/d19ap/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3f0h6/screenshots/cbztf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3f0h6/screenshots/bh22g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3f0h6/screenshots/0osgt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3f0h6/screenshots/hyx09/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3f0h6/screenshots/4mrj2/default.jpg"
        ],
        "live_demo": "https://asset-guild.vercel.app",
        "source_code": "https://github.com/KryptoNights/asset-guild",
        "link": "https://ethglobal.com/showcase/asset-guild-3f0h6"
    },
    {
        "title": "datai",
        "brief_description": "Data marketplace with ZK proofs and staking that incentivizes users to share data",
        "long_description": "Datai is a smart contract built on Ethereum that allows users to securely submit data using zk-SNARK (zero-knowledge) proofs, while ensuring their identity remains private. The data is stored off-chain on IPFS, and the contract only stores the IPFS hash on-chain. Users are rewarded for submitting valid data, and they have the ability to revoke access to their data at any time. Additionally, the contract implements bot prevention mechanisms, such as a cooldown period between submissions and a minimum gas price requirement. To further enhance security, the contract includes a stake mechanism. Before submitting data, users are required to deposit a stake, which is locked for a specified period. This ensures that users have a financial commitment when interacting with the contract, discouraging bots and spam. After the cooldown period, users can withdraw their stake. The combination of zk-SNARKs, IPFS storage, bot prevention, and staking creates a privacy-preserving and secure system for submitting and managing data. This project is built using Solidity to create the smart contract that integrates zk-SNARKs for privacy-preserving proof verification. I used ZoKrates to generate the zk-SNARK circuits and corresponding verifier contracts, which allow users to prove ownership of data without revealing their identity. The data itself is stored off-chain on IPFS, with only the IPFS hash being recorded on-chain. This keeps the on-chain storage minimal and ensures the privacy of the actual data. For security, bot prevention techniques such as cooldown periods and minimum gas price requirements are implemented to limit spamming. The project also incorporates a stake mechanism where users must lock up a certain amount of Ether before submitting data, adding an additional layer of security. ZoKrates was key in generating zk-SNARK proofs, and IPFS helps keep the contract decentralized and cost-efficient by reducing on-chain storage. The integration of these technologies creates a seamless system that balances privacy, security, and decentralization. The combination of zk-SNARKs and IPFS allowed us to build a system where users can prove data ownership without ever revealing sensitive information.",
        "how_its_made": "This project is built using Solidity to create the smart contract that integrates zk-SNARKs for privacy-preserving proof verification. I used ZoKrates to generate the zk-SNARK circuits and corresponding verifier contracts, which allow users to prove ownership of data without revealing their identity. The data itself is stored off-chain on IPFS, with only the IPFS hash being recorded on-chain. This keeps the on-chain storage minimal and ensures the privacy of the actual data. For security, bot prevention techniques such as cooldown periods and minimum gas price requirements are implemented to limit spamming. The project also incorporates a stake mechanism where users must lock up a certain amount of Ether before submitting data, adding an additional layer of security. ZoKrates was key in generating zk-SNARK proofs, and IPFS helps keep the contract decentralized and cost-efficient by reducing on-chain storage. The integration of these technologies creates a seamless system that balances privacy, security, and decentralization. The combination of zk-SNARKs and IPFS allowed us to build a system where users can prove data ownership without ever revealing sensitive information.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2mo1s/screenshots/pphjv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2mo1s/screenshots/xuhce/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2mo1s/screenshots/66hmz/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/lovdeep7/datai",
        "link": "https://ethglobal.com/showcase/datai-2mo1s"
    },
    {
        "title": "WhoDis",
        "brief_description": "An AI tool for analyzing and describing the behavior of a wallet address in simple natural language",
        "long_description": "Our project focuses on retrieving and analyzing transaction history data of a NEAR blockchain address. This process begins by fetching the wallet's transaction history, capturing all incoming and outgoing activities, such as transfers, token swaps, and other on-chain events. Once this data is collected, we extract a list of all other wallet addresses involved in the transactions, and fetch metadata about each address, like whether it's a smart contract, if it belongs to a known Dapp, and if it does, then to which category does that project belong (DeFi, NFT, tooling...).\nAfter fetching all required data, we pass it to an LLM (in this case: gpt-4o) to systematically analyze the transactions and identify patterns, and behaviors that reflect the user's activities and interests. This enables us to generate a detailed description that accurately characterizes the user or wallet's primary activities, such as whether they are involved in frequent trading, liquidity providing, participating in decentralized finance (DeFi) platforms, or any other blockchain-based activity. By integrating both raw transaction data and cross-checked insights from relevant external sources, we create a more refined and precise understanding of how the wallet is being used.\nThe objective of this project is to provide users or stakeholders with a clear, data-backed representation of a wallet\u2019s transactional footprint. We built this project using a Python backend (Flask) and a HTML+JS+CSS web interface. When the user inputs a wallet address, a Python script retrieves transaction data via APIs, processes and analyzes it to map user activity based on transaction patterns. External data from the PikesPeak  API is integrated to enhance the analysis, and the backend serves the processed information to the frontend, which displays a behavior profile.",
        "how_its_made": "We built this project using a Python backend (Flask) and a HTML+JS+CSS web interface. When the user inputs a wallet address, a Python script retrieves transaction data via APIs, processes and analyzes it to map user activity based on transaction patterns. External data from the PikesPeak  API is integrated to enhance the analysis, and the backend serves the processed information to the frontend, which displays a behavior profile.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0d13u/screenshots/3c9s1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0d13u/screenshots/acjpg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0d13u/screenshots/s149a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0d13u/screenshots/e1saz/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MikePawel/ethglobal-singapore-24",
        "link": "https://ethglobal.com/showcase/whodis-0d13u"
    },
    {
        "title": "QIVE",
        "brief_description": "Introducing QIVE: Donate once, and make an impact forever! \ud83c\udf0d Using MACI's QF, Dynamic wallet, liquid staking, WorldID, and OApps, we turn your donation into yield-generating assets that continuously fund causes. It's fair, democratic, and creates lasting change.",
        "long_description": "The beauty of QIVE\u2019s tech stack lies in its long-term vision. By turning donations into perpetually active, yield-generating assets by leveraging LSTs and LRTs, QIVE is building a sustainable funding model that could eventually support universal basic income (UBI) for communities in need. As long as Ethereum runs and users remain staked, the platform becomes a self-sustaining engine for social good. It\u2019s a forward-thinking approach to charity, designed not just for short-term relief but for long-lasting, global impact. QIVE is a groundbreaking platform that leverages cutting-edge Web3 technologies to solve the inefficiencies of traditional charitable donations. At its core, QIVE uses Quadratic Funding, a method that democratically allocates funds based on community votes, ensuring that the most popular causes receive the most support. This system is powered by Minimal Anti-Collusion Infrastructure (MACI), which ensures that votes remain secure, private, and free from manipulation. The vote is encrypted using a coordinator's PK. By integrating WorldID\u2019s anti-Sybil technology with unique for max authentication that triggers the creation of Dynamic wallet using its Telegram auto-login (programmatic wallet generation), QIVE ensures that only verified human users participate, preventing bots, multiple accounts, or fraudulent entities from swaying the outcomes. The tech stack doesn\u2019t stop there. Donations on QIVE are transformed into yield-generating assets through liquid staking and restaking protocols like Lido. When a user donates, their funds are staked, and the yield generated from these assets is continuously used to fund causes in future rounds. This means that your initial contribution never depletes\u2014only the yields are donated. Through LayerZero's omni-chain messaging and lzNativeDrop, we enable seamless fast cross-chain transactions, ensuring that donations can be bridged from any blockchain to Ethereum\u2019s mainnet, creating a fluid and user-friendly experience for onboarding and participation. Not just from chains using ETH, but it also support seamlessly converting MATIC or BNB to ETH. We deployed the app server in Vercel and launch the app as a Telegram mini-app since it's currently the most convenient platform.",
        "how_its_made": "QIVE is a groundbreaking platform that leverages cutting-edge Web3 technologies to solve the inefficiencies of traditional charitable donations. At its core, QIVE uses Quadratic Funding, a method that democratically allocates funds based on community votes, ensuring that the most popular causes receive the most support. This system is powered by Minimal Anti-Collusion Infrastructure (MACI), which ensures that votes remain secure, private, and free from manipulation. The vote is encrypted using a coordinator's PK. By integrating WorldID\u2019s anti-Sybil technology with unique for max authentication that triggers the creation of Dynamic wallet using its Telegram auto-login (programmatic wallet generation), QIVE ensures that only verified human users participate, preventing bots, multiple accounts, or fraudulent entities from swaying the outcomes. The tech stack doesn\u2019t stop there. Donations on QIVE are transformed into yield-generating assets through liquid staking and restaking protocols like Lido. When a user donates, their funds are staked, and the yield generated from these assets is continuously used to fund causes in future rounds. This means that your initial contribution never depletes\u2014only the yields are donated. Through LayerZero's omni-chain messaging and lzNativeDrop, we enable seamless fast cross-chain transactions, ensuring that donations can be bridged from any blockchain to Ethereum\u2019s mainnet, creating a fluid and user-friendly experience for onboarding and participation. Not just from chains using ETH, but it also support seamlessly converting MATIC or BNB to ETH. We deployed the app server in Vercel and launch the app as a Telegram mini-app since it's currently the most convenient platform.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8nzq4/screenshots/fu6n6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8nzq4/screenshots/ta0vi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8nzq4/screenshots/0z6j6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8nzq4/screenshots/t3tyu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ParallaxNetwork/qv-perpetual-donation",
        "link": "https://ethglobal.com/showcase/qive-8nzq4"
    },
    {
        "title": "Fm",
        "brief_description": "Permissioned marketplace protocol allowing anyone to build their own ebay",
        "long_description": "This project allows people to create their own marketplace allowing buyers, sellers and couriers they choose to interact in the network. This builds a trustful marketplace useful for groups that don't have trust issues.\nWhen buyers purchase from sellers, money instantly goes to seller. Buyers also pay couriers to collect and deliver. In case of dispute, users resolve between themselves. This project uses mongodb for storage, cloud vms for compute and CryptoCurrency for payments.\nThe protocol is initialised on a server with a secret pass. This is used to sign and approve requests from users who want to join the network.\nDetails of their acceptance is saved in mongodb for future verification.\nDid not use smart contracts because it relies on trust between parties.",
        "how_its_made": "This project uses mongodb for storage, cloud vms for compute and CryptoCurrency for payments.\nThe protocol is initialised on a server with a secret pass. This is used to sign and approve requests from users who want to join the network.\nDetails of their acceptance is saved in mongodb for future verification.\nDid not use smart contracts because it relies on trust between parties.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/99b7b/screenshots/8916c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/99b7b/screenshots/6s8jx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/99b7b/screenshots/qyrk1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/femimarket/fm",
        "link": "https://ethglobal.com/showcase/fm-99b7b"
    },
    {
        "title": "Fm",
        "brief_description": "Permissioned marketplace protocol allowing anyone to build their own ebay",
        "long_description": "This project allows people to create their own marketplace allowing buyers, sellers and couriers they choose to interact in the network. This builds a trustful marketplace useful for groups that don't have trust issues.\nWhen buyers purchase from sellers, money instantly goes to seller. Buyers also pay couriers to collect and deliver. In case of dispute, users resolve between themselves. This project uses mongodb for storage, cloud vms for compute and CryptoCurrency for payments.\nThe protocol is initialised on a server with a secret pass. This is used to sign and approve requests from users who want to join the network.\nDetails of their acceptance is saved in mongodb for future verification.\nDid not use smart contracts because it relies on trust between parties.",
        "how_its_made": "This project uses mongodb for storage, cloud vms for compute and CryptoCurrency for payments.\nThe protocol is initialised on a server with a secret pass. This is used to sign and approve requests from users who want to join the network.\nDetails of their acceptance is saved in mongodb for future verification.\nDid not use smart contracts because it relies on trust between parties.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/99b7b/screenshots/8916c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/99b7b/screenshots/6s8jx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/99b7b/screenshots/qyrk1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/femimarket/fm",
        "link": "https://ethglobal.com/showcase/fm-99b7b"
    },
    {
        "title": "ShipHooks",
        "brief_description": "OpenZeppline for Uniswap Hooks, easily install and use any pre available Uniswap Hooks",
        "long_description": "ShipHooks is the ultimate toolkit for Uniswap developers, offering a robust and flexible framework for creating, testing, and deploying custom hooks. Built on the principles of OpenZeppelin, ShipHooks brings enterprise-grade security and efficiency to the world of decentralized finance. Solidity: The core of ShipHooks is written in Solidity, the primary language for Ethereum smart contract development. We've leveraged the latest features of Solidity 0.8.x to ensure type safety and gas optimization.\nHardhat & Foundry: Our development environment is powered by Hardhat and Foundry, providing a flexible and extensible toolkit for Ethereum development. Hardhat's testing framework and network simulation capabilities have been crucial in ensuring the reliability of our hooks.\nTypeScript: For our testing suite and deployment scripts, we've used TypeScript. This brings strong typing and improved developer experience to our JavaScript-based tools.\nUniswap v4 Core: Our hooks are designed to integrate seamlessly with Uniswap v4, leveraging the new hook system to extend and customize pool behavior.",
        "how_its_made": "Solidity: The core of ShipHooks is written in Solidity, the primary language for Ethereum smart contract development. We've leveraged the latest features of Solidity 0.8.x to ensure type safety and gas optimization.\nHardhat & Foundry: Our development environment is powered by Hardhat and Foundry, providing a flexible and extensible toolkit for Ethereum development. Hardhat's testing framework and network simulation capabilities have been crucial in ensuring the reliability of our hooks.\nTypeScript: For our testing suite and deployment scripts, we've used TypeScript. This brings strong typing and improved developer experience to our JavaScript-based tools.\nUniswap v4 Core: Our hooks are designed to integrate seamlessly with Uniswap v4, leveraging the new hook system to extend and customize pool behavior.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sh20b/screenshots/3wbq7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sh20b/screenshots/4r03j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sh20b/screenshots/8nchn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sh20b/screenshots/u9pae/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sh20b/screenshots/zhvxw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sh20b/screenshots/197b1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/bevatsal1122/ShipHooks",
        "link": "https://ethglobal.com/showcase/shiphooks-sh20b"
    },
    {
        "title": "TeleSplit",
        "brief_description": "Tele-Split is a Telegram bot that allows you to split bills with your friends. It is built with the Telegram Web App and uses the blockchain to enable transactions.",
        "long_description": "Telegram bots are becoming increasingly popular, now extending support to the TON ecosystem. However, there's a growing demand for EVM-based features in Telegram web apps and games. With a Telegram bot, we can easily build online stores, games, and enable seamless in-app payments using an EVM wallet. This functionality supports not just B2C models, but also C2C social interactions. An example of this is TeleSplit, inspired by Splitwise. When people travel together, they often need to track shared expenses, but Splitwise only records debts and doesn't facilitate payments. This creates difficulty in tracking finances and settling debts automatically. TeleSplit addresses these issues by: We use dynamic to let users connect their existing wallets in telegram bot. It also allows user to login through email, web2 OAuth. It creates seamless user experience to connect to users wallet.\nThe Telegram Web App SDK is used to perform telegram web app functions, such as cloud storage, biometric authentication, and user authentication. These functions can only be used in telegram web browser. With telegram native cloud storage and biometric authentication, it makes private key storage more easy, safe and more portable.\nThe payment of TeleSplit is inspired by USDC. USDC is one of the most uses stable coins. The situation that users travel with friends, they want to keep the value stable instead of floating prices. In this project we deployed an ERC20 called USDC and used it in the peer payment. It is more reasonable to pay with USDC instead of ETH or native coin. It will be easily to switch to real USDC/EURC when switching the contract address since the ABI is the same.\nWe explore the usage of AirDAO that we deployed a mock USDC on AirDAO testnet, and the wallets can switch to AirDAO seamlessly. We also use the following tools for building: next.js, vercel and mongodb\nNext.js and Vercel plays an important role in deploying the bot and the service. Mongodb is used to store the user groups, splits and so on.",
        "how_its_made": "We use dynamic to let users connect their existing wallets in telegram bot. It also allows user to login through email, web2 OAuth. It creates seamless user experience to connect to users wallet.\nThe Telegram Web App SDK is used to perform telegram web app functions, such as cloud storage, biometric authentication, and user authentication. These functions can only be used in telegram web browser. With telegram native cloud storage and biometric authentication, it makes private key storage more easy, safe and more portable.\nThe payment of TeleSplit is inspired by USDC. USDC is one of the most uses stable coins. The situation that users travel with friends, they want to keep the value stable instead of floating prices. In this project we deployed an ERC20 called USDC and used it in the peer payment. It is more reasonable to pay with USDC instead of ETH or native coin. It will be easily to switch to real USDC/EURC when switching the contract address since the ABI is the same.\nWe explore the usage of AirDAO that we deployed a mock USDC on AirDAO testnet, and the wallets can switch to AirDAO seamlessly. We also use the following tools for building: next.js, vercel and mongodb\nNext.js and Vercel plays an important role in deploying the bot and the service. Mongodb is used to store the user groups, splits and so on.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hoz0q/screenshots/0ujpo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hoz0q/screenshots/p3jad/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hoz0q/screenshots/00n7k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hoz0q/screenshots/gxbaf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hoz0q/screenshots/z5fhi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hoz0q/screenshots/2164v/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/chengggkk/tele-split",
        "link": "https://ethglobal.com/showcase/telesplit-hoz0q"
    },
    {
        "title": "Solara",
        "brief_description": "Solara enables under-collateralized microfinance by leveraging historical blockchain transactions and social reputation. It helps users access loans by assessing their trustworthiness through transaction history and social attestations from DAOs, bridging the gap in DeFi lending.",
        "long_description": "The problem of not having access to finance with onchain social reputation leads to no advantage of your transaction history and belonging to a community. Problem Statement\n\u2022\tLack of Undercollateralized Access to Microfinance On-chain: In DeFi, most loans require over-collateralization, limiting access to capital for individuals or small businesses who don\u2019t have sufficient assets to pledge.\n\u2022\tLack of enforcement by law: Traditional microfinance systems benefit from legal frameworks that enforce repayment, but on-chain lending lacks this type of enforcement. This creates higher risks for lenders, as there are limited mechanisms to ensure that borrowers repay their loans in the absence of formal legal consequences.\n\u2022\tTrust and Creditworthiness Gaps: On-chain microfinance is struggling to scale due to the difficulty in assessing risk without requiring excessive collateral. Solution Overview\n\u2022\tSocial Reputation: Allowing your social circle to vouch for your borrowing where their risk is of damaging their credit score.\n\u2022\tLeveraging Historical Transactions: Borrowers\u2019 transaction history on the blockchain can serve as a transparent credit score, improving trust and access to finance.\n\u2022\tIncorporating On-chain social Reputation: Social reputation from DAOs, attestations, and participation in decentralized communities(ETHGlobal) can be used to assess borrower trustworthiness. How It Works (Workflow)\n\u2022\tUser Onboarding: Individuals connect their wallets, and the system accesses their on-chain transaction history on Gnosis Chain & Ethereum.\n\u2022\tCredit Scoring Mechanism: The credit score is built using a combination of historical transaction data (frequency, volume) and previous microfinances.\n\u2022\tLoan Issuance: Lending pool smart contract allows borrowing for anyone who satisfies the required criteria.\n\u2022\tRepayment Tracking: Loan repayments are recorded on-chain, contributing to the borrower\u2019s ongoing reputation and creditworthiness. Use Case Example\n\u2022\tScenario: A builder who has participated in several online hackathon wants to participate at ETHBangkok & is short of few hundred dollars.\n\u2022\tOnboarding Process: The borrower connects their wallet, the smart contract evaluates their historical transactions, and the reputation at ETHGlobal.\n\u2022\tLoan Issuance: The borrower receives a microloan based on their on-chain trust score and reputation, and the loan is automatically tracked for repayment. We verify Proof of Humans using Worldcoin to avoid the same person using multiple wallets to take advantage of under-collateralized loans. We also use to check whether the signer is different. We use Sign Protocol to attest for borrowers that, they will pay back the loan. We use this attestation to release the borrowed amount from the Lending pool. Reown Notifications help in informing the signer about the pending request. The borrower also received notification for repaying the loan on time. We have deployed our contracts on Gnosis Chain.",
        "how_its_made": "We verify Proof of Humans using Worldcoin to avoid the same person using multiple wallets to take advantage of under-collateralized loans. We also use to check whether the signer is different. We use Sign Protocol to attest for borrowers that, they will pay back the loan. We use this attestation to release the borrowed amount from the Lending pool. Reown Notifications help in informing the signer about the pending request. The borrower also received notification for repaying the loan on time. We have deployed our contracts on Gnosis Chain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/c9scd/screenshots/j3mg9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c9scd/screenshots/8xkzr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c9scd/screenshots/2qqk2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c9scd/screenshots/rybo1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c9scd/screenshots/12a4v/default.jpg"
        ],
        "live_demo": "https://solara-alpha.vercel.app/",
        "source_code": "https://github.com/prajapati-yash/solara",
        "link": "https://ethglobal.com/showcase/solara-c9scd"
    },
    {
        "title": "Aether",
        "brief_description": "Low-code checkout solution using Worldcoin\u2019s World ID, Mina Protocol, and Circle\u2019s USDC for secure, privacy-first transactions",
        "long_description": "Aether is a low-code checkout solution integrating Worldcoin\u2019s World ID for user authentication, Mina Protocol for privacy-preserving transaction verification, and Circle\u2019s USDC for payment processing. The solution separates concerns by using Mina for transaction verification while handling payments with Circle\u2019s API on chains that support USDC, like Ethereum. This approach ensures secure, private, and cross-chain compatible payments. Key outcomes include enhanced security, privacy, and seamless cross-chain transactions, creating a robust and scalable checkout experience. We built Aether to revolutionize checkout with speed, security, and privacy. Here\u2019s how: Technologies Used: Integration: Hacky Approach:\nTo meet the hackathon deadline, we used pre-built modules and a modular architecture, allowing us to move fast without breaking things. Partnering with Worldcoin, Mina, and Circle saved time and ensured top-notch security and scalability.",
        "how_its_made": "We built Aether to revolutionize checkout with speed, security, and privacy. Here\u2019s how: Technologies Used: Integration: Hacky Approach:\nTo meet the hackathon deadline, we used pre-built modules and a modular architecture, allowing us to move fast without breaking things. Partnering with Worldcoin, Mina, and Circle saved time and ensured top-notch security and scalability.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sxp3o/screenshots/8qtkn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sxp3o/screenshots/qdtoa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sxp3o/screenshots/11pui/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sxp3o/screenshots/7cxtj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/vivekpal1/aether",
        "link": "https://ethglobal.com/showcase/aether-sxp3o"
    },
    {
        "title": "KaRoot",
        "brief_description": "Radix trie optimized for efficient order matching for onchain orderbooks",
        "long_description": "On-chain orderbooks are not widely used as most matching algorithms have linear matching, which makes it almost impossible to execute onchain. For this reason we implement radix trie in cairo, that can be used to efficiently implement on-chain matching with logarithmic complexity. Binary radix trie is constructed separately for bid and ask orders. Key is constructed as a combination of price and order number, which helps to maintain price-time priority. Each leaf of the trie is an order, each node contains sum_value and sum_coins of its children. In order to acknowledge actual distribution of orders, we additionally optimize rightmost-branch of the trie, so that it keeps only sums of left children. This allows us to skip going up across the rightmost branch of the trie each time we change an order on the rightmost branch.",
        "how_its_made": "Binary radix trie is constructed separately for bid and ask orders. Key is constructed as a combination of price and order number, which helps to maintain price-time priority. Each leaf of the trie is an order, each node contains sum_value and sum_coins of its children. In order to acknowledge actual distribution of orders, we additionally optimize rightmost-branch of the trie, so that it keeps only sums of left children. This allows us to skip going up across the rightmost branch of the trie each time we change an order on the rightmost branch.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/cjgdy/screenshots/md1vd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cjgdy/screenshots/m7rmt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cjgdy/screenshots/ogtd1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ruquant/karoot-global",
        "link": "https://ethglobal.com/showcase/karoot-cjgdy"
    },
    {
        "title": "Nearer",
        "brief_description": "An AI-powered platform that simplifies NEAR Chain Signatures. Users can manage multiple EVM wallets, store derived addresses, send funds, stake and move assets across chains with Onchain AI and an ML model for seamless DeFi management.",
        "long_description": "NEAR Protocol introduced Chain Signatures in March 2024 during BUIDL Asia in Seoul, a feature that allows NEAR accounts to control multiple addresses across various blockchains using a decentralized Multi-Party Computation (MPC) network. This enables users to sign transactions on different blockchains with one NEAR account, simplifying cross-chain interactions. However, despite the innovation, there isn\u2019t a widely adopted tool or wallet that fully leverages this capability. Most available wallets focus on managing a single EVM address or work only with Ethereum. There is no existing solution that provides users (especially non-technical ones) with a seamless way to create, manage, and interact with multiple EVM addresses from a single NEAR account, while performing typical blockchain activities like sending funds or staking. This results in: Project Overview:\nOur project solves these problems by creating an AI-powered platform that leverages NEAR Chain Signatures to manage multiple EVM addresses with ease. Users can perform standard blockchain tasks such as creating derived wallet addresses, sending transactions, staking, and asset management\u2014all driven by a natural language interface powered by AI (like ChatGPT). The platform provides an intuitive UI/UX that caters to both Web2 and Web3 users, making it easier for anyone to interact with blockchain technologies. Additionally, the platform integrates a machine learning model to automate and optimize staking decisions. By analyzing real-time and historical data from the Pyth Network, the AI identifies the best staking opportunities and automatically moves assets to the chain with the highest APY. To ensure the system remains secure and abuse-free, World ID is integrated to verify that each user is a unique individual. How it is made:\nNEAR Protocol: NEAR\u2019s Chain Signatures technology allows users to manage multiple EVM wallets from a single NEAR account. This simplifies the complexity of handling multiple blockchain addresses and enables cross-chain transactions efficiently. The platform allows seamless cross-chain operations, such as transferring funds and staking, by leveraging NEAR\u2019s Chain Signatures and interactions with multiple EVM chains. This provides users with a smooth experience while moving assets across blockchains. Phala Network's Red Pill Contract: The Red Pill contract is integrated with OpenAI\u2019s language models, allowing users to interact with the platform using natural language. Commands like \"list wallets\" or \"send funds\" are translated into actionable blockchain transactions through the AI interface. The AI and machine learning models are hosted on-chain using Phala\u2019s network, ensuring decentralized, secure, and transparent processes. Pyth Network: Real-time and historical price data from Pyth Network are fed into a Long Short-Term Memory (LSTM) machine learning model, which predicts the best staking opportunities across various EVM chains, optimizing users\u2019 asset management. World ID Integration: To prevent system abuse, World ID is integrated for user verification. This ensures that each user is a verified individual, eliminating the risk of bots or malicious actors exploiting the platform. How these benefit our project:\nThe use of NEAR Protocol's Chain Signatures with the MPC (Multi-Party Computation) model was pivotal in making the entire platform feasible, setting it apart from other solutions. The MPC model in NEAR allows for seamless management of multiple EVM addresses under a single account, a feature that drastically simplifies blockchain interactions for users. Unlike traditional wallets or decentralized applications (dApps) that require managing separate private keys or seed phrases for each address, NEAR's Chain Signatures and MPC network enable a user to control numerous EVM accounts effortlessly, using a single NEAR account and signature process. This capability allowed us to introduce features like derived wallet management, where users can store and manage multiple wallet addresses across chains like Ethereum, Polygon, and Optimism with ease. Each derived wallet is managed through NEAR\u2019s MPC model, making it possible to sign transactions on different chains while maintaining the same account structure. Other available blockchain solutions would require manual handling of multiple wallets, private keys, and bridges, creating complexity for users. NEAR\u2019s MPC model eliminates this complexity by allowing users to store and manage EVM addresses without worrying about the backend technicalities, enhancing the overall user experience. In addition, Phala Network\u2019s Red Pill contract proved to be an invaluable asset to the project. Phala Network is relatively low-cost and extremely easy to integrate. The Red Pill contract, running AI models on-chain, offers a seamless interaction with OpenAI, which enabled us to deploy the natural language processing (NLP) interface that drives the platform's user interactions. Without Phala\u2019s flexible and cost-effective infrastructure, running an AI-powered DeFi platform with real-time, on-chain AI processing would have been either prohibitively expensive or technically unfeasible. This allowed us to build not only a scalable platform but also one that can easily be maintained and expanded. Phala's integration made it possible to perform tasks such as training and running an LSTM model for predicting staking opportunities directly on-chain. The platform\u2019s affordability and ease of use made it highly practical to deploy machine learning functionalities that normally would require off-chain computation, ensuring that our solution remains decentralized and secure. These partner technologies provided a foundation that helped us simplify complex blockchain processes, making the platform both user-friendly and technically advanced. Notable Technical Challenges and Solutions:\nDerived Wallet Management: A particularly hacky part of the project is the management of derived wallet addresses. Although all addresses initially exist, storing and interacting with them required a novel approach. We used a mechanism where a small test fund is sent to an address derived from a NEAR Chain Signature account, ensuring the address is active. This is achieved by iterating through the wallet\u2019s derivation paths until an unused one is found. The system identifies this path and stores the address, allowing users to manage multiple wallets effortlessly. This method allows seamless wallet storage without manual intervention. Cross-Chain Asset Exchange without Bridges or Exchanges: Another notable feature is the ability to bridge or swap assets without relying on traditional bridges, decentralized exchanges (DEXs), or centralized exchanges (CEXs). This is done by leveraging NEAR\u2019s MPC (Multi-Party Computation) model. Two users can exchange assets by sending them to each other\u2019s derived addresses, after which the MPC model grants them access to these new addresses. This eliminates the need for a third-party service to swap assets, making the process both decentralized and highly efficient. On-Chain LSTM Model: A unique achievement in this project was the creation of an LSTM model entirely on-chain using Phala\u2019s Red Pill agent. Typically, LSTM models rely on TensorFlow, which is not natively available in TypeScript. To overcome this limitation, we manually coded the LSTM model using mathematical formulas and logic entirely in TypeScript. This allowed us to run the model on-chain, giving users real-time AI-driven insights into the best staking opportunities without needing off-chain computational resources.",
        "how_its_made": "How it is made:\nNEAR Protocol: NEAR\u2019s Chain Signatures technology allows users to manage multiple EVM wallets from a single NEAR account. This simplifies the complexity of handling multiple blockchain addresses and enables cross-chain transactions efficiently. The platform allows seamless cross-chain operations, such as transferring funds and staking, by leveraging NEAR\u2019s Chain Signatures and interactions with multiple EVM chains. This provides users with a smooth experience while moving assets across blockchains. Phala Network's Red Pill Contract: The Red Pill contract is integrated with OpenAI\u2019s language models, allowing users to interact with the platform using natural language. Commands like \"list wallets\" or \"send funds\" are translated into actionable blockchain transactions through the AI interface. The AI and machine learning models are hosted on-chain using Phala\u2019s network, ensuring decentralized, secure, and transparent processes. Pyth Network: Real-time and historical price data from Pyth Network are fed into a Long Short-Term Memory (LSTM) machine learning model, which predicts the best staking opportunities across various EVM chains, optimizing users\u2019 asset management. World ID Integration: To prevent system abuse, World ID is integrated for user verification. This ensures that each user is a verified individual, eliminating the risk of bots or malicious actors exploiting the platform. How these benefit our project:\nThe use of NEAR Protocol's Chain Signatures with the MPC (Multi-Party Computation) model was pivotal in making the entire platform feasible, setting it apart from other solutions. The MPC model in NEAR allows for seamless management of multiple EVM addresses under a single account, a feature that drastically simplifies blockchain interactions for users. Unlike traditional wallets or decentralized applications (dApps) that require managing separate private keys or seed phrases for each address, NEAR's Chain Signatures and MPC network enable a user to control numerous EVM accounts effortlessly, using a single NEAR account and signature process. This capability allowed us to introduce features like derived wallet management, where users can store and manage multiple wallet addresses across chains like Ethereum, Polygon, and Optimism with ease. Each derived wallet is managed through NEAR\u2019s MPC model, making it possible to sign transactions on different chains while maintaining the same account structure. Other available blockchain solutions would require manual handling of multiple wallets, private keys, and bridges, creating complexity for users. NEAR\u2019s MPC model eliminates this complexity by allowing users to store and manage EVM addresses without worrying about the backend technicalities, enhancing the overall user experience. In addition, Phala Network\u2019s Red Pill contract proved to be an invaluable asset to the project. Phala Network is relatively low-cost and extremely easy to integrate. The Red Pill contract, running AI models on-chain, offers a seamless interaction with OpenAI, which enabled us to deploy the natural language processing (NLP) interface that drives the platform's user interactions. Without Phala\u2019s flexible and cost-effective infrastructure, running an AI-powered DeFi platform with real-time, on-chain AI processing would have been either prohibitively expensive or technically unfeasible. This allowed us to build not only a scalable platform but also one that can easily be maintained and expanded. Phala's integration made it possible to perform tasks such as training and running an LSTM model for predicting staking opportunities directly on-chain. The platform\u2019s affordability and ease of use made it highly practical to deploy machine learning functionalities that normally would require off-chain computation, ensuring that our solution remains decentralized and secure. These partner technologies provided a foundation that helped us simplify complex blockchain processes, making the platform both user-friendly and technically advanced. Notable Technical Challenges and Solutions:\nDerived Wallet Management: A particularly hacky part of the project is the management of derived wallet addresses. Although all addresses initially exist, storing and interacting with them required a novel approach. We used a mechanism where a small test fund is sent to an address derived from a NEAR Chain Signature account, ensuring the address is active. This is achieved by iterating through the wallet\u2019s derivation paths until an unused one is found. The system identifies this path and stores the address, allowing users to manage multiple wallets effortlessly. This method allows seamless wallet storage without manual intervention. Cross-Chain Asset Exchange without Bridges or Exchanges: Another notable feature is the ability to bridge or swap assets without relying on traditional bridges, decentralized exchanges (DEXs), or centralized exchanges (CEXs). This is done by leveraging NEAR\u2019s MPC (Multi-Party Computation) model. Two users can exchange assets by sending them to each other\u2019s derived addresses, after which the MPC model grants them access to these new addresses. This eliminates the need for a third-party service to swap assets, making the process both decentralized and highly efficient. On-Chain LSTM Model: A unique achievement in this project was the creation of an LSTM model entirely on-chain using Phala\u2019s Red Pill agent. Typically, LSTM models rely on TensorFlow, which is not natively available in TypeScript. To overcome this limitation, we manually coded the LSTM model using mathematical formulas and logic entirely in TypeScript. This allowed us to run the model on-chain, giving users real-time AI-driven insights into the best staking opportunities without needing off-chain computational resources.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bwbft/screenshots/m6ttx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bwbft/screenshots/tocgz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bwbft/screenshots/y1w32/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bwbft/screenshots/kn18x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bwbft/screenshots/pyw6s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bwbft/screenshots/wmwps/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/derek2403/eth",
        "link": "https://ethglobal.com/showcase/nearer-bwbft"
    },
    {
        "title": "Encrypted_Compute",
        "brief_description": "User's input is encrypted using FHE which he wants to run on an ML model. The initial layers of model are taken, and we perform operations of those initial layers on the encrypted data. Then the output is decrypted and sent to the model for further computation.",
        "long_description": "Encrypted_Compute is an innovative platform designed to enable secure computations on private data using advanced computational models, such as machine learning models and large language models (LLMs), without exposing the data to model providers or any third parties. This solution is particularly crucial in fields where data privacy is paramount, such as healthcare, finance, and personal data analytics. Problem Statement Users often possess sensitive or private data that they cannot share publicly due to privacy concerns, legal restrictions, or personal preferences. Despite this, they may wish to leverage advanced computational models to gain insights, predictions, or analyses from their data. For instance, consider a patient suffering from a severe oral disease that results in distressing images. The patient wants to obtain a diagnosis or prognosis using AI models but is reluctant to share these images publicly or with model providers due to privacy concerns. Solution Overview Encrypted_Compute addresses this challenge by providing a secure platform where users can: Encrypt their private data using Fully Homomorphic Encryption (FHE).\nSelect and utilize computational models from various model creators.\nSpecify initial layers of the model to perform computations on encrypted data.\nEnsure data remains confidential throughout the computation process.\nReceive results without ever exposing their raw data.\nDetailed Explanation Data Encryption with Fully Homomorphic Encryption (FHE) What is FHE? Fully Homomorphic Encryption is an advanced cryptographic technique that allows computations to be performed directly on encrypted data without needing to decrypt it first.\nThe result of these computations is also in encrypted form and, when decrypted, matches the outcome of operations performed on the plaintext data.\nUser Data Encryption Users upload their sensitive data (e.g., medical images) to the Encrypted_Compute platform.\nThe platform encrypts the data using FHE algorithms, ensuring that the data remains secure and inaccessible to unauthorized parties, including the platform itself.\nModel Selection and Layer Specification Model Repository The platform hosts a repository of computational models uploaded by various model creators.\nThese models can range from machine learning algorithms to complex neural networks and LLMs.\nUser Choice and Customization Users browse and select a model that suits their needs.\nDue to the computational intensity of performing operations on encrypted data, users can specify which initial layers of the model they want to run on their encrypted data.\nThis partitioning is essential because processing the entire model on encrypted data is currently impractical due to computational limitations.\nSecure Computation in a Trusted Execution Environment (TEE) What is a TEE? A Trusted Execution Environment is a secure area within a processor that ensures code and data loaded inside are protected with respect to confidentiality and integrity.\nTEEs prevent unauthorized access and tampering while code is executing within them.\nUtilizing Phala Network The Encrypted_Compute platform leverages the Phala Network, which provides decentralized TEE services.\nPhala Network allows computations to be performed in a secure and private manner, ensuring that the encrypted data remains confidential.\nComputational Constraints Phala Network's TEE services have a time limit, typically around 1 minute.\nThis limitation necessitates efficient computation and is another reason for processing only the initial layers of the model within the TEE.\nIntermediate Output Decryption and Obfuscation Decrypting the Output After the computation within the TEE, the resulting output (still encrypted) is decrypted by the platform.\nThis output is an intermediate representation of the data after being processed by the initial model layers.\nObfuscated Data The decrypted output is obfuscated, meaning it is transformed in a way that retains essential features needed for further computation but does not reveal the original sensitive data.\nObfuscation ensures that even if the data is intercepted or accessed by unauthorized parties, the original information cannot be reconstructed.\nFinal Computation by Model Creator Transferring Obfuscated Data The obfuscated intermediate data is securely transferred to the model creator.\nThe model creator processes this data through the remaining layers of their model.\nData Privacy Assurance The model creator does not have access to the user's raw data at any point.\nThe obfuscated data is designed to prevent reverse-engineering or reconstruction of the original data.\nResult Delivery to User Receiving the Final Output The model creator sends the final computation results back to the Encrypted_Compute platform.\nThe platform then delivers these results to the user.\nConfidentiality Maintained Throughout the entire process, the user's data remains confidential.\nThe user obtains the desired output without compromising their privacy.\nAdvantages of Encrypted_Compute Enhanced Data Privacy Users can utilize advanced computational models without exposing their sensitive data.\nThe combination of FHE and TEE technologies ensures end-to-end data confidentiality.\nFlexibility and Control Users can choose which parts of the model to run on their data.\nThis allows for customization based on computational constraints and privacy preferences.\nSecure Collaboration Model creators can offer their services without risking exposure to sensitive data.\nEncourages more widespread adoption of AI and ML models in sensitive fields.\nScalability The platform can be expanded to include more models and support a larger user base.\nModular design allows for integration with various computational models and services.\nTechnical Components Explained Fully Homomorphic Encryption (FHE) Functionality Allows for arbitrary computation on encrypted data.\nEnsures that the data remains encrypted throughout the computation process.\nChallenges Computationally intensive and slower than operations on plaintext data.\nRequires optimization and efficient algorithms to be practical for real-world applications.\nTrusted Execution Environment (TEE) Functionality Provides a secure enclave for computations.\nProtects data and code from external access and tampering.\nPhala Network Integration Offers decentralized TEE services suitable for the platform's needs.\nTime-limited computations necessitate efficient processing strategies.\nModel Partitioning Why Partition Models? Running entire models on encrypted data is impractical due to computational overhead.\nPartitioning allows initial layers (e.g., feature extraction layers) to run on encrypted data, reducing computational demands.\nBenefits Balances between data privacy and computational feasibility.\nEnables the processing of complex models within the constraints of FHE and TEE.\nObfuscated Intermediate Data Purpose Acts as a bridge between the encrypted computation and the model creator's processing.\nContains necessary features extracted from the data without revealing sensitive information.\nSecurity Measures Designed to prevent reverse-engineering.\nEnsures that even if accessed, the original data cannot be reconstructed.\nUse Case Scenario Healthcare Application\nPatient Uploads Data\nA patient uploads encrypted medical images to the platform.\nModel Selection\nThe patient selects a diagnostic AI model and specifies the initial layers for encrypted computation.\nSecure Computation\nThe encrypted images are processed within the TEE, extracting essential features.\nData Obfuscation\nThe intermediate output is decrypted and obfuscated.\nModel Creator Processing\nThe obfuscated data is sent to the model creator, who processes it through the remaining model layers.\nReceiving Results\nThe patient receives a diagnosis or analysis without ever exposing their raw images.\nChallenges and Considerations Computational Overhead FHE is resource-intensive, leading to longer computation times.\nRequires powerful hardware and optimization techniques.\nTime Constraints The 1-minute limit within the TEE necessitates efficient algorithms and model partitioning.\nComplex models may need further segmentation or approximation methods.\nModel Compatibility Not all models are suitable for partitioning or encrypted computation.\nCollaboration with model creators is essential to adapt models for the platform.\nSecurity Assurance Continuous updates and audits are necessary to maintain security.\nPotential vulnerabilities in encryption or TEE implementation must be addressed promptly.\nFuture Enhancements Optimizing FHE Algorithms Research into more efficient FHE schemes could reduce computational overhead.\nImplementation of hybrid encryption methods to balance performance and security.\nExtending TEE Capabilities Exploring partnerships with other TEE providers to extend computation time limits.\nDeveloping proprietary TEE solutions tailored to the platform's needs.\nModel Repository Expansion Encouraging more model creators to join the platform.\nProviding tools and guidelines for model adaptation and partitioning.\nUser Interface Improvements Enhancing the platform's usability with intuitive design.\nProviding detailed documentation and support for users and model creators.\nConclusion Encrypted_Compute offers a groundbreaking solution to the challenge of performing computations on sensitive data without compromising privacy. By integrating advanced cryptographic techniques like FHE with secure computation environments like TEE, the platform enables users to harness the power of advanced models while maintaining full control over their data. This approach not only benefits individual users but also has the potential to transform industries where data privacy is a critical concern. Key Takeaways Data Privacy and Security Users retain control over their data throughout the entire process.\nAdvanced encryption and secure computation environments safeguard against unauthorized access.\nEmpowering Users Provides access to cutting-edge computational models without sacrificing privacy.\nEnables users to make informed decisions based on advanced analytics.\nInnovative Collaboration Bridges the gap between data owners and model creators.\nFosters a secure ecosystem for sharing and processing sensitive information. Detailed Explanation Data Encryption with Fully Homomorphic Encryption (FHE) What is FHE? Fully Homomorphic Encryption is an advanced cryptographic technique that allows computations to be performed directly on encrypted data without needing to decrypt it first.\nThe result of these computations is also in encrypted form and, when decrypted, matches the outcome of operations performed on the plaintext data.\nUser Data Encryption Users upload their sensitive data (e.g., medical images) to the Encrypted_Compute platform.\nThe platform encrypts the data using FHE algorithms, ensuring that the data remains secure and inaccessible to unauthorized parties, including the platform itself.\nModel Selection and Layer Specification Model Repository The platform hosts a repository of computational models uploaded by various model creators.\nThese models can range from machine learning algorithms to complex neural networks and LLMs.\nUser Choice and Customization Users browse and select a model that suits their needs.\nDue to the computational intensity of performing operations on encrypted data, users can specify which initial layers of the model they want to run on their encrypted data.\nThis partitioning is essential because processing the entire model on encrypted data is currently impractical due to computational limitations.\nSecure Computation in a Trusted Execution Environment (TEE) What is a TEE? A Trusted Execution Environment is a secure area within a processor that ensures code and data loaded inside are protected with respect to confidentiality and integrity.\nTEEs prevent unauthorized access and tampering while code is executing within them.\nUtilizing Phala Network The Encrypted_Compute platform leverages the Phala Network, which provides decentralized TEE services.\nPhala Network allows computations to be performed in a secure and private manner, ensuring that the encrypted data remains confidential.\nComputational Constraints Phala Network's TEE services have a time limit, typically around 1 minute.\nThis limitation necessitates efficient computation and is another reason for processing only the initial layers of the model within the TEE.\nIntermediate Output Decryption and Obfuscation Decrypting the Output After the computation within the TEE, the resulting output (still encrypted) is decrypted by the platform.\nThis output is an intermediate representation of the data after being processed by the initial model layers.\nObfuscated Data The decrypted output is obfuscated, meaning it is transformed in a way that retains essential features needed for further computation but does not reveal the original sensitive data.\nObfuscation ensures that even if the data is intercepted or accessed by unauthorized parties, the original information cannot be reconstructed.\nFinal Computation by Model Creator Transferring Obfuscated Data The obfuscated intermediate data is securely transferred to the model creator.\nThe model creator processes this data through the remaining layers of their model.\nData Privacy Assurance The model creator does not have access to the user's raw data at any point.\nThe obfuscated data is designed to prevent reverse-engineering or reconstruction of the original data.\nResult Delivery to User Receiving the Final Output The model creator sends the final computation results back to the Encrypted_Compute platform.\nThe platform then delivers these results to the user.\nConfidentiality Maintained Throughout the entire process, the user's data remains confidential.\nThe user obtains the desired output without compromising their privacy.\nAdvantages of Encrypted_Compute Enhanced Data Privacy Users can utilize advanced computational models without exposing their sensitive data.\nThe combination of FHE and TEE technologies ensures end-to-end data confidentiality.\nFlexibility and Control Users can choose which parts of the model to run on their data.\nThis allows for customization based on computational constraints and privacy preferences.\nSecure Collaboration Model creators can offer their services without risking exposure to sensitive data.\nEncourages more widespread adoption of AI and ML models in sensitive fields.\nScalability The platform can be expanded to include more models and support a larger user base.\nModular design allows for integration with various computational models and services.",
        "how_its_made": "Detailed Explanation Data Encryption with Fully Homomorphic Encryption (FHE) What is FHE? Fully Homomorphic Encryption is an advanced cryptographic technique that allows computations to be performed directly on encrypted data without needing to decrypt it first.\nThe result of these computations is also in encrypted form and, when decrypted, matches the outcome of operations performed on the plaintext data.\nUser Data Encryption Users upload their sensitive data (e.g., medical images) to the Encrypted_Compute platform.\nThe platform encrypts the data using FHE algorithms, ensuring that the data remains secure and inaccessible to unauthorized parties, including the platform itself.\nModel Selection and Layer Specification Model Repository The platform hosts a repository of computational models uploaded by various model creators.\nThese models can range from machine learning algorithms to complex neural networks and LLMs.\nUser Choice and Customization Users browse and select a model that suits their needs.\nDue to the computational intensity of performing operations on encrypted data, users can specify which initial layers of the model they want to run on their encrypted data.\nThis partitioning is essential because processing the entire model on encrypted data is currently impractical due to computational limitations.\nSecure Computation in a Trusted Execution Environment (TEE) What is a TEE? A Trusted Execution Environment is a secure area within a processor that ensures code and data loaded inside are protected with respect to confidentiality and integrity.\nTEEs prevent unauthorized access and tampering while code is executing within them.\nUtilizing Phala Network The Encrypted_Compute platform leverages the Phala Network, which provides decentralized TEE services.\nPhala Network allows computations to be performed in a secure and private manner, ensuring that the encrypted data remains confidential.\nComputational Constraints Phala Network's TEE services have a time limit, typically around 1 minute.\nThis limitation necessitates efficient computation and is another reason for processing only the initial layers of the model within the TEE.\nIntermediate Output Decryption and Obfuscation Decrypting the Output After the computation within the TEE, the resulting output (still encrypted) is decrypted by the platform.\nThis output is an intermediate representation of the data after being processed by the initial model layers.\nObfuscated Data The decrypted output is obfuscated, meaning it is transformed in a way that retains essential features needed for further computation but does not reveal the original sensitive data.\nObfuscation ensures that even if the data is intercepted or accessed by unauthorized parties, the original information cannot be reconstructed.\nFinal Computation by Model Creator Transferring Obfuscated Data The obfuscated intermediate data is securely transferred to the model creator.\nThe model creator processes this data through the remaining layers of their model.\nData Privacy Assurance The model creator does not have access to the user's raw data at any point.\nThe obfuscated data is designed to prevent reverse-engineering or reconstruction of the original data.\nResult Delivery to User Receiving the Final Output The model creator sends the final computation results back to the Encrypted_Compute platform.\nThe platform then delivers these results to the user.\nConfidentiality Maintained Throughout the entire process, the user's data remains confidential.\nThe user obtains the desired output without compromising their privacy.\nAdvantages of Encrypted_Compute Enhanced Data Privacy Users can utilize advanced computational models without exposing their sensitive data.\nThe combination of FHE and TEE technologies ensures end-to-end data confidentiality.\nFlexibility and Control Users can choose which parts of the model to run on their data.\nThis allows for customization based on computational constraints and privacy preferences.\nSecure Collaboration Model creators can offer their services without risking exposure to sensitive data.\nEncourages more widespread adoption of AI and ML models in sensitive fields.\nScalability The platform can be expanded to include more models and support a larger user base.\nModular design allows for integration with various computational models and services.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5tatf/screenshots/scoz0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5tatf/screenshots/vjyq2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5tatf/screenshots/y0db4/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/surfer05/eth_sg",
        "link": "https://ethglobal.com/showcase/encrypted-compute-5tatf"
    },
    {
        "title": "DualSign",
        "brief_description": "DualSign - a secure/verifiable layer for transferring tokens omnichain.",
        "long_description": "\ud83d\udca1 Ever felt paranoid before transferring tokens, double-checking every character in the address? We've all been there, knowing there's no undo button in blockchain. That\u2019s why we built DualSign \ud83d\udee1\ufe0f\u2014a payment dApp that adds an extra layer of security using EIP-712 signatures. Both the sender and recipient must sign off before tokens move, ensuring the funds go exactly where they\u2019re meant to. And guess what? Gas fees can be paid by anyone! \ud83d\udcb0 Plus Plus! DualSign enables cross-chain transfers, so you can move funds effortlessly across different blockchains. DualSign is a payment protocol designed to add an extra layer of security to token transfers by leveraging EIP-712 signatures. When a sender initiates a transaction, they sign the transfer request, which is then attested by the recipient using their own signature. The recipient\u2019s attestation confirms the sender's signature, creating a dual-signature process that ensures both parties validate the transaction. This multi-step mechanism prevents common issues like sending tokens to the wrong address, a critical problem in blockchain transactions. Once both signatures are in place, the transaction can be executed by anyone\u2014including third parties\u2014with gas sponsorship, allowing gas fees to be covered by someone other than the sender or receiver. This makes gasless, sponsored transactions possible and easy. DualSign also supports cross-chain transfers via CCIP (Cross-Chain Interoperability Protocol), allowing tokens to be transferred seamlessly across different blockchains. By adding this extra security and flexibility, DualSign helps users avoid costly mistakes, validates Ethereum addresses, and simplifies token transfers on and across blockchains. EIP-712 Signatures & Attestations:\ndualSign uses EIP-712 signatures for secure transactions. The sender signs the transfer, which is attested and linked to the recipient\u2019s address. The recipient then attests their acceptance using their own signature, validating the transfer. Sign Protocol Integration:\nThe protocol records and manages attestations securely. Both sender and recipient sign, ensuring mutual agreement on the transfer. On-Chain Signature Verification:\nWhen the transaction is executed, both signatures are verified on-chain before the transfer occurs. Chainlink CCIP for Cross-Chain Transfers:\ndualSign integrates Chainlink's CCIP to enable token transfers across multiple blockchains, allowing users to send tokens to any chain.\nGraph Protocol for Indexing: The Graph indexing service fetches attestation details in real-time, offering transparent access to transaction data. CCTP by Circle for USDC Transfers:\nCircle\u2019s Cross-Chain Transfer Protocol (CCTP) is used for seamless USDC transfers across chains in the demo.",
        "how_its_made": "EIP-712 Signatures & Attestations:\ndualSign uses EIP-712 signatures for secure transactions. The sender signs the transfer, which is attested and linked to the recipient\u2019s address. The recipient then attests their acceptance using their own signature, validating the transfer. Sign Protocol Integration:\nThe protocol records and manages attestations securely. Both sender and recipient sign, ensuring mutual agreement on the transfer. On-Chain Signature Verification:\nWhen the transaction is executed, both signatures are verified on-chain before the transfer occurs. Chainlink CCIP for Cross-Chain Transfers:\ndualSign integrates Chainlink's CCIP to enable token transfers across multiple blockchains, allowing users to send tokens to any chain.\nGraph Protocol for Indexing: The Graph indexing service fetches attestation details in real-time, offering transparent access to transaction data. CCTP by Circle for USDC Transfers:\nCircle\u2019s Cross-Chain Transfer Protocol (CCTP) is used for seamless USDC transfers across chains in the demo.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/q0exs/screenshots/fvegq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q0exs/screenshots/niw7v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q0exs/screenshots/1p7v9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q0exs/screenshots/qcu86/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q0exs/screenshots/rep3h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q0exs/screenshots/n71ha/default.jpg"
        ],
        "live_demo": "https://dual-sign.vercel.app/",
        "source_code": "https://github.com/jaydip676/DualSign",
        "link": "https://ethglobal.com/showcase/dualsign-q0exs"
    },
    {
        "title": "World Vote",
        "brief_description": "A voting platform that is sybil resistance backed by World ID",
        "long_description": "Introducing a Sybil-resistant voting platform that ensures secure and fair participation. By leveraging World ID for human verification, each voter can confidently cast their vote knowing the system is protected from bots and fake accounts. This platform prioritizes transparency, privacy, and the integrity of the voting process, making sure every vote counts and is backed by real people. We built our frontend using Scaffold-ETH as a boilerplate, which accelerated development. We integrated World IDKit for human verification to ensure each vote comes from a unique human, preventing Sybil attacks. Customizing Scaffold-ETH's front end to integrate World ID's widget allowed us to quickly develop a secure, user-friendly platform resistant to fraudulent activities.",
        "how_its_made": "We built our frontend using Scaffold-ETH as a boilerplate, which accelerated development. We integrated World IDKit for human verification to ensure each vote comes from a unique human, preventing Sybil attacks. Customizing Scaffold-ETH's front end to integrate World ID's widget allowed us to quickly develop a secure, user-friendly platform resistant to fraudulent activities.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/45hq0/screenshots/zf6yo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/45hq0/screenshots/bqx2i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/45hq0/screenshots/mesvt/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jeedani/world-vote-egsingapore",
        "link": "https://ethglobal.com/showcase/world-vote-45hq0"
    },
    {
        "title": "EZ-Pay",
        "brief_description": "A crypto wallet app for seamless transactions and payments via links or QR codes, offering quick, secure transfers with just a few clicks for both personal and business use.",
        "long_description": "Our project presents a comprehensive payment solution called ez-pay, designed to simplify the complexity of traditional crypto payment systems by leveraging programmable wallets and payment APIs. Built for a hackathon, this app provides a seamless and intuitive way for users to send and receive cryptocurrency, overcoming the challenges often associated with manual crypto transactions. Problem Overview: Complexity of Traditional Crypto Payments\nTraditionally, making a crypto payment involves numerous steps, as outlined: Wallet Creation: Users must generate a wallet and manage complex elements such as private keys and seed phrases.\nTransaction Setup: This requires buying crypto from exchanges, verifying wallet addresses, selecting gas fees, and waiting for blockchain confirmations.\nSecurity and Recordkeeping: Users must securely store their private keys and monitor transaction trends.\nThis process is not only cumbersome but prone to user error, making it difficult for businesses and everyday users to adopt crypto payments easily. Solution: ez-pay\nThe ez-pay application transforms the user experience by streamlining the entire crypto payment process into three simple steps: Login: The user logs into the app using email authentication.\nSelect Receiver and Input Amount: Users select the recipient and enter the amount they wish to send OR Just click the payment link sent by others\nPress Send: With one click, the crypto transaction is completed.\nThis simplicity is achieved through programmable wallets and payment APIs that abstract away the manual steps associated with crypto payments. Key Features of ez-pay:\nSeamless Crypto Payments: Users can generate payment requests using links or QR codes, allowing recipients to pay easily without managing complicated wallet addresses.\nDeveloper-Controlled Wallets: These wallets are automatically created and managed through Circle's Web3 services, eliminating the need for users to manually handle private keys or seed phrases.\nGasless Transactions: The app supports gasless transactions, reducing the burden of transaction fees for users.\nConfidential and Secure: With integrated encryption (through smart contract technology), users and businesses are ensured that sensitive payment information is protected.\nFor Businesses:\nPayment API: Businesses can create payment requests with protected payment information, streamlining the process of receiving payments.\nPost-Payment Automation: Once a payment is completed, external applications or business services can seamlessly trigger post-payment activities such as product delivery or order processing.\nArchitecture:\nThe architecture (shown in the diagram) demonstrates the flow: Frontend: The app uses Next.js for frontend and email authentication via mail.\nCircle Web3 Service: Wallet creation is powered by Circle\u2019s Web3 API, which manages programmable wallets.\nProgrammable Wallets: Users have individual wallets (Wallet A, Wallet B) that interact with encrypted smart contracts for secure payments.\nSmart Contract Deployment and Encryption: Utilizing Fhenix for smart contract deployment and encryption, ensuring that transactions are confidential and secure.\nFinal Thoughts:\nez-pay is designed to eliminate the complexity of crypto payments by providing a streamlined user experience with advanced security features. By allowing users to send crypto in just a few clicks and enabling businesses to integrate payment APIs seamlessly, ez-pay positions itself as an innovative solution for the growing crypto economy. Frontend: Built with Next.js\nWe used Next.js to build the frontend of the application. This was chosen for its simplicity, scalability, and ease of integrating authentication mechanisms like user Sign-In. The frontend allows users to:\n\u2022\tLog in via email authentication using email.\n\u2022\tEasily navigate the wallet creation, payment request generation, and transaction process.\nNext.js benefits:\n\u2022\tServer-side rendering (SSR) helped us optimize performance.\n\u2022\tThe flexible routing system allowed us to easily handle user interactions and display real-time updates about transaction statuses. Authentication: Gmail Integration\nWe implemented email authentication using email, allowing users to log in with their email accounts. This step was crucial for securing the application and making the user onboarding process simple, especially for users unfamiliar with crypto wallets. Programmable Wallets: Circle Web3 Service\nOne of the core components of ez-pay is the Circle Web3 Service. Circle\u2019s service allowed us to seamlessly create programmable wallets without requiring users to manually manage private keys or seed phrases.\nHow Circle Web3 helped:\n\u2022\tAutomated Wallet Creation: Once the user authenticates, Circle\u2019s API automatically generates and manages their wallet, significantly reducing the complexity users usually face.\n\u2022\tGasless Transactions: Circle also provides mechanisms to support gasless transactions, allowing users to transfer crypto without worrying about transaction fees. This made the app much more user-friendly. Payment APIs and Smart Contracts: Fhenix Smart Contract Encryption\nWe built the crypto payment functionality using smart contracts for security, with Fhenix providing encryption for these contracts. The smart contracts are deployed on the blockchain and allow users to:\n\u2022\tCreate and send payment requests securely.\n\u2022\tProcess payments with a single click, thanks to automation embedded in the smart contracts.\nThe encryption technology provided by Fhenix ensures that the payment process is secure, protecting sensitive payment information during the transaction.\nSmart Contract Highlights:\n\u2022\tAutomation: Once a payment request is generated, the smart contract automatically processes the transaction once the user confirms it.\n\u2022\tConfidentiality: Smart contract encryption protects payment details, making the app highly secure and privacy-focused. Developer-Controlled Wallets\nThe wallets in ez-pay are developer-controlled, meaning that while the app handles the creation and management of wallets, users do not need to directly interact with private keys. This was a major benefit of using Circle\u2019s programmable wallets, as it removed the biggest friction point in crypto payments\u2014wallet management. Secure Payment Flow: Links and QR Codes\nTo make the user experience frictionless, we introduced payment requests using links and QR codes. Users can generate a payment request and send it to others, allowing them to make payments without the hassle of manually inputting wallet addresses or selecting gas fees.\n\u2022\tLinks/QR Codes: Once the recipient scans the QR code or clicks the link, the app opens a pre-filled transaction form, requiring only one click to confirm the payment. Technologies Used:\n\u2022\tNext.js: For building the frontend and managing user interactions.\n\u2022\tEmail Authentication: For simple, secure login.\n\u2022\tCircle Web3 API: For programmable wallet creation and gasless transactions.\n\u2022\tFhenix: For secure smart contract encryption and deployment.\nThe project came together through a combination of web technologies, blockchain services, and security-focused encryption. Each component played a crucial role in ensuring that the payment process is not only fast and easy but also secure and reliable. By integrating Circle\u2019s Web3 services and Fhenix encryption, we were able to hack around the traditional complexities of crypto payments and deliver a seamless experience for both users and businesses.",
        "how_its_made": "Frontend: Built with Next.js\nWe used Next.js to build the frontend of the application. This was chosen for its simplicity, scalability, and ease of integrating authentication mechanisms like user Sign-In. The frontend allows users to:\n\u2022\tLog in via email authentication using email.\n\u2022\tEasily navigate the wallet creation, payment request generation, and transaction process.\nNext.js benefits:\n\u2022\tServer-side rendering (SSR) helped us optimize performance.\n\u2022\tThe flexible routing system allowed us to easily handle user interactions and display real-time updates about transaction statuses. Authentication: Gmail Integration\nWe implemented email authentication using email, allowing users to log in with their email accounts. This step was crucial for securing the application and making the user onboarding process simple, especially for users unfamiliar with crypto wallets. Programmable Wallets: Circle Web3 Service\nOne of the core components of ez-pay is the Circle Web3 Service. Circle\u2019s service allowed us to seamlessly create programmable wallets without requiring users to manually manage private keys or seed phrases.\nHow Circle Web3 helped:\n\u2022\tAutomated Wallet Creation: Once the user authenticates, Circle\u2019s API automatically generates and manages their wallet, significantly reducing the complexity users usually face.\n\u2022\tGasless Transactions: Circle also provides mechanisms to support gasless transactions, allowing users to transfer crypto without worrying about transaction fees. This made the app much more user-friendly. Payment APIs and Smart Contracts: Fhenix Smart Contract Encryption\nWe built the crypto payment functionality using smart contracts for security, with Fhenix providing encryption for these contracts. The smart contracts are deployed on the blockchain and allow users to:\n\u2022\tCreate and send payment requests securely.\n\u2022\tProcess payments with a single click, thanks to automation embedded in the smart contracts.\nThe encryption technology provided by Fhenix ensures that the payment process is secure, protecting sensitive payment information during the transaction.\nSmart Contract Highlights:\n\u2022\tAutomation: Once a payment request is generated, the smart contract automatically processes the transaction once the user confirms it.\n\u2022\tConfidentiality: Smart contract encryption protects payment details, making the app highly secure and privacy-focused. Developer-Controlled Wallets\nThe wallets in ez-pay are developer-controlled, meaning that while the app handles the creation and management of wallets, users do not need to directly interact with private keys. This was a major benefit of using Circle\u2019s programmable wallets, as it removed the biggest friction point in crypto payments\u2014wallet management. Secure Payment Flow: Links and QR Codes\nTo make the user experience frictionless, we introduced payment requests using links and QR codes. Users can generate a payment request and send it to others, allowing them to make payments without the hassle of manually inputting wallet addresses or selecting gas fees.\n\u2022\tLinks/QR Codes: Once the recipient scans the QR code or clicks the link, the app opens a pre-filled transaction form, requiring only one click to confirm the payment. Technologies Used:\n\u2022\tNext.js: For building the frontend and managing user interactions.\n\u2022\tEmail Authentication: For simple, secure login.\n\u2022\tCircle Web3 API: For programmable wallet creation and gasless transactions.\n\u2022\tFhenix: For secure smart contract encryption and deployment.\nThe project came together through a combination of web technologies, blockchain services, and security-focused encryption. Each component played a crucial role in ensuring that the payment process is not only fast and easy but also secure and reliable. By integrating Circle\u2019s Web3 services and Fhenix encryption, we were able to hack around the traditional complexities of crypto payments and deliver a seamless experience for both users and businesses.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8jytc/screenshots/9zmtg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jytc/screenshots/t61qt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jytc/screenshots/vq2hb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jytc/screenshots/e50dp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jytc/screenshots/2fprg/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ez-pay/ezpay",
        "link": "https://ethglobal.com/showcase/ez-pay-8jytc"
    },
    {
        "title": "Enclave",
        "brief_description": "Fully Homomorphic Encryption enabled ENS domain records for a privacy centric team",
        "long_description": "This project is a privacy focused spin on ENS domains. It allows the user to store encrypted records on-chain and only allow certain users to decrypt the given secrets. This application is perfect for a team wanting to utilise the blockchain as a single source of truth without revealing any secrets and while making it simpler to collaborate. It is made using Solidity smart contracts deployed on Ethereum Sepolia and Fhenix Helium testnet, aswell as an API built in Typescript deployed using railway to a server with a scaffold-eth enabled frontend built in next.js. Version control used is Github. The smart contract framework used throughout the project is Foundry, including writing tests for the FHE operations and deployment scripts to different chains.",
        "how_its_made": "It is made using Solidity smart contracts deployed on Ethereum Sepolia and Fhenix Helium testnet, aswell as an API built in Typescript deployed using railway to a server with a scaffold-eth enabled frontend built in next.js. Version control used is Github. The smart contract framework used throughout the project is Foundry, including writing tests for the FHE operations and deployment scripts to different chains.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wyek3/screenshots/sxskz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyek3/screenshots/2rkm5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyek3/screenshots/n6k64/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyek3/screenshots/98j3w/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/marronjo/enclave",
        "link": "https://ethglobal.com/showcase/enclave-wyek3"
    },
    {
        "title": "PolyVote",
        "brief_description": "PolyElection is an end-to-end  private voting service using MPC, ZK and AI to recommend and process votes",
        "long_description": "PolyElection is an end-to-end private voting service using MPC, ZK and AI to recommend and process votes Modern voting systems face significant challenges in maintaining privacy, preventing collusion, and ensuring trust. PolyElection is an end-to-end private voting service that leverages Multi-Party Computation (MPC), Zero-Knowledge Proofs (ZK), and AI to recommend and process votes while maintaining full privacy for users.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6hwky/screenshots/m71d2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6hwky/screenshots/u6e8h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6hwky/screenshots/79mj5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6hwky/screenshots/38ioe/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6hwky/screenshots/twm49/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6hwky/screenshots/t9gg9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ElectionZap/eth-singapore",
        "link": "https://ethglobal.com/showcase/polyvote-6hwky"
    },
    {
        "title": "Coin sync",
        "brief_description": "A Telegram bot that simplifies crypto portfolio management. Link all your wallets in one place, get real-time balance updates, gas fee alerts, and make micro-transactions. Manage your crypto smarter and faster with secure, seamless wallet integration\u2014all within Telegram!",
        "long_description": "This project is a Telegram-based bot that simplifies cryptocurrency portfolio management by utilizing a dynamic embedded wallet, allowing users to link multiple wallets from various blockchains into one unified view. With real-time updates, seamless transactions, and an intuitive interface, the bot efficiently manages crypto portfolios directly within Telegram. Key Features: User Experience:",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gu5w7/screenshots/ouooa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gu5w7/screenshots/bw8e3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gu5w7/screenshots/4p5je/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gu5w7/screenshots/qkb72/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gu5w7/screenshots/jg2rx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gu5w7/screenshots/29e1d/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/flo-3/coin-sync",
        "link": "https://ethglobal.com/showcase/coin-sync-gu5w7"
    },
    {
        "title": "TailTrack",
        "brief_description": "TailTrack comes to feel the need to have a closer look into our pets lives to avoid health issues.",
        "long_description": "TailTrack is a computer vision project to track the activities of any pets, the main reason to build it is because I have 6 cats that are mostly alone when I travel, when I travel I can\u00b4\u00b4t be paying as much attention as I would like.\nThis is not the only use, it can also be used for cat shelters or colonies, veterinary clinics and many other places where your pet might be alone or needed extra attention. I used Phala Network API to connect to gpt4o model to analize the pictures from my security cameras, with that information I can have a daily report that is analized by a more specialized model that I trained with Gaia  (Gaianet) with some data to get exactly the important activities of the cats, like eating, drinking and going to the toilet. For the future i will also want to track the play/movement time as it is also very important to be aware for health reasons.",
        "how_its_made": "I used Phala Network API to connect to gpt4o model to analize the pictures from my security cameras, with that information I can have a daily report that is analized by a more specialized model that I trained with Gaia  (Gaianet) with some data to get exactly the important activities of the cats, like eating, drinking and going to the toilet. For the future i will also want to track the play/movement time as it is also very important to be aware for health reasons.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/7t1zg/screenshots/1vmph/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7t1zg/screenshots/3xmo6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7t1zg/screenshots/1sm2t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7t1zg/screenshots/5ypq4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7t1zg/screenshots/8j6u4/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/armsves/TailTrack",
        "link": "https://ethglobal.com/showcase/tailtrack-7t1zg"
    },
    {
        "title": "Geeg",
        "brief_description": "Match with the perfect talent for a seamless and transparent project experience, secured by blockchain technology.",
        "long_description": "Geeg (derived from the word \"gig\") is a blockchain-powered talent matching platform designed to address the limitations of traditional freelancing platforms by introducing a decentralized system that provides transparency, reduced fees, and fast payments. By removing the centralized intermediary, Geeg enables talents and clients to engage in peer-to-peer transactions, drastically reducing fees through the use of smart contracts built on the Flow network. Cross-border payments and collaborations are streamlined and more secure with an automated escrow system that guarantees immediate payment upon gig completion, preventing delays and ensuring freelancers are paid promptly. Positive and negative actions will be algorithmically rewarded or penalized, with decentralized governance empowering the community to create policies that benefit all participants. The decentralized platform also promotes fair and transparent dispute resolution, where community members holding utility tokens can serve as judges. These judges will vote on outcomes, ensuring fairness and transparency with rewards for correct jurors. By decentralizing platform control, Geeg reduces the risks of account suspensions or biased regulations, giving freelancers and clients confidence in smart contracts and decentralized governance. With Geeg, we are building the future of freelancing by empowering talents and clients through blockchain technology. Our platform eliminates the inefficiencies of traditional systems, offering a fair, transparent, and secure environment where both freelancers and clients thrive. Geegg is redefining the freelancing experience for the modern digital workforce. This project is built full stack using Next.js. We're using Reown's AppKit to onboard users by creating wallets from their social accounts. This really aligns with our goal of being accessible to everyone. We know that using a new app might be intimidating, so we're building our own set of AI agent to onboard clients and help them understand what kind of service they're looking for. Our core matchmaking feature is built using LLMs from RedPill. The usage of TEE in Phala Network really helps us abstract the model calls so that the code can be well organized. For the smart contract escrow, we're building on the Flow blockchain, where we believe the efficiency and low-cost nature of the network really aligns with our vision of faster and cheaper transactions in getting digital services.",
        "how_its_made": "This project is built full stack using Next.js. We're using Reown's AppKit to onboard users by creating wallets from their social accounts. This really aligns with our goal of being accessible to everyone. We know that using a new app might be intimidating, so we're building our own set of AI agent to onboard clients and help them understand what kind of service they're looking for. Our core matchmaking feature is built using LLMs from RedPill. The usage of TEE in Phala Network really helps us abstract the model calls so that the code can be well organized. For the smart contract escrow, we're building on the Flow blockchain, where we believe the efficiency and low-cost nature of the network really aligns with our vision of faster and cheaper transactions in getting digital services.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/70kwa/screenshots/z0juj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70kwa/screenshots/5q636/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70kwa/screenshots/vjgdj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70kwa/screenshots/hqo0f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70kwa/screenshots/84tng/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ahmadrafidev/geeg",
        "link": "https://ethglobal.com/showcase/geeg-70kwa"
    },
    {
        "title": "OxENS",
        "brief_description": "Making blockchain easy: Blockchain education and AI driven platform to measure trustworthiness of crypto assests.",
        "long_description": "This project aimed to make blockchain easy for you. The goals are two-fold: to educate users on ENS and to give users the ability to know what the trustworthiness of crypto assets is through analysing factors such as asset value, market cap and other factors to determine if the coin can be trusted to be invested or not. The ENS knowledge is the first step to understanding web3 seamlessly, which makes it far easier for many people to easily learn and be on chain and be part of the web3 community. The project uses in the backend, Python in VS code with OpenAI API calls and web scraping from coingecko to identify the trustworthiness of coins and allows people to make informed investment decisions. While the frontend uses Next.JS, with a ENS based wallet resolver utilises an easy user interface that is both easy to use and educational and onboard people in to web3. The ENS and ReOwn aspect is a simple Next.js based app to help users learn more about web3 by playing with resolving ENS domains. This has been built with: Install dependencies: A ReOwn was created and our Project ID was added to .env.local: We then started the development server: Then http://localhost:3000 was opened with our browser to see the result. The frontend was edited by modifying pages/index.tsx. Furthermore, the project was deployed with Vercel",
        "how_its_made": "The project uses in the backend, Python in VS code with OpenAI API calls and web scraping from coingecko to identify the trustworthiness of coins and allows people to make informed investment decisions. While the frontend uses Next.JS, with a ENS based wallet resolver utilises an easy user interface that is both easy to use and educational and onboard people in to web3. The ENS and ReOwn aspect is a simple Next.js based app to help users learn more about web3 by playing with resolving ENS domains. This has been built with: Install dependencies: A ReOwn was created and our Project ID was added to .env.local: We then started the development server: Then http://localhost:3000 was opened with our browser to see the result. The frontend was edited by modifying pages/index.tsx. Furthermore, the project was deployed with Vercel",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/n7xrq/screenshots/qig8x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n7xrq/screenshots/7immm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n7xrq/screenshots/25j19/default.jpg"
        ],
        "live_demo": "https://ox-ens-dradakus-projects.vercel.app",
        "source_code": "https://github.com/ethglobal",
        "link": "https://ethglobal.com/showcase/oxens-n7xrq"
    },
    {
        "title": "MEV-Engine",
        "brief_description": "A tool to help you find mev opportunities on starknet, sync data from the defi applications you need. If the defi app you looking for isnt supported implement the trait, and rest else should work.",
        "long_description": "MEV-Engine is a library written in Rust which is a simple and modular framework for writing MEV bots or strategies.\nMEV searchers face significant challenges when tracking opportunities across different protocols. Each protocol often has its own unique architecture, transaction sequencing, and state synchronization patterns, requiring searchers to constantly adapt their bots to monitor various sources for profitable trades.\nThis crate is implemented with keeping modularity in mind to interact with a variety of AMMs for now. We also plan to extend this library for aggregating various lending-borrowing protocols as well.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/k5fyp/screenshots/ij05z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k5fyp/screenshots/5wxwb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k5fyp/screenshots/oh30w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k5fyp/screenshots/1iyxt/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/RaveenaBhasin/mev-engine",
        "link": "https://ethglobal.com/showcase/mev-engine-k5fyp"
    },
    {
        "title": "Upper World",
        "brief_description": "Upperworld is an innovative, on-chain multiplayer game that brings the beloved Pok\u00e9mon concept into the world of blockchain technology",
        "long_description": "Upperworld is an innovative, on-chain multiplayer game that brings the beloved Pok\u00e9mon concept into the world of blockchain technology. Players can catch, battle, and earn across different networks, creating a truly decentralized gaming experience. An on-chain multiplayer Pok\u00e9mon-style game where players can: Catch Pok\u00e9mon NFTs across different blockchains\nBattle in real-time with other players\nEarn meme tokens as rewards Rootstock Integration\nWe integrated Rootstock by deploying our core game contracts (Pokemon, PikaCoin, and PokemonBattle) on the Rootstock testnet. This allows us to leverage Bitcoin's robust security model while enabling complex game logic and NFT interactions. The main Pokemon contract is deployed at 0xA7D5FcEb3e860618336753c19b668b2fA76Be47E. Cross-chain Interoperability using Hyperlane\nERC721 & ERC20 Standards for NFTs and tokens on rootstock\nReal-time PvP Battles on-chain",
        "how_its_made": "Rootstock Integration\nWe integrated Rootstock by deploying our core game contracts (Pokemon, PikaCoin, and PokemonBattle) on the Rootstock testnet. This allows us to leverage Bitcoin's robust security model while enabling complex game logic and NFT interactions. The main Pokemon contract is deployed at 0xA7D5FcEb3e860618336753c19b668b2fA76Be47E. Cross-chain Interoperability using Hyperlane\nERC721 & ERC20 Standards for NFTs and tokens on rootstock\nReal-time PvP Battles on-chain",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ysmrp/screenshots/3jy13/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ysmrp/screenshots/1so3n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ysmrp/screenshots/5fxdc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ysmrp/screenshots/kyyu1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AqilJaafree/upperworld-ethglobalsg",
        "link": "https://ethglobal.com/showcase/upper-world-ysmrp"
    },
    {
        "title": "PriVote",
        "brief_description": "Privote is an open-source, decentralized voting platform that uses MACI for privacy and offers various authentication methods for secure, private polling.",
        "long_description": "Privote is a decentralized voting mechanism that allows users to vote on-chain in a private and secure manner. It uses Maci protocol made by PSE team to ensure that votes don't leak and are not tampered with. The project is open-source and anyone can contribute to it. Privote enables users to create various types of private polls and vote on them. It also provides various types of auth mechanisms like Anon-Aadhar (aadhar based verification from India), WorldCoin-auth, NFC (can be used in IRL events like ethglobal hackathons), etc, enabling holding of various interesting polls without revealing the choice of voters. The project uses MACI to ensure privacy and collusion resistant voting .\nWe solved various problems through various stacks listed below-\nOn-chain Vote Visibility: Lack of Ways to Avoid Bad Actors (Multiple Voting, etc.): Bribery and Coercion: Lack of Cross-chain Compatibility:",
        "how_its_made": "The project uses MACI to ensure privacy and collusion resistant voting .\nWe solved various problems through various stacks listed below-\nOn-chain Vote Visibility: Lack of Ways to Avoid Bad Actors (Multiple Voting, etc.): Bribery and Coercion: Lack of Cross-chain Compatibility:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hertg/screenshots/89pz6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hertg/screenshots/d31fd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hertg/screenshots/ts50y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hertg/screenshots/a54dk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hertg/screenshots/kev2f/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/PriVote-Project",
        "link": "https://ethglobal.com/showcase/privote-hertg"
    },
    {
        "title": "AirSoul",
        "brief_description": "Simplifying blockchain with an easy-to-use bot, AirSoul empowers nearly 1 billion users to check balances, send tokens, view NFT details, and more.",
        "long_description": "\ud83e\udd16 AirSoul - A bot that is more than a bot Web3 and blockchain is an ever growing technology market. It has a lot of applications and use cases but the general public is still not able to use these applications due to their complexity. AirSoul is an all in one bot hosted on the Telegram.\nNow, you might think;\nWhy Telegram? \ud83e\udd14\nTelegram is one of the biggest messaging applications in the world. It has the robust user base of nearly 1 billion users across the world. Telegram is available in almost all the major countries including the USA, European Union, UK, India, Russia, Canada, etc.\nMostly people are afraid to adapt to new web3 applications due to the complexity and ineffective UI/UX.\nAirSoul is the one stop solution which allows the users to communicate with the blockchain using Telegram. Few advantages of AirSoul:-\nEasy to access: Users can directly chat with the AirSoul bot in the Telegram.\nUser friendly interface: Users can chat with the bot like the other chats.\nHuge population coverage: AirSoul bot is available to all the approx. 1 billion users of Telegram.\nSupports many blockchains: AirSoul provides services on the following networks - Airdao, Hedera, Morph, etc.\nAirSoul also offers different bots for different networks to avoid confusion amongst users and make the process easy for the users. Features of AirSoul:-\nCheck balance - Users can check the native AMBR token balance for any address.\nFetch ERC20 token balance - Users can fetch the ERC20 token balance for an address and token contract.\nNetwork Info - Users can find the current network information like latest block and gas price.\nBlock Info - Users can get the information related to a specific block.\nLatest Gas Price - Users can also find the latest gas prices.\nSend Native Token - Users can easily send the native token to a specific address by simply communicating with the bot.\nSend ERC20 Token - Users can also send the ERC20 tokens to the specific address.\nLatest block info - Users can fetch the latest block info by simply clicking on /latestblock.\nNFT Info - Users can get all the details related to an ERC721 NFT.\nSend NFT - Not only fetch the NFT\u2019s info, Users can also send the NFT to another address using the bot. These are few of the features of AirSoul which covers the basic (& also advanced) usage of a general user. This user-friendly Telegram tool enables easy interaction with various blockchains and simplifies task execution. It's built using the Telegram Bot API and runs on a Node.js server that listens for and processes all incoming bot events and requests, ensuring 24/7 availability. The tool includes a wide range of functionalities, eliminating the need for users to rely on other tools. The frontend is developed with Next.js, where users can access the Telegram tool and mint SBTs if they want.",
        "how_its_made": "This user-friendly Telegram tool enables easy interaction with various blockchains and simplifies task execution. It's built using the Telegram Bot API and runs on a Node.js server that listens for and processes all incoming bot events and requests, ensuring 24/7 availability. The tool includes a wide range of functionalities, eliminating the need for users to rely on other tools. The frontend is developed with Next.js, where users can access the Telegram tool and mint SBTs if they want.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/151xz/screenshots/c4ftw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/151xz/screenshots/z7woo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/151xz/screenshots/h9cqv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/151xz/screenshots/5cy8v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/151xz/screenshots/cwb4k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/151xz/screenshots/axsrk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Gautambnsl/AirSoul-EthSingapore",
        "link": "https://ethglobal.com/showcase/airsoul-151xz"
    },
    {
        "title": "COCswap",
        "brief_description": "COCSwap: An Intelligent AMM powered by Convex Optimization and ZKPs",
        "long_description": "COCSwap (Convex Optimization Computation Swap) is an automated market maker (AMM) that leverages convex optimization techniques and zero-knowledge proofs to provide efficient and adaptive AMM pools. Unlike Constant Function Market Makers that use simple formulas (e.g., constant product), COCSwap allows for complex calculations off-chain using convex optimization techniques. This allows for more sophisticated pricing models and capital efficiency. Zero-Knowledge Proofs and Zero Knowledge Machine Learning allow for off-chain calculations to be verifiable onchain trustlessly without the need for oracles and economic consensus, allowing for better capital efficiency as well as correctness. Given the expression of AMM as a convex optimization problem, we are able to expand the range of pricing models and objectives subject to expressive constraints. The use of convex optimization allows for a wide range of pricing models and constraints, which can be adjusted to suit different market conditions or asset characteristics. In addition, Convex Optimization allows for multi-asset pools beyond 2 assets alone. This makes the AMM much smarter and adaptive allowing for different pricing strategies that may reduce risk on LPs and increase execution efficiency in swaps. Summary on How it works: When a user initiates a transaction (swap, add liquidity, or remove liquidity), the current state and proposed action are input into a convex optimization model off-chain. The model, implemented using AI frameworks like PyTorch, optimizes the new state of the pool based on the defined objective function and constraints. Using EZKL we are able to convert the AI model in to a corresponding ZK circuit. Allowing for a zk proof to be generated for the optimization model written in PyTorch. EZKL generates an EVM compatible verifier. We can then implement a Smart Contract in solidity which incorporates the EVM compatible verifier. We used Foundry for our Smart Contracts. The smart contract receives the proposed new state along with the zero-knowledge proof. It verifies the proof to ensure the integrity of the off-chain computation. If the proof is valid, the contract updates the pool state and executes the user's transaction.",
        "how_its_made": "Summary on How it works: When a user initiates a transaction (swap, add liquidity, or remove liquidity), the current state and proposed action are input into a convex optimization model off-chain. The model, implemented using AI frameworks like PyTorch, optimizes the new state of the pool based on the defined objective function and constraints. Using EZKL we are able to convert the AI model in to a corresponding ZK circuit. Allowing for a zk proof to be generated for the optimization model written in PyTorch. EZKL generates an EVM compatible verifier. We can then implement a Smart Contract in solidity which incorporates the EVM compatible verifier. We used Foundry for our Smart Contracts. The smart contract receives the proposed new state along with the zero-knowledge proof. It verifies the proof to ensure the integrity of the off-chain computation. If the proof is valid, the contract updates the pool state and executes the user's transaction.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/s4yga/screenshots/j8z8p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s4yga/screenshots/g71b8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s4yga/screenshots/kj81n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s4yga/screenshots/hkxya/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jseam2/cocswap",
        "link": "https://ethglobal.com/showcase/cocswap-s4yga"
    },
    {
        "title": "Stormbit",
        "brief_description": "Stormbit on Morph L2: Simplifying loans for you. Connects lenders & borrowers directly, cutting out banks. Secure, accessible, and now with free liquidations for swift, hassle-free transactions.",
        "long_description": "Introducing Stormbit on Morph L2 - where we're revolutionizing loans for the everyday user. Our platform strips away complexity, hooking you up directly with lenders or borrowers, no bank required. Think of it as your gateway to straightforward, secure, and accessible financial services, tailored for the modern consumer. Building Stormbit: Blockchain: Utilized MorphL2 with Alchemy for node services.\nSmart Contracts: Developed using OpenZeppelin's secure standards in Solidity.\nFrontend: React with TypeScript for user interaction.\nBackend: Node.js with Express.js for API management.\nFree Liquidations: Automated, no-cost liquidations via a self-sustaining fee pool.\nModular Design: Enhanced by OpenZeppelin's modular contracts for flexibility.",
        "how_its_made": "Building Stormbit: Blockchain: Utilized MorphL2 with Alchemy for node services.\nSmart Contracts: Developed using OpenZeppelin's secure standards in Solidity.\nFrontend: React with TypeScript for user interaction.\nBackend: Node.js with Express.js for API management.\nFree Liquidations: Automated, no-cost liquidations via a self-sustaining fee pool.\nModular Design: Enhanced by OpenZeppelin's modular contracts for flexibility.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hoon6/screenshots/g6vgd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hoon6/screenshots/x4r1m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hoon6/screenshots/5daud/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hoon6/screenshots/xw7p5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hoon6/screenshots/drcdb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hoon6/screenshots/befvs/default.jpg"
        ],
        "live_demo": "https://stormbit-nextjs.vercel.app/",
        "source_code": "https://github.com/technophile-04/p2p-lending-ethglobal",
        "link": "https://ethglobal.com/showcase/stormbit-hoon6"
    },
    {
        "title": "BlockElf",
        "brief_description": "An on-chain LLM search engine that enables user to query on-chain data through natural language.",
        "long_description": "BlockElf is an on-chain LLM search engine designed to simplify access to blockchain data through natural language queries. Traditionally, users rely on third-party dashboards or must orchestrate their own data pipelines\u2014often requiring technical expertise. BlockElf changes this by allowing anyone to access on-chain data effortlessly. Users simply input their intent in plain language, and BlockElf\u2019s agent formulates a plan, utilizes integrated tools, and delivers a clear response. By integrating with multiple blockchain data providers and orchestrating an advanced AI pipeline, BlockElf redesigns how we all can  on-chain data truly accessible to everyone. This project use an on-chain LLM deployed on Phala using Redpill and OpenRouter. Apart from that, we offer novel models like GPT, Gemini. We have multiple of tools integrated into the system. Namely, Technically, the user's query is received by one agent that determines what tools to use in what order to give user the response. Then, the tools are called to get required data, format it, and give the appropriate response to the user.",
        "how_its_made": "This project use an on-chain LLM deployed on Phala using Redpill and OpenRouter. Apart from that, we offer novel models like GPT, Gemini. We have multiple of tools integrated into the system. Namely, Technically, the user's query is received by one agent that determines what tools to use in what order to give user the response. Then, the tools are called to get required data, format it, and give the appropriate response to the user.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qxtw5/screenshots/wwq4v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qxtw5/screenshots/pq2nr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qxtw5/screenshots/ne5sn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qxtw5/screenshots/mr60n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qxtw5/screenshots/x2ijc/default.jpg"
        ],
        "live_demo": "https://blockelf-demo.vercel.app/",
        "source_code": "https://github.com/y-pakorn/blockelf-demo",
        "link": "https://ethglobal.com/showcase/blockelf-qxtw5"
    },
    {
        "title": "Nyx",
        "brief_description": "Discover a therapy AI app using Oasis Protocol and Dynamic Labs, prioritizing user privacy with off-chain chat storage. Therapists can securely access data on-chain, enhancing trust and transparency, all powered by ENS for easy identification.",
        "long_description": "Introducing a cutting-edge therapy AI app developed using the Oasis Protocol, Dynamic Labs, and Ethereum Name Service (ENS). This app prioritizes user privacy by storing confidential chat histories off-chain, ensuring that sensitive information remains secure. Therapists can request access to this data on-chain, facilitated by a seamless integration with the Oasis Protocol for enhanced security and scalability. With Dynamic Labs' innovative features and ENS for easy user identification, this app empowers both patients and therapists to engage in a trusted, transparent therapeutic experience. We developed a cutting-edge therapy AI app using the Oasis Protocol, Dynamic Labs, and Ethereum Name Service (ENS) to prioritize user privacy and enhance the therapeutic experience. Key Technologies:\nOasis Protocol: Provided secure, confidential data handling, allowing off-chain storage of chat histories while enabling authorized access on-chain.\nDynamic Labs: Offered machine learning features for real-time analytics and personalized therapy recommendations.\nEthereum Name Service (ENS): Simplified user identification with human-readable names for easier onboarding and trust verification. Architecture:\nFront-end: Built with React for an intuitive interface.\nBack-end: Utilized Node.js and Express, with decentralized storage via IPFS.\nBlockchain Integration: Employed Ethereum smart contracts for secure data access control.",
        "how_its_made": "We developed a cutting-edge therapy AI app using the Oasis Protocol, Dynamic Labs, and Ethereum Name Service (ENS) to prioritize user privacy and enhance the therapeutic experience. Key Technologies:\nOasis Protocol: Provided secure, confidential data handling, allowing off-chain storage of chat histories while enabling authorized access on-chain.\nDynamic Labs: Offered machine learning features for real-time analytics and personalized therapy recommendations.\nEthereum Name Service (ENS): Simplified user identification with human-readable names for easier onboarding and trust verification. Architecture:\nFront-end: Built with React for an intuitive interface.\nBack-end: Utilized Node.js and Express, with decentralized storage via IPFS.\nBlockchain Integration: Employed Ethereum smart contracts for secure data access control.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/b3j3b/screenshots/8qmvo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b3j3b/screenshots/e1wzk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b3j3b/screenshots/6hfo9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b3j3b/screenshots/5h1md/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b3j3b/screenshots/9jx2g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b3j3b/screenshots/1m4h6/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/knlbb/therapyonchain",
        "link": "https://ethglobal.com/showcase/nyx-b3j3b"
    },
    {
        "title": "DarkLegacyShop",
        "brief_description": "An NFC-powered exploration game where players trade resources, shape the world, and co-create a dynamic, community-driven virtual experience.",
        "long_description": "A reality-based NFC interaction exploration game where players can not only discover and trade resources but also actively participate in the construction and development of the world. Through the inheritance system, players\u2019 contributions can influence the future of the game. The co-creation elements allow every player to become a designer and builder of the game world, creating a truly community-driven dynamic virtual world. This project is built on top of the @Flow and @Linea blockchains, with a general tech stack of Solidity and Next.js to create a mobile-first web application. Internally, we lack experience in iOS and Android development, which is why we opted for a mobile-first approach. We also integrated @Dynamic and @Worldcoin to support login and KYC.",
        "how_its_made": "This project is built on top of the @Flow and @Linea blockchains, with a general tech stack of Solidity and Next.js to create a mobile-first web application. Internally, we lack experience in iOS and Android development, which is why we opted for a mobile-first approach. We also integrated @Dynamic and @Worldcoin to support login and KYC.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rs0k0/screenshots/u7y5d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rs0k0/screenshots/636ps/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rs0k0/screenshots/gu2uh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rs0k0/screenshots/xs2pu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rs0k0/screenshots/swung/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rs0k0/screenshots/2xb6f/default.jpg"
        ],
        "live_demo": "https://darklegacyshop.vercel.app/",
        "source_code": "https://github.com/yisiliu/darklegacyshop",
        "link": "https://ethglobal.com/showcase/darklegacyshop-rs0k0"
    },
    {
        "title": "TransferMoney",
        "brief_description": "This project is about money transfers and includes three main functions: money storage, money transfer, and investment projects.",
        "long_description": "The goal of the platform is to offer a decentralized space where creators can post projects requiring funding, and investors can contribute funds. The platform operates through the Ethereum blockchain, leveraging the transparency and immutability of decentralized technology. The project is based on smart contracts, which securely handle the creation of projects, investments, and financial transactions without intermediaries.\nObjectives The Transfer Platform leverages the Sepolia Test Network for blockchain testing, Solidity for smart contract development, and Flask with SQLite for back-end management. On the front end, HTML, CSS, and Bootstrap ensure a responsive interface, while Web3.js facilitates interaction with the blockchain. These technologies and tools were chosen to create a secure, scalable, and user-friendly decentralized investment platform that meets the needs of modern blockchain users.",
        "how_its_made": "The Transfer Platform leverages the Sepolia Test Network for blockchain testing, Solidity for smart contract development, and Flask with SQLite for back-end management. On the front end, HTML, CSS, and Bootstrap ensure a responsive interface, while Web3.js facilitates interaction with the blockchain. These technologies and tools were chosen to create a secure, scalable, and user-friendly decentralized investment platform that meets the needs of modern blockchain users.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/35h5q/screenshots/xix7c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/35h5q/screenshots/nwhb1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/35h5q/screenshots/kbvva/default.jpg",
            "https://ethglobal.b-cdn.net/projects/35h5q/screenshots/o28g8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/emyyao/ethglobal_transfer",
        "link": "https://ethglobal.com/showcase/transfermoney-35h5q"
    },
    {
        "title": "AttackGen",
        "brief_description": "LLM agent which analyses a given smart contract for vulnerabilities and creates a smart contract to attack it.",
        "long_description": "AttackGen automates the analysis of a smart contract by taking its address as input and retrieving the source code and ABI from Etherscan. Using this data, a machine learning model (LLM), guided by audit insights, generates a custom attack contract to exploit vulnerabilities such as Reentrancy and Public minting issues. The generated contract is then deployed to test the target contract for weaknesses. The entire process runs within Phala Network\u2019s Trusted Execution Environment (TEE), which provides several key benefits: it ensures the confidentiality of the contract data, protects the vulnerability detection results, isolates the testing environment from external attacks, and maintains the integrity of the attack generation process. Multiple instances of these agents can automatically include vulnerabilities as part of verification of contracts.These features make TEE vital not just for secure deployment but also for preserving the privacy and security of the overall testing workflow, offering a safer and more effective tool for security researchers and bounty hunters. Implements a RAG pipeline to create embeddings out of Solodit Cyfrin audits github repo(https://github.com/Cyfrin/cyfrin-audit-reports). Finds out the most relevant chunks of examples and code snippets most similar to the Source code and adds it to the Prompt.\nThe prompt is tailored to generate solidity smart contracts which can interact with the input contract by passing the ABI and source code into the prompt.\nThis agent is implemented using Phala networks TEE agent template(Trusted execution environment). Have used Open AI API embeddings to create the vector store of chunks audits data. Use cosine similarity to find the most similar chunks to the source code of the input contract. Saved the vectors into markdown_embeddings.json file for easy access and experimentation. Alternatively you can run the \"setup_pgvector_db.sh\" to setup a local vector DB using postgres, this will need you to setup pgVector to correctly setup.\nCreating or adding new vectors/embeddings from other relevant documents will require you to run \"embedCreate.py\" with a folder where all the documents are present in markdown format.",
        "how_its_made": "Implements a RAG pipeline to create embeddings out of Solodit Cyfrin audits github repo(https://github.com/Cyfrin/cyfrin-audit-reports). Finds out the most relevant chunks of examples and code snippets most similar to the Source code and adds it to the Prompt.\nThe prompt is tailored to generate solidity smart contracts which can interact with the input contract by passing the ABI and source code into the prompt.\nThis agent is implemented using Phala networks TEE agent template(Trusted execution environment). Have used Open AI API embeddings to create the vector store of chunks audits data. Use cosine similarity to find the most similar chunks to the source code of the input contract. Saved the vectors into markdown_embeddings.json file for easy access and experimentation. Alternatively you can run the \"setup_pgvector_db.sh\" to setup a local vector DB using postgres, this will need you to setup pgVector to correctly setup.\nCreating or adding new vectors/embeddings from other relevant documents will require you to run \"embedCreate.py\" with a folder where all the documents are present in markdown format.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/57m78/screenshots/t9bvq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/57m78/screenshots/sgtti/default.jpg",
            "https://ethglobal.b-cdn.net/projects/57m78/screenshots/bwj2e/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/pranay5255/AttackGen",
        "link": "https://ethglobal.com/showcase/attackgen-57m78"
    },
    {
        "title": "ZkCredit",
        "brief_description": "ZkCredit is a way to borrow crypto assets using traditional models of credit scoring (assets and income). Leveraging Mina's protokit SDK and zkSNARK's our project enables lenders to lend to borrowers who meet certain credit criteria without learning anything about them!",
        "long_description": "Lending protocols in crypto have always required large collateralization of assets. This in turn makes web3 unsuitable for one of the most basic aspects of tradfi: credit. Our project uses the same principles used for centuries by tradfi, ownership of assets (in our case homes), and proof of income to enable lenders to provide credit without the need for collateral. \"However, if this has been something tradfi has done for centuries, why is this even worth exploring?\" This is a question we asked ourselves when thinking about this problem. After much deliberation, we came to the conclusion that nobody wants their income slip or home address on the blockchain, for everybody to see. Privacy is a major concern for borrowers. This is why zkSNARKs are crucial to our project, enabling us to prove asset ownership and income without revealing that information to the blockchain. Using Mina's provable code model and the Protokit SDK, we developed a lending protocol that allows borrowers to prove their creditworthiness while ensuring that their private information is kept hidden. Lenders can specify exactly how credit-worthy (asset value/ income) they want their borrowers to be as well as the interest rates and payback duration. These offers can then be taken up by interested borrowers, who prove that they have met the constraints of the offer using a ZK proof. We also designed a traceable identity system and a blacklist to ensure that bad actors are banned from the lending protocol. Using this system, a bad actor cannot just change their wallet address (create a new wallet) and borrow money again since the blacklist would ban their assets as well. In the future, we would utilize an insurance fund to insure lenders. However, we were not able to finish this feature due to time constraints. Our model also allows for an orderbook-style loan marketplace where lenders can specify exactly what kinds of loans they are willing to give and borrowers can be matched with the best possible loans. The project is based on the hybrid runtime model of Mina and utilizes the Protokit to build and prove the constraints for the proof of assets and income. We initially planned to use government entities' signatures to prove the ownership of assets (such as the ECDSA signature used by the Singapore Government in Singpass) however, as of now, we could not find an sdk/open source project on Mina that does so for any reasonable signature scheme. Instead, we hacked together a Merkle tree implementation where the leaves are assets of every individual in a country, a Merkle tree constructed by the government. Borrowers then prove their Merkle proof of inclusion as well as showing that the assets satisfy min_value constraints. We also designed a traceable identity system, utilizing a nonce, hashes of the assets, and only one message between a borrower and a lender. This way, a defaulting borrower can be blacklisted and their assets cannot be reused for another loan. In the future, we may use Worldcoin ID for this feature.",
        "how_its_made": "The project is based on the hybrid runtime model of Mina and utilizes the Protokit to build and prove the constraints for the proof of assets and income. We initially planned to use government entities' signatures to prove the ownership of assets (such as the ECDSA signature used by the Singapore Government in Singpass) however, as of now, we could not find an sdk/open source project on Mina that does so for any reasonable signature scheme. Instead, we hacked together a Merkle tree implementation where the leaves are assets of every individual in a country, a Merkle tree constructed by the government. Borrowers then prove their Merkle proof of inclusion as well as showing that the assets satisfy min_value constraints. We also designed a traceable identity system, utilizing a nonce, hashes of the assets, and only one message between a borrower and a lender. This way, a defaulting borrower can be blacklisted and their assets cannot be reused for another loan. In the future, we may use Worldcoin ID for this feature.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gfx87/screenshots/12tez/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gfx87/screenshots/qguxu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gfx87/screenshots/0w6xd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gfx87/screenshots/k1fth/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gfx87/screenshots/1ftnu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gfx87/screenshots/7tbo7/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/EkamSinghPandher/ZkCredit",
        "link": "https://ethglobal.com/showcase/zkcredit-gfx87"
    },
    {
        "title": "private-cast",
        "brief_description": "A fully private predication market for verified human, built with Oasis Sapphire and Worldcoin.",
        "long_description": "This is a prediction market where user can place bets on topics and different choices. The user must be verified as human with zk proof using WorldID in order to place a bet. After the oracle reveals its result, a user can claim the funds on his bets onchain. The contract is deployed e2e on Oasis Sapphire testnet and the worldcoin contract is available on Ethereum sepolia testnet. This project leveraged Sapphire Oasis for a fully private onchain state, for the choice and amount of all bets. The frontend is built with Vue and smart contract deployed with oasis CLI on Sapphire testnet. As a workaround to Worldcoin not being available on Sapphire, I deployed the same contract on Eth sepolia for completeness.",
        "how_its_made": "This project leveraged Sapphire Oasis for a fully private onchain state, for the choice and amount of all bets. The frontend is built with Vue and smart contract deployed with oasis CLI on Sapphire testnet. As a workaround to Worldcoin not being available on Sapphire, I deployed the same contract on Eth sepolia for completeness.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0vg89/screenshots/bfnxg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0vg89/screenshots/eprhd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0vg89/screenshots/tjqsy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0vg89/screenshots/7j810/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0vg89/screenshots/zhitv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/mangoqvq/private-cast",
        "link": "https://ethglobal.com/showcase/private-cast-0vg89"
    },
    {
        "title": "GraphGPT",
        "brief_description": "GraphGPT makes interacting with subgraphs easier. It transforms complex queries into a user-friendly experience, helps users extract insights from data, and simplifies data visualization.",
        "long_description": "There are three significant issues related to subgraph interactions: GraphGPT aims to make interacting with subgraphs easier by: How it works? Step1. The user inputs the query through the \"LLM planner\" to perform keyword extraction, generating an easy-read query JSON file.\nStep2. The JSON file is sent to \"LLM GraphQL Intelligence,\" which produces a GraphQL Query and then calls the subgraph API to output the graphQL query result JSON file.\nStep3. The graphQL query result JSON file is then sent to the \"LLM Data Analysis,\" which generates user visualization and insights. We are focused on building an AI agent system that can handle various user queries when interacting with The Graph. We aim to provide a seamless user experience and visualize data for better understanding. Technologies used: The Graph: By leveraging The Graph, we can query data from subgraphs such as Uniswap, Lido, Snapshot, and more.\nAI Agent: We use AI LLM and AI Agent techniques to generate GraphQL queries for querying subgraphs.\nVisualization and Postprocessing: OpenAI LLM is employed to generate plotting code and save the script for data visualization.\nFrontend:\nPython Streamlit - chatbox\nBackend:\nThe Graph, Python, LLM AI",
        "how_its_made": "We are focused on building an AI agent system that can handle various user queries when interacting with The Graph. We aim to provide a seamless user experience and visualize data for better understanding. Technologies used: The Graph: By leveraging The Graph, we can query data from subgraphs such as Uniswap, Lido, Snapshot, and more.\nAI Agent: We use AI LLM and AI Agent techniques to generate GraphQL queries for querying subgraphs.\nVisualization and Postprocessing: OpenAI LLM is employed to generate plotting code and save the script for data visualization.\nFrontend:\nPython Streamlit - chatbox\nBackend:\nThe Graph, Python, LLM AI",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6pty0/screenshots/4iref/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6pty0/screenshots/4g6ja/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6pty0/screenshots/xhix9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6pty0/screenshots/8ueqt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6pty0/screenshots/5afc4/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/abcd5251/GraphGPT",
        "link": "https://ethglobal.com/showcase/graphgpt-6pty0"
    },
    {
        "title": "LendingSapphire",
        "brief_description": "Introducing a private, KYC-free lending platform on Oasis Sapphire. Utilizes dual-token setup, ROFL (TEE) for fetching real time price feeds. Features on-chain and off-chain confidentiality to ensure secure, private transactions.",
        "long_description": "PROJECT OVERVIEW : A private lending platform in the Oasis Sapphire blockchain that leverages on-chain and off-chain confidentiality to provide secure and private financial transactions without KYC. It simulates a dual-token setup for loans and collateral, with automated oracle price feeds facilitated by Runtime Off-Chain Logic (ROFL) in Trusted Execution Environments (TEEs). HOW SAPPHIRE BENEFITS OUR PLATFORM ? This platform takes full advantage of the Oasis Sapphire blockchain to offer a secure environment for executing EVM compatible smart contracts with enhanced on-chain data confidentiality. This feature ensures that sensitive transaction details such as sender and receiver information are encrypted, allowing users to engage in lending and borrowing without compromising privacy. This shields them from common blockchain threats like front-running, where exposed transaction details could be misused by opportunistic observers. Moreover, we integrate off-chain confidentiality using ROFL, which significantly boosts out platform's integrity and security, when paired with Trusted Execution Environments (TEEs). This setup not only secures sensitive operations like real-time pricing feeds but also ensures the accuracy and integrity of these feeds, crucial for calculating loan values reliably. By automating financial processes such as loan issuance based on collateral and auto-liquidation protocols in a secure manner, out platform delivers tailored and responsive financial services that preserve the inherent privacy first ideals of blockchain technology. HOW THE PLATFORM WORKS ? Dual token setup: Token1 is used as collateral by borrowers and Token2 is loan currency provided by liquidity providers. This is what borrowers receive when they take out a loan. Lending process: People who want to lend money, deposit Token2 into a lending pool and earn an interest rate of 6% for particular time periods. These deposits boost the total amount of money available in the pool, which is then used to provide loans to borrowers. Borrowing process: Borrowers secure a loan by depositing Token1 as collateral. Then they receive an amount of Token2 equivalent to 90% of their Token1's current market value. This price feed is fetched through real-time, secure price feeds from ROFL. Borrowers are charged an interest rate of 7% on the loan amount. Pricing and Valuation: The value of Token1 and Token2 is dynamically updated using data from ROFL, which gathers information form multiple off-chain sources to ensure accurate, tamper proof pricing (with the help of TEEs). This is critical for fair loan assessments. Repayment process: Borrowers agree to repay the borrowed Token2 plus the accrued interest. The total amount to be repaid is based on how long the loan has been outstanding. Auto-Liquidation: A system continuously checks the price ratio of Token1 to Token2. If the value of the collateral falls significantly, and the loan-to-value (LTV) ratio drops below a set threshold, auto-liquidation is triggered automatically. Security leverage: All price feeds are tamper proof, with the help of TEEs, and on-chain confidential transactions leveraged over Sapphire. WHAT REAL WORLD PROBLEM OUR PLATFORM INTENDS TO SOLVE ? Eliminates the need for personal identification through KYC, ensuring user transactions remain anonymous and secure. Uses confidential smart contracts to keep transaction details private, preventing potential front-running and market manipulation. Integrates real-time data feeds to dynamically adjust loan terms based on market conditions, protecting both lenders and borrowers from volatility. Utilizes blockchain's inherent properties to offer a transparent and secure environment, reducing the risks of fraud and corruption. FRONTEND:\nFor the frontend of our dapp, we have used react.js famework and bootstrap, material UI\nfor the CSS of our dapp. ethers.js library is used to call the smart contract functions from the frontend. SMART CONTRACTS:\nWe have two ERC20 tokens and the main lending contract which provide functionalities such as depositing into liquidity pool by LPs, getLoan function that gives loan to the borrower, repayLoan where user can repay the loan with the interest. The borrower has to deposit the collateral for taking the loan and if the user is unable to pay the loan, their collateral will be locked in the pool forever.\nThe contracts are deployed on sapphire, which ensure the encryption and security of all the addresses being used. ROFL APP\nThe ROFL app has 3 main parts: The rust app which calls the data of the price of the 2 tokens in the decentralized TEE, the solidity contract written on hardhat, which pushes all the data coming periodically on chain, and finally the ts file, which allows us to interact with the deployed chain. Alternatively, the deployed solidity contract is also called in the front-end, which shows the live price of both the tokens as the state changes, and from where the prices is used to calculate the maximum allowed loan and auto-liquidation conditions.",
        "how_its_made": "FRONTEND:\nFor the frontend of our dapp, we have used react.js famework and bootstrap, material UI\nfor the CSS of our dapp. ethers.js library is used to call the smart contract functions from the frontend. SMART CONTRACTS:\nWe have two ERC20 tokens and the main lending contract which provide functionalities such as depositing into liquidity pool by LPs, getLoan function that gives loan to the borrower, repayLoan where user can repay the loan with the interest. The borrower has to deposit the collateral for taking the loan and if the user is unable to pay the loan, their collateral will be locked in the pool forever.\nThe contracts are deployed on sapphire, which ensure the encryption and security of all the addresses being used. ROFL APP\nThe ROFL app has 3 main parts: The rust app which calls the data of the price of the 2 tokens in the decentralized TEE, the solidity contract written on hardhat, which pushes all the data coming periodically on chain, and finally the ts file, which allows us to interact with the deployed chain. Alternatively, the deployed solidity contract is also called in the front-end, which shows the live price of both the tokens as the state changes, and from where the prices is used to calculate the maximum allowed loan and auto-liquidation conditions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jrbsc/screenshots/jh41i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jrbsc/screenshots/vfnxk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jrbsc/screenshots/4z0tj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jrbsc/screenshots/wwb5w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jrbsc/screenshots/77m3d/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/barrytra/project",
        "link": "https://ethglobal.com/showcase/lendingsapphire-jrbsc"
    },
    {
        "title": "starknet-zk-verifier",
        "brief_description": "A repository where I show how to use cairo and garaga to veryfy zk-SNARKS on starknet",
        "long_description": "The starknet-zkproof-verifier project demonstrates how to verify zk-SNARKs (Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge) on StarkNet, a layer-2 scalability solution for Ethereum. The project involves two main parts: Starknado-Cash: This section shows an attempt to implement Tornado Cash functionality (a privacy-preserving protocol) on StarkNet, enabling private transactions. The Starknado-Cash system leverages zk-SNARKs to ensure anonymity. I made the project using:",
        "how_its_made": "I made the project using:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ms19y/screenshots/0may1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ms19y/screenshots/idedb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ms19y/screenshots/q7kkq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/fabriziogianni7/starknet-zkproof-verifier",
        "link": "https://ethglobal.com/showcase/starknet-zk-verifier-ms19y"
    },
    {
        "title": "starknet-zk-verifier",
        "brief_description": "A repository where I show how to use cairo and garaga to veryfy zk-SNARKS on starknet",
        "long_description": "The starknet-zkproof-verifier project demonstrates how to verify zk-SNARKs (Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge) on StarkNet, a layer-2 scalability solution for Ethereum. The project involves two main parts: Starknado-Cash: This section shows an attempt to implement Tornado Cash functionality (a privacy-preserving protocol) on StarkNet, enabling private transactions. The Starknado-Cash system leverages zk-SNARKs to ensure anonymity. I made the project using:",
        "how_its_made": "I made the project using:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ms19y/screenshots/0may1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ms19y/screenshots/idedb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ms19y/screenshots/q7kkq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/fabriziogianni7/starknet-zkproof-verifier",
        "link": "https://ethglobal.com/showcase/starknet-zk-verifier-ms19y"
    },
    {
        "title": "MultiVault",
        "brief_description": "A Decentralized Multichain Asset Management Protocol with focus on security and risk management.",
        "long_description": "MultiVaul is an innovative system designed to manage digital assets across multiple blockchains while ensuring security, efficiency, and flexibility. This protocol leverages cutting-edge technologies such as ERC6551 for advanced NFT-based asset ownership, LayerZero for omnichain communication, Chainlink oracles for reliable price and volatility data, and Uniswap for decentralized trading with built-in risk management. Together, these components create a robust framework for seamless cross-chain asset management, tailored to meet the needs of both managers and depositors. I used solidity for the smart contracts, leveraging some standards like ERC6551, ERC721, ERC20 and others. I also leverage chainlink libraries for datafeed of prices and volatility rates of assets, uniswap libraries to create a risk management hook. I have a simple frontend to interact with this, it's written in React and uses ethers.js.",
        "how_its_made": "I used solidity for the smart contracts, leveraging some standards like ERC6551, ERC721, ERC20 and others. I also leverage chainlink libraries for datafeed of prices and volatility rates of assets, uniswap libraries to create a risk management hook. I have a simple frontend to interact with this, it's written in React and uses ethers.js.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/o583a/screenshots/ujao1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o583a/screenshots/aamrv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o583a/screenshots/brtf5/default.jpg"
        ],
        "live_demo": "https://ethsingapore-2024.vercel.app/",
        "source_code": "https://github.com/luiz-lvj/ethsingapore-2024",
        "link": "https://ethglobal.com/showcase/multivault-o583a"
    },
    {
        "title": "EZKPoll",
        "brief_description": "EzkPoll, the most comfortable polling system in Web3. It utilizes MACI to empower ZK on polling and A/B testing.",
        "long_description": "Introduction:\nEzkPoll, built with MACI, offers zero-knowledge polling and A/B testing, combining the comfort of Web2 with the power of Web3. It empowers organizers with reliable results while enabling users to poll anonymously, ensuring every voice counts towards impactful decisions. Problem Statement:\nExisting opinion polls lack transparency, leaving people questioning their validity. Thus, we propose a transparent and trustworthy polling system. This system can also ensure anonymity on polling participants. Solution: Our solution allows organizers to set up A/B tests or poll questions effortlessly. Leveraging MACI, we develop a reliable, user-friendly platform. For organizers, we streamline the setup process, while for participants, we ensure a seamless experience with privacy protection through Web3 technology and social login. Conclusion:\nWe invite you to review our pitch deck and demo video. Your feedback on EzkPoll's solution is valuable to us. Reach out and share your thoughts on how we can enhance the polling experience together. Pitch Deck:\nhttps://pitch.com/v/ezkpoll-pitch-deck-3qciuw/d5a9c82a-68db-4179-b418-547d341c9833 Demo Site:\nhttps://ezkpoll.onrender.com/ Frontend Tech:\nNext.js React Tailwind for Building Frontend tech.\nUse Figma to beautify frontend first. then create frontend\nBackend:\nNodejs, Postgres DB\nfor saving polling data and other information. Contract:\nMACI, Solidity, Circom\nFor calculate polling result\nAlso ensure anonymity and Privacy\nFLOW [\u2713] VkRegistry deployed at: 0x98757A83811aBFdCB62744d3BA0c50Ac613A8Ce8\nFLOW [\u2713] MACI deployed at:  0x79068D623dE9A3173c7b71F2B266b07C4e3EFf88\nFLOW [i] Transaction hash: 0x753cbfbb2a358d0b2c3d5f1fc2e07e765c7a8cd1c30565f391519447b4439455 [i] Poll ID: 0\n[i] Poll contract: 0xFE1BbE10A52B70efF41BBBcA0a88233221bD7F90\n[i] Message Processor contract: 0x08a3D50eacAa6130487057c939B01B0195F6Dbcc\n[i] Tally contract: 0x5Dd10A3870238aC1E3b8c5D6D1402d8c2BFac736",
        "how_its_made": "Frontend Tech:\nNext.js React Tailwind for Building Frontend tech.\nUse Figma to beautify frontend first. then create frontend\nBackend:\nNodejs, Postgres DB\nfor saving polling data and other information. Contract:\nMACI, Solidity, Circom\nFor calculate polling result\nAlso ensure anonymity and Privacy\nFLOW [\u2713] VkRegistry deployed at: 0x98757A83811aBFdCB62744d3BA0c50Ac613A8Ce8\nFLOW [\u2713] MACI deployed at:  0x79068D623dE9A3173c7b71F2B266b07C4e3EFf88\nFLOW [i] Transaction hash: 0x753cbfbb2a358d0b2c3d5f1fc2e07e765c7a8cd1c30565f391519447b4439455 [i] Poll ID: 0\n[i] Poll contract: 0xFE1BbE10A52B70efF41BBBcA0a88233221bD7F90\n[i] Message Processor contract: 0x08a3D50eacAa6130487057c939B01B0195F6Dbcc\n[i] Tally contract: 0x5Dd10A3870238aC1E3b8c5D6D1402d8c2BFac736",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/x37xw/screenshots/bu2g0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x37xw/screenshots/bnw2i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x37xw/screenshots/bc52x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x37xw/screenshots/ajyua/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/abcd5251/EzkPoll",
        "link": "https://ethglobal.com/showcase/ezkpoll-x37xw"
    },
    {
        "title": "Unify Finance",
        "brief_description": "Reputation pool subscribers and portfolio manager across different wallets",
        "long_description": "Our project tackles different components. Firstly, we are proposing a reputation mechanism for liquidity pool on Uniswap. The idea is to leverage the 'ISubscriber' interface from Uniswap to monitor the pool movement and be able to produce a score for each users. We also, interested in hook development to proposed different strategy. We focus our attention our two main approaches: one hook for stable coin pool where after a swap we wanted to adjust the pool reserve. And another hook where we wanted to do a dynamic tick adjustment. In this specific case, we wanted to rotate liquidity tick limit after a swap to maintain and liquidity concentration. This scenario can happened when we have a large order on the pool, where it has no impact on other pool, and the user have approve before hand the pool rebalancing. Finally, we wanted to provide an interface where users can monitor their positions and manage in a single interface all the possible actions. We are relying on Near protocol to generate and manage multiple wallets through a single near wallet. Regarding the Uniswap subscriber, we are relying on the 'ISubscriber' interface. We then create a Reputation contract that manage all the logic for the reputation. The idea is to track all the open position provided by a user and build a reputation score from it. The longer the user provide liquidity, the higher the reputation will be. For the reputation, we are looking at the amount of the two tokens provided. Then, when the user transfer liquidity or remove one, we are removing from our tracking list the token. Notice that if the number of token is less that the total position, we still want to compound previous token based on the initial time deposit. On the Near integration, we have build on top of the template provided. We also try to simplify the chain behavior by starting to think on a SDK approach where we could simplify process that are common across the different chains.",
        "how_its_made": "Regarding the Uniswap subscriber, we are relying on the 'ISubscriber' interface. We then create a Reputation contract that manage all the logic for the reputation. The idea is to track all the open position provided by a user and build a reputation score from it. The longer the user provide liquidity, the higher the reputation will be. For the reputation, we are looking at the amount of the two tokens provided. Then, when the user transfer liquidity or remove one, we are removing from our tracking list the token. Notice that if the number of token is less that the total position, we still want to compound previous token based on the initial time deposit. On the Near integration, we have build on top of the template provided. We also try to simplify the chain behavior by starting to think on a SDK approach where we could simplify process that are common across the different chains.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9dipd/screenshots/hizbp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9dipd/screenshots/4821q/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9dipd/screenshots/fkfys/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/RegisGraptin/ETHGlobalSingapore",
        "link": "https://ethglobal.com/showcase/unify-finance-9dipd"
    },
    {
        "title": "Wheelswap",
        "brief_description": "Select the amount of crypto to swap and spin the wheel to receive a random cryptocurrency",
        "long_description": "Wheelswap enables users to swap their crypto in a new and exciting way. First, the user specifies the cryptocurrency and amount of it to swap. Users can pick from cbBTC, DEGEN, or WETH. Then, the user spins the wheel to determine which cryptocurrency they will receive, with a chance of winning big. We created the frontend with TypeScript and Flutter. For the backend, we used Solidity to create the smart contract and randomize the outcome of spinning the wheel, Dynamic to enable the user to connect their wallet, and Uniswap to implement the swapping functionality. Dynamic made it trivial for users to connect any wallet to our marketplace.",
        "how_its_made": "We created the frontend with TypeScript and Flutter. For the backend, we used Solidity to create the smart contract and randomize the outcome of spinning the wheel, Dynamic to enable the user to connect their wallet, and Uniswap to implement the swapping functionality. Dynamic made it trivial for users to connect any wallet to our marketplace.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ihux9/screenshots/5ws4q/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ihux9/screenshots/o77ad/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ihux9/screenshots/3z7sh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/fahimahmedx/wheel-spin",
        "link": "https://ethglobal.com/showcase/wheelswap-ihux9"
    },
    {
        "title": "NearYou",
        "brief_description": "NearYou is a Chrome extension using OpenAI, NEAR Protocol, and Worldcoin for secure verification. It provides real-time insights into NEAR blockchain transactions, simplifying data with AI-driven answers to user questions.",
        "long_description": "NearYou is a cutting-edge Chrome extension designed to bridge the gap between everyday users and the complexities of blockchain technology. By integrating OpenAI, the NEAR Protocol, and Worldcoin for human verification, NearYou offers an intuitive, AI-powered tool that simplifies interaction with NEAR blockchain transactions. How It Works: User Verification with Worldcoin: To ensure the security and integrity of the platform, users are required to verify their identity using Worldcoin. Worldcoin leverages advanced biometric technology to confirm that the person interacting with NearYou is a real human, safeguarding the extension from bots or malicious actors. This verification occurs before users can access the main features of the extension, ensuring a secure and reliable ecosystem. NEAR Protocol Integration: NEAR Protocol is a fast, scalable, and user-friendly blockchain designed to facilitate decentralized applications and smart contracts. Once verified, users can enter transaction hashes or related queries into the extension, which fetches live data from the NEAR blockchain in real time. This allows users to view specific transaction details, including transfers, contract executions, or token balances. AI-Powered Analysis with OpenAI: The core functionality of NearYou revolves around OpenAI. Users can ask questions about the transaction details, and the AI interprets this data, providing a clear and easy-to-understand explanation. For instance, instead of reading through complex transaction logs or smart contract codes, users can simply ask questions like: \"What does this transaction do?\"\n\"Which wallet sent these tokens?\"\n\"What is the purpose of this smart contract?\"\nOpenAI processes the blockchain data, explains the transaction in human-readable terms, and answers any follow-up questions. This makes understanding blockchain data as simple as chatting with an assistant, enabling even non-technical users to gain insights into how NEAR transactions work. Features:\n1)Human Verification: Secure access to the extension is provided via Worldcoin's biometric authentication, ensuring the system is safeguarded against bots and automated threats.\n2)Transaction Exploration: Users can input a NEAR transaction hash and receive detailed information about the transaction, including sender, receiver, amounts, and contract interactions.\n3)AI-Driven Insights: Powered by OpenAI, NearYou allows users to ask natural language questions about blockchain transactions, providing a simplified explanation of complex technical data.\n4)User-Friendly Interface: The Chrome extension is designed with ease of use in mind, featuring an intuitive layout that allows even blockchain novices to interact with NEAR data without a steep learning curve. Benefits:\nSimplicity: NearYou reduces the technical barrier to understanding blockchain transactions by offering AI-driven explanations in plain language.\nSecurity: Worldcoin\u2019s biometric verification adds an extra layer of security, ensuring that the platform is only accessible to real people.\nReal-Time Data: The extension taps directly into the NEAR Protocol, ensuring users receive up-to-date information on their queries.\nOpenAI-Powered: Users benefit from advanced natural language processing, which makes even complex blockchain interactions digestible and actionable. When we first set out to create NearYou, we faced a challenge that many in the blockchain space grapple with\u2014making complex transaction data understandable for the average user. We were fascinated by how powerful NEAR Protocol was, but we also knew that explaining blockchain transactions in plain language required more than just the usual tools. That\u2019s where AI came in. Initially, we asked ourselves, \"What if we could combine the interpretive power of AI with blockchain to make NEAR more accessible to everyone?\" The idea was exciting, but it wasn't without its hurdles. Merging AI with a decentralized protocol wasn\u2019t something that had been widely explored yet, especially in a way that could break down transactions in real-time. So, we took the plunge, deciding to integrate OpenAI with NEAR to build an intuitive, human-friendly interface for blockchain analysis. We didn't stop there, though. One of the biggest issues with any web application, especially one involving financial data, is ensuring security and user verification. That\u2019s where Worldcoin came in. We leveraged their cutting-edge biometric technology to verify users as real humans before allowing them to interact with NearYou. This step was critical\u2014not only to protect against bots but also to build trust among users who were interacting with sensitive blockchain data. Partner Technologies:\nWorldcoin was a game-changer. By ensuring that only verified, human users could access the app, we were able to enhance the platform\u2019s security and prevent unwanted access.\nNEAR Protocol brought scalability, speed, and a user-friendly blockchain experience. NEAR\u2019s focus on usability and its thriving ecosystem made it the perfect choice to base our extension on.\nBut what's really notable about this project is that NEAR Protocol and OpenAI together created an almost AI-driven experience for blockchain interaction. With AI becoming the backbone of so many innovations today, we thought, \"Why not push this forward into the blockchain space too?\" Even though this was uncharted territory, we managed to pull it off by blending AI\u2019s analytical capabilities with the decentralized nature of NEAR. The result is a seamless, AI-enhanced tool that turns technical blockchain data into understandable insights, all while ensuring the utmost security through biometric verification. It was new, it was challenging, but we made it work\u2014better than we initially imagined. And in a world increasingly driven by AI, we think this is just the beginning.",
        "how_its_made": "When we first set out to create NearYou, we faced a challenge that many in the blockchain space grapple with\u2014making complex transaction data understandable for the average user. We were fascinated by how powerful NEAR Protocol was, but we also knew that explaining blockchain transactions in plain language required more than just the usual tools. That\u2019s where AI came in. Initially, we asked ourselves, \"What if we could combine the interpretive power of AI with blockchain to make NEAR more accessible to everyone?\" The idea was exciting, but it wasn't without its hurdles. Merging AI with a decentralized protocol wasn\u2019t something that had been widely explored yet, especially in a way that could break down transactions in real-time. So, we took the plunge, deciding to integrate OpenAI with NEAR to build an intuitive, human-friendly interface for blockchain analysis. We didn't stop there, though. One of the biggest issues with any web application, especially one involving financial data, is ensuring security and user verification. That\u2019s where Worldcoin came in. We leveraged their cutting-edge biometric technology to verify users as real humans before allowing them to interact with NearYou. This step was critical\u2014not only to protect against bots but also to build trust among users who were interacting with sensitive blockchain data. Partner Technologies:\nWorldcoin was a game-changer. By ensuring that only verified, human users could access the app, we were able to enhance the platform\u2019s security and prevent unwanted access.\nNEAR Protocol brought scalability, speed, and a user-friendly blockchain experience. NEAR\u2019s focus on usability and its thriving ecosystem made it the perfect choice to base our extension on.\nBut what's really notable about this project is that NEAR Protocol and OpenAI together created an almost AI-driven experience for blockchain interaction. With AI becoming the backbone of so many innovations today, we thought, \"Why not push this forward into the blockchain space too?\" Even though this was uncharted territory, we managed to pull it off by blending AI\u2019s analytical capabilities with the decentralized nature of NEAR. The result is a seamless, AI-enhanced tool that turns technical blockchain data into understandable insights, all while ensuring the utmost security through biometric verification. It was new, it was challenging, but we made it work\u2014better than we initially imagined. And in a world increasingly driven by AI, we think this is just the beginning.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pvf28/screenshots/jkt3h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pvf28/screenshots/31gsz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pvf28/screenshots/2q0v8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pvf28/screenshots/7ahd4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pvf28/screenshots/qn3wh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pvf28/screenshots/b1ue9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/dhivya910/nearAI-Assist",
        "link": "https://ethglobal.com/showcase/nearyou-pvf28"
    },
    {
        "title": "TrendMarket",
        "brief_description": "TrendMarket is an innovative prediction market using LLM technology to create and execute markets with minimal human involvement. It addresses liquidity fragmentation by having LLMs select popular markets and automatically determine outcomes through multi-LLM voting.",
        "long_description": "What We Are Solving: In prediction markets, there exists a dilemma between the quality/quantity of markets available and the fragmentation of liquidity. While markets should leverage user preferences to create appealing opportunities, the more markets that are created, the more liquidity gets fragmented, leading to a poor user experience. We solve this problem by utilizing AI-driven curation. Another issue in existing prediction markets is the presence of trust points in every aspect\u2014market creation, matching, and execution (e.g., Polymarket's operations). These markets rely heavily on human intervention. In contrast, our product enables likely fully on-chain transactions without the involvement of malicious actors, covering everything from market creation to trading and closing. Additionally, existing prediction markets often use oracles like Chainlink or UMA. However, these oracles cannot be considered fully trustless. Since they rely on trusted nodes or token-based decision mechanisms, they cannot fundamentally prevent attacks when there is a market with returns that outweigh the cost. We address this issue by using a collective decision-making process powered by multiple AIs. Overview of the Application: This application is divided into three main components: the creation of market topics for the prediction market, the AMM contract where users buy and sell tokens, and the integration of proposal outcomes determined by LLMs. For the AMM contract, we have implemented the CPAMM, which is commonly used in prediction markets. The creation of proposals and the determination of their outcomes are handled by LLMs, eliminating the influence of malicious actors or staking-based manipulation. Application Details: The involved entities are the market creators, prediction market participants, as well as the LLM and the AMM smart contract. Prediction Market Creation b. Preventing Liquidity Fragmentation c. Market Details Setup Token Trading via AMM Existing prediction markets often rely on oracles like Chainlink and UMA. Chainlink is operated by trusted third-party nodes, and information is updated quickly, with nodes building reputation. On the other hand, UMA uses an Optimistic Oracle, where participants vote using UMA tokens if there is opposition within a set period. However, neither Chainlink nor UMA can be considered fully trustless. Whether due to node trust or token-based voting, they cannot fully prevent attacks if a market exists where the returns exceed the cost. We solve this issue by using a consensus-driven approach involving multiple Als. To build this prediction market, I implemented a Constant Product AMM in Solidity, referencing Uniswap V2's AMM. The created contracts were deployed on both AirDAO and Ethereum testnets, and I accessed their information using Dynamic and ether.js.\nA particularly notable and innovative feature is the dynamic market generation system that utilizes the OpenAI API. This system automatically generates markets from news articles and deploys them on the blockchain. This allows us to provide prediction markets based on the most current topics.\nThe project combines various technologies, including Solidity for smart contract development, blockchain networks (AirDAO and Ethereum testnets) for deployment, Dynamic and ether.js for interfacing with the blockchain, and the OpenAI API for generating market content.\nThe integration of AI-powered market generation with blockchain technology is a unique aspect of this project, enabling real-time creation of relevant prediction markets based on current events.",
        "how_its_made": "To build this prediction market, I implemented a Constant Product AMM in Solidity, referencing Uniswap V2's AMM. The created contracts were deployed on both AirDAO and Ethereum testnets, and I accessed their information using Dynamic and ether.js.\nA particularly notable and innovative feature is the dynamic market generation system that utilizes the OpenAI API. This system automatically generates markets from news articles and deploys them on the blockchain. This allows us to provide prediction markets based on the most current topics.\nThe project combines various technologies, including Solidity for smart contract development, blockchain networks (AirDAO and Ethereum testnets) for deployment, Dynamic and ether.js for interfacing with the blockchain, and the OpenAI API for generating market content.\nThe integration of AI-powered market generation with blockchain technology is a unique aspect of this project, enabling real-time creation of relevant prediction markets based on current events.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/kummv/screenshots/ytkbm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kummv/screenshots/1k3p9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kummv/screenshots/9q7f2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kummv/screenshots/uiwzu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kummv/screenshots/a79yn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kummv/screenshots/ivatb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/maobushi/trend-market",
        "link": "https://ethglobal.com/showcase/trendmarket-kummv"
    },
    {
        "title": "ChillVille",
        "brief_description": "We built a private onchain voting system with sybil resistance by combining MACI and zkTLS. This allows for fairer governance by eliminating bribery and collusion, and enabling private voting based on off-chain contributions.",
        "long_description": "This project combines MACI (Minimum Anti-Collusion Infrastructure) and zkTLS to build a private, sybil-resistant onchain voting system. The goal is to address two major challenges in onchain governance: vote transparency and sybil attacks.\nOnchain voting is a critical component of decentralized governance, but individual votes are often made public, which can lead to bribery, collusion, and undue influence. Moreover, preventing sybil attacks\u2014where malicious actors use multiple identities to manipulate votes\u2014remains difficult. Relying solely on onchain mechanisms to solve these problems is challenging, and integrating off-chain data into Web3 applications presents its own difficulties. To tackle these issues, we integrated MACI, zkTLS, and zkML. MACI is a private onchain voting infrastructure that uses encryption and zero-knowledge proofs to keep individual votes private while revealing only the final results, enabling privacy-preserving onchain voting. zkTLS is a protocol that serves as a gateway between private Web2 data and the Web3 ecosystem. Users can securely export their data from any website, generate zk-proofs, and have them verified by any verifier or smart contract. This allows off-chain data to be used portably, privately, and permissionlessly. By combining MACI and zkTLS, we have created a sybil-resistant, private onchain voting system that incorporates off-chain data. Additionally, zkML is a technology that proves the inference results from specific models without revealing the input data, expanding the scope of verifiable private Web2 data. By integrating these technologies, we enable off-chain contributions to be flexibly portable, verifiable through zkTLS and zkML, and fed into MACI, achieving a sybil-resistant, private onchain voting system based on off-chain activities. Our project leverages a combination of cutting-edge technologies\u2014MACI, zkTLS, and zkML\u2014to create a sybil-resistant, private on-chain voting system that integrates off-chain data securely. MACI (Minimal Anti-Collusion Infrastructure): zkTLS Protocol (zkPass): zkML (Zero-Knowledge Machine Learning):",
        "how_its_made": "Our project leverages a combination of cutting-edge technologies\u2014MACI, zkTLS, and zkML\u2014to create a sybil-resistant, private on-chain voting system that integrates off-chain data securely. MACI (Minimal Anti-Collusion Infrastructure): zkTLS Protocol (zkPass): zkML (Zero-Knowledge Machine Learning):",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6zo6g/screenshots/z4go9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6zo6g/screenshots/95ok6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6zo6g/screenshots/eg601/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6zo6g/screenshots/bm1do/default.jpg"
        ],
        "live_demo": "https://eth-sg.vercel.app/",
        "source_code": "https://github.com/wasabijiro/ChillVille",
        "link": "https://ethglobal.com/showcase/chillville-6zo6g"
    },
    {
        "title": "GeorgeAI",
        "brief_description": "Data analytics for airdrop sybil attack detection. 12355-78901354792003774838388383838",
        "long_description": "We use ai and data analytics to detect sybic attacks. We use sklearn and basic python in detecting most common sybic attacks on chainsWe use sklearn and basic python in detecting most common sybic attacks on chains 2563748399393949598595959940292994757282))49_94)_)859173628+\"(\u20ac(\u20ac!(\u20ac(\u20ac(\u20ac(\u20ac((\u20ac( We use sklearn and basic python in detecting most common sybic attacks on. We use ai and data analytics to detect sybic attacks. We use sklearn and basic python in detecting most common sybic attacks on chainsWe use sklearn and basic python in detectingrkkrkkeididieiekiekek most common sybic attacks on chains Yfjdkslldlfldirlrkdldllzlflgkkfkzkzlkzlxlxkxkfnkfkxk",
        "how_its_made": "We use sklearn and basic python in detecting most common sybic attacks on. We use ai and data analytics to detect sybic attacks. We use sklearn and basic python in detecting most common sybic attacks on chainsWe use sklearn and basic python in detectingrkkrkkeididieiekiekek most common sybic attacks on chains Yfjdkslldlfldirlrkdldllzlflgkkfkzkzlkzlxlxkxkfnkfkxk",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/owhoa/screenshots/j6i00/default.jpg",
            "https://ethglobal.b-cdn.net/projects/owhoa/screenshots/ham5k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/owhoa/screenshots/esbb6/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AnteroE/sg2024",
        "link": "https://ethglobal.com/showcase/georgeai-owhoa"
    },
    {
        "title": "Refuge Link",
        "brief_description": "Introducing RefugeLink: A pixelated, Nouns-inspired platform using Flow blockchain and USDC for transparent, direct donations to refugees. Empowering them with digital wallets via email and verifying identity through World ID by Worldcoin.",
        "long_description": "Project Name:\nRefugeLink Overview:\nRefugeLink is a blockchain-based platform designed to provide refugees with direct access to financial aid through donations, digital identity verification, and a seamless user experience inspired by the NounsDAO pixelated aesthetic. This project aims to solve the issues faced by refugees\u2014lack of financial access, verifiable identity, and transparency in donation distribution\u2014by leveraging Flow blockchain, USDC, and World ID by Worldcoin. The platform is not only a technical solution but also an accessible and community-friendly interface, using a pixelated design similar to NounsDAO branding. This aesthetic choice is meant to attract attention, create a recognizable identity, and make the platform easy to engage with for users and potential donors. Key Features:\nPixelated, Nouns-Inspired UI:\nThe platform will have a fun, user-friendly, pixelated user interface (UI), drawing inspiration from the NounsDAO ecosystem. The design is meant to be visually striking and recognizable, encouraging engagement and setting the platform apart from more conventional blockchain solutions. The pixelated avatars and branding aim to appeal to a broader audience and increase participation. Flow Blockchain Integration:\nFlow blockchain will be the backbone of the platform due to its high scalability, low transaction costs, and ease of development. Flow enables secure and efficient transactions, ensuring that donations can be made transparently and without high fees. This will allow the platform to handle donations from a global audience, ranging from micro-donations to larger contributions, making sure that every transaction is transparent and trackable. USDC for Donations:\nRefugeLink will use USDC (USD Coin), a stablecoin backed by the U.S. dollar, for handling all financial transactions on the platform. By using USDC, the platform ensures that donations are stable in value, avoiding the volatility often seen in other cryptocurrencies. Refugees will receive USDC directly into their digital wallets, which they can use for immediate purchases or convert into their local currencies. The integration of a stablecoin allows for seamless, cross-border payments without the need for a traditional bank account, making it particularly beneficial for refugees. World ID Verification via Worldcoin:\nMany refugees face challenges proving their identity, which restricts their access to services and financial aid. By integrating World ID from Worldcoin, RefugeLink provides a secure, verifiable digital identity. World ID offers proof-of-personhood through biometric verification (e.g., iris scans) in a privacy-preserving manner. This ensures that each user on the platform is unique and verified without requiring traditional identification documents, which many refugees lack. Reown Email-based Wallet Creation:\nFor refugees, creating a wallet can be a barrier, as many lack the knowledge or access to create traditional cryptocurrency wallets. Reown allows users to create a digital wallet simply by signing up with an email address, bypassing the complexity of blockchain technology. This feature ensures that anyone, even those unfamiliar with crypto, can easily receive donations and access their funds. How RefugeLink Works:\nUser Onboarding and Identity Verification: A refugee signs up on RefugeLink using their email, which generates a Reown wallet.\nThe refugee\u2019s identity is verified via Worldcoin\u2019s World ID, providing them with a digital identity linked to their wallet.\nThe system ensures privacy while confirming the person\u2019s identity, ensuring that each wallet is tied to a real, unique individual without needing traditional documentation.\nDonations: Donors can visit the RefugeLink platform and select individual refugees or refugee groups to support. The platform allows for one-time or recurring donations.\nDonations are made in USDC, ensuring stability and transparency. USDC is preferred for its low volatility and wide acceptance.\nFlow blockchain ensures that these donations are securely and efficiently recorded. Each transaction is auditable and can be tracked on the blockchain, ensuring complete transparency for donors.\nReceiving Funds: Once donations are made, the refugee receives USDC in their Reown wallet.\nThey can use the funds to purchase necessities, transfer to other accounts, or convert the USDC to their local currency through various crypto exchanges or financial services.\nRefugees can manage their wallets through the RefugeLink platform, which provides an easy-to-use interface for sending, receiving, and tracking funds.\nWhy RefugeLink Matters:\nEmpowering Refugees with Financial Independence:\nBy giving refugees direct access to financial aid through digital wallets, RefugeLink provides them with immediate, secure funds. This eliminates the dependency on traditional aid distribution channels, which can often be slow, inefficient, or prone to corruption. Secure and Transparent Donation System:\nOne of the main challenges in donating to causes such as refugee aid is the lack of transparency. Donors often have little visibility into how their funds are used. RefugeLink addresses this issue by using blockchain technology to make every donation trackable and auditable. Donors can see exactly where their money goes and how it impacts the recipients. Accessibility and Ease of Use:\nMany refugees face barriers to accessing financial systems, whether due to a lack of ID, a bank account, or technological knowledge. RefugeLink eliminates these obstacles by providing an easy-to-use, email-based wallet creation system with Reown and a clear, simple interface. This ensures that even those unfamiliar with blockchain can still benefit from the platform. Global Reach and Scalability:\nFlow blockchain\u2019s efficiency and scalability allow RefugeLink to handle donations from a global community. The platform can process thousands of transactions seamlessly, ensuring that even micro-donations reach their destination without incurring high fees. Stablecoin Advantage:\nBy using USDC, the platform avoids the volatility often seen in cryptocurrencies, providing refugees with funds that retain their value over time. This ensures that donations have a consistent, reliable impact. Digital Identity for All:\nThe use of Worldcoin\u2019s World ID ensures that each refugee has a secure, verifiable identity, enabling them to access not just RefugeLink\u2019s services but potentially other platforms that require proof of identity. This also opens doors for refugees to access other forms of aid, employment opportunities, and services in the future. Future Plans:\nExpanding Services:\nIn the future, we aim to integrate additional services, such as financial literacy tools, access to education, and healthcare, directly through the platform. Refugees will be able to use their verified digital identity to access a wider range of services securely. Partnerships with NGOs:\nBy partnering with humanitarian organizations, RefugeLink can serve as a trusted tool for distributing aid and managing resources. NGOs could use the platform to allocate funds transparently, ensuring that resources reach the intended recipients. Growing the Donor Community:\nRefugeLink plans to grow its donor base by engaging with corporate sponsors, philanthropists, and individuals looking for transparent, impactful ways to support refugees. The pixelated NounsDAO-inspired design also makes the platform appealing to Web3 communities and NFT enthusiasts who align with decentralized charity efforts. Conclusion:\nRefugeLink combines cutting-edge blockchain technology with a human-centric design, allowing refugees to receive donations securely, directly, and transparently. With Flow blockchain ensuring scalability, USDC providing stability, and World ID securing identities, the platform revolutionizes how aid is distributed and managed. Flow Blockchain for Handling Donations\nWe used Flow blockchain to manage all the donations because it's fast, cheap, and scalable. With small donations coming in regularly, Flow was the perfect choice for ensuring we wouldn\u2019t run into high transaction fees or slow speeds. What we did:\nWe wrote smart contracts on Flow that handle the donation flow. Whenever someone donates USDC, the contract processes the transaction and sends it to the refugee\u2019s wallet. Using Flow\u2019s SDK, we integrated these contracts with the back-end so donations are instantly reflected on the front-end.\nUSDC for Stable Donations\nTo avoid the volatility common in other cryptos like BTC or ETH, we went with USDC\u2014a stablecoin pegged to the U.S. dollar. This made sure that both donors and refugees wouldn\u2019t have to worry about the value of their donations fluctuating. What we did:\nWe set up Flow to natively support USDC for transactions. Donors contribute in USDC, and it goes directly into the refugee\u2019s Flow-based wallet. USDC stays stable, so the refugees can use or convert it without worrying about losing value.\nReown for Email-based Wallet Creation\nWe knew creating a crypto wallet could be tricky, especially for refugees unfamiliar with blockchain tech. That\u2019s why we integrated Reown, which lets users create wallets simply by signing up with their email. What we did:\nWe hooked up Reown\u2019s API to RefugeLink. When a refugee signs up, their email is used to create a wallet, linked directly to their Flow address. We integrated this into the back-end so that when donations come in, the refugee can manage their funds via their email-linked wallet without needing to mess with private keys or complex setups.\nWorldcoin\u2019s World ID for Identity Verification\nMany refugees don\u2019t have access to traditional IDs, which makes verifying identity a challenge. Worldcoin\u2019s World ID offers a solution by using biometric verification, like an iris scan, to prove a person\u2019s identity without needing physical documents. What we did:\nWe integrated World ID into the sign-up process using Worldcoin\u2019s API. This lets us verify that each refugee is a unique individual, preventing duplicate accounts. After the verification, we store this status alongside their wallet information, ensuring that donations go to real, verified users.\nPixelated, Nouns-Inspired UI with Next.js\nFor the front-end, we chose Next.js to build a clean, fast interface. We decided to make the UI NounsDAO-inspired, using a pixelated aesthetic. The idea was to create something fun and visually distinct, but still functional. What we did:\nThe front end is built using Next.js, which allows for server-side rendering and fast performance. We used Canvas and CSS Grid to dynamically generate pixelated avatars and UI elements. Each refugee gets a unique, pixelated avatar when they sign up, which ties into the overall look and feel of the platform.\nHow It All Fits Together\nNext.js Front-End:\nThe front-end interface is built with Next.js for fast performance and SEO-friendly features. This setup allows us to deliver a fast, server-rendered experience for users while ensuring the platform can scale. The UI is pixelated and designed to look like a playful, NounsDAO-style app, making it more engaging. Flow Blockchain & USDC Transactions:\nDonations are processed using Flow. The smart contracts on Flow handle the flow of funds from the donor to the refugee\u2019s wallet, and it\u2019s all done in USDC for stability. This makes sure transactions are fast, cheap, and reliable. Reown & Wallet Management:\nRefugees create wallets with just their email via Reown. This removes all the usual blockchain complexity, allowing even non-tech-savvy users to easily manage their donations. These wallets are tied directly to their Flow address. World ID for Verification:\nWe verify each refugee using Worldcoin\u2019s World ID, ensuring they\u2019re real, unique individuals. This verification is linked to their wallet, preventing duplicate or fraudulent accounts. The Tech Stack in a Nutshell:\nWe built RefugeLink using Next.js for the front end, Flow for handling transactions, USDC for stable donations, Reown for easy wallet creation, and World ID for secure identity verification. All these tools work together to make a platform that\u2019s both user-friendly and powerful, ensuring refugees can access donations directly and donors know their contributions are going to the right people. *Note UNHCR will verify the refugee status and world coin will be used after for world ID",
        "how_its_made": "Flow Blockchain for Handling Donations\nWe used Flow blockchain to manage all the donations because it's fast, cheap, and scalable. With small donations coming in regularly, Flow was the perfect choice for ensuring we wouldn\u2019t run into high transaction fees or slow speeds. What we did:\nWe wrote smart contracts on Flow that handle the donation flow. Whenever someone donates USDC, the contract processes the transaction and sends it to the refugee\u2019s wallet. Using Flow\u2019s SDK, we integrated these contracts with the back-end so donations are instantly reflected on the front-end.\nUSDC for Stable Donations\nTo avoid the volatility common in other cryptos like BTC or ETH, we went with USDC\u2014a stablecoin pegged to the U.S. dollar. This made sure that both donors and refugees wouldn\u2019t have to worry about the value of their donations fluctuating. What we did:\nWe set up Flow to natively support USDC for transactions. Donors contribute in USDC, and it goes directly into the refugee\u2019s Flow-based wallet. USDC stays stable, so the refugees can use or convert it without worrying about losing value.\nReown for Email-based Wallet Creation\nWe knew creating a crypto wallet could be tricky, especially for refugees unfamiliar with blockchain tech. That\u2019s why we integrated Reown, which lets users create wallets simply by signing up with their email. What we did:\nWe hooked up Reown\u2019s API to RefugeLink. When a refugee signs up, their email is used to create a wallet, linked directly to their Flow address. We integrated this into the back-end so that when donations come in, the refugee can manage their funds via their email-linked wallet without needing to mess with private keys or complex setups.\nWorldcoin\u2019s World ID for Identity Verification\nMany refugees don\u2019t have access to traditional IDs, which makes verifying identity a challenge. Worldcoin\u2019s World ID offers a solution by using biometric verification, like an iris scan, to prove a person\u2019s identity without needing physical documents. What we did:\nWe integrated World ID into the sign-up process using Worldcoin\u2019s API. This lets us verify that each refugee is a unique individual, preventing duplicate accounts. After the verification, we store this status alongside their wallet information, ensuring that donations go to real, verified users.\nPixelated, Nouns-Inspired UI with Next.js\nFor the front-end, we chose Next.js to build a clean, fast interface. We decided to make the UI NounsDAO-inspired, using a pixelated aesthetic. The idea was to create something fun and visually distinct, but still functional. What we did:\nThe front end is built using Next.js, which allows for server-side rendering and fast performance. We used Canvas and CSS Grid to dynamically generate pixelated avatars and UI elements. Each refugee gets a unique, pixelated avatar when they sign up, which ties into the overall look and feel of the platform.\nHow It All Fits Together\nNext.js Front-End:\nThe front-end interface is built with Next.js for fast performance and SEO-friendly features. This setup allows us to deliver a fast, server-rendered experience for users while ensuring the platform can scale. The UI is pixelated and designed to look like a playful, NounsDAO-style app, making it more engaging. Flow Blockchain & USDC Transactions:\nDonations are processed using Flow. The smart contracts on Flow handle the flow of funds from the donor to the refugee\u2019s wallet, and it\u2019s all done in USDC for stability. This makes sure transactions are fast, cheap, and reliable. Reown & Wallet Management:\nRefugees create wallets with just their email via Reown. This removes all the usual blockchain complexity, allowing even non-tech-savvy users to easily manage their donations. These wallets are tied directly to their Flow address. World ID for Verification:\nWe verify each refugee using Worldcoin\u2019s World ID, ensuring they\u2019re real, unique individuals. This verification is linked to their wallet, preventing duplicate or fraudulent accounts. The Tech Stack in a Nutshell:\nWe built RefugeLink using Next.js for the front end, Flow for handling transactions, USDC for stable donations, Reown for easy wallet creation, and World ID for secure identity verification. All these tools work together to make a platform that\u2019s both user-friendly and powerful, ensuring refugees can access donations directly and donors know their contributions are going to the right people. *Note UNHCR will verify the refugee status and world coin will be used after for world ID",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fhpjh/screenshots/4i7x9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fhpjh/screenshots/mvcrh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fhpjh/screenshots/vqyvv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fhpjh/screenshots/5b6bi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fhpjh/screenshots/uygsf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fhpjh/screenshots/f4140/default.jpg"
        ],
        "live_demo": "https://refuge-link.vercel.app/",
        "source_code": "https://github.com/Dharanshi/refugee-support-system",
        "link": "https://ethglobal.com/showcase/refuge-link-fhpjh"
    },
    {
        "title": "maci-tbd",
        "brief_description": "This project use MACI to improve DAO voting with significantly reduced risk of cheating",
        "long_description": "This project use MACI to improve DAO voting with significantly reduced risk of cheating, like bribery or collusion, through the use of Ethereum smart contracts, encryption, and zero-knowledge proofs. Together these technologies provide a set of guarantees including censorship resistance, correct execution, privacy, and a receipt-free voting scheme, which ensures results are transparent but makes it impossible for outsiders to verify how any specific user voted. This project use MACI to improve DAO voting with significantly reduced risk of cheating, like bribery or collusion, through the use of Ethereum smart contracts, encryption, and zero-knowledge proofs. Together these technologies provide a set of guarantees including censorship resistance, correct execution, privacy, and a receipt-free voting scheme, which ensures results are transparent but makes it impossible for outsiders to verify how any specific user voted.",
        "how_its_made": "This project use MACI to improve DAO voting with significantly reduced risk of cheating, like bribery or collusion, through the use of Ethereum smart contracts, encryption, and zero-knowledge proofs. Together these technologies provide a set of guarantees including censorship resistance, correct execution, privacy, and a receipt-free voting scheme, which ensures results are transparent but makes it impossible for outsiders to verify how any specific user voted.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t6cc5/screenshots/ch1xe/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t6cc5/screenshots/3raev/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t6cc5/screenshots/92ou2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/gzeoneth/maci-tbd",
        "link": "https://ethglobal.com/showcase/maci-tbd-t6cc5"
    },
    {
        "title": "puzzle-nouns",
        "brief_description": "Unlock blockchain-themed puzzle pieces by answering quizzes and sharing artwork in twitter! Collect all 27 pieces and receive your Nouns NFT. Each piece is generated based on key words from your answers. Complete the puzzle, share your artwork, and showcase your knowledge!",
        "long_description": "This project is an interactive, blockchain-based puzzle game that combines education, gamification, and social engagement. Users start by providing key words or prompts related to blockchain or other relevant topics, which generate unique puzzle pieces. The goal is to collect all 27 pieces by unlocking them through answering blockchain quizzes and sharing puzzle pieces on social media, particularly on Twitter. Each time a user generates a puzzle piece, they must share it on social media to unlock the next one, creating a viral loop that encourages social interaction and growth. As users continue to prompt and share, they progressively build their puzzle. Once all 27 pieces are collected, the user is rewarded with an exclusive non-fungible token (NFT) representing the completed puzzle. This NFT serves as a token of accomplishment, showcasing the user's journey through the game and their knowledge gained about blockchain technology. The puzzle game is designed to leverage social platforms to enhance engagement, learning, and collaboration. By blending blockchain education with creative prompts and social sharing, users experience a unique and personalised journey while building a puzzle that culminates in a  NFT reward. This project is built using Next.js for both the frontend and backend, with TypeScript ensuring type safety and improved code quality. The application integrates MetaMask for secure user authentication and Ethereum interactions, using the ethers.js library to facilitate transactions and NFT management. A key feature is the use of the Nouns NFT API to generate unique puzzle pieces based on user prompts; when users submit prompts, key words are processed to create visually distinct artwork. To unlock puzzle pieces, users must share their progress on Twitter, utilising the Twitter API for social engagement, which promotes broader visibility for the project. Once all 27 pieces are collected, users receive an NFT minted on the Ethereum blockchain, representing their completed puzzle. The backend, powered by Next.js, handles prompt processing, API interactions, and wallet management, while the frontend offers an interactive React-based UI. A notable hack involved adapting the Nouns API to customise puzzle pieces according to user inputs, enhancing the personalisation feature of our platform. This innovative approach blends education, social sharing, and blockchain technology into a rewarding learning experience.",
        "how_its_made": "This project is built using Next.js for both the frontend and backend, with TypeScript ensuring type safety and improved code quality. The application integrates MetaMask for secure user authentication and Ethereum interactions, using the ethers.js library to facilitate transactions and NFT management. A key feature is the use of the Nouns NFT API to generate unique puzzle pieces based on user prompts; when users submit prompts, key words are processed to create visually distinct artwork. To unlock puzzle pieces, users must share their progress on Twitter, utilising the Twitter API for social engagement, which promotes broader visibility for the project. Once all 27 pieces are collected, users receive an NFT minted on the Ethereum blockchain, representing their completed puzzle. The backend, powered by Next.js, handles prompt processing, API interactions, and wallet management, while the frontend offers an interactive React-based UI. A notable hack involved adapting the Nouns API to customise puzzle pieces according to user inputs, enhancing the personalisation feature of our platform. This innovative approach blends education, social sharing, and blockchain technology into a rewarding learning experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tm17o/screenshots/ncafv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tm17o/screenshots/biitj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tm17o/screenshots/waz7o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tm17o/screenshots/xrqu7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tm17o/screenshots/atk34/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tm17o/screenshots/zf9dy/default.jpg"
        ],
        "live_demo": "https://puzzle-nouns-git-master-donnys-projects-b6709f8a.vercel.app/BuildNft",
        "source_code": "https://github.com/Donnykk/Puzzle_nouns",
        "link": "https://ethglobal.com/showcase/puzzle-nouns-tm17o"
    },
    {
        "title": "Merlion's Bloom",
        "brief_description": "A super simple, consumer-focused, single-player, coin toss game with novel game mechanics, where a player can win a prize by flipping a coin.",
        "long_description": "Merlion\u2019s Bloom is a consumer-focused, single-player game, inspired by Coin Flip, a classic digital game that allows you to flip a virtual coin in the air as if it were a real one, leaving the decision up to chance. Merlion\u2019s Bloom adds a twist by incorporating DeFi and novel game mechanisms that make the game a compelling experience and providing its players with real opportunities to win prizes. Why Merlion\u2019s Bloom? With the theme of Singapore, Merlion\u2019s Bloom blends the Merlion with the idea of blossoming, growth, and cycles in a softer, more organic way. Life is not linear, and weathering and thriving in ups & downs, players should trust the process! How does it work? To participate, a player deposits a specific amount of FLOW tokens, equal to or greater than the current game pool\u2019s liquidity. Only one player can play at a time. Once the deposit is made, the game uses randomness to determine the outcome. The game uses FLOW\u2019s built-in randomness feature (VRF), which ensures the randomness is generated on-chain, without needing any external services to verify it. If a player wins, they receive their entire deposit back plus the same amount\u2014effectively doubling their original stake. For instance, if they deposit 4 FLOW tokens and win, they will receive 8 FLOW tokens in total. This is often referred to as \u201cDouble or Nothing.\u201d If a player loses, they forfeit their deposit, which gets added to the game\u2019s pool. The next player will then need to deposit an amount that matches or exceeds the updated pool\u2019s liquidity to play. The game pool\u2019s liquidity grows with each loss, while winnings come from previous players\u2019 deposits, supported by an initial reserve pool to keep the game running. Merlion\u2019s Bloom is an end-to-end, fully functional, live project built using several components. The UI (web application) is built with Next.JS and React components, leveraging the Reown AppKit to allow players to seamlessly sign in and connect to the app. The underlying smart contracts that hold the novel game mechanics are written in solidity, completely functional, and deployed live to FLOW's mainnet. The project leverages FLOW's built-in randomness feature (VRF), which ensures the randomness is generated on-chain, without needing any external services (e.g. Oracles) to verify it. This provides a much simpler developer experience and also makes the Merlion\u2019s Bloom app fair for all players. The middleware connecting the smart contracts with the UI uses Envio's easy-to-use indexing framework that supports any EVM blockchain using RPC, in this case, we used FLOW's publicly available RPC to index, query, and present our smart contract data in the Merlion's Bloom Front-End UI. Integrating the Reown AppKit supports Merlin's Bloom's mission of being a super simple, intuitive, onboarding-friendly, consumer crypto app, allowing us to seamlessly onboard users in minutes with social & email embedded wallets, web3 wallet login. Unfortunately, Reown AppKit did not support social logins on the Flow EVM chain.",
        "how_its_made": "Merlion\u2019s Bloom is an end-to-end, fully functional, live project built using several components. The UI (web application) is built with Next.JS and React components, leveraging the Reown AppKit to allow players to seamlessly sign in and connect to the app. The underlying smart contracts that hold the novel game mechanics are written in solidity, completely functional, and deployed live to FLOW's mainnet. The project leverages FLOW's built-in randomness feature (VRF), which ensures the randomness is generated on-chain, without needing any external services (e.g. Oracles) to verify it. This provides a much simpler developer experience and also makes the Merlion\u2019s Bloom app fair for all players. The middleware connecting the smart contracts with the UI uses Envio's easy-to-use indexing framework that supports any EVM blockchain using RPC, in this case, we used FLOW's publicly available RPC to index, query, and present our smart contract data in the Merlion's Bloom Front-End UI. Integrating the Reown AppKit supports Merlin's Bloom's mission of being a super simple, intuitive, onboarding-friendly, consumer crypto app, allowing us to seamlessly onboard users in minutes with social & email embedded wallets, web3 wallet login. Unfortunately, Reown AppKit did not support social logins on the Flow EVM chain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/niy74/screenshots/31kex/default.jpg",
            "https://ethglobal.b-cdn.net/projects/niy74/screenshots/usqzn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/niy74/screenshots/wiaqd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/niy74/screenshots/hf05u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/niy74/screenshots/j0wfw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/niy74/screenshots/j78b4/default.jpg"
        ],
        "live_demo": "https://merlions-bloom.vercel.app/",
        "source_code": "https://github.com/DenhamPreen/merlions-bloom",
        "link": "https://ethglobal.com/showcase/merlions-bloom-niy74"
    },
    {
        "title": "SecureFi",
        "brief_description": "SecureFi is a privacy-first platform using Mina Protocol for secure, encrypted financial data sharing via zero-knowledge proofs, while also offering separate USDC/MINA DeFi lending services. Users maintain full privacy and control over their data during loan approvals.",
        "long_description": "SecureFi is a privacy-focused platform that offers two key services: secure financial data sharing and DeFi lending. Using Mina Protocol and zero-knowledge proofs (ZKPs), the platform allows users to share their wallet portfolios in an encrypted form with institutions for processes like loan approvals, visa applications, and job screenings. This ensures that users' sensitive financial data remains private and accessible only to authorized recipients, giving them full control over what is shared and with whom. In addition to secure data sharing, SecureFi offers a standalone DeFi lending service where users can borrow USDC and MINA. The lending platform operates independently of the data-sharing service, allowing users to access funds while maintaining full privacy over their financial information. With a focus on both privacy and utility, SecureFi aims to revolutionize how users interact with financial institutions in a decentralized manner. SecureFi is built using a combination of cutting-edge decentralized technologies with a focus on privacy, data security, and DeFi lending. The project integrates the following key components: Mina Protocol: At the core of SecureFi is Mina Protocol, known for its lightweight blockchain and privacy features. We leveraged zero-knowledge proofs (ZKPs) to enable secure, privacy-preserving financial data sharing. By using Protokit, we created off-chain computations and proofs that allow users to securely share their wallet portfolios with authorized parties, ensuring that sensitive financial data remains encrypted and only accessible to the designated recipient. Zero-Knowledge Proofs (ZKPs): ZKPs are implemented to verify and share data without exposing actual details. For example, when users share their financial data for loan approvals, only the verification process is revealed, while the data itself remains confidential. This creates a trustless and private communication layer between users and institutions. DeFi Lending: For the lending platform, we integrated smart contracts that support USDC and MINA lending. This portion of the platform operates independently of the data-sharing mechanism, allowing users to borrow funds based on their lending needs without exposing their financial history.",
        "how_its_made": "SecureFi is built using a combination of cutting-edge decentralized technologies with a focus on privacy, data security, and DeFi lending. The project integrates the following key components: Mina Protocol: At the core of SecureFi is Mina Protocol, known for its lightweight blockchain and privacy features. We leveraged zero-knowledge proofs (ZKPs) to enable secure, privacy-preserving financial data sharing. By using Protokit, we created off-chain computations and proofs that allow users to securely share their wallet portfolios with authorized parties, ensuring that sensitive financial data remains encrypted and only accessible to the designated recipient. Zero-Knowledge Proofs (ZKPs): ZKPs are implemented to verify and share data without exposing actual details. For example, when users share their financial data for loan approvals, only the verification process is revealed, while the data itself remains confidential. This creates a trustless and private communication layer between users and institutions. DeFi Lending: For the lending platform, we integrated smart contracts that support USDC and MINA lending. This portion of the platform operates independently of the data-sharing mechanism, allowing users to borrow funds based on their lending needs without exposing their financial history.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xshkw/screenshots/qk6qa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xshkw/screenshots/nx2ss/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xshkw/screenshots/tqkof/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xshkw/screenshots/pv5ja/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xshkw/screenshots/7ebps/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xshkw/screenshots/ae2ve/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sambitsargam/ethglobal-singapore",
        "link": "https://ethglobal.com/showcase/securefi-xshkw"
    },
    {
        "title": "BlockBird",
        "brief_description": "BlockBird is an on-chain Flappy Bird game deployed on Arbitrum Sepolia, integrating Chainlink, The Graph, and Dynamic Wallet. Fly through the chain, navigating obstacles while earning rewards.",
        "long_description": "BlockBird is an innovative on-chain game that brings the classic Flappy Bird experience to the blockchain. Deployed on Arbitrum Sepolia, it combines the simplicity of a browser-based game with the security and transparency of decentralized technology. Players control a bird, navigating through obstacles on-chain, and can earn rewards as they progress. By integrating Chainlink for randomness and fair gameplay, The Graph for efficient querying, and Dynamic Wallet for seamless user experience BlockBird was built with a strong focus on utilizing the latest Web3 technologies. The core game logic is coded in Solidity and deployed on Arbitrum Sepolia, leveraging the scalability and low-cost transactions of this Layer 2 solution. Chainlink VRF (Verifiable Random Function) is used to ensure fair and unpredictable game mechanics, adding a layer of trustless randomness to the gameplay. The Graph is employed to efficiently index and query the game\u2019s data, providing real-time updates on leaderboards and player statistics. Dynamic Wallet integration ensures that players can easily connect and play the game without leaving their browser, making the on-chain experience as smooth as possible. One particularly hacky aspect was optimizing the gas costs associated with in-game transactions. We achieved this by minimizing the number of on-chain interactions required during gameplay, offloading as much computation as possible to the frontend while maintaining the integrity and security of the game. This balance between on-chain and off-chain processing ensures a seamless and cost-effective gaming experience.",
        "how_its_made": "BlockBird was built with a strong focus on utilizing the latest Web3 technologies. The core game logic is coded in Solidity and deployed on Arbitrum Sepolia, leveraging the scalability and low-cost transactions of this Layer 2 solution. Chainlink VRF (Verifiable Random Function) is used to ensure fair and unpredictable game mechanics, adding a layer of trustless randomness to the gameplay. The Graph is employed to efficiently index and query the game\u2019s data, providing real-time updates on leaderboards and player statistics. Dynamic Wallet integration ensures that players can easily connect and play the game without leaving their browser, making the on-chain experience as smooth as possible. One particularly hacky aspect was optimizing the gas costs associated with in-game transactions. We achieved this by minimizing the number of on-chain interactions required during gameplay, offloading as much computation as possible to the frontend while maintaining the integrity and security of the game. This balance between on-chain and off-chain processing ensures a seamless and cost-effective gaming experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1di1c/screenshots/7geyw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1di1c/screenshots/9o2zh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1di1c/screenshots/9nn6g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1di1c/screenshots/o3a75/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1di1c/screenshots/94zz0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Ash20pk/flappy-bird/",
        "link": "https://ethglobal.com/showcase/blockbird-1di1c"
    },
    {
        "title": "deBBS",
        "brief_description": "deBBS builds self-sustaining communities by charging small fees for posts and thread creation to prevent spam in anonymous networks. These fees are distributed as rewards to moderators and frontend providers, creating an incentive structure that supports community maintenance.",
        "long_description": "Decentralized onchain BBS owned and maintained by users.\nBlockchain communities are already thriving, with DAOs actively operating.\nSo why not take the conversation on-chain? deBBS functions as a tool for building a self-sustaining community by charging a small fee for posting and thread creation as a spam prevention measure in highly anonymous networks, and distributing the collected fees as rewards to moderators and frontend providers who contribute to maintaining the community through an incentive structure. At deBBS, we have developed a fully on-chain BBS system that operates entirely on the EVM through its payment and data storage functionalities. To enhance immediacy in the frontend and foster stronger interrelationships between communities (Boards), we created SubGraphs on The Graph. This allows us to organize and retrieve data independently of the data structure within smart contracts. However, recognizing the practical challenge of writing large amounts of data to the blockchain on Ethereum Mainnet due to high gas fees, we opted to build the application on various L2 blockchains, where transaction fees are relatively lower.",
        "how_its_made": "At deBBS, we have developed a fully on-chain BBS system that operates entirely on the EVM through its payment and data storage functionalities. To enhance immediacy in the frontend and foster stronger interrelationships between communities (Boards), we created SubGraphs on The Graph. This allows us to organize and retrieve data independently of the data structure within smart contracts. However, recognizing the practical challenge of writing large amounts of data to the blockchain on Ethereum Mainnet due to high gas fees, we opted to build the application on various L2 blockchains, where transaction fees are relatively lower.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jg3nd/screenshots/ny5zi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jg3nd/screenshots/ki4ea/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jg3nd/screenshots/mwtce/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jg3nd/screenshots/0fxv2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jg3nd/screenshots/1mk7e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jg3nd/screenshots/1au5k/default.jpg"
        ],
        "live_demo": "https://debbs.vercel.app/",
        "source_code": "https://github.com/el3ctricpenguin/debbs",
        "link": "https://ethglobal.com/showcase/debbs-jg3nd"
    },
    {
        "title": "Mint Book",
        "brief_description": "Mint Book is a collaborative project where users can contribute notes to create a unique book. Once completed, it can be minted as an NFT. Collaborators earn royalties upon sale. Connect your wallet, add your thoughts, and be part of this innovative project!",
        "long_description": "Project Overview: Mint Book is an interactive platform that allows multiple users to contribute notes and ideas to a collaborative book project. Once the book is complete, it can be minted as an NFT. When sold, all contributors earn royalties, creating a rewarding collaborative experience. How It Works: Connect Wallet:\nUsers click the \"Connect Wallet\" button to link their Rainbow Wallet to the platform. Add Notes:\nAfter wallet connection, a text description area appears where users can input relevant notes or ideas for the book. Collaboration:\nMultiple users can add their contributions, enriching the book with diverse perspectives. Minting:\nOnce all collaborators have submitted their content, the completed book can be minted as an NFT. Royalty Distribution:\nUpon sale of the minted book, all contributors receive a share of the royalties, incentivizing collaboration and creativity. This project uses following Tech stack: Next.js: For building the user interface and handling server-side rendering.\nHard Hat: For smart contract development and deployment on the Ethereum blockchain.\nRainbow Wallet: For user wallet integration and transaction handling.\nMongoDB: For storing user contributions and project data efficiently.",
        "how_its_made": "This project uses following Tech stack: Next.js: For building the user interface and handling server-side rendering.\nHard Hat: For smart contract development and deployment on the Ethereum blockchain.\nRainbow Wallet: For user wallet integration and transaction handling.\nMongoDB: For storing user contributions and project data efficiently.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/aimky/screenshots/1yz72/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aimky/screenshots/kcdkn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aimky/screenshots/w0jnu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aimky/screenshots/iiqy7/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/deepakdecrypt/scaffold-eth",
        "link": "https://ethglobal.com/showcase/mint-book-aimky"
    },
    {
        "title": "Raise Sign",
        "brief_description": "An escrow service that holds fundraise until both parties sign the contracts",
        "long_description": "Raise Sign allows any web3 project raise funds confidently. We allow the VCs escrow the funds and let the project owner create documents to be signed.\nUsing Sign attestation we deposit the funds to the project's account when both parties agree and sign the contracts. During this time the funds are held in a contract and in case of a disagreement on the contract, the funds are sent back to the VCs. We used Sign to create an attestation per contract. This attestation is also accompanied with the actual contract file, in pdf for now, in Arweave distributed file storage. We keep the funds in a multi-sig contract with a defined time limit. In an agreement or disagreement, the funds are sent to either the project owner's wallet or back to the VCs.",
        "how_its_made": "We used Sign to create an attestation per contract. This attestation is also accompanied with the actual contract file, in pdf for now, in Arweave distributed file storage. We keep the funds in a multi-sig contract with a defined time limit. In an agreement or disagreement, the funds are sent to either the project owner's wallet or back to the VCs.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/aa686/screenshots/sgm2u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aa686/screenshots/76z6i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aa686/screenshots/p0i02/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/bulenttastan/RaiseSign",
        "link": "https://ethglobal.com/showcase/raise-sign-aa686"
    },
    {
        "title": "EchoChain",
        "brief_description": "EchoChain is a revolutionary decentralized platform designed to connect service providers",
        "long_description": "What sets EchoChain apart is its ability to store all service data on-chain, making it immutable and tamper-proof. By leveraging smart contracts, service agreements between guides and clients are automatically enforced. This guarantees that once both parties agree on the terms, no changes can be made without mutual consent. The platform also integrates a multi-step confirmation process, ensuring that clients finalize their booking only after they are fully satisfied with the service details. Payments are handled securely through smart contracts, where funds are held until both parties confirm the service's successful completion. In addition, EchoChain prioritizes user experience by allowing seamless interaction with Ethereum-compatible wallets like MetaMask. Clients can easily browse, book services, and pay directly from their wallets, while guides can publish their services in a few clicks. EchoChain offers a new way to ensure fairness and reliability in the service marketplace, making it an ideal solution for both providers and clients. EchoChain's technical workflow is designed to leverage blockchain technology for enhanced transparency, security, and efficiency in transactions between guides and clients. The core of EchoChain\u2019s functionality revolves around smart contracts deployed on the Ethereum network. These contracts serve as automated, tamper-proof agreements that execute transactions based on predefined conditions, ensuring that both the guide and client are bound by the terms they agree upon. Key steps in the EchoChain technical workflow:\nService Publishing: Guides use the platform to publish their services, including details such as service type, description, and hourly rate. This information is recorded on-chain via a smart contract, making it immutable and viewable to all users. By storing service data on-chain, EchoChain ensures that no one, including the guide, can later alter service descriptions or prices. Booking Process: Clients browse through available services and select the ones that suit their needs. Upon selecting a service, the client initiates the booking by providing service details such as the desired start and end times. The booking request is logged on-chain, and the corresponding guide is notified. Confirmation and Agreement: Once a booking is submitted, the guide can choose to accept or reject the request. If the guide accepts, the booking enters a pending state, where the client must confirm their final agreement with the terms. This two-step confirmation process ensures that clients are fully aware of the booking's details, including the price and timing, before proceeding. Smart Contract Execution: Upon final confirmation from both parties, a smart contract is triggered to lock the client's payment into escrow. The funds remain secure in the contract until the service is completed. After the service is delivered and confirmed by both parties, the smart contract automatically releases the payment to the guide. Completion and Payment Release: Once the service is marked as complete, both the guide and client must confirm the transaction. Upon mutual confirmation, the payment is automatically transferred to the guide, and the transaction is logged on-chain for future reference. EchoChain\u2019s fully decentralized and trustless architecture ensures that all parties involved in a transaction are protected, and the process is both transparent and irreversible. By leveraging blockchain, EchoChain minimizes risks such as payment disputes or service alterations, creating a more secure marketplace for guide services.",
        "how_its_made": "EchoChain's technical workflow is designed to leverage blockchain technology for enhanced transparency, security, and efficiency in transactions between guides and clients. The core of EchoChain\u2019s functionality revolves around smart contracts deployed on the Ethereum network. These contracts serve as automated, tamper-proof agreements that execute transactions based on predefined conditions, ensuring that both the guide and client are bound by the terms they agree upon. Key steps in the EchoChain technical workflow:\nService Publishing: Guides use the platform to publish their services, including details such as service type, description, and hourly rate. This information is recorded on-chain via a smart contract, making it immutable and viewable to all users. By storing service data on-chain, EchoChain ensures that no one, including the guide, can later alter service descriptions or prices. Booking Process: Clients browse through available services and select the ones that suit their needs. Upon selecting a service, the client initiates the booking by providing service details such as the desired start and end times. The booking request is logged on-chain, and the corresponding guide is notified. Confirmation and Agreement: Once a booking is submitted, the guide can choose to accept or reject the request. If the guide accepts, the booking enters a pending state, where the client must confirm their final agreement with the terms. This two-step confirmation process ensures that clients are fully aware of the booking's details, including the price and timing, before proceeding. Smart Contract Execution: Upon final confirmation from both parties, a smart contract is triggered to lock the client's payment into escrow. The funds remain secure in the contract until the service is completed. After the service is delivered and confirmed by both parties, the smart contract automatically releases the payment to the guide. Completion and Payment Release: Once the service is marked as complete, both the guide and client must confirm the transaction. Upon mutual confirmation, the payment is automatically transferred to the guide, and the transaction is logged on-chain for future reference. EchoChain\u2019s fully decentralized and trustless architecture ensures that all parties involved in a transaction are protected, and the process is both transparent and irreversible. By leveraging blockchain, EchoChain minimizes risks such as payment disputes or service alterations, creating a more secure marketplace for guide services.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/s75qn/screenshots/b6t0r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s75qn/screenshots/6fhpx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s75qn/screenshots/di3cr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Tangleaphne/Echochain.git",
        "link": "https://ethglobal.com/showcase/echochain-s75qn"
    },
    {
        "title": "Cointributors",
        "brief_description": "Cointributors enables fair and automated donation distribution to open-source contributors and dependencies using Ethereum smart contracts. Link your repository, allocate funds, deploy your contract, and display a badge to invite donations and showcase your support.",
        "long_description": "Cointributors is a platform aimed at transforming open-source contributions by providing a streamlined, standardized approach for allocating and deploying donation contracts for both project contributors and dependencies. Through Ethereum smart contracts, Cointributors automates the equitable distribution of ERC-20 tokens, ensuring that contributors and project dependencies are properly supported. Users can link their GitHub repositories, where the platform scans for contributors and dependencies with associated Gist addresses, and deploy a smart contract to manage donations. By integrating with package managers like npm, RubyGems, NuGet, and PyPi, Cointributors identifies dependencies and determines the appropriate recipients of funds. The system also supports hierarchical funding, allowing dependencies to allocate a portion of their donations to their own contributors. This creates a transparent, automated framework to sustain open-source ecosystems. Contributors can showcase their involvement by displaying a badge on their GitHub profiles, encouraging others to donate and support the open-source community. Cointributors is built using a combination of .NET, Nethereum, and Razor, creating a robust and scalable platform for automating donations in the open-source ecosystem. .NET & Razor: The frontend is developed with Razor Pages, a .NET-based web framework that allows for dynamic web content generation. Razor seamlessly integrates front-end and back-end logic, providing a smooth and intuitive user experience for linking GitHub repositories and deploying smart contracts. Nethereum: Nethereum, a .NET library for interacting with Ethereum, is used to handle all blockchain-related operations. It facilitates smart contract deployment, management, and interaction, ensuring secure and transparent token transfers. Nethereum is essential in managing ERC-20 token transactions, contract deployment, and validating recipients. Smart Contracts: At the core of Cointributors are Solidity-based smart contracts that automate donation distribution to contributors and dependencies. These contracts ensure funds are allocated based on predefined percentages and support hierarchical distribution structures, enabling dependencies to distribute funds to their own contributors proportionally. GitHub Integration: GitHub\u2019s API is integrated to allow users to link repositories and identify both contributors and dependencies. This integration enables Cointributors to automate the donation process, associating funds with the appropriate individuals and packages, streamlining the entire workflow for users. Hacky Details: One notable hack involved implementing package manager scanning to identify dependencies. This is partially implemented for npm, RubyGems, NuGet, and Python. By parsing package files and mapping them to GitHub profiles, we can dynamically identify dependencies for open-source projects. We also leveraged Razor\u2019s flexibility to iterate rapidly on the frontend design. This allowed us to provide real-time feedback during the smart contract deployment process without heavy reliance on JavaScript frameworks. These technologies, along with smart contracts and GitHub integration, enable Cointributors to deliver a transparent, automated, and secure platform for distributing donations across the open-source ecosystem.",
        "how_its_made": "Cointributors is built using a combination of .NET, Nethereum, and Razor, creating a robust and scalable platform for automating donations in the open-source ecosystem. .NET & Razor: The frontend is developed with Razor Pages, a .NET-based web framework that allows for dynamic web content generation. Razor seamlessly integrates front-end and back-end logic, providing a smooth and intuitive user experience for linking GitHub repositories and deploying smart contracts. Nethereum: Nethereum, a .NET library for interacting with Ethereum, is used to handle all blockchain-related operations. It facilitates smart contract deployment, management, and interaction, ensuring secure and transparent token transfers. Nethereum is essential in managing ERC-20 token transactions, contract deployment, and validating recipients. Smart Contracts: At the core of Cointributors are Solidity-based smart contracts that automate donation distribution to contributors and dependencies. These contracts ensure funds are allocated based on predefined percentages and support hierarchical distribution structures, enabling dependencies to distribute funds to their own contributors proportionally. GitHub Integration: GitHub\u2019s API is integrated to allow users to link repositories and identify both contributors and dependencies. This integration enables Cointributors to automate the donation process, associating funds with the appropriate individuals and packages, streamlining the entire workflow for users. Hacky Details: One notable hack involved implementing package manager scanning to identify dependencies. This is partially implemented for npm, RubyGems, NuGet, and Python. By parsing package files and mapping them to GitHub profiles, we can dynamically identify dependencies for open-source projects. We also leveraged Razor\u2019s flexibility to iterate rapidly on the frontend design. This allowed us to provide real-time feedback during the smart contract deployment process without heavy reliance on JavaScript frameworks. These technologies, along with smart contracts and GitHub integration, enable Cointributors to deliver a transparent, automated, and secure platform for distributing donations across the open-source ecosystem.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9iaiy/screenshots/dvy3o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9iaiy/screenshots/96kqj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9iaiy/screenshots/h4fit/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9iaiy/screenshots/tsfxa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9iaiy/screenshots/zg4uf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9iaiy/screenshots/v4y8u/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Cointributors/Cointributors",
        "link": "https://ethglobal.com/showcase/cointributors-9iaiy"
    },
    {
        "title": "staketomake",
        "brief_description": "A blockchain-enabled health and wellness social app using staking to build healthy habits. Combines crypto \"skin in the game\" with social support for wellness. Unique features: monetary/social motivation, group challenges, reward for effort, built for non crypto-natives.",
        "long_description": "StakeToMake is a blockchain-powered health and wellness consumer social app that leverages a simple and unique staking system to encourage users to build and sustain healthy habits. Designed with a focus on simplicity and inclusivity, users can join with minimal friction by linking their existing wallet or easily creating a new one with their email on telegram. No prior crypto experience is required. Our application offers the opportunity for users to build any habit they are serious about. Users can set physical health goals such as daily step counts, nutrition tracking, to mental health goals such as meditation and sleep improvement. Our MVP focuses on four main habit-building tracks across key areas of physical and mental wellness. These four tracks are: How is this different from all other habit tracking apps? With our unique monetary and social motivation incentive mechanism, coupled with abstraction of blockchain complexities by leveraging Telegram for onboarding, submission and progress verification, StakeToMake makes it easy for non-crypto natives to participate. This approach combines the \"skin in the game\" concept from crypto trading with the power of social support to motivate and reward users for taking charge of their personal well-being. How it works (User Journey) Frontend (Next.js, Vercel, Dynamic.xyz)\nWe used Next.js because it's flexible and easy to work with, especially for features like server-side rendering. Vercel was our deployment choice since it integrates perfectly with Next.js, making deployments and scaling super easy. For secure, decentralized user login, we integrated dynamic.xyz for Web3 authentication. Telegram Bot (Dynamic.xyz)\nTo make the app more accessible, we built a Telegram Bot that offers another way for users to interact with our system. Just like the frontend, the bot uses Web3 APIs for user authentication and communicates directly with our backend to process user actions. The bot offers limited functionality in comparison to the frontend, focusing on core aspects such as goal submissions. Backend (Python, FastAPI, web3.py)\nOur backend is built with Python and FastAPI. web3.py handles blockchain interactions with our smart contracts. The backend manages requests from both the frontend and Telegram Bot via FastAPI, and web3.py interacts with our Solidity smart contract for all on-chain tasks. Our backend stores text and image data in Supabase, discussed below. Database (Supabase)\nWe chose Supabase as our database because it\u2019s real-time, open-source, and integrates easily with our backend. Since we started off with a predefined data model before we started building, it was easier to structure our codebase around relational data. The backend uses Supabase for storing and retrieving data, with direct access also used by the Telegram Bot's backend code, ensuring data consistency across the platform. Smart Contract (Solidity, Chainlink)\nThe core logic of our app runs on a Solidity smart contract, handling key operations like transactions, fund distribution, and our escrow logic, providing a secure foundation for all blockchain-related activities. We use Chainlink Keepers for polling/cron jobs in the smart contract for automatic goal completion and release of funds.",
        "how_its_made": "Frontend (Next.js, Vercel, Dynamic.xyz)\nWe used Next.js because it's flexible and easy to work with, especially for features like server-side rendering. Vercel was our deployment choice since it integrates perfectly with Next.js, making deployments and scaling super easy. For secure, decentralized user login, we integrated dynamic.xyz for Web3 authentication. Telegram Bot (Dynamic.xyz)\nTo make the app more accessible, we built a Telegram Bot that offers another way for users to interact with our system. Just like the frontend, the bot uses Web3 APIs for user authentication and communicates directly with our backend to process user actions. The bot offers limited functionality in comparison to the frontend, focusing on core aspects such as goal submissions. Backend (Python, FastAPI, web3.py)\nOur backend is built with Python and FastAPI. web3.py handles blockchain interactions with our smart contracts. The backend manages requests from both the frontend and Telegram Bot via FastAPI, and web3.py interacts with our Solidity smart contract for all on-chain tasks. Our backend stores text and image data in Supabase, discussed below. Database (Supabase)\nWe chose Supabase as our database because it\u2019s real-time, open-source, and integrates easily with our backend. Since we started off with a predefined data model before we started building, it was easier to structure our codebase around relational data. The backend uses Supabase for storing and retrieving data, with direct access also used by the Telegram Bot's backend code, ensuring data consistency across the platform. Smart Contract (Solidity, Chainlink)\nThe core logic of our app runs on a Solidity smart contract, handling key operations like transactions, fund distribution, and our escrow logic, providing a secure foundation for all blockchain-related activities. We use Chainlink Keepers for polling/cron jobs in the smart contract for automatic goal completion and release of funds.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/y5o7j/screenshots/qo7mt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y5o7j/screenshots/jovh6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y5o7j/screenshots/53inp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y5o7j/screenshots/fnmez/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y5o7j/screenshots/6bium/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y5o7j/screenshots/fxiy2/default.jpg"
        ],
        "live_demo": "https://staketomake.vercel.app/",
        "source_code": "https://github.com/Vshnv2001/staketomake",
        "link": "https://ethglobal.com/showcase/staketomake-y5o7j"
    },
    {
        "title": "GT for Ton",
        "brief_description": "We wanted to try to build a galaxy strategic mini game for telegram.",
        "long_description": "we thought about to develop an immersive galaxy strategic mini-game for Telegram, where players will explore distant star systems, manage resources, build fleets, and engage in tactical space battles, all while forging alliances in a vast, dynamic universe.\" During the process we learned a lot of things from ton documentations etc and we were able to write down a smart contract while we hadn't enough time to finish to work on the frontend. We began by thoroughly studying various documentation, focusing on the foundational concepts needed to proceed. After that, we shifted our focus to building smart contracts using FunC and Blueprint, ensuring a solid blockchain backend. Once that was underway, we started working on the frontend, leveraging the power of Next.js for server-side rendering, Tailwind CSS for modern styling, ShadcnUI for streamlined UI components, and TypeScript for robust type checking and improved developer experience. Together, this allowed us to create a full-stack architecture that balances performance, aesthetics, and security.",
        "how_its_made": "We began by thoroughly studying various documentation, focusing on the foundational concepts needed to proceed. After that, we shifted our focus to building smart contracts using FunC and Blueprint, ensuring a solid blockchain backend. Once that was underway, we started working on the frontend, leveraging the power of Next.js for server-side rendering, Tailwind CSS for modern styling, ShadcnUI for streamlined UI components, and TypeScript for robust type checking and improved developer experience. Together, this allowed us to create a full-stack architecture that balances performance, aesthetics, and security.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/n7tzr/screenshots/1cuzy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n7tzr/screenshots/n8csv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n7tzr/screenshots/entix/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n7tzr/screenshots/egjrr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/BromeRST/gt-ton",
        "link": "https://ethglobal.com/showcase/gt-for-ton-n7tzr"
    },
    {
        "title": "Pump.Flow",
        "brief_description": "Pump.Flow is the first unruggable meme token launchpad on Flow blockchain",
        "long_description": "Pump.Flow is the first unruggable meme token launchpad on the Flow blockchain. Leveraging Flow's fast, cheap, and scalable infrastructure, Pump.Flow enables anyone to safely create and launch their own meme tokens with no coding required. This innovative platform ensures secure, user-friendly token creation, empowering creators to bring their ideas to life on the Flow blockchain with ease. Building Pump.Flow involved leveraging a variety of cutting-edge technologies to ensure a seamless and robust platform. We used Supabase to handle the storage of token images and associated comments, providing a reliable backend that integrates smoothly with our application. For the frontend, we chose Next.js, a powerful framework that allowed us to build a fast and efficient user interface, and deployed it using Vercel, which ensured smooth and scalable deployment. One of the unique aspects of Pump.Flow is that we converted our application into a Telegram mini app, making it more accessible to a wider audience and integrating it into a popular messaging platform. We also implemented a bonding curve to balance supply and price, ensuring a fair and dynamic pricing mechanism for the tokens. Throughout the development, we made sure to optimize each component, integrating these technologies in a way that maximized performance and user experience. This blend of tools and techniques allowed us to create a secure, scalable, and user-friendly launchpad on the Flow blockchain.",
        "how_its_made": "Building Pump.Flow involved leveraging a variety of cutting-edge technologies to ensure a seamless and robust platform. We used Supabase to handle the storage of token images and associated comments, providing a reliable backend that integrates smoothly with our application. For the frontend, we chose Next.js, a powerful framework that allowed us to build a fast and efficient user interface, and deployed it using Vercel, which ensured smooth and scalable deployment. One of the unique aspects of Pump.Flow is that we converted our application into a Telegram mini app, making it more accessible to a wider audience and integrating it into a popular messaging platform. We also implemented a bonding curve to balance supply and price, ensuring a fair and dynamic pricing mechanism for the tokens. Throughout the development, we made sure to optimize each component, integrating these technologies in a way that maximized performance and user experience. This blend of tools and techniques allowed us to create a secure, scalable, and user-friendly launchpad on the Flow blockchain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/k7f1g/screenshots/6mx6u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k7f1g/screenshots/rnqh9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k7f1g/screenshots/z93rg/default.jpg"
        ],
        "live_demo": "https://pump-flow.vercel.app/",
        "source_code": "https://github.com/metehancaliskan/Pump.flow",
        "link": "https://ethglobal.com/showcase/pump-flow-k7f1g"
    },
    {
        "title": "SocX",
        "brief_description": "Soc X is a decentralized social media platform that focuses on monetizing both the creator and consumer economy as well as focus on user privacy and keep the audience authentic.",
        "long_description": "SocX is a groundbreaking decentralized social media platform that seeks to empower both content creators and consumers by enabling them to monetize their participation. The platform is designed to create a balanced ecosystem where both creators and users benefit from the content they engage with, all while ensuring top-tier privacy and security. One of the features of SocX is its use of  IPFS  to store user data on-chain, eliminating reliance on traditional centralized servers. This decentralized storage model significantly reduces the risk of data breaches and privacy violations, which are common in conventional social media platforms. To ensure that all users are verified and authentic, SocX integrates Worldcoin for identity verification. This system helps prevent identity theft, forgery, and the presence of bots, making SocX a spam-free environment. Worldcoin\u2019s verification system guarantees that only real users can interact on the platform, providing a more authentic and secure social experience. A unique aspect of SocX is its use of ENS (Ethereum Name Service) as the username system. Instead of using complicated 18-character wallet addresses, SocX users can register and use human-readable ENS names. This allows for easy identification of who owns specific posts or content. Moreover, ENS names serve as verified identities on the platform, making it easier for users to interact, connect, and transact. Users can directly donate to content creators using their ENS names, simplifying the donation process while ensuring the addresses are authentic. SocX is currently deployed on the Morph Holesky testnet, providing a highly efficient and seamless environment for testing the platform\u2019s features and operations. The testnet ensures that SocX can scale efficiently and handle the decentralized functions that make the platform unique. In terms of features, SocX offers a variety of innovative tools designed to enhance user experience:\nDonation System: Users can directly support their favorite content creators by donating funds. This feature encourages creators to continue producing high-quality content by providing a sustainable revenue stream.\nMinting Content as NFTs: SocX allows content creators to post their work either as regular posts or mint them as NFTs (. This feature gives creators the ability to tokenize their content, making it unique and tradeable.\nNFT Staking: For NFTs posted by content creators, users have the option to stake on those NFTs. By staking, users can earn interest over time, creating a financial incentive for users to support and engage with NFT content on the platform. Overall, SocX is redefining social media by combining the benefits of decentralization, enhanced privacy, and monetization opportunities, all while ensuring authenticity and eliminating spam through cutting-edge technologies like Morph L2, Worldcoin, and ENS. The project integrates advanced technologies to create a decentralized and user-friendly platform. Rainbow SDK enables seamless wallet connectivity, while Worldcoin ensures unique and authentic users, maintaining a bot-free environment. ENS simplifies user interaction with human-readable names for transparency. Smart contracts are deployed on the Morph Holesky testnet, and IPFS stores user data securely on-chain. Together, these technologies deliver a practical, feature-rich application that addresses real-world issues around decentralization, privacy, and user verification.",
        "how_its_made": "The project integrates advanced technologies to create a decentralized and user-friendly platform. Rainbow SDK enables seamless wallet connectivity, while Worldcoin ensures unique and authentic users, maintaining a bot-free environment. ENS simplifies user interaction with human-readable names for transparency. Smart contracts are deployed on the Morph Holesky testnet, and IPFS stores user data securely on-chain. Together, these technologies deliver a practical, feature-rich application that addresses real-world issues around decentralization, privacy, and user verification.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xb41g/screenshots/v3q5z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xb41g/screenshots/umdn8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xb41g/screenshots/mtkkq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xb41g/screenshots/w1h5a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xb41g/screenshots/vuscx/default.jpg"
        ],
        "live_demo": "https://socxglobal.vercel.app/",
        "source_code": "https://github.com/ayush035/ETHSingapore",
        "link": "https://ethglobal.com/showcase/socx-xb41g"
    },
    {
        "title": "Mintly",
        "brief_description": "A web3 rewards platform combining the best of tranditional credit card loyalty schemes and the unique benefits of web3.",
        "long_description": "Mintly is a revolutionary loyalty reward token and storefront that incentivizes consumers to make purchases using cryptocurrency, such as Ethereum. By harnessing the power of the Flow blockchain and The Graph, Mintly offers a seamless and engaging way for users to earn Mintie tokens for their purchases, which can be redeemed for a variety of rewards, including discounts, other currencies, or NFTs. Mintly's unique approach combines the best of traditional loyalty programs with the innovations that crypto can uniquely deliver, creating a universal rewards currency that eliminates the need for users to manage multiple loyalty apps or miss out on rewards. For merchants, Mintly provides enhanced consumer insights through detailed consumer personas, enabling them to tailor their marketing and inventory strategies more effectively. The platform's curated portal, comprising brands across industries, and its universal rewards currency keep users highly engaged, fostering deeper connections and brand loyalty. Initially focusing on merchants selling NFTs, such as Disney, Mintly aims to expand its reach to any retailer looking to modernize their loyalty program with blockchain technology. With a growing interest in crypto and NFTs, Mintly is well-positioned to capture a significant share of this expanding market. We used the Flow blockchain to record transactions for purchases made by consumers. A smart contract then distributes the Principal (purchase amount) to the merchant, and calculates the reward amount based on the agreed percentage with the merchant. The reward is deposited into the customer's Mintly wallet.\nAlthough not yet implemented, merchants sign up through a separate smart contract, where they commit to funding a pot for rewards proportional to the transaction amount for each transaction. This funds the rewards we provide as Mintly tokens.\nWe envision using The Graph to scan transactions on the Flow blockchain to provide unique consumer insights to merchants, helping them to tailor their marketing.\nThe frontend is built using React, and incorporates Dynamic for wallet management. This also enables Google account login, making the onboarding process for new-to-crypto consumers seamless.",
        "how_its_made": "We used the Flow blockchain to record transactions for purchases made by consumers. A smart contract then distributes the Principal (purchase amount) to the merchant, and calculates the reward amount based on the agreed percentage with the merchant. The reward is deposited into the customer's Mintly wallet.\nAlthough not yet implemented, merchants sign up through a separate smart contract, where they commit to funding a pot for rewards proportional to the transaction amount for each transaction. This funds the rewards we provide as Mintly tokens.\nWe envision using The Graph to scan transactions on the Flow blockchain to provide unique consumer insights to merchants, helping them to tailor their marketing.\nThe frontend is built using React, and incorporates Dynamic for wallet management. This also enables Google account login, making the onboarding process for new-to-crypto consumers seamless.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/stcxn/screenshots/40x68/default.jpg",
            "https://ethglobal.b-cdn.net/projects/stcxn/screenshots/6snwv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/stcxn/screenshots/3e7e3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/artemis283/webs3",
        "link": "https://ethglobal.com/showcase/mintly-stcxn"
    },
    {
        "title": "Bakul",
        "brief_description": "Bakul is a decentralized platform for building, sharing, and integrating blockchain-powered components known as Blinks. From donations and swaps to cross-chain bridges, Bakul empowers users to seamlessly incorporate Web3 features into any part of the web",
        "long_description": "Bakul is a decentralized platform inspired by Solana's Blinks, designed to seamlessly integrate blockchain functionalities into digital spaces such as websites and social media. At its heart are \"Blinks\"\u2014modular components that enable decentralized actions like donations, token swaps, and cross-chain bridges. Key Features\nPre-Built Blinks: Users can effortlessly embed features like decentralized donation buttons, real-time token swaps across multiple blockchains, and secure cross-chain bridges for asset transfers. Idea Sharing Platform: Bakul fosters community-driven innovation by allowing users to submit ideas for new Blinks. The open-source framework encourages collaboration, where the most popular ideas are prioritized for development. Decentralized Hosting: All Blinks are hosted on IPFS, ensuring security, accessibility, and censorship resistance. This model prevents reliance on centralized servers, enhancing Bakul's resilience. Why Bakul?\nBakul bridges the gap between blockchain technology and everyday users, offering a streamlined way to implement decentralized tools. Its community-driven approach promotes transparency and innovation, enabling developers to refine ideas collaboratively. How Bakul is Built\nBakul empowers users to create, share, and integrate blockchain functionalities seamlessly, drawing inspiration from Solana Blinks while being tailored for the Ethereum Virtual Machine (EVM) ecosystem. Core Technologies\nDynamic Protocol: Facilitates secure wallet connections and signing for user-generated Blinks, ensuring content is verified and trustworthy. Smart Contracts: Deployed across multiple testnets, including Hedera, Flow, Morph HoleSky, and Sepolia, enabling extensive testing and compatibility with various blockchains. Hedera Consensus Service (HCS): Creates decentralized, auditable logs of events within Bakul, providing trusted timestamps and ordered records. The Graph: Indexes and queries user interaction data for real-time updates and efficient Blink management. IPFS: Stores all Blinks securely and decentralized, allowing user access without reliance on centralized servers. Twitter Integration: A browser extension enables easy sharing of Blinks on Twitter by injecting IPFS hashes directly into tweets, promoting community engagement. Notable Innovations\nUser Experience: The Dynamic protocol simplifies blockchain interactions for non-technical users, enhancing accessibility. Community Engagement: The Twitter extension boosts visibility and fosters a community-driven ethos. Interoperability: Multi-chain deployment showcases Bakul's commitment to broader compatibility and comprehensive testing.",
        "how_its_made": "How Bakul is Built\nBakul empowers users to create, share, and integrate blockchain functionalities seamlessly, drawing inspiration from Solana Blinks while being tailored for the Ethereum Virtual Machine (EVM) ecosystem. Core Technologies\nDynamic Protocol: Facilitates secure wallet connections and signing for user-generated Blinks, ensuring content is verified and trustworthy. Smart Contracts: Deployed across multiple testnets, including Hedera, Flow, Morph HoleSky, and Sepolia, enabling extensive testing and compatibility with various blockchains. Hedera Consensus Service (HCS): Creates decentralized, auditable logs of events within Bakul, providing trusted timestamps and ordered records. The Graph: Indexes and queries user interaction data for real-time updates and efficient Blink management. IPFS: Stores all Blinks securely and decentralized, allowing user access without reliance on centralized servers. Twitter Integration: A browser extension enables easy sharing of Blinks on Twitter by injecting IPFS hashes directly into tweets, promoting community engagement. Notable Innovations\nUser Experience: The Dynamic protocol simplifies blockchain interactions for non-technical users, enhancing accessibility. Community Engagement: The Twitter extension boosts visibility and fosters a community-driven ethos. Interoperability: Multi-chain deployment showcases Bakul's commitment to broader compatibility and comprehensive testing.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qejf1/screenshots/yk5pq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qejf1/screenshots/6yf03/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qejf1/screenshots/u2tnu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qejf1/screenshots/wtzv7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qejf1/screenshots/phmbt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qejf1/screenshots/sz5t3/default.jpg"
        ],
        "live_demo": "https://bakul.vercel.app/",
        "source_code": "https://github.com/chiragbadhe/bakul",
        "link": "https://ethglobal.com/showcase/bakul-qejf1"
    },
    {
        "title": "SportsBet",
        "brief_description": "A crypto price betting platform built on the AirDAO network, where users stake AirDAO tokens (AMB) to bet on the price movements of other cryptocurrencies. The app is powered by React, Solidity, and integrates with MetaMask for secure wallet connections.",
        "long_description": "This project is a decentralized platform for betting on the price movements of cryptocurrencies. Users can stake AirDAO tokens (AMB) to place bets on whether the price of selected cryptocurrencies will rise or fall within a set period. The app is designed to offer a seamless and engaging user experience, with a featured sports-like betting interface for crypto price movements. The platform is fully decentralized, leveraging smart contracts for transparency and security, while enabling users to manage their bets and view outcomes in real time. MetaMask integration allows users to securely connect their wallets, manage AMB tokens, and interact with the platform. The project was developed using React for the frontend, JavaScript for managing interactions, and Solidity for smart contract logic. React's component-based structure makes the user interface modular and scalable, ensuring efficient updates. The smart contracts, written in Solidity, manage the logic of betting, staking, and payouts. These contracts are deployed on the AirDAO network to utilize its native token, AMB, for staking. MetaMask is integrated to enable users to connect their wallets securely and easily interact with the dApp. The platform features decentralized logic to manage betting pools and outcomes, ensuring transparency and fair results.",
        "how_its_made": "The project was developed using React for the frontend, JavaScript for managing interactions, and Solidity for smart contract logic. React's component-based structure makes the user interface modular and scalable, ensuring efficient updates. The smart contracts, written in Solidity, manage the logic of betting, staking, and payouts. These contracts are deployed on the AirDAO network to utilize its native token, AMB, for staking. MetaMask is integrated to enable users to connect their wallets securely and easily interact with the dApp. The platform features decentralized logic to manage betting pools and outcomes, ensuring transparency and fair results.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/uhjiq/screenshots/kfg9k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uhjiq/screenshots/8utsp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uhjiq/screenshots/dau49/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/JeromeGohRY/ETHGlobal-Submission",
        "link": "https://ethglobal.com/showcase/sportsbet-uhjiq"
    },
    {
        "title": "Symbio Hooks",
        "brief_description": "Enabling the best hooks and the most successful pools to come together, again and again",
        "long_description": "Typically, a pool is \"soul-bonded\" to a hook at its creation, this forced coupling will inevitably lead to mismatch and sub-optimal pairing. For example, a useful hook may not find sufficient liquidity / volume to bring out its value, and highly used pool may be stuck with an outdated hook. Symbio Hooks solve this problem by introducing a host/symbiont hooks system that allows multiple hooks to be attached/detached to a pool at anytime: This project is built on Foundry with a dependency on the Uniswap v4 Core repository, 100% pure Solidity. Extra attention is given to keep part of Symbio Hooks loosely coupled. Besides that a pool can have multiple hooks attached and a hook can attach to multiple pools, a symbiont hook can further specify which hook call (function selector) it want to respond to for each pool. User security and fairness is another area of consideration. For this purpose, beforeSwap and beforeDonate are not supported at host hook level, to prevent sandwich attack and just in time liquidity exploit respectively. Symbion hooks will reimburse caller for the gas they consume (and hopefully more). Symbiont hooks that don't have sufficient balance or result in failure will be promptly removed from host hook to save resource. Also reverts from inside symbiont hooks are swallowed by the host hook and not re-thrown, so successful symbionts are not affected, and again failed ones will be removed.",
        "how_its_made": "This project is built on Foundry with a dependency on the Uniswap v4 Core repository, 100% pure Solidity. Extra attention is given to keep part of Symbio Hooks loosely coupled. Besides that a pool can have multiple hooks attached and a hook can attach to multiple pools, a symbiont hook can further specify which hook call (function selector) it want to respond to for each pool. User security and fairness is another area of consideration. For this purpose, beforeSwap and beforeDonate are not supported at host hook level, to prevent sandwich attack and just in time liquidity exploit respectively. Symbion hooks will reimburse caller for the gas they consume (and hopefully more). Symbiont hooks that don't have sufficient balance or result in failure will be promptly removed from host hook to save resource. Also reverts from inside symbiont hooks are swallowed by the host hook and not re-thrown, so successful symbionts are not affected, and again failed ones will be removed.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9buqu/screenshots/cvzu8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9buqu/screenshots/gb2up/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9buqu/screenshots/th6gp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9buqu/screenshots/ozasv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jeffishjeff/SymbioHook",
        "link": "https://ethglobal.com/showcase/symbio-hooks-9buqu"
    },
    {
        "title": "Silent Wars",
        "brief_description": "A telegram mini-app guild based game with resource collection and voting",
        "long_description": "Silent Wars is a fully on-chain game exploring censorship resistance and governance.\nPlayers influence game direction via on-chain governance. The world is made up of 3 factions/guilds: 1. Cypherpunk; 2. Moloch; 3. Memecoin. The 3 factions represent 3 different ideologies and result in different gameplay. 3 factions have different territories on the map, and have different kind of resources yielding differently as well. The player jumps in the game, stake to be qualified for the reward after the game, and start participating in the war (the game). Players need to work closely with other faction members, to build strategic plans on what kind of resources to collect, what kind of gameplay styles to choose - aggressive or defensive - making sure that there faction is the strongest among the 3. Every now and then, the war would pose a very tough situational choice for all players and factions: a Global State Change. Such change affects the variables within a game (such as the yields from collecting certain resources) in a resonable way, and is represented by a fictional event. Players need to collectively vote as a faction, and secure what\u2019s best for the future of the faction. For example, a Global State Change that raises the value of the Cypherpunk\u2019s resource, by saying \u201cAll people in the world learns how to interact with smart contracts and the ideas of CryptoPunk\u201d, is very appealing to the CypherPunk people, so they will try to seize this vote. We\u2019d like to use this game to really show the Silent Wars that\u2019s going around us: the fight between ideologies, and also the people behind it, voting, doing their hard work, and make the player learns the governance from inside and out. This project uses reactJS and PhaserJS (game animations) for the frontend and can be accessed from Telegram mini-app or browsers. Login is done with Dynamic. We have also integrated MACI voting mechanics within the game. For the smart contracts, we have used remix for the multi chain deployment. Players can either stake or use World ID for ensuring a fairer voting. For the gameplay design, we\u2019ve incorporated game designs from many trending traditional games, and. we designed our game with the Public Goods values in mind. We want players to be constantly faced with options, and these options are in most times best be done with collective minds.",
        "how_its_made": "This project uses reactJS and PhaserJS (game animations) for the frontend and can be accessed from Telegram mini-app or browsers. Login is done with Dynamic. We have also integrated MACI voting mechanics within the game. For the smart contracts, we have used remix for the multi chain deployment. Players can either stake or use World ID for ensuring a fairer voting. For the gameplay design, we\u2019ve incorporated game designs from many trending traditional games, and. we designed our game with the Public Goods values in mind. We want players to be constantly faced with options, and these options are in most times best be done with collective minds.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dpayg/screenshots/97wgb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dpayg/screenshots/gzze6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dpayg/screenshots/1zy4w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dpayg/screenshots/1c22h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dpayg/screenshots/vtsmu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dpayg/screenshots/7baoz/default.jpg"
        ],
        "live_demo": "https://2024-eth-singapore-5k28.vercel.app/",
        "source_code": "https://github.com/taijusanagi/2024-eth-singapore",
        "link": "https://ethglobal.com/showcase/silent-wars-dpayg"
    },
    {
        "title": "SybilGuard AI",
        "brief_description": "SybilGuard AI is an AI-powered tool designed to eliminate Sybil attacks in airdrops and decentralized governance.",
        "long_description": "SybilGuard AI addresses a critical challenge in Web3\u2014Sybil attacks, where malicious actors create multiple wallets to unfairly claim rewards during airdrops or manipulate governance systems. Our platform allows users or protocols to upload a list of wallet addresses, which are then analysed using machine learning algorithms and graph theory to identify connections and suspicious activity patterns. The AI model analyses historical transaction data to detect clusters of wallets that exhibit Sybil-like behavior, such as high transaction frequency between wallets or shared connections. Flagged addresses are presented with a risk score, enabling protocols to make informed decisions about excluding potential attackers from their airdrop distributions. By offering a transparent, automated, and scalable solution, SybilGuard AI helps safeguard the integrity of decentralised ecosystems, ensuring fair distribution and preventing manipulation. Our tool can be easily integrated into any protocol running reward-based events, staking, or decentralised governance voting. Backend & Data Handling:\nUsing python script, the backend fetches transaction data from blockchain APIs (currently using EtherScan). This data is then analysed for suspicious patterns. AI & Machine Learning:\nWe use Python and graph analysis tools like NetworkX to detect connections between wallet transactions. Machine learning models analyse transaction patterns to identify Sybil attacks. Graph-Based Detection:\nUsing Graph Theory, we map wallet relationships and look for suspicious structures, such as clusters of wallets interacting abnormally.",
        "how_its_made": "Backend & Data Handling:\nUsing python script, the backend fetches transaction data from blockchain APIs (currently using EtherScan). This data is then analysed for suspicious patterns. AI & Machine Learning:\nWe use Python and graph analysis tools like NetworkX to detect connections between wallet transactions. Machine learning models analyse transaction patterns to identify Sybil attacks. Graph-Based Detection:\nUsing Graph Theory, we map wallet relationships and look for suspicious structures, such as clusters of wallets interacting abnormally.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/u3rz6/screenshots/z2d2r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/u3rz6/screenshots/t152i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/u3rz6/screenshots/ua963/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/adityakaklij/SybilGuardAI",
        "link": "https://ethglobal.com/showcase/sybilguard-ai-u3rz6"
    },
    {
        "title": "1inch AI Agent",
        "brief_description": "A user-friendly platform utilizing smart actions for seamless and efficient token swapping. Designed for ease of use, with real-time updates, secure transactions, and intuitive interface to ensure a smooth and effortless experience for all users.",
        "long_description": "1inch Agent is a platform that leverages a chat interface to seamlessly execute various tasks related to 1inch, offering a user-friendly experience. Through 1inch Agent, users can interact with the system via text to perform actions such as retrieving 1inch information, sending funds to other wallet addresses, fetching cryptocurrency prices, and executing swaps. This solution optimizes the user experience by simplifying complex operations, providing a quick, intuitive, and friendly way to access decentralized services on the 1inch platform. 1inch Agent leverages AI, specifically a multiple agents model, to seamlessly connect various tasks like querying 1inch data, sending funds, and executing swaps. Each agent specializes in a function, ensuring accurate calculations and efficient coordination. Technologies used include Next.js for FE, Node.js for backend, OpenAI API for natural language processing, and the 1inch API for real-time DeFi actions. The highlight of the project is how we simplified complex DeFi operations, making them accessible to low-tech users through a user-friendly chat interface. By integrating with 1inch, we ensured secure, real-time transactions and data accuracy, making DeFi approachable for everyone.",
        "how_its_made": "1inch Agent leverages AI, specifically a multiple agents model, to seamlessly connect various tasks like querying 1inch data, sending funds, and executing swaps. Each agent specializes in a function, ensuring accurate calculations and efficient coordination. Technologies used include Next.js for FE, Node.js for backend, OpenAI API for natural language processing, and the 1inch API for real-time DeFi actions. The highlight of the project is how we simplified complex DeFi operations, making them accessible to low-tech users through a user-friendly chat interface. By integrating with 1inch, we ensured secure, real-time transactions and data accuracy, making DeFi approachable for everyone.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fvfhx/screenshots/zjq7r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fvfhx/screenshots/abbs3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fvfhx/screenshots/2eee2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Joyboyx12/1inchagent_FE",
        "link": "https://ethglobal.com/showcase/1inch-ai-agent-fvfhx"
    },
    {
        "title": "Moraq League",
        "brief_description": "Moraq League is a fun crypto price prediction tournament! Predict token prices, battle through harder rounds, and stake tokens for big rewards. Exit early with winnings or risk it all for the jackpot. Compete, climb the leaderboard, and win like anything.",
        "long_description": "Hii , We are a team of 2 devs from India developing an Moraq Leagues at Ethglobal Singapore. Note:- Moraq is the place where Thor killed Thanos, so it\u2019s the best place to make your good bets against the evil crypto market. Again , In simple words, it\u2019s a tournament of Prediction Markets but only on crypto prices. Moraq League is all about turning crypto price predictions into a fun, competitive, and rewarding tournament.\u2028\u2028So , we are ready to rock right ?\u2028As we know, what polymarket has been boosted in past couple of years, it\u2019s totally insane. So, what we are bringing to table is bit different than prediction markets. It\u2019s a mix of Gaming & Prediction. And we are very excited from here. Moraq League is all about an Unexplored Prediction market, In simple words it\u2019s a tournament of Prediction Markets but only on crypto prices. Moraq League is all about turning crypto price predictions into a fun, competitive, and rewarding tournament.\nUnlike traditional prediction markets, where you just bet on outcomes, here you battle through multiple rounds with increasing difficulty.\nBut How to Play Right? At Moraq League, we\u2019re mixing gaming and predictions to create a new kind of experience where users engage with crypto markets in an exciting, tournament-style competition. Isn\u2019t that Interesting? Join us in both ways: Moraq League is a fun entertainment prediction tournament platform to make the experience seamless and fun. Pyth provides real-time crypto data, while Next.js ensures a smooth interface. Payments and sign-ins are handled easily with Rebase. AirDAO and Morph manage the blockchain side, and Flow is used for its focus on mass adoption. Gnosis Circles ensures trust and rewards, making everything secure and engaging for players.",
        "how_its_made": "Moraq League is a fun entertainment prediction tournament platform to make the experience seamless and fun. Pyth provides real-time crypto data, while Next.js ensures a smooth interface. Payments and sign-ins are handled easily with Rebase. AirDAO and Morph manage the blockchain side, and Flow is used for its focus on mass adoption. Gnosis Circles ensures trust and rewards, making everything secure and engaging for players.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/e14rc/screenshots/tser7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/e14rc/screenshots/m9ddk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/e14rc/screenshots/qj4im/default.jpg",
            "https://ethglobal.b-cdn.net/projects/e14rc/screenshots/pr2o7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/e14rc/screenshots/sgccv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/e14rc/screenshots/g3b9g/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sushmitsarmah/eth_singapore_24",
        "link": "https://ethglobal.com/showcase/moraq-league-e14rc"
    },
    {
        "title": "LedgeFolio",
        "brief_description": "LedgeFolio is a comprehensive web application that integrates Ledger hardware wallets with various Web3 functionalities, including NFT management, cross-chain token bridging, ENS domain operations, and cryptocurrency purchases.",
        "long_description": "In a world where digital assets are increasingly valuable and vulnerable, LedgeFolio emerges as the fortress that doesn't compromise on accessibility. We've created a bridge between the impenetrable security of Ledger hardware wallets and the vibrant, ever-evolving Web3 ecosystem. LedgeFolio is not just an application; it's a paradigm shift in how we interact with blockchain technology.\nImagine a world where your NFTs, cryptocurrencies, and digital identities are all secured by cold storage, yet as accessible as if they were in a hot wallet. That's the world LedgeFolio creates. Our platform allows users to manage their entire Web3 portfolio - from NFTs to bridging tokens across chains, from buying crypto to buying ENS domains - all through the secure interface of their Ledger device. LedgeFolio is the Swiss Army knife for your Ledger, the mission control for your digital assets, and the gateway to Web3 that never leaves your assets exposed. It's where security meets functionality, where cold storage meets hot swaps, and where your Ledger becomes your passport to the entire blockchain universe. LedgeFolio is built on three pillars of innovation:\nThe Secure Nexus:\nAt the heart of LedgeFolio is our Next.js frontend, a sleek interface built with TypeScript and adorned with Shadcn UI components. This isn't just a pretty face - it's a secure command center. Every action, from viewing your NFTs to initiating a cross-chain transfer, is routed through your Ledger device. We've leveraged Ethers.js, Wagmi, Ledger Hq and Viem to create a seamless interaction between your hardware wallet and various blockchain networks. The result? A user experience as smooth as a hot wallet, with the security of cold storage. The Bridge Builder:\nWe've pushed the boundaries of what's possible with a hardware wallet by implementing Circle's SDK for cross-chain operations. Want to move your assets from Ethereum to Base? Just a few clicks, and your Ledger takes care of the rest. But we didn't stop there. Our ENS integration allows you to manage your Web3 identity directly from your Ledger. Not only can you resolve ENS names to Ethereum addresses, but our advanced integration also lets you retrieve Bitcoin addresses associated with ENS names. This multi-chain resolution capability broadens the scope of Web3 identity management. Buy ENS domains without ever exposing your private keys, and use them as a universal identifier across different blockchain networks. It's like having a decentralized, multi-chain address book secured in your pocket. The Portfolio Maestro: Using Alchemy's NFT API, we've created an NFT gallery that turns your Ledger into a museum of digital art. View, transfer, and manage your NFTs with the peace of mind that comes from hardware wallet security.",
        "how_its_made": "LedgeFolio is built on three pillars of innovation:\nThe Secure Nexus:\nAt the heart of LedgeFolio is our Next.js frontend, a sleek interface built with TypeScript and adorned with Shadcn UI components. This isn't just a pretty face - it's a secure command center. Every action, from viewing your NFTs to initiating a cross-chain transfer, is routed through your Ledger device. We've leveraged Ethers.js, Wagmi, Ledger Hq and Viem to create a seamless interaction between your hardware wallet and various blockchain networks. The result? A user experience as smooth as a hot wallet, with the security of cold storage. The Bridge Builder:\nWe've pushed the boundaries of what's possible with a hardware wallet by implementing Circle's SDK for cross-chain operations. Want to move your assets from Ethereum to Base? Just a few clicks, and your Ledger takes care of the rest. But we didn't stop there. Our ENS integration allows you to manage your Web3 identity directly from your Ledger. Not only can you resolve ENS names to Ethereum addresses, but our advanced integration also lets you retrieve Bitcoin addresses associated with ENS names. This multi-chain resolution capability broadens the scope of Web3 identity management. Buy ENS domains without ever exposing your private keys, and use them as a universal identifier across different blockchain networks. It's like having a decentralized, multi-chain address book secured in your pocket. The Portfolio Maestro: Using Alchemy's NFT API, we've created an NFT gallery that turns your Ledger into a museum of digital art. View, transfer, and manage your NFTs with the peace of mind that comes from hardware wallet security.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1ub39/screenshots/ephnj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1ub39/screenshots/myj9s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1ub39/screenshots/88np5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1ub39/screenshots/63ama/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1ub39/screenshots/ydg9s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1ub39/screenshots/vc2je/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/karangoraniya/ledgfolio",
        "link": "https://ethglobal.com/showcase/ledgefolio-1ub39"
    },
    {
        "title": "LedgeFolio",
        "brief_description": "LedgeFolio is a comprehensive web application that integrates Ledger hardware wallets with various Web3 functionalities, including NFT management, cross-chain token bridging, ENS domain operations, and cryptocurrency purchases.",
        "long_description": "In a world where digital assets are increasingly valuable and vulnerable, LedgeFolio emerges as the fortress that doesn't compromise on accessibility. We've created a bridge between the impenetrable security of Ledger hardware wallets and the vibrant, ever-evolving Web3 ecosystem. LedgeFolio is not just an application; it's a paradigm shift in how we interact with blockchain technology.\nImagine a world where your NFTs, cryptocurrencies, and digital identities are all secured by cold storage, yet as accessible as if they were in a hot wallet. That's the world LedgeFolio creates. Our platform allows users to manage their entire Web3 portfolio - from NFTs to bridging tokens across chains, from buying crypto to buying ENS domains - all through the secure interface of their Ledger device. LedgeFolio is the Swiss Army knife for your Ledger, the mission control for your digital assets, and the gateway to Web3 that never leaves your assets exposed. It's where security meets functionality, where cold storage meets hot swaps, and where your Ledger becomes your passport to the entire blockchain universe. LedgeFolio is built on three pillars of innovation:\nThe Secure Nexus:\nAt the heart of LedgeFolio is our Next.js frontend, a sleek interface built with TypeScript and adorned with Shadcn UI components. This isn't just a pretty face - it's a secure command center. Every action, from viewing your NFTs to initiating a cross-chain transfer, is routed through your Ledger device. We've leveraged Ethers.js, Wagmi, Ledger Hq and Viem to create a seamless interaction between your hardware wallet and various blockchain networks. The result? A user experience as smooth as a hot wallet, with the security of cold storage. The Bridge Builder:\nWe've pushed the boundaries of what's possible with a hardware wallet by implementing Circle's SDK for cross-chain operations. Want to move your assets from Ethereum to Base? Just a few clicks, and your Ledger takes care of the rest. But we didn't stop there. Our ENS integration allows you to manage your Web3 identity directly from your Ledger. Not only can you resolve ENS names to Ethereum addresses, but our advanced integration also lets you retrieve Bitcoin addresses associated with ENS names. This multi-chain resolution capability broadens the scope of Web3 identity management. Buy ENS domains without ever exposing your private keys, and use them as a universal identifier across different blockchain networks. It's like having a decentralized, multi-chain address book secured in your pocket. The Portfolio Maestro: Using Alchemy's NFT API, we've created an NFT gallery that turns your Ledger into a museum of digital art. View, transfer, and manage your NFTs with the peace of mind that comes from hardware wallet security.",
        "how_its_made": "LedgeFolio is built on three pillars of innovation:\nThe Secure Nexus:\nAt the heart of LedgeFolio is our Next.js frontend, a sleek interface built with TypeScript and adorned with Shadcn UI components. This isn't just a pretty face - it's a secure command center. Every action, from viewing your NFTs to initiating a cross-chain transfer, is routed through your Ledger device. We've leveraged Ethers.js, Wagmi, Ledger Hq and Viem to create a seamless interaction between your hardware wallet and various blockchain networks. The result? A user experience as smooth as a hot wallet, with the security of cold storage. The Bridge Builder:\nWe've pushed the boundaries of what's possible with a hardware wallet by implementing Circle's SDK for cross-chain operations. Want to move your assets from Ethereum to Base? Just a few clicks, and your Ledger takes care of the rest. But we didn't stop there. Our ENS integration allows you to manage your Web3 identity directly from your Ledger. Not only can you resolve ENS names to Ethereum addresses, but our advanced integration also lets you retrieve Bitcoin addresses associated with ENS names. This multi-chain resolution capability broadens the scope of Web3 identity management. Buy ENS domains without ever exposing your private keys, and use them as a universal identifier across different blockchain networks. It's like having a decentralized, multi-chain address book secured in your pocket. The Portfolio Maestro: Using Alchemy's NFT API, we've created an NFT gallery that turns your Ledger into a museum of digital art. View, transfer, and manage your NFTs with the peace of mind that comes from hardware wallet security.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1ub39/screenshots/ephnj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1ub39/screenshots/myj9s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1ub39/screenshots/88np5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1ub39/screenshots/63ama/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1ub39/screenshots/ydg9s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1ub39/screenshots/vc2je/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/karangoraniya/ledgfolio",
        "link": "https://ethglobal.com/showcase/ledgefolio-1ub39"
    },
    {
        "title": "Spam Protector",
        "brief_description": "Tired of getting insurance , loans , scam calls ? Spam protector is here to save the day",
        "long_description": "I come from a country where getting 4-6 calls a day from scam callers, telemarketers , banks , insurance , robo callers, etc is the norm. We can manage with some frustration, but you do not want the people you care about getting scammed out of their money tomorrow. This mobile application addresses this problem by building a community database of mobile numbers to keep an active track of new spam numbers popping up. Tools with centralised data stores such as Truecallers are losing trust and have gatekept community-contributed data. This data has to be democratised so that anyone can write a client to determine who they think is spam. We also manage privacy while eliminating spam calls unlike popular apps out there like truecaller. We have created a mobile app , where users can select the spam numbers they have received and upload the numbers. All this is done gaslessly. Through worldcoin, we have eliminated attacks on the database by verified individuals only. The added benefit is that tomorrow, we can incentivise people to publish these numbers. Since all the spam events are on the blockchain, anyone now can build clients using indexers like graph and determine what to consider a spam number or not. Democratising the data will enable multiple different toolsets to come out to eliminate spam. For ex: we have made a test client using gaia, where people can analyse the numbers published and choose whom to consider as spam.",
        "how_its_made": "We have created a mobile app , where users can select the spam numbers they have received and upload the numbers. All this is done gaslessly. Through worldcoin, we have eliminated attacks on the database by verified individuals only. The added benefit is that tomorrow, we can incentivise people to publish these numbers. Since all the spam events are on the blockchain, anyone now can build clients using indexers like graph and determine what to consider a spam number or not. Democratising the data will enable multiple different toolsets to come out to eliminate spam. For ex: we have made a test client using gaia, where people can analyse the numbers published and choose whom to consider as spam.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/41gx8/screenshots/tg936/default.jpg",
            "https://ethglobal.b-cdn.net/projects/41gx8/screenshots/to3ae/default.jpg",
            "https://ethglobal.b-cdn.net/projects/41gx8/screenshots/4j4iy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/41gx8/screenshots/ppwui/default.jpg",
            "https://ethglobal.b-cdn.net/projects/41gx8/screenshots/zbk1d/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/lazycoder1/scamProtector ",
        "link": "https://ethglobal.com/showcase/spam-protector-41gx8"
    },
    {
        "title": "MayBee\ud83d\udc1d",
        "brief_description": "MayBee is a Telegram Mini App that lets you make fun wagers with friends or strangers. Using Telegram provides a simple and intuitive experience, so you can place your bets quickly and easily. Join the buzz and start betting in your favorite hive! \ud83d\udc1d\u2728",
        "long_description": "MayBee is a Telegram Mini App that brings a seamless betting experience to users. By integrating with Telegram and utilizing the Flow network, MayBee provides a quick and intuitive way to place wagers on trending topics. Users can engage with the app either through the Telegram Bot @maybee01_bot or directly via the MayBee App. Within the app, users can explore all active wagers and place bets using Flow tokens. To help users stay up-to-date with the most popular wagers, we've created two dedicated channels highlighting the hottest topics over the last hour and 24 hours. MayBee aims to make betting more accessible and engaging by leveraging the power of decentralized technology and the convenience of Telegram. MayBee is a decentralized prediction market platform built on the Flow blockchain, leveraging modern web technologies and blockchain integration for a seamless user experience. Frontend Architecture:\nThe application is built using Next.js, with TypeScript for enhanced type safety and code reliability. The UI is styled using Tailwind CSS, ensuring responsive and consistent design across devices. State management is handled efficiently through React hooks, providing a smooth and reactive user interface. Key components like Button, Card, and Spinner are designed for reusability, promoting a consistent look and feel throughout the application. Client-side navigation is implemented using Next.js routing, ensuring fast and fluid transitions between pages. Authentication and Blockchain Integration:\nUser authentication and wallet integration are managed by Dynamic, offering a secure and user-friendly sign-in process that includes Telegram login. For Ethereum wallet interactions, the app utilizes WagmiProvider, enabling seamless connection with various Ethereum-based wallets. Telegram Bot Integration:\nA custom Telegram bot, built with the Telegraf library, serves as a bridge between the platform and users. The bot initializes with a Telegram token and uses JWT for secure authentication. It offers interactive features such as welcome messages with inline buttons for easy navigation to the web app, allowing users to create or join markets directly from Telegram. The bot maintains user engagement by periodically updating channel topics with the latest \"Hottest 1H\" and \"Hottest 24H\" markets, complete with clickable links. For testing and manual updates, a 'testmessage' command is available. Security is ensured through custom Telegram hash generation. Smart Contract:\nThe core functionality of MayBee is powered by a smart contract deployed on the Flow network. This contract, written in Solidity, manages the creation and resolution of prediction markets, as well as user bets and reward distribution.\nKey features of the smart contract include:",
        "how_its_made": "MayBee is a decentralized prediction market platform built on the Flow blockchain, leveraging modern web technologies and blockchain integration for a seamless user experience. Frontend Architecture:\nThe application is built using Next.js, with TypeScript for enhanced type safety and code reliability. The UI is styled using Tailwind CSS, ensuring responsive and consistent design across devices. State management is handled efficiently through React hooks, providing a smooth and reactive user interface. Key components like Button, Card, and Spinner are designed for reusability, promoting a consistent look and feel throughout the application. Client-side navigation is implemented using Next.js routing, ensuring fast and fluid transitions between pages. Authentication and Blockchain Integration:\nUser authentication and wallet integration are managed by Dynamic, offering a secure and user-friendly sign-in process that includes Telegram login. For Ethereum wallet interactions, the app utilizes WagmiProvider, enabling seamless connection with various Ethereum-based wallets. Telegram Bot Integration:\nA custom Telegram bot, built with the Telegraf library, serves as a bridge between the platform and users. The bot initializes with a Telegram token and uses JWT for secure authentication. It offers interactive features such as welcome messages with inline buttons for easy navigation to the web app, allowing users to create or join markets directly from Telegram. The bot maintains user engagement by periodically updating channel topics with the latest \"Hottest 1H\" and \"Hottest 24H\" markets, complete with clickable links. For testing and manual updates, a 'testmessage' command is available. Security is ensured through custom Telegram hash generation. Smart Contract:\nThe core functionality of MayBee is powered by a smart contract deployed on the Flow network. This contract, written in Solidity, manages the creation and resolution of prediction markets, as well as user bets and reward distribution.\nKey features of the smart contract include:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5x6o0/screenshots/ti00w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5x6o0/screenshots/uo64k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5x6o0/screenshots/pa35j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5x6o0/screenshots/66c3a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5x6o0/screenshots/kc87d/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Tanguyvans/maybee",
        "link": "https://ethglobal.com/showcase/maybee-5x6o0"
    },
    {
        "title": "Coin Copycat TG Bot",
        "brief_description": "Coin Copycat is a socialfi telegram trading bot that let's you copy trade your friends in your TG group!",
        "long_description": "CoinCopyCat is an innovative Telegram bot that enables crypto copy-trading on Ethereum's Holesky testnet, focusing on Uniswap V2 swaps. This project allows users to easily participate in copy-trading strategies without the need for complex setups or deep technical knowledge.\nKey features include: Seamless wallet creation and management directly through Telegram.\nReal-time balance checking for ETH and popular ERC20 tokens.\nAbility to copy trades from any Ethereum address on the Holesky testnet.\nAutomatic trade replication with customizable trade sizing.\nDirect swap functionality using Uniswap V2.\nUser-friendly interface with inline keyboards for easy navigation. CoinCopyCat democratizes copy-trading by making it accessible to anyone with a Telegram account. It's designed to be educational, allowing users to learn about DeFi and trading strategies in a risk-free testnet environment. The bot's simplicity and integration with Telegram make it an ideal tool for both crypto newcomers and experienced traders looking to test new strategies. CoinCopyCat is built using a stack of modern technologies, carefully integrated to create a seamless user experience: Node.js: The core of the application, handling the bot's logic and interactions.\nEthers.js: Used for Ethereum blockchain interactions, including wallet management, transaction signing, and smart contract interactions.\nTelegram Bot API (node-telegram-bot-api): Enables the bot to communicate with users through Telegram, providing a familiar and accessible interface.\nSQLite (sqlite3): A lightweight, serverless database used to store user data and copy-trading relationships, ensuring persistence across bot restarts.\nUniswap V2 SDK: Integrated to facilitate swap operations on the Uniswap decentralized exchange.\nDotenv: Used for managing environment variables, keeping sensitive information like API keys secure.\nCrypto (Node.js built-in): Employed for encrypting and decrypting private keys, adding an extra layer of security for user wallets. The bot's architecture is modular, with separate functions handling different aspects like wallet management, balance checking, and trade execution. This design allows for easy maintenance and future expansion.\nOne particularly innovative aspect is the real-time transaction monitoring system. It uses Ethers.js event listeners to detect trades made by copied addresses instantly. When a trade is detected, the bot decodes the transaction input and replicates the trade for all followers, adjusting the trade size based on each follower's settings.\nThe integration with Telegram's inline keyboards creates an intuitive, app-like experience within the messaging platform, making complex DeFi interactions as simple as tapping a button.\nA notable \"hacky\" solution was implementing a simple key-value store using SQLite for fast, lightweight data storage, avoiding the need for a full-fledged database server while still maintaining data persistence.\nBy leveraging the Holesky testnet, we've created a risk-free environment for users to explore copy-trading strategies, learn about DeFi, and experiment with different approaches to crypto trading, all through the familiar interface of Telegram.",
        "how_its_made": "CoinCopyCat is built using a stack of modern technologies, carefully integrated to create a seamless user experience: Node.js: The core of the application, handling the bot's logic and interactions.\nEthers.js: Used for Ethereum blockchain interactions, including wallet management, transaction signing, and smart contract interactions.\nTelegram Bot API (node-telegram-bot-api): Enables the bot to communicate with users through Telegram, providing a familiar and accessible interface.\nSQLite (sqlite3): A lightweight, serverless database used to store user data and copy-trading relationships, ensuring persistence across bot restarts.\nUniswap V2 SDK: Integrated to facilitate swap operations on the Uniswap decentralized exchange.\nDotenv: Used for managing environment variables, keeping sensitive information like API keys secure.\nCrypto (Node.js built-in): Employed for encrypting and decrypting private keys, adding an extra layer of security for user wallets. The bot's architecture is modular, with separate functions handling different aspects like wallet management, balance checking, and trade execution. This design allows for easy maintenance and future expansion.\nOne particularly innovative aspect is the real-time transaction monitoring system. It uses Ethers.js event listeners to detect trades made by copied addresses instantly. When a trade is detected, the bot decodes the transaction input and replicates the trade for all followers, adjusting the trade size based on each follower's settings.\nThe integration with Telegram's inline keyboards creates an intuitive, app-like experience within the messaging platform, making complex DeFi interactions as simple as tapping a button.\nA notable \"hacky\" solution was implementing a simple key-value store using SQLite for fast, lightweight data storage, avoiding the need for a full-fledged database server while still maintaining data persistence.\nBy leveraging the Holesky testnet, we've created a risk-free environment for users to explore copy-trading strategies, learn about DeFi, and experiment with different approaches to crypto trading, all through the familiar interface of Telegram.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/4vpv6/screenshots/6hef8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4vpv6/screenshots/r6r9u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4vpv6/screenshots/xyqsj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MikeDank/Coin-Copycat-TG-Bot",
        "link": "https://ethglobal.com/showcase/coin-copycat-tg-bot-4vpv6"
    },
    {
        "title": "Hyperspeed Bridge",
        "brief_description": "Hyperspeed Bridge is a lightning fast native to native bridge that uses the Hyperlane protocol to execute bridging transactions instantly before finality is reached. The bridge is secured against reorgs through an Insurance Fund, which caps the max bridgeable amount.",
        "long_description": "Hyperspeed Bridge uses a modified version of Hyperlane to create an instantly executing bridge, before finality is reached. Normally in bridges, finality must be reached before a bridging transaction can be processed to prevent the bridge contract from losing funds due to a reorg of the chain the user initially deposited funds on. This can result in very long bridging times depending on the chain - Bitcoin can take 30 mins or more to resolve finality for instance. Hyperspeed Bridge solves this issue by creating an Insurance Fund. If a reorg occurs, the Insurance Fund pays out the bridge contract to ensure the bridging protocol suffers no losses. Users are incentivized to deposit funds into the Insurance Fund as it receives a portion (20%) of the fees taken on outbound and inbound bridging transactions. Additionally, the Insurance Fund utilizes it's assets in a yield generating DeFi income stream. Finally, Hyperspeed Bridge has implemented a basic version of the EigenLayer slashing mechanism on Hyperlane such that validators will not be slashed for validating before finality is reached, but will be slashed for malicious actions. The funds from this slashing is distributed to the Insurance Fund depositors. Hyperspeed Bridge has also added functionality on top of Hyperlane to allow for the bridging of different value native coins. In this demo, an Ethereum <-> Rootstock bridge has been deployed that allows the bridging between ETH and RBTC, with prices fetched from Chainlink & Umbrella Network. This route was chosen due to the relatively long finality periods of both of these chains, as well as being a way to connect the two largest blockchain ecosystems by $ value (Ethereum & Bitcoin). The amount of value that can be transferred at any time is defined as:\nAmount of USD value on the inbound chain's Insurance Fund - The USD value of transactions that are being bridged and have not yet reached finality. In this way, users are only ever able to bridge an amount of funds that is secured by the Insurance Fund. Reorgs are detected purely onchain by sending and storing key information about the protocol during each user's bridging transaction. On each chain, every time a bridging transaction is run information is stored on an index on the outbound chain and inbound chain. If a reorg were to happen, then the value at this index would be reset. Afterwards, when a user makes a bridging transaction, it will attempt to store this value on the inbound chain but run into a data collision. This indicates to the system a reorg has occurred, the transaction is filed separately and funds are pulled from the Insurance Fund to balance the system. Most of the bridging fees (80%) are distributed to the liquidity providers who put up liquidity that users can use to access the bridge. Initial Commits were made in: https://github.com/Tranquil-Flow/hyperspeed-bridge These changes were then ported into the main submitted repo: https://github.com/Tranquil-Flow/hyperspeed-bridge-fork\nThe modifications we ported on the Hyperlane-monorepo are on that PR: https://github.com/Tranquil-Flow/hyperspeed-bridge-fork/pull/1 Frontend is built in: https://github.com/Tranquil-Flow/hyperspeed-bridge-ui InsuranceFund on Ethereum: 0x7e05c160EeF912304e0718615EAE9BbAE8F5E9C6\nInsuranceFund on Rootstock: 0xbCb715478a95e6157aD395273477371424FF6b66 NativeChallengerV1 (rootstock): 0x0163EE73720988ae1bD8816Fa5Cb586633a69b65\n0x6eF12190b6aC5c4929652DDa05F21b86bee2c9E9 (point Holesky) ECDSAStakeRegistry (holesky): 0xA509d6507B0Fc18691Af03c406F35b41F03b7c17\nHSM (holesky): 0x722d2c3c18f161edF8778A2Dd4F5893A3dA89540\nRemoteChallengerV1 (Holesky): 0xCaDE4a9F4F06c10353c06920fBE055976D000943\nSlasher: 0xFb91dd18A1Ac21e6dEB70FD242410fD96aea9c8C The following technologies have been utilized for this project: Hyperlane: The Hyperspeed Bridge builds on top of the core Hyperlane protocol, editing it to fit it's intended purpose. Oracles are integrated to facilitate native to native transfers between assets of different values (ETH and BTC). The data being sent cross chain includes additional parameters for tracking the $ value of the bridge liquidity, $ value of the Insurance Fund and bridge transaction information to detect reorgs. Rootstock: The bridge connects Ethereum to Rootstock so that users can bridge funds between the Ethereum & Bitcoin ecosystem, as well as being able to take advantage of a much faster bridging time compared to others that must wait on the long finality of Rootstock. Chainlink: On the Ethereum contract the ETH/USD price feed is used for converting between ETH and USD. A user deposits ETH, but sends a USD value cross chain. The contract receives a USD value and converts it to ETH to forward to the user. Umbrella Network: Same implementation as Chainlink, but for the Rootstock contract.",
        "how_its_made": "The following technologies have been utilized for this project: Hyperlane: The Hyperspeed Bridge builds on top of the core Hyperlane protocol, editing it to fit it's intended purpose. Oracles are integrated to facilitate native to native transfers between assets of different values (ETH and BTC). The data being sent cross chain includes additional parameters for tracking the $ value of the bridge liquidity, $ value of the Insurance Fund and bridge transaction information to detect reorgs. Rootstock: The bridge connects Ethereum to Rootstock so that users can bridge funds between the Ethereum & Bitcoin ecosystem, as well as being able to take advantage of a much faster bridging time compared to others that must wait on the long finality of Rootstock. Chainlink: On the Ethereum contract the ETH/USD price feed is used for converting between ETH and USD. A user deposits ETH, but sends a USD value cross chain. The contract receives a USD value and converts it to ETH to forward to the user. Umbrella Network: Same implementation as Chainlink, but for the Rootstock contract.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fh34h/screenshots/6nm82/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fh34h/screenshots/trtm0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fh34h/screenshots/w03x8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fh34h/screenshots/6urqi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fh34h/screenshots/is1nu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fh34h/screenshots/rxh5n/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Tranquil-Flow/hyperspeed-bridge-fork",
        "link": "https://ethglobal.com/showcase/hyperspeed-bridge-fh34h"
    },
    {
        "title": "IntroGram",
        "brief_description": "IntroGram is a Telegram mini-app that enhances networking by allowing users to record, transcribe, and summarize conversations. It helps users add Telegram handles to interactions, making it easier to remember details and reconnect with new contacts",
        "long_description": "IntroGram streamlines the networking process by enabling users to capture audio during conversations at events or meetings. The app transcribes the recordings using AI, generates concise summaries, and extracts key details like names, companies, projects, and social media handles. By associating Telegram handles with each conversation, users can easily follow up and build their professional network Blockchain:\nSmart Contracts for minting NFT owned by 2 parties(people who met) on Oasis and Linea. Frontend:\nReact and Next.js for a responsive user interface.\nTypeScript for type safety.\nMaterial-UI (MUI) for UI components.\nWeb Audio API for audio recording.\nHTML5 Canvas for real-time audio visualization.\nBackend Services: OpenAI Whisper API for transcribing audio recordings.\nOpenAI GPT-4 API for generating summaries and extracting metadata.\nAxios for handling HTTP requests.\nData Storage: IndexedDB using the idb library for client-side data storage. Authentication:\nDynamic SDK for user authentication and session management.\nTelegram Login Flow for seamless sign-in and Telegram handle integration.\nNotable Implementations: Real-Time Audio Visualization: Displays live audio waveforms during recording.\nAI-Powered Transcription and Summarization: Uses AI to transcribe and summarize conversations.\nEfficient Search: Allows searching through notes by keywords.\nResponsive Design: Optimized for both mobile and desktop devices.\nIntroGram combines audio processing and AI technologies to provide a practical tool for professionals to record and remember networking conversations, making follow-ups and connections more efficient.",
        "how_its_made": "Blockchain:\nSmart Contracts for minting NFT owned by 2 parties(people who met) on Oasis and Linea. Frontend:\nReact and Next.js for a responsive user interface.\nTypeScript for type safety.\nMaterial-UI (MUI) for UI components.\nWeb Audio API for audio recording.\nHTML5 Canvas for real-time audio visualization.\nBackend Services: OpenAI Whisper API for transcribing audio recordings.\nOpenAI GPT-4 API for generating summaries and extracting metadata.\nAxios for handling HTTP requests.\nData Storage: IndexedDB using the idb library for client-side data storage. Authentication:\nDynamic SDK for user authentication and session management.\nTelegram Login Flow for seamless sign-in and Telegram handle integration.\nNotable Implementations: Real-Time Audio Visualization: Displays live audio waveforms during recording.\nAI-Powered Transcription and Summarization: Uses AI to transcribe and summarize conversations.\nEfficient Search: Allows searching through notes by keywords.\nResponsive Design: Optimized for both mobile and desktop devices.\nIntroGram combines audio processing and AI technologies to provide a practical tool for professionals to record and remember networking conversations, making follow-ups and connections more efficient.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/x72by/screenshots/fua53/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x72by/screenshots/0ksqb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x72by/screenshots/p5gh8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Entropizm/introgram",
        "link": "https://ethglobal.com/showcase/introgram-x72by"
    },
    {
        "title": "zkApollo",
        "brief_description": "Verifiable Proof of Reserve for RWAs Tokenization in a privacy-preserve way",
        "long_description": "RWAs Tokenization promises the next wave of financial revolution. However, we still lack a standard way to verify the reserves backing the RWA tokens. Since TradFi players are joining the Mina ecosystem (eg. Mirae Asset Financial Group and Copper), we believe zkApollo can be the solution to verify the reserve for RWA tokenized securities, supporting the mission of Proof of Everything. How It Works? Our AppChain was built on ProtoKit (a framework for building privacy-enabled application chains) on Mina blockchain L1. It's zkapp with the SDK called \"o1js\".\nWe can fetch the data via any API from custodians provided by the off-chain data to bring the data into the runtime module.\nThe frontend was written in NextJS and testing is using jest test runner.",
        "how_its_made": "Our AppChain was built on ProtoKit (a framework for building privacy-enabled application chains) on Mina blockchain L1. It's zkapp with the SDK called \"o1js\".\nWe can fetch the data via any API from custodians provided by the off-chain data to bring the data into the runtime module.\nThe frontend was written in NextJS and testing is using jest test runner.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wygag/screenshots/yp7nf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wygag/screenshots/diuer/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wygag/screenshots/s8uwt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wygag/screenshots/kzckr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sitthaveet/zkApollo",
        "link": "https://ethglobal.com/showcase/zkapollo-wygag"
    },
    {
        "title": "AuditGPT",
        "brief_description": "AuditGPT is an AI agent that helps you audit your smart contracts before deployment, giving you recommendations on how to resolve any potential vulnerabilities.",
        "long_description": "AuditGPT is an AI agent that helps you audit your smart contracts before deployment, giving you recommendations on how to resolve any potential vulnerabilities. This project combines the use of AI agents with blockchain data for an important use case - smart contract auditing. This project uses NextJS for the Frontend, with a Express + MongoDB backend. For the AI Agent, we used a LangChain and OpenAI based agent deployed on IPFS via Phala Network. We forked the Near CLI to modify the deployment command and add the audit flag. Finally, for the Nextblocks explorer, we used a chrome extension to display a verified badge if the contract has been audited.",
        "how_its_made": "This project uses NextJS for the Frontend, with a Express + MongoDB backend. For the AI Agent, we used a LangChain and OpenAI based agent deployed on IPFS via Phala Network. We forked the Near CLI to modify the deployment command and add the audit flag. Finally, for the Nextblocks explorer, we used a chrome extension to display a verified badge if the contract has been audited.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0fti1/screenshots/ydz6d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0fti1/screenshots/7poe2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0fti1/screenshots/4yx71/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/arvindbr95/ethglobal-singapore",
        "link": "https://ethglobal.com/showcase/auditgpt-0fti1"
    },
    {
        "title": "DeFold",
        "brief_description": "Defold is a platform where researchers upload genomic data on-chain. Buyers browse a marketplace, purchase queries and get computations on encrypted data without seeing raw data. Researchers monetize data, buyers get valuable insights, all while maintaining privacy and security.",
        "long_description": "DeFold enables users to securely upload their sequenced genomic data on-chain and list it on a marketplace where interested buyers can run compute queries over it without accessing the underlying data. This project emerged in response to recent data breaches, like the 23andMe incident which affected 7 million people, highlighted the need for more secure genomic data infrastructure. DeFold aims to bridge the funding gap between academia and the biotech industry by creating a resource distribution pipeline. It allows researchers to monetize their sequenced data, sustaining their research independently while fostering innovation. By providing a secure, decentralized marketplace for genomic data, DeFold establishes a symbiotic relationship between academia and the startup ecosystem, accelerating breakthroughs in personalized medicine and genetic research while maintaining data privacy and data security. Authentication:\nFor authentication DeFold leverages @worldcoin for proof of humanity which allows them to login, Users are greeted with playful Nouns artwork upon successful authentication. Home Screen:\nPresents two primary options: Access the DeFold marketplace to buy genomic data, Upload personal genomic data to sell. Loading Screens:\nFeature animated Nouns artwork to create a relaxed atmosphere. Aim to alleviate stress which bioinformatics is known to cause;) Data Upload (Sell) Flow: Users choose \"Upload to Sell\"\nPrompted to upload their genomic dataset. Data is encrypted and securely stored on the Sapphire blockchain by @Oasis Protocol. Sapphire blockchain chosen for its robust privacy features, crucial for sensitive genomic information and they are also rewarded with a NounsDAO artwork for their contributions to the knowledge tree. DeFold Marketplace (Buy) Flow:\nUsers browse available genomic datasets. Only dataset descriptions and metadata are visible. Raw data remains private. Buyers select datasets based on provided information. Users choose specific queries or computations to run on the selected dataset. After query selection, users initiate the transaction. Query is executed on the encrypted data without exposing raw information. Results are returned to the buyer.\nBuyer completes the payment transaction\nPost-Transaction: Researchers (data sellers) receive payment for their data contributions. Buyers are prompted to review data quality, contributing to a reputation system for future uploads TLDR of DeFold: NOTE: This is just a mvp and the flow of things is not perfect.",
        "how_its_made": "Authentication:\nFor authentication DeFold leverages @worldcoin for proof of humanity which allows them to login, Users are greeted with playful Nouns artwork upon successful authentication. Home Screen:\nPresents two primary options: Access the DeFold marketplace to buy genomic data, Upload personal genomic data to sell. Loading Screens:\nFeature animated Nouns artwork to create a relaxed atmosphere. Aim to alleviate stress which bioinformatics is known to cause;) Data Upload (Sell) Flow: Users choose \"Upload to Sell\"\nPrompted to upload their genomic dataset. Data is encrypted and securely stored on the Sapphire blockchain by @Oasis Protocol. Sapphire blockchain chosen for its robust privacy features, crucial for sensitive genomic information and they are also rewarded with a NounsDAO artwork for their contributions to the knowledge tree. DeFold Marketplace (Buy) Flow:\nUsers browse available genomic datasets. Only dataset descriptions and metadata are visible. Raw data remains private. Buyers select datasets based on provided information. Users choose specific queries or computations to run on the selected dataset. After query selection, users initiate the transaction. Query is executed on the encrypted data without exposing raw information. Results are returned to the buyer.\nBuyer completes the payment transaction\nPost-Transaction: Researchers (data sellers) receive payment for their data contributions. Buyers are prompted to review data quality, contributing to a reputation system for future uploads TLDR of DeFold: NOTE: This is just a mvp and the flow of things is not perfect.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hz1sv/screenshots/a4w5a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hz1sv/screenshots/n0d9x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hz1sv/screenshots/w9iqc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hz1sv/screenshots/gpzft/default.jpg"
        ],
        "live_demo": "https://singapore-frontend.vercel.app/",
        "source_code": "https://github.com/ishaan-chadha1/singapore-frontend",
        "link": "https://ethglobal.com/showcase/defold-hz1sv"
    },
    {
        "title": "StakeSchedule",
        "brief_description": "A Calendly like app that allows you to schedule calls by providing a stake (in ETH). No-shows lose their money.",
        "long_description": "This Calendar app is an enables users to create and manage calendars onchain. Users can define calendars by specifying a stake amount and call length, setting the terms for scheduling appointments. Other users can schedule appointments with calendar owners by staking the required amount and selecting a desired date and time. Calendar owners have the ability to confirm or deny attendance for scheduled appointments, keeping control over their schedules. Users can view their scheduled and received appointments in a dedicated section, with appointments sorted by date and time for easy tracking. The app includes a feature for users to withdraw their available stakes, displaying the balance from the smart contract's balances mapping. Denied calls (no-shows) move the staked amount of the scheduler to the balance of the contract owner, which incentivises users to only schedule calls they will actually attend.\nThe provided frontend is a gridview displaying all functionalities of the calendar contract. It is a super simple project withut much magic involved. We used React for the frontend, ethers for contract interactions, deployed the contract on Sepolia with Remix, and used tailwind for basic styling of the app. We did not run into any major difficulties.\nUnfortunately, none of the sponsor bounties are relevant to this POC. We could have deployed on chains that are sponsoring, but it would be purely for the sake of the bounty, which is why we decieded to stay away from it.",
        "how_its_made": "It is a super simple project withut much magic involved. We used React for the frontend, ethers for contract interactions, deployed the contract on Sepolia with Remix, and used tailwind for basic styling of the app. We did not run into any major difficulties.\nUnfortunately, none of the sponsor bounties are relevant to this POC. We could have deployed on chains that are sponsoring, but it would be purely for the sake of the bounty, which is why we decieded to stay away from it.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/g6jda/screenshots/ra739/default.jpg",
            "https://ethglobal.b-cdn.net/projects/g6jda/screenshots/zbj5g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/g6jda/screenshots/h1rh1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/lennardevertz/ethSingapore2024",
        "link": "https://ethglobal.com/showcase/stakeschedule-g6jda"
    },
    {
        "title": "ProjectG",
        "brief_description": "Project G is a decentralised Supply Chain Visibility Solution",
        "long_description": "This project is an advanced supply chain management solution. Our platform leverages blockchain technology - Gnosis + Rootstock to ensure transparency, traceability, and efficiency in your supply chain operations and Subgraph to aggregate live Supply Chain data.\nAdvantages of Project G : This project uses Gnosis + Rootstock for base operations. This project heavily relies on Graph for all Data Aggregation and Visualisations.\nA Subgraph is added to index to all the Supply Chain events for an Order, different Users, Order Status Change. Project G would support any Shipment Provider like DHL, FedEx.",
        "how_its_made": "This project uses Gnosis + Rootstock for base operations. This project heavily relies on Graph for all Data Aggregation and Visualisations.\nA Subgraph is added to index to all the Supply Chain events for an Order, different Users, Order Status Change. Project G would support any Shipment Provider like DHL, FedEx.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jdgc8/screenshots/d3mqw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jdgc8/screenshots/t8y6m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jdgc8/screenshots/j9jz3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jdgc8/screenshots/s43nn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jdgc8/screenshots/p3uvg/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ProjectG-ETHGlobal",
        "link": "https://ethglobal.com/showcase/projectg-jdgc8"
    },
    {
        "title": "Reputify",
        "brief_description": "Reputify is a prediction market platform where users can stake tokens to upvote someone\u2019s prediction. If the prediction is correct, the predictor earns a portion of the staked tokens, rewarding accurate insights and fostering a reputation-based system of trust.",
        "long_description": "Reputify is a decentralized prediction market platform that integrates smart contracts and a user-friendly frontend. Users log in with external wallets like MetaMask or Phantom, and upon registering, they receive tokens. The app allows users to make their own predictions or upvote/downvote others' predictions, staking tokens in a collective pool. Once a prediction's outcome is determined, rewards are distributed based on the result. If the prediction is correct, the predictor earns tokens and upvoters reclaim a portion of their staked tokens. If wrong, the predictor receives nothing, and upvoters lose their stake, while downvoters are rewarded. Reputify incentivizes users to share and support accurate predictions, fostering a token-based reputation system. Reputify leverages multiple cutting-edge technologies to create a seamless Web3 experience. On the backend, Hedera Token Service was used to deploy the token smart contracts, enabling users to stake and earn tokens within the prediction market. Additionally, Hedera File Service and Hedera Smart Contract Service were utilized to deploy another layer of smart contracts, ensuring decentralized and secure execution of platform functionalities. On the frontend, Next.js was chosen to provide a robust and scalable infrastructure, ensuring a smooth user experience. The platform uses MySQL as the primary database to store user data, ensuring fast access and reliability. For user authentication, the app integrates with Dynamic, allowing for flexible and secure sign-ins using external wallets like MetaMask or Phantom. To manage the development environment, Docker was employed to containerize the codebase and spin up the database, ensuring a consistent setup across different environments. In addition, Docker Compose was used to configure and spin up an Nginx server, enabling smooth integration with external services like 1inch APIs for token swaps and other DeFi functionalities. Reputify\u2019s combination of Web3 technologies (Hedera services, smart contracts) and traditional Web2 tools (Next.js, MySQL, Docker) ensures a secure, scalable, and user-friendly platform for its prediction market model.",
        "how_its_made": "Reputify leverages multiple cutting-edge technologies to create a seamless Web3 experience. On the backend, Hedera Token Service was used to deploy the token smart contracts, enabling users to stake and earn tokens within the prediction market. Additionally, Hedera File Service and Hedera Smart Contract Service were utilized to deploy another layer of smart contracts, ensuring decentralized and secure execution of platform functionalities. On the frontend, Next.js was chosen to provide a robust and scalable infrastructure, ensuring a smooth user experience. The platform uses MySQL as the primary database to store user data, ensuring fast access and reliability. For user authentication, the app integrates with Dynamic, allowing for flexible and secure sign-ins using external wallets like MetaMask or Phantom. To manage the development environment, Docker was employed to containerize the codebase and spin up the database, ensuring a consistent setup across different environments. In addition, Docker Compose was used to configure and spin up an Nginx server, enabling smooth integration with external services like 1inch APIs for token swaps and other DeFi functionalities. Reputify\u2019s combination of Web3 technologies (Hedera services, smart contracts) and traditional Web2 tools (Next.js, MySQL, Docker) ensures a secure, scalable, and user-friendly platform for its prediction market model.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/nk8r7/screenshots/wjq8r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nk8r7/screenshots/h2w4h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nk8r7/screenshots/44i62/default.jpg"
        ],
        "live_demo": "https://reputify.vercel.app/",
        "source_code": "https://github.com/JasonYapzx/reputify",
        "link": "https://ethglobal.com/showcase/reputify-nk8r7"
    },
    {
        "title": "Data_Sanctuary",
        "brief_description": "Data Sanctuary is a decentralized file storage platform that integrates with MetaMask for easy uploads, storing files on IPFS-Filecoin via Lighthouse API. Each file is a storage deal tracked on FEVM, offering secure, persistent, and corporate-free storage for users",
        "long_description": "Data Sanctuary is a decentralized file storage and management platform that provides users with a secure and reliable way to store their critical files and data. It integrates with Metamask, a popular web3 wallet, to make the process of uploading and storing files as simple and easy as possible. The platform utilizes the light house storage API to store files on IPFS-Filecoin, which ensures the persistence and security of the stored data. Each file stored on Data Sanctuary is treated as a storage deal, with information such as the deal id, cid, client, and provider being recorded and stored on the Market API smart contract on FEVM. This smart contract not only ensures the persistent storage of the files but also gives users the ability to manage their storage deals and interact with the FEVM contract for added control over their data. With Data Sanctuary, individuals can enjoy the benefits of decentralized storage without having to worry about corporate control over their data. The platform offers a secure and reliable solution for storing critical files, freeing users from the constraints of centralized storage solutions. Whether you're an individual looking to store personal data or a business looking to store sensitive information, Data Sanctuary provides a decentralized solution that offers complete control over your stored files. This project was built using Metamask Snaps for connecting to FILSnap and then approving before doing any activities such as Uploading a File, Fetching Notifications, and Sending Messages.\nWhile uploading the file I have used Light house storage and for sending the message and fetching the notification I have used PUSH Notification service. All the contracts required here are deployed on Hyperspace and the frontend is built using ReactJS.",
        "how_its_made": "This project was built using Metamask Snaps for connecting to FILSnap and then approving before doing any activities such as Uploading a File, Fetching Notifications, and Sending Messages.\nWhile uploading the file I have used Light house storage and for sending the message and fetching the notification I have used PUSH Notification service. All the contracts required here are deployed on Hyperspace and the frontend is built using ReactJS.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/r2woj/screenshots/g557p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r2woj/screenshots/waen2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r2woj/screenshots/1277n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r2woj/screenshots/r9vhe/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/TheDARKFURY/Data_Sanctuary",
        "link": "https://ethglobal.com/showcase/data-sanctuary-r2woj"
    },
    {
        "title": "0xmnipresent",
        "brief_description": "chain-agnostic solution for minting, enabling payment of gas fees with tokens from a different chain",
        "long_description": "Our project offers a chain-agnostic NFT minting solution, allowing users to mint NFTs and pay gas fees using tokens from different blockchains. This eliminates the need for native tokens, providing a seamless and user-friendly experience for creators and collectors across multiple networks. With cross-chain compatibility and enhanced accessibility, we simplify the NFT ecosystem and drive broader adoption. Our chain-agnostic NFT minting solution was built with a focus on flexibility, scalability, and user experience. The project integrates cutting-edge technologies to enable cross-chain transactions, with Hyperlane being the core cross-chain messaging protocol. Here's a breakdown of how we built it: Technologies Used: Hyperlane: We leveraged Hyperlane's cross-chain messaging infrastructure to facilitate secure and seamless communication between blockchains. Hyperlane allows for the transfer of data (in this case, gas fee payments and NFT minting instructions) across multiple chains, ensuring consistency and security. Smart Contracts: Solidity-based smart contracts were deployed on each supported blockchain to handle the minting process. These contracts work in tandem with Hyperlane, listening for cross-chain messages related to gas fee payments and minting instructions. Backend: Our backend is built using Node.js and Express to handle off-chain logic, API integrations, and user requests. This backend communicates with the smart contracts to initiate the minting process after verifying cross-chain payments. Frontend: The frontend was developed using React.js for an intuitive and user-friendly interface. We utilized Web3.js and ethers.js libraries to interact with the blockchain from the client side, allowing users to connect their wallets and initiate the minting process. Blockchain Networks: The project supports multiple blockchain networks, including Ethereum, Polygon, and Binance Smart Chain. Hyperlane enables the smooth transfer of data between these networks. Cross-Chain Payment System: To enable gas fee payments with tokens from different chains, we built a custom cross-chain payment system. This system converts the token from the user's chain of choice into the appropriate amount of gas for the target chain, facilitated by liquidity pools and oracles for real-time token pricing. Security: To ensure the security of cross-chain transactions, we implemented a multi-signature validation system on the target chain, verifying that the payment data received via Hyperlane matches the minting request.",
        "how_its_made": "Our chain-agnostic NFT minting solution was built with a focus on flexibility, scalability, and user experience. The project integrates cutting-edge technologies to enable cross-chain transactions, with Hyperlane being the core cross-chain messaging protocol. Here's a breakdown of how we built it: Technologies Used: Hyperlane: We leveraged Hyperlane's cross-chain messaging infrastructure to facilitate secure and seamless communication between blockchains. Hyperlane allows for the transfer of data (in this case, gas fee payments and NFT minting instructions) across multiple chains, ensuring consistency and security. Smart Contracts: Solidity-based smart contracts were deployed on each supported blockchain to handle the minting process. These contracts work in tandem with Hyperlane, listening for cross-chain messages related to gas fee payments and minting instructions. Backend: Our backend is built using Node.js and Express to handle off-chain logic, API integrations, and user requests. This backend communicates with the smart contracts to initiate the minting process after verifying cross-chain payments. Frontend: The frontend was developed using React.js for an intuitive and user-friendly interface. We utilized Web3.js and ethers.js libraries to interact with the blockchain from the client side, allowing users to connect their wallets and initiate the minting process. Blockchain Networks: The project supports multiple blockchain networks, including Ethereum, Polygon, and Binance Smart Chain. Hyperlane enables the smooth transfer of data between these networks. Cross-Chain Payment System: To enable gas fee payments with tokens from different chains, we built a custom cross-chain payment system. This system converts the token from the user's chain of choice into the appropriate amount of gas for the target chain, facilitated by liquidity pools and oracles for real-time token pricing. Security: To ensure the security of cross-chain transactions, we implemented a multi-signature validation system on the target chain, verifying that the payment data received via Hyperlane matches the minting request.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yviwj/screenshots/7xcc1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yviwj/screenshots/daerp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yviwj/screenshots/8fw8y/default.jpg"
        ],
        "live_demo": "https://0xmnipresent.vercel.app/",
        "source_code": "https://github.com/imanishbarnwal/0xmnipresent",
        "link": "https://ethglobal.com/showcase/0xmnipresent-yviwj"
    },
    {
        "title": "Trend",
        "brief_description": "Meet Trend, the decentralized social layer for fitness apps! Leverage Sign Protocol to record verified, on-chain attestations of your fitness achievements, making them composable with reputation systems and other Web3 protocols.",
        "long_description": "Trend introduces a decentralized social layer for fitness apps, allowing users to verify their workout achievements through on-chain attestations. Powered by Sign Protocol, users can create verifiable proof of completed workouts, such as running or cycling with their peers. By recording these activities on-chain, Trend enables composability with other decentralized systems, like reputation protocols, allowing users to build a verified fitness track record that transcends individual platforms. This decentralized approach adds trust and flexibility to fitness data, enabling a richer social experience for users while maintaining privacy and control over their information. There are many Web2 fitness apps, like Nike Run Club, Strava, and Hevy, which have built-in social features to track workouts and engage users through competition and collaboration. However, these apps operate on centralized databases, limiting composability and user control over their data. Trend bridges this gap by providing a decentralized social layer. Using Sign Protocol, users can verify their fitness activities on-chain. This composable data can integrate with reputation systems, allowing for broader, cross-platform recognition of fitness achievements, enhancing both social interaction and user ownership. Trend leverages Sign Protocol to power its attestation layer, enabling decentralized verification of fitness activities. Attestations are stored on-chain, ensuring the data is immutable and composable with other protocols, such as decentralized reputation systems. Smart contracts, written in Solidity, handle the attestation issuance and verification process. By using open standards, Trend enables fitness apps to easily integrate this decentralized social layer, while ensuring data privacy, scalability, and interoperability with Web3 ecosystems.",
        "how_its_made": "Trend leverages Sign Protocol to power its attestation layer, enabling decentralized verification of fitness activities. Attestations are stored on-chain, ensuring the data is immutable and composable with other protocols, such as decentralized reputation systems. Smart contracts, written in Solidity, handle the attestation issuance and verification process. By using open standards, Trend enables fitness apps to easily integrate this decentralized social layer, while ensuring data privacy, scalability, and interoperability with Web3 ecosystems.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/p3r89/screenshots/mziyr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/p3r89/screenshots/k58t0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/p3r89/screenshots/nva69/default.jpg",
            "https://ethglobal.b-cdn.net/projects/p3r89/screenshots/dhdha/default.jpg"
        ],
        "live_demo": "https://trend-plum.vercel.app/",
        "source_code": "https://github.com/Web3Rizzards/trend",
        "link": "https://ethglobal.com/showcase/trend-p3r89"
    },
    {
        "title": "Geist",
        "brief_description": "Geist is a Decentralized Autonomous Website (DAW) Builder. Wallet Whitelist for Private Previews, Trustless zk-proof based deployment after anti collusion proposal voting, we allow DAOs to collaborate at scale and make the Internet more trustless.",
        "long_description": "ETHGlobal SG 24 Submission | Presentation Today, one can build a static dWebsite that is censorship resistent, decentralized by hosting it on IPFS, with resolution handled by ENS domain. Websites can be updated via IPNS wiith immutable content trails and made persistent with IPFS pinnings. Great tools such as eth.limo and fleek made such approach user friendly. Pairing with smart contract, we can create autonomous dApp comprised of UI and fully on-chain application states that benefit from security and governance mechanism of Ethereum. As billions of websites are not decentralized today, we explore challenges and opportunites for making dWebsite greater and more autonomous. We build Geist to support DAW by removing trust assumptions in development & deployment, add private previews to website and support anti collusion voting, so we can say good bye to seat-based pricing centralization tools and for DAO to collaborate at scale. IPFS has no content encryption and teams or DAOs always fallback to small trusted core team and centralized identity for collaboration.\nIn particualr, private previews and review/voting on proposal are often essential for websites. Existing platforms such as Github, Vercel are hard to be utilized by large, diverse group of contributors, due to high seat-based pricing and lack of web3-identity (e.g. wallets/ens) based access control mechanisms. On-chain whitelist is often prohibitive due to inflexibility and cost. Websites deployment are subject to all sort of attack vectors, from DNS registrar, supply chain attack to various hosting concerns. Censorship resistance is not guarantee on hosted platforms and pipelines always require priviledged access. We would like to bring on-chain security to make websites more autonomous, add guardrails and make changes more trackable?\nWe see a lot of use cases from DAW, from displaying censorship-sensitive key information, Whistle Bowling, Crowdfunding, Community Notes, Internet Archive to where fair mechanisms is in need such  Autonomous World or Advertisement. We host websites preview on IPFS encrypted behind our gateway website.\nUsers are required to visit gateway and sign with wallet to for access. With CCIP protocol, we deployed a Hybrid resolver which is able to resolve both on and off chain data. The resolver will resolve encrypted hash at TXT record of target domain and attach token to custom gateway for authentication. UI Gateway will redirect user given derypted ipfs hash response if user is whitelisted. we use MACI to support users to decide which version of proposed website can be deployed. A zk proof on the tally results will be generated and can be associated with the build. we deployed a Hybrid resolver which is able to resolve both on and off chain data. source code of gateway is under apps/worker, originally maintained at separate forked repository ens-offchain-registrar Proof of Build is created for each website build We use MINA chain to verify the build to be deployed is in line with proposal, by creating merkle map and and comparing against on-chain commitment In future, it is possible to further automate the trustless process once Protokit is able to roll up to L1 and the production EVM bridge is deployed.",
        "how_its_made": "We host websites preview on IPFS encrypted behind our gateway website.\nUsers are required to visit gateway and sign with wallet to for access. With CCIP protocol, we deployed a Hybrid resolver which is able to resolve both on and off chain data. The resolver will resolve encrypted hash at TXT record of target domain and attach token to custom gateway for authentication. UI Gateway will redirect user given derypted ipfs hash response if user is whitelisted. we use MACI to support users to decide which version of proposed website can be deployed. A zk proof on the tally results will be generated and can be associated with the build. we deployed a Hybrid resolver which is able to resolve both on and off chain data. source code of gateway is under apps/worker, originally maintained at separate forked repository ens-offchain-registrar Proof of Build is created for each website build We use MINA chain to verify the build to be deployed is in line with proposal, by creating merkle map and and comparing against on-chain commitment In future, it is possible to further automate the trustless process once Protokit is able to roll up to L1 and the production EVM bridge is deployed.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/x3fur/screenshots/cnrr2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x3fur/screenshots/hcuvb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x3fur/screenshots/2pses/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x3fur/screenshots/s96cn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x3fur/screenshots/cq76m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x3fur/screenshots/6c546/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/debuggingfuture/geist",
        "link": "https://ethglobal.com/showcase/geist-x3fur"
    },
    {
        "title": "SQUIDL",
        "brief_description": "Squidl is a privacy-focused platform that makes managing payments simple and secure. With private static payment links that also work as ENS addresses, you can easily accept crypto or credit card payments while keeping everything untraceable.",
        "long_description": "Squidl.me is a platform designed to give individuals and businesses total control over their payments and financial transactions. By using stealth addresses, Squidl ensures that every transaction is private and untraceable. With custom static payment links that double as ENS addresses, users can easily receive payments in crypto or fiat without exposing their identities or financial data.\nThe platform offers seamless integration with various blockchain networks, including Ethereum, BSC, Morph, Linea, and Flow EVM, allowing users to accept a wide range of payment options. Additionally, credit card payments are converted to USDC and bridged to BSC, ensuring both convenience and privacy. Squidl also features the ability to bridge funds to the Oasis Sapphire network, where transactions become completely untraceable, adding an extra layer of security.\nSquidl\u2019s flexibility extends to asset transfers as well, supporting the private transfer of NFTs, soulbound tokens, and liquidity tokens. With its easy-to-use interface, unified dashboard, and powerful SDK for developers, Squidl is the go-to platform for anyone looking to manage payments with privacy, flexibility, and control. Our double-blind stealth address system guarantees that no third party, including us as developers, can ever know of the existence of any stealth address, or the financial value stored in these stealth addresses, marking a breakthrough in EVM privacy that rivals Bitcoin\u2019s silent payment wallets. We use Sapphire ParaTime to make our stealth address system fully non-custodial. While Vitalik\u2019s stealth addresses offer a lightweight approach to enhanced privacy on Ethereum, they require Elliptic Curve Diffie-Hellman (ECDH), which in other implementations exposes private keys to potentially insecure environments like the user\u2019s device, dApp website, or developer\u2019s server backend, or user\u2019s browser runtime (that time and again have reported vulnerabilities). By leveraging Sapphire\u2019s EVM precomputes, we generate entropy and perform elliptic curve operations all within Sapphire\u2019s Trusted Execution Environment (TEE), eliminating the risk of private key theft or exfiltration, especially when used with hardware wallets. We also use Sapphire\u2019s precomputes to derive secp256k1 public keys from ECDH shared secrets, a critical operation for silent payments (BIP 0352 / EIP 5564) that would normally require significant gas without these optimizations, (in fact more that 550,000 gas for just one derivation of a single stealth address). Our setup enables the creation of simple, reusable payment URLs with no expiration, which encode static meta-addresses for use across multiple transactions. These URLs can generate an unlimited amount of stealth addresses, and are secure against man-in-the-middle attacks, with the only potential risk being the unlikely scenario of a malicious or compromised Sapphire Network RPC provider. Additionally, we use Sapphire ROFL to fetch stealth-ephemeralPubKeys announcement pages from off-chain public servers from within attested Sapphire TEEs/SGX, and then scan for on-chain activity of stealth addresses through omni-chain wallet API providers (1inch). Since each visit to our payment link or ENS resolution generates a unique stealth address, many such generated addresses may not be used at all. The ROFL TEE Oracle checks for transactions or ERC-20 transfers linked to each stealth address, before recording announcements (ephemeralPubKeys) permanently on-chain through on-chain event logs (that reveal no address or secrets). This improves upon the previous cumbersome UX within EIP 5562, of requiring the sender or payer to publish an announcement data on-chain, after any transaction to each stealth address. EIP 5562 also leaks the existence of such stealth addresses through the emitted Announcement event that contains all stealth addresses in plaintext.\nThe way that our smart contracts and oracles are built on top of Sapphire\u2019s technology stack, avoids such an issue, thus guaranteeing that no third party, including us as developers, can ever know of the existence of these stealth addresses, or the financial value stored in these stealth addresses, marking a breakthrough in EVM privacy that rivals Bitcoin\u2019s silent payment wallets. Noteworthy Hack 1:  Sender privacy is significantly more difficult to achieve than receiver privacy. Receiver privacy means the sender does not know the receiver\u2019s identity, while sender privacy means the recipient does not know the sender\u2019s identity. Achieving sender anonymity for fungible and non-fungible token transfers has been a long-standing challenge in the EVM ecosystem, previously only possible through gas-intensive solutions like Tornado Cash or Railgun, which are vulnerable to international sanctions. With the use of Cellar cBridge, ERC20 tokens can be converted into special Sapphire private wrapped tokens that prevent leakage of recipient balances or sender addresses. By transferring these private wrapped tokens between stealth addresses within Sapphire\u2019s privacy-focused network, all typical ERC20 event logs\u2014such as ERC20.Transfer(from, to)\u2014are concealed, making sender privacy attainable on the EVM. This ensures that third-party observers, including the recipient, cannot identify the sender\u2019s address. Combined with our stealth address system, recipients can create uniquely labeled payment links that do not expose the sender\u2019s identity after the transaction. This solution enables token transfers with full sender privacy and no additional gas overhead (compared to a typical ERC20 Transfer). Noteworthy Hack 2: All cryptographic operations required for stealth addresses are performed within Sapphire\u2019s EVM. Including signing transactions when spending/sending from stealth addresses. Keys never leave the secure enclave, thus becoming like a HSM in the cloud. Noteworthy Hack 3: We developed StealthSdk.sol, a contract that can be deployed on any EVM chain supported by Sapphire\u2019s OPL. This allows users to register for our stealth address system by simply calling StealthSdk.register(eip712Auth) on their home network, without needing to acquire ROSE (Sapphire\u2019s gas token) themselves. However, we can only demo this feature after further coordination with Sapphire testnet SGN operators.",
        "how_its_made": "Our double-blind stealth address system guarantees that no third party, including us as developers, can ever know of the existence of any stealth address, or the financial value stored in these stealth addresses, marking a breakthrough in EVM privacy that rivals Bitcoin\u2019s silent payment wallets. We use Sapphire ParaTime to make our stealth address system fully non-custodial. While Vitalik\u2019s stealth addresses offer a lightweight approach to enhanced privacy on Ethereum, they require Elliptic Curve Diffie-Hellman (ECDH), which in other implementations exposes private keys to potentially insecure environments like the user\u2019s device, dApp website, or developer\u2019s server backend, or user\u2019s browser runtime (that time and again have reported vulnerabilities). By leveraging Sapphire\u2019s EVM precomputes, we generate entropy and perform elliptic curve operations all within Sapphire\u2019s Trusted Execution Environment (TEE), eliminating the risk of private key theft or exfiltration, especially when used with hardware wallets. We also use Sapphire\u2019s precomputes to derive secp256k1 public keys from ECDH shared secrets, a critical operation for silent payments (BIP 0352 / EIP 5564) that would normally require significant gas without these optimizations, (in fact more that 550,000 gas for just one derivation of a single stealth address). Our setup enables the creation of simple, reusable payment URLs with no expiration, which encode static meta-addresses for use across multiple transactions. These URLs can generate an unlimited amount of stealth addresses, and are secure against man-in-the-middle attacks, with the only potential risk being the unlikely scenario of a malicious or compromised Sapphire Network RPC provider. Additionally, we use Sapphire ROFL to fetch stealth-ephemeralPubKeys announcement pages from off-chain public servers from within attested Sapphire TEEs/SGX, and then scan for on-chain activity of stealth addresses through omni-chain wallet API providers (1inch). Since each visit to our payment link or ENS resolution generates a unique stealth address, many such generated addresses may not be used at all. The ROFL TEE Oracle checks for transactions or ERC-20 transfers linked to each stealth address, before recording announcements (ephemeralPubKeys) permanently on-chain through on-chain event logs (that reveal no address or secrets). This improves upon the previous cumbersome UX within EIP 5562, of requiring the sender or payer to publish an announcement data on-chain, after any transaction to each stealth address. EIP 5562 also leaks the existence of such stealth addresses through the emitted Announcement event that contains all stealth addresses in plaintext.\nThe way that our smart contracts and oracles are built on top of Sapphire\u2019s technology stack, avoids such an issue, thus guaranteeing that no third party, including us as developers, can ever know of the existence of these stealth addresses, or the financial value stored in these stealth addresses, marking a breakthrough in EVM privacy that rivals Bitcoin\u2019s silent payment wallets. Noteworthy Hack 1:  Sender privacy is significantly more difficult to achieve than receiver privacy. Receiver privacy means the sender does not know the receiver\u2019s identity, while sender privacy means the recipient does not know the sender\u2019s identity. Achieving sender anonymity for fungible and non-fungible token transfers has been a long-standing challenge in the EVM ecosystem, previously only possible through gas-intensive solutions like Tornado Cash or Railgun, which are vulnerable to international sanctions. With the use of Cellar cBridge, ERC20 tokens can be converted into special Sapphire private wrapped tokens that prevent leakage of recipient balances or sender addresses. By transferring these private wrapped tokens between stealth addresses within Sapphire\u2019s privacy-focused network, all typical ERC20 event logs\u2014such as ERC20.Transfer(from, to)\u2014are concealed, making sender privacy attainable on the EVM. This ensures that third-party observers, including the recipient, cannot identify the sender\u2019s address. Combined with our stealth address system, recipients can create uniquely labeled payment links that do not expose the sender\u2019s identity after the transaction. This solution enables token transfers with full sender privacy and no additional gas overhead (compared to a typical ERC20 Transfer). Noteworthy Hack 2: All cryptographic operations required for stealth addresses are performed within Sapphire\u2019s EVM. Including signing transactions when spending/sending from stealth addresses. Keys never leave the secure enclave, thus becoming like a HSM in the cloud. Noteworthy Hack 3: We developed StealthSdk.sol, a contract that can be deployed on any EVM chain supported by Sapphire\u2019s OPL. This allows users to register for our stealth address system by simply calling StealthSdk.register(eip712Auth) on their home network, without needing to acquire ROSE (Sapphire\u2019s gas token) themselves. However, we can only demo this feature after further coordination with Sapphire testnet SGN operators.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/psquk/screenshots/1ypkm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/psquk/screenshots/2m1d4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/psquk/screenshots/o7bdo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/psquk/screenshots/2mx8v/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/engowl/squidl",
        "link": "https://ethglobal.com/showcase/squidl-psquk"
    },
    {
        "title": "izanami",
        "brief_description": "izanami is an AI-powered social reputation tool that evaluates and analyzes blockchain addresses, providing users with comprehensive insights based on AI and community-driven reviews.",
        "long_description": "Izanami is an innovative tool that leverages AI and community insights to evaluate blockchain addresses. It uses a large language model (LLM) to categorize users based on various dimensions, securely storing all data on the blockchain. Users can decrypt their identity and engage in group voting, creating a unique social persona verified by the community. This persona evolves with each interaction, allowing users to express different facets of their personality in various social contexts. Izanami helps users make informed decisions by providing detailed evaluations and personalized insights. Izanami is built using a combination of state-of-the-art technologies. The backend is powered by Phala Network's decentralized serverless cloud, utilizing the Hono framework for ultrafast web services.\nThe AI evaluations are conducted using RedPill's API, which integrates seamlessly with the system.\nThe frontend includes a Chrome extension for real-time address evaluations on social networks.\nThe project also employs smart contracts on the Flow Testnet to manage reputation scores, ensuring secure and transparent evaluations.\nThe integration of these technologies allows Izanami to provide reliable and comprehensive address analysis. Website: Izanami Flow Testnet: 0xe3a6b8Da8932354592E7F3f6199b82D6E2bdBDb2 Chrome Extension: pnpm run build --filter extension\nhttps://github.com/hollow-leaf/izanami/blob/main/apps/extension/contentScript.js Phana Ai: https://wapo-testnet.phala.network/ipfs/QmW5ddBNgH6y6NCbgcKQDMDBvW2x2gyhutKBR1eVQEXq7A?key=2342b0ccac844129&address=0xe3a6b8Da8932354592E7F3f6199b82D6E2bdBDb2 Izanami is an innovative address analysis tool that combines AI and community-driven insights. It helps you evaluate and understand social interactions with ease and precision. Using a large language model (LLM), users are grouped into categories based on multiple dimensions. All data, including evaluations and historical information, is securely stored on the blockchain and encrypted. Only the user can decrypt their identity, while group voting enables users to engage in discussions or decisions with a unique social persona. This persona, verified and recognized by the community, may change after each social interaction. The system allows users to express different aspects of their personality in various social contexts. For example, an introverted person who actively votes in an outdoor activity might have their vote carry more weight. Conversely, an extrovert contributing to solitary challenges can demonstrate the tool\u2019s value. Overall, Izanami provides a way for users to showcase multiple facets of their personality in different social scenarios, all within a secure and decentralized framework. apps/extension apps/phana-ai apps/serverless apps/update-host packages/contract",
        "how_its_made": "Izanami is built using a combination of state-of-the-art technologies. The backend is powered by Phala Network's decentralized serverless cloud, utilizing the Hono framework for ultrafast web services.\nThe AI evaluations are conducted using RedPill's API, which integrates seamlessly with the system.\nThe frontend includes a Chrome extension for real-time address evaluations on social networks.\nThe project also employs smart contracts on the Flow Testnet to manage reputation scores, ensuring secure and transparent evaluations.\nThe integration of these technologies allows Izanami to provide reliable and comprehensive address analysis. Website: Izanami Flow Testnet: 0xe3a6b8Da8932354592E7F3f6199b82D6E2bdBDb2 Chrome Extension: pnpm run build --filter extension\nhttps://github.com/hollow-leaf/izanami/blob/main/apps/extension/contentScript.js Phana Ai: https://wapo-testnet.phala.network/ipfs/QmW5ddBNgH6y6NCbgcKQDMDBvW2x2gyhutKBR1eVQEXq7A?key=2342b0ccac844129&address=0xe3a6b8Da8932354592E7F3f6199b82D6E2bdBDb2 Izanami is an innovative address analysis tool that combines AI and community-driven insights. It helps you evaluate and understand social interactions with ease and precision. Using a large language model (LLM), users are grouped into categories based on multiple dimensions. All data, including evaluations and historical information, is securely stored on the blockchain and encrypted. Only the user can decrypt their identity, while group voting enables users to engage in discussions or decisions with a unique social persona. This persona, verified and recognized by the community, may change after each social interaction. The system allows users to express different aspects of their personality in various social contexts. For example, an introverted person who actively votes in an outdoor activity might have their vote carry more weight. Conversely, an extrovert contributing to solitary challenges can demonstrate the tool\u2019s value. Overall, Izanami provides a way for users to showcase multiple facets of their personality in different social scenarios, all within a secure and decentralized framework. apps/extension apps/phana-ai apps/serverless apps/update-host packages/contract",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6uk7u/screenshots/kbs4w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6uk7u/screenshots/a67s8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6uk7u/screenshots/qc6zy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6uk7u/screenshots/90fuh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6uk7u/screenshots/9hjpj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/hollow-leaf/izanami/",
        "link": "https://ethglobal.com/showcase/izanami-6uk7u"
    },
    {
        "title": "StarkBoost",
        "brief_description": "Under-collateralized lending protocol using verifiable credentials to give a credit score for opening dynamic credit line and give more voting power for small and loyal users on Starknet.",
        "long_description": "Star User is the Only Dust of users. This under-collateralized lending protocol leverages the on-chain reputation on Starknet to give a credit score and open a dynamic credit line to small and loyal users, allowing them to borrow $STRK, encourage active participation in governance by wrapping $STRK, and improve activity on Starknet thanks to their actions. We want to continue this project after the hackathon and work with the Starknet Foundation and open-source contributors from Only Dust. CURRENT STATE CORE PROPERTIES TO BOOST VOTING POWER FOR SMALL/LOYAL USERS The protocol targets about 30% of the best small and loyal users on Starknet, without including whales. As with any monetary system, it's all about trust. 1 - Credit Scoring\nThe credit score helps to check the eligible users to receive a credit line and define 3 types of eligible users to borrow between 1,000 to 5,000 STRK with a credit score between 65% to 100%. We are using different elements to track this credit score (/100), including a few variables (from X% to X%) on each element like the seniority and activity (wallet activity, social connections...) 2 - Dynamic Credit Line\nThe liquidity is coming from Starknet incentives for users. The credit score opens a dynamic credit line, where this one can up or down following continuous actions on Starknet (governance activity, refer good people, payback credibility..) 3 - Safeguarding System\nAt first, the user base will be small, but then it will grow virtuously. We will be able to see the best users, not in terms of amount, but only because the user is loyal and manages to build a reliable user community around him. When you give access to 2 people from your circle to the protocol as a safeguard, you can earn points by referring someone good for Starknet as a user, or get a malus when one of your safeguards has bad behavior or it's a bot, etc. We are using game theory and the right to open contests to judge people on the protocol and build a strong community. 4 - Innovative Loan System (smart contract workflow)\n1\ufe0f\u20e3 According to their credit score and credit line (X), the user sends X $STRK and defines how much he wants to put in vSTRK (minimum 40%) 2\ufe0f\u20e3 According to the amount put in vSTRK, the smart contract asks a Y percentage of X $STRK, that is superior of the amount sent by the user (to boost the voting power) 3\ufe0f\u20e3 The foundation sends Y $STRK to the smart-contract 4\ufe0f\u20e3 & 5\ufe0f\u20e3 The smart contract wraps in vSTRK the X $STRK from the user and the 40% minimum from the foundation to boost voting power 6\ufe0f\u20e3 The smart contract locks and delegates Z $vSTRK 7\ufe0f\u20e3 The remains Y $STRK from the foundation is sent to the user to increase on-chain activity 5 - Payback System (2 options) Repayment from the user's wallet: The user reimburses the amount lent by the foundation. The delegated vSTRK is undelegated and sent back to the user.\nUndelegating the VSTRK: The delegated vSTRK are undelegated. The loan is reimbursed to the foundation and the remaining amount is returned to the user.` ROADMAP FRONTEND Scaffold-Stark open-source frontend design\nImport Starknet components through Rainbowkit (like Argent wallet)` BACKEND We have created several scripts using the API for the various data to be fetched to calculate the credit score. SMART CONTRACT FUNCTIONS We are using the functions that already exist in the STRK token contract that swap STRK to vSTRK, and delegate it at the same time. 1\ufe0f\u20e3 GET THE LOAN Get_token_from_fondation: - Requests the desired amount of STRK from the foundation's pool. Wrapp_token: - Wraps the STRK received from the user and the foundation. Delegate: - Immediately delegates the wrapped STRK to the user who initiated the transaction. Send_left_token: - Sends 60% or less of the foundation's STRK to the user. 2\ufe0f\u20e3 PAYBACK THE LOAN Undelegate_token: - Remove the delegation to the user. UnWrapp_token: - UnWrapp vSTRK to STRK. Repay_user: - Send back the amount of the loan to the foundation + Send back the token to the user.",
        "how_its_made": "FRONTEND Scaffold-Stark open-source frontend design\nImport Starknet components through Rainbowkit (like Argent wallet)` BACKEND We have created several scripts using the API for the various data to be fetched to calculate the credit score. SMART CONTRACT FUNCTIONS We are using the functions that already exist in the STRK token contract that swap STRK to vSTRK, and delegate it at the same time. 1\ufe0f\u20e3 GET THE LOAN Get_token_from_fondation: - Requests the desired amount of STRK from the foundation's pool. Wrapp_token: - Wraps the STRK received from the user and the foundation. Delegate: - Immediately delegates the wrapped STRK to the user who initiated the transaction. Send_left_token: - Sends 60% or less of the foundation's STRK to the user. 2\ufe0f\u20e3 PAYBACK THE LOAN Undelegate_token: - Remove the delegation to the user. UnWrapp_token: - UnWrapp vSTRK to STRK. Repay_user: - Send back the amount of the loan to the foundation + Send back the token to the user.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3ejxn/screenshots/ig7r0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3ejxn/screenshots/6xkgy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3ejxn/screenshots/pvd5f/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/frgpy/Singapore",
        "link": "https://ethglobal.com/showcase/starkboost-3ejxn"
    },
    {
        "title": "JITLiq Network",
        "brief_description": "JIT Liquidity Network\u2014a scalable liquidity layer powered by an actively validated solver network, making fast and efficient bridging across multiple chains possible",
        "long_description": "JIT Liquidity Network is a scalable liquidity layer that delivers cross-chain liquidity just-in-time without locking assets. By solving requests instantly and allowing users to keep using their assets, it maximizes liquidity efficiency across chains. This approach reduces fragmentation and ensures fast, seamless transfers without delays or trust assumptions. JIT Liquidity Network consists of solver nodes written in Golang, using libp2p for gossip and attestation of orders. The nodes listen to events from the entrypoint, locking the solver\u2019s stake if the task is not completed. Solvers prepare the destination bridge call, pulling the approved amount. Once completed, a Layer Zero event releases the stake and distributes fees and refunds. The contracts are deployed on Base, Arbitrum, and Flow",
        "how_its_made": "JIT Liquidity Network consists of solver nodes written in Golang, using libp2p for gossip and attestation of orders. The nodes listen to events from the entrypoint, locking the solver\u2019s stake if the task is not completed. Solvers prepare the destination bridge call, pulling the approved amount. Once completed, a Layer Zero event releases the stake and distributes fees and refunds. The contracts are deployed on Base, Arbitrum, and Flow",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/m2cw1/screenshots/uy5vw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m2cw1/screenshots/oedyx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m2cw1/screenshots/b5w5u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m2cw1/screenshots/dgk7a/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/JITLiq",
        "link": "https://ethglobal.com/showcase/jitliq-network-m2cw1"
    },
    {
        "title": "XNFT",
        "brief_description": "Cryptographic verification of twitter followers onchain using TLSNotary",
        "long_description": "We have built a way to prove on-chain how many twitter followers a user has using TLSNotary. This produces a soulbound NFT that proves how many twitter followers a user has. The possible applications of this are endless: proof of humanity, reputation-based voting, decentralised Patreon, etc. TLSNotary allows Web2 requests (and responses) to be proven. Whilst making a request, a proof of this request is made using MPC between the webserver and a third party, and this guarantees the request and response that happened. This proof can then be verified in Rust. TLSNotary verification has not yet been written in an EVM-compatible language. The current implementation is written in Rust and uses many secondary libraries such as Tokio. Thus, to run our code verifiably onchain, we use Cartesi - Cartesi is optimistic offchain compute that executes in a Linux VM, thus allowing us to use all of the dependencies of TLSNotary. A web request is made to a Twitter server by an authorised user - we can catch this web request and 'notarise' it, to form two proofs; one that the account is owned by this user, and another that the account has n followers. This proof is then pushed on-chain and then verified by the off-chain Cartesi coprocessor. This then produces a soulbound NFT, proving that the user had this many twitter followers at that time.",
        "how_its_made": "TLSNotary allows Web2 requests (and responses) to be proven. Whilst making a request, a proof of this request is made using MPC between the webserver and a third party, and this guarantees the request and response that happened. This proof can then be verified in Rust. TLSNotary verification has not yet been written in an EVM-compatible language. The current implementation is written in Rust and uses many secondary libraries such as Tokio. Thus, to run our code verifiably onchain, we use Cartesi - Cartesi is optimistic offchain compute that executes in a Linux VM, thus allowing us to use all of the dependencies of TLSNotary. A web request is made to a Twitter server by an authorised user - we can catch this web request and 'notarise' it, to form two proofs; one that the account is owned by this user, and another that the account has n followers. This proof is then pushed on-chain and then verified by the off-chain Cartesi coprocessor. This then produces a soulbound NFT, proving that the user had this many twitter followers at that time.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sys01/screenshots/wfjq8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sys01/screenshots/y60pc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sys01/screenshots/qvz7r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sys01/screenshots/sz2so/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MattyAB/tlsn_twitter",
        "link": "https://ethglobal.com/showcase/xnft-sys01"
    },
    {
        "title": "P2P Cash",
        "brief_description": "QuickPay is a crypto-to-fiat solution for expats and tourists, enabling smooth payments with local merchants. Built on Flow blockchain, it offers low fees, requires no local bank account, and integrates easily with businesses.",
        "long_description": "QuickPay is a crypto-to-fiat payment system designed for expats and tourists to interact seamlessly with local merchants, solving the challenges of needing local bank accounts or cash.  In this hackathon, we developed a web-based mobile app for both users and agents, where agents manually handle transactions to enhance the user experience. Offering lower fees than cards, it\u2019s a decentralized, mobile-first solution adaptable across countries. Built on the Flow blockchain, it integrates with existing systems using QR codes, enabling payments without additional hardware or crypto knowledge for merchants. QuickPay leverages Dynamic/Metamask for wallet management, Chainlink for currency conversion, and Worldcoin for KYC compliance.",
        "how_its_made": "Built on the Flow blockchain, it integrates with existing systems using QR codes, enabling payments without additional hardware or crypto knowledge for merchants. QuickPay leverages Dynamic/Metamask for wallet management, Chainlink for currency conversion, and Worldcoin for KYC compliance.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1jspx/screenshots/er0oi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1jspx/screenshots/e7nc8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1jspx/screenshots/vpsyr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1jspx/screenshots/kxoij/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1jspx/screenshots/bcu9j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1jspx/screenshots/u18yi/default.jpg"
        ],
        "live_demo": "https://p2p-cash.vercel.app/",
        "source_code": "https://github.com/UniqSoftTech/p2p-cash",
        "link": "https://ethglobal.com/showcase/p2p-cash-1jspx"
    },
    {
        "title": "Rebirth of Humanity",
        "brief_description": "Rebirth of Humanity: A post-apocalyptic text-based strategy game where players guide humanity's survival by making crucial decisions in a world dominated by AI",
        "long_description": "AI Agent: We built AI agent to drive the game\u2019s core decision-making process. These agents dynamically create narrative paths based on user choices, ensuring each decision significantly impacts the storyline. The AI agents also analyze user inputs, adapting the game's scenarios and challenges in real-time, resulting in a personalized experience for each player. The agents are built using Phala TEE smart contract system allowing players to interact with the blockchain using AI automatically . Identity Verification with Worldcoin: Before players embark on their journey, they must verify their humanity using Worldcoin. This step ensures that users are humans, not AI agents, setting the stage for the narrative of human survival and AI dominance. Worldcoin provides decentralized identity verification in a seamless way, integrated directly into the game's onboarding flow. Flow Blockchain for Game Logic: We used Flow to handle in-game logic and asset ownership, including players\u2019 progress, rewards, and achievements. By leveraging Flow\u2019s efficient and scalable infrastructure, we ensure a smooth user experience with minimal gas fees and high-speed interactions.\nFlow also manages the game's XP and prize redemption system, allowing users to accumulate rewards and redeem them for in-game assets or advantages as they progress through the storyline. Dynamic Web3 Wallet Integration: We integrated Dynamic, to handle seamless asset management for players. Dynamic allows users to securely interact with the game's blockchain features without friction. User Interface: We designed a minimalist, intuitive UI that focuses on user immersion. The user's story dynamically changes based on player actions and AI decisions, offering a reactive and engaging player experience, with subtle visual cues and responsive elements that highlight the emotional tension and consequences of each choice. Game Logic and Interaction: Each decision is part of a larger story tree, where user inputs directly impact the next stage of the narrative. We implemented conditional logic to ensure that each choice leads to unique outcomes, with the possibility of multiple storylines based on the paths chosen. The player's actions influence the future of humanity, whether they choose to cooperate with AI or resist. Our project uses React and Node.js to build the core functionality, while leveraging the Replicate API to power Flux, the AI model responsible for generating dynamic storylines and decision-making. We integrated Wagmi for handling Web3 interactions, and Dynamic serves as the Web3 wallet for seamless user authentication and secure asset management. For decentralized identity verification, we implemented Worldcoin. Flow was used as the blockchain. Phala makes it possible for the AI to automatically interact with the blockchain.",
        "how_its_made": "Our project uses React and Node.js to build the core functionality, while leveraging the Replicate API to power Flux, the AI model responsible for generating dynamic storylines and decision-making. We integrated Wagmi for handling Web3 interactions, and Dynamic serves as the Web3 wallet for seamless user authentication and secure asset management. For decentralized identity verification, we implemented Worldcoin. Flow was used as the blockchain. Phala makes it possible for the AI to automatically interact with the blockchain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xqvgm/screenshots/y8zvj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xqvgm/screenshots/48nj3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xqvgm/screenshots/qgtch/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xqvgm/screenshots/mdu27/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xqvgm/screenshots/kitfi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xqvgm/screenshots/nwymk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ethsingapore-roh/roh-game",
        "link": "https://ethglobal.com/showcase/rebirth-of-humanity-xqvgm"
    },
    {
        "title": "Artstock",
        "brief_description": "Artstock revolutionizes the art market by tokenizing physical artworks: transparent and secure. Track provenance and be sure about authenticity of art pieces, while having extra liquidity by trading on our escrowed market. Redeemed for physical delivery at any time.",
        "long_description": "Artstock will revolutionize the art market by tokenizing physical art: a more transparent and secure way to buy and sell art. Artstock makes possible the tracking of provenance and authenticity of art pieces through curators, therefore making it easier to verify the authenticity of art pieces. Artstock also features a secondary market for art pieces, allowing for the trading of art pieces in a secure and transparent manner. Artstock will revolutionize the art market by tokenizing physical art: a more transparent and secure way to buy and sell art. Artstock makes possible the tracking of provenance and authenticity of art pieces through curators, therefore making it easier to verify the history of artworks. Artstock also features a secondary market for art, allowing for the trading of art pieces in a secure and transparent manner. The physical items have to be held by a guardian in order to go through careful curation, before they can be traded on our market using an escrow smart contract. The token can be redeemed for physical delivery at any time. Tech stack: Build on the Rootstock blockchain to get the security and liquidity of Bitcoin, while having the smart contract possibilities of an EVM. This worked pretty good due to EVM-compatibility, while deploying faced outages from RPC and explorers.\nLogin (both web2 and web3) are powered by Dynamic to make the user experience easy for non-crypto users (at least the curators and guardians) and screen for sanctioned wallets when paying.\nSmart contracts in Solidity. Frontend in React with Next.js.",
        "how_its_made": "Artstock will revolutionize the art market by tokenizing physical art: a more transparent and secure way to buy and sell art. Artstock makes possible the tracking of provenance and authenticity of art pieces through curators, therefore making it easier to verify the history of artworks. Artstock also features a secondary market for art, allowing for the trading of art pieces in a secure and transparent manner. The physical items have to be held by a guardian in order to go through careful curation, before they can be traded on our market using an escrow smart contract. The token can be redeemed for physical delivery at any time. Tech stack: Build on the Rootstock blockchain to get the security and liquidity of Bitcoin, while having the smart contract possibilities of an EVM. This worked pretty good due to EVM-compatibility, while deploying faced outages from RPC and explorers.\nLogin (both web2 and web3) are powered by Dynamic to make the user experience easy for non-crypto users (at least the curators and guardians) and screen for sanctioned wallets when paying.\nSmart contracts in Solidity. Frontend in React with Next.js.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/grypg/screenshots/jdcv4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/grypg/screenshots/qyj02/default.jpg",
            "https://ethglobal.b-cdn.net/projects/grypg/screenshots/vwfyf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/grypg/screenshots/796ck/default.jpg",
            "https://ethglobal.b-cdn.net/projects/grypg/screenshots/i5pvt/default.jpg"
        ],
        "live_demo": "https://artstock-eight.vercel.app/",
        "source_code": "https://github.com/wariomx/Artstock/",
        "link": "https://ethglobal.com/showcase/artstock-grypg"
    },
    {
        "title": "NounsPilot",
        "brief_description": "NounsPilot optimizes crypto portfolios by analyzing holdings and recommending strategies to maximize rewards. It leverages cross-chain protocols, restaking services, and high-yield opportunities to enhance user returns. Built with 1inch, Circle, LayerZero, and NounsDAO assets.",
        "long_description": "NounsPilot is a cutting-edge platform designed to help users maximize the utility of their assets through optimized DeFi strategies. By analyzing a user's portfolio, it identifies the most effective ways to enhance returns. For instance, if a user is already utilizing a restaking service, NounsPilot can recommend additional platforms to further deposit stacked tokens, maximizing the potential for rewards. The platform also highlights the highest yields and rates available, including cross-chain opportunities, ensuring users can make informed decisions across various protocols. NounsPilot integrates 1inch APIs for accurate balance and token data, Circle for seamless USDC transactions, and LayerZero for effortless cross-chain token bridging, enabling users to implement advanced DeFi strategies with ease. The user interface is thoughtfully designed with NounsDAO's distinctive style and assets, offering an intuitive, visually engaging experience that makes decentralized investing both simple and rewarding. NounsPilot leverages a robust combination of advanced technologies and APIs to deliver a seamless and powerful DeFi experience. By integrating 1inch's Dev Portal APIs, the platform ensures precise portfolio analysis with real-time balance and token information. Circle's USDC integration enables smooth financial transactions within the platform, while LayerZero's bridging capabilities allow for seamless cross-chain token transfers, enhancing interoperability across multiple blockchains. The Dynamic Connect Wallet feature ensures secure and frictionless wallet connections, offering users peace of mind while navigating their investments. Drawing inspiration from NounsDAO, the user interface incorporates their unique style and assets, creating a visually engaging and intuitive experience. NounsPilot's innovative use of LayerZero\u2019s bridging and compose techniques sets it apart, providing users with unparalleled flexibility to maximize their crypto rewards. This integration of cutting-edge technologies not only enhances functionality but also ensures a smooth, user-friendly experience tailored to sophisticated DeFi strategies.",
        "how_its_made": "NounsPilot leverages a robust combination of advanced technologies and APIs to deliver a seamless and powerful DeFi experience. By integrating 1inch's Dev Portal APIs, the platform ensures precise portfolio analysis with real-time balance and token information. Circle's USDC integration enables smooth financial transactions within the platform, while LayerZero's bridging capabilities allow for seamless cross-chain token transfers, enhancing interoperability across multiple blockchains. The Dynamic Connect Wallet feature ensures secure and frictionless wallet connections, offering users peace of mind while navigating their investments. Drawing inspiration from NounsDAO, the user interface incorporates their unique style and assets, creating a visually engaging and intuitive experience. NounsPilot's innovative use of LayerZero\u2019s bridging and compose techniques sets it apart, providing users with unparalleled flexibility to maximize their crypto rewards. This integration of cutting-edge technologies not only enhances functionality but also ensures a smooth, user-friendly experience tailored to sophisticated DeFi strategies.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vyw3q/screenshots/aiwca/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vyw3q/screenshots/jhe2f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vyw3q/screenshots/cyysb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vyw3q/screenshots/by77d/default.jpg"
        ],
        "live_demo": "https://nouns-pilot.vercel.app/",
        "source_code": "https://github.com/mordochi/NounsPilot",
        "link": "https://ethglobal.com/showcase/nounspilot-vyw3q"
    },
    {
        "title": "Telegram-DAO-bot",
        "brief_description": "Telegram bot that allows you to interact with AirDAO smart contract. This contract is a list of members of \"InternetDAO\" which is a collective to bargain for better internet deals from service providers.",
        "long_description": "Collective of people that want to order Internet together cheaply. Potential further development: DAO that wants to stake together, buy energy together, or organic food. You can find the contract on testnet: https://testnet.airdao.io/explorer/address/0x13EAe3662a85b947388284D59b5c49EA66F11c24/ The telegram bot code, logic and Worldcoin Identification on:\nhttps://replit.com/@MiliSkrap/TelegramBotSetup-v2?v=1 The smart contract code at:\nhttps://gist.github.com/Milbaxter/1c50d07beb8e0f3f3932804041ac699f",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xwwyy/screenshots/urtog/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xwwyy/screenshots/ez4dx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xwwyy/screenshots/h013k/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ethglobal",
        "link": "https://ethglobal.com/showcase/telegram-dao-bot-xwwyy"
    },
    {
        "title": "Power Clash",
        "brief_description": "Step into the world of fair gaming with our blockchain-powered game which is built on top of ZkNoid SDK",
        "long_description": "This project is a decentralized Dynamite-Alien-Cockroach-Water wave-Sponge ( a variation of Rock-Paper-Scissor) game built on top of Mina Protocol using the ZKnoid SDK and ProtoKit. The backend is powered by the o1js library, implementing secure game logic and state management. PowerClash integrates zk proofs to ensure move privacy and verify fairness without revealing sensitive data.\nA commit-reveal scheme is employed for each move, guaranteeing that players cannot alter their choices after seeing their opponent's move, thus reinforcing trust in the game's integrity. The game utilizes Mina's succinct blockchain to efficiently store game states and manage player interactions.\nThe frontend, built with TypeScript and React, provides an intuitive and interactive interface.\nKey features include: Partner Technologies:\n\u2022\tzknoid SDK and Protokit allowed for easy integration of zk proofs, lobby creation, match making, significantly reducing the complexity of incorporating zero-knowledge components.\n\u2022\tMina Protocol provided the ideal environment for deploying zk-based decentralized applications, benefiting from its lightweight and privacy-focused approach. Technologies Used:\n\u2022\tMina Protocol: The blockchain platform used to deploy the Dynamite-Alien-Cockroach-Water wave-Sponge game, ensuring decentralized and lightweight operation.\n\u2022\tProtokit: It is used to structure the smart contract and handle on-chain state management.\n\u2022\tZkNoid SDK: It is used for building zero-knowledge applications and integrating zk proofs into the game for verifiable fairness, importing matchmaking and lobby from sdk.\n\u2022\to1js Library: Used for cryptographic operations and interfacing with the Mina blockchain.\n\u2022\tTypeScript and React: Used for developing the frontend, providing a dynamic and interactive user experience. Architecture and Integration:\n\u2022\tPowerClash integrates Mina Protocol as the blockchain foundation, with ZKnoid SDK for zero-knowledge proofs and ProtoKit for smart contract development.\n\u2022\tThe o1js library handles cryptographic operations and blockchain interactions.\n\u2022\tThe backend, written in TypeScript, manages game logic and state.\n\u2022\tReact powers the frontend, providing an interactive UI.\n\u2022\tWebSockets enable real-time updates, while GraphQL facilitates efficient data fetching between frontend and backend.",
        "how_its_made": "Partner Technologies:\n\u2022\tzknoid SDK and Protokit allowed for easy integration of zk proofs, lobby creation, match making, significantly reducing the complexity of incorporating zero-knowledge components.\n\u2022\tMina Protocol provided the ideal environment for deploying zk-based decentralized applications, benefiting from its lightweight and privacy-focused approach. Technologies Used:\n\u2022\tMina Protocol: The blockchain platform used to deploy the Dynamite-Alien-Cockroach-Water wave-Sponge game, ensuring decentralized and lightweight operation.\n\u2022\tProtokit: It is used to structure the smart contract and handle on-chain state management.\n\u2022\tZkNoid SDK: It is used for building zero-knowledge applications and integrating zk proofs into the game for verifiable fairness, importing matchmaking and lobby from sdk.\n\u2022\to1js Library: Used for cryptographic operations and interfacing with the Mina blockchain.\n\u2022\tTypeScript and React: Used for developing the frontend, providing a dynamic and interactive user experience. Architecture and Integration:\n\u2022\tPowerClash integrates Mina Protocol as the blockchain foundation, with ZKnoid SDK for zero-knowledge proofs and ProtoKit for smart contract development.\n\u2022\tThe o1js library handles cryptographic operations and blockchain interactions.\n\u2022\tThe backend, written in TypeScript, manages game logic and state.\n\u2022\tReact powers the frontend, providing an interactive UI.\n\u2022\tWebSockets enable real-time updates, while GraphQL facilitates efficient data fetching between frontend and backend.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/c9gmt/screenshots/jepsa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c9gmt/screenshots/scyum/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c9gmt/screenshots/ph4i4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c9gmt/screenshots/wr2s9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c9gmt/screenshots/vthyw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c9gmt/screenshots/0fz7i/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/RamanS1819/Power-Clash/",
        "link": "https://ethglobal.com/showcase/power-clash-c9gmt"
    },
    {
        "title": "sp1demo",
        "brief_description": "Simple SP1 demo proving correct evaluation of the paraboloid of equation: z = f(x, y) = x\u00b2 + y\u00b2",
        "long_description": "SP1 is a performant and \"clean\" zkVM running a (slightly modified) RISC-V ISA implemented in Rust by Succinct Labs. Succinct offer a hosted compute solution, Succinct Prover Network. At Frontiers 2024, Succinct demonstrated verification of real Ethereum blocks, costing to the order of a cent. SP1 is a performant and \"clean\" zkVM running a (slightly modified) RISC-V ISA implemented in Rust by Succinct Labs. Succinct offer a hosted compute solution, Succinct Prover Network. At Frontiers 2024, Succinct demonstrated verification of real Ethereum blocks, costing to the order of a cent.",
        "how_its_made": "SP1 is a performant and \"clean\" zkVM running a (slightly modified) RISC-V ISA implemented in Rust by Succinct Labs. Succinct offer a hosted compute solution, Succinct Prover Network. At Frontiers 2024, Succinct demonstrated verification of real Ethereum blocks, costing to the order of a cent.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1gona/screenshots/jm1f3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1gona/screenshots/2ha1c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1gona/screenshots/ia8mt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1gona/screenshots/zscdw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1gona/screenshots/0fa76/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/zkzoomer/sp1demo",
        "link": "https://ethglobal.com/showcase/sp1demo-1gona"
    },
    {
        "title": "Sniper",
        "brief_description": "Target Full Potential, Hit Every Goal, Leave Your Marks. Your AI companion enhancing focus with real-time guidance, memorializing achievements on-chain.",
        "long_description": "Sniper is an AI companion designed to improve personal productivity and growth. In today's fast-paced, digital world, achieving deep focus has become increasingly challenging. After high school, I noticed a significant decline in my ability to enter what psychologists call a \"flow state\" - that magical condition where you're fully immersed, feeling energized, creative, and incredibly productive. The average knowledge worker is interrupted every 11 minutes, and it can take up to 23 minutes to regain focus after each disruption. There are no good solutions yet. Unlike simple blockers or gamified apps, Sniper offers personalized, adaptive support and creates lasting value. It's not just about being productive today; it's about building a transparent, fair record of your capabilities for tomorrow. We've also incorporated community features, allowing users to form teams with similar goals, amplifying motivation and support. And with blockchain technology, we're ensuring fairness and creating opportunities for recognition on a global scale. We've incorporated blockchain technology to create a fair and transparent system for personal growth and opportunity. Blockchain enables sustainable motivation through continuous reward models and ensures fairness in our gamification elements. Moreover, it provides a verifiable record of dedication, potentially serving as career credentials in the future. Sniper uses advanced multimodal AI to detect user\u2019s focus state and provide real-time guidance. We integrate several partner technologies to make Sniper possible: Serves as the quick entry point for user login.\nBenefit: Reduces friction in user adoption, enhancing overall engagement Used for human verification (KYC) after login.\nBenefit: Prevents fraud and maintains the integrity of the community Records the WorldID attestation, which is also used to verify voting eligibility.\nBenefit: Builds a trustworthy record of user activities, crucial for reputation and rewards Implements a secure voting system.\nBenefit: Ensures democratic decision-making within the community while preventing collusion Used for sponsorship and potentially for rewards.\nBenefit: Adds real economic value to user participation and achievements Enables efficient querying of blockchain data\nBenefit: Allows for real-time analytics and user-friendly data presentation",
        "how_its_made": "Sniper uses advanced multimodal AI to detect user\u2019s focus state and provide real-time guidance. We integrate several partner technologies to make Sniper possible: Serves as the quick entry point for user login.\nBenefit: Reduces friction in user adoption, enhancing overall engagement Used for human verification (KYC) after login.\nBenefit: Prevents fraud and maintains the integrity of the community Records the WorldID attestation, which is also used to verify voting eligibility.\nBenefit: Builds a trustworthy record of user activities, crucial for reputation and rewards Implements a secure voting system.\nBenefit: Ensures democratic decision-making within the community while preventing collusion Used for sponsorship and potentially for rewards.\nBenefit: Adds real economic value to user participation and achievements Enables efficient querying of blockchain data\nBenefit: Allows for real-time analytics and user-friendly data presentation",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/va6c6/screenshots/53qgu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/va6c6/screenshots/ihb1b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/va6c6/screenshots/fehot/default.jpg",
            "https://ethglobal.b-cdn.net/projects/va6c6/screenshots/d77ax/default.jpg",
            "https://ethglobal.b-cdn.net/projects/va6c6/screenshots/puhm4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/va6c6/screenshots/pfxbv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MusubiLabs/sniper",
        "link": "https://ethglobal.com/showcase/sniper-va6c6"
    },
    {
        "title": "Cross3",
        "brief_description": "Onchain Social Layer for Web3 Pages and Payments, All in Portfolios.",
        "long_description": "Cross3 is an Onchain Social Layer for Decentralized Portfolio Pages and Payments, All in Portfolios. Your web3 gateway to show everything you are and create. Onchain Social Layer. EVM-based Pages & Payments. But Rich and Beautiful. \u2705 EVM All deployed On-chain. Your Social Feeds. Payments. Photos. Videos. Galleries. NFT Collections. Streams. Calendar. Events . . . React.js tailwindui daisyui Material-UI Redux Next.js scss vercel\nvercel:env MongoDB\nMongoDB Gitbook web3.js wagmi rainbowkit wallet To learn more about Next.js, take a look at the following resources: You can check out the Next.js GitHub repository - your feedback and contributions are welcome! Different branches correspond to different environments The easiest way to deploy your Next.js app is to use the Vercel Platform from the creators of Next.js. Check out our Next.js deployment documentation for more details. You can start editing the page by modifying pages/index.js. The page auto-updates as you edit the file. API routes can be accessed on http://127.0.0.1:3000/api/hello. This endpoint can be edited in pages/api/hello.js. The pages/api directory is mapped to /api/*. Files in this directory are treated as API routes instead of React pages.",
        "how_its_made": "React.js tailwindui daisyui Material-UI Redux Next.js scss vercel\nvercel:env MongoDB\nMongoDB Gitbook web3.js wagmi rainbowkit wallet To learn more about Next.js, take a look at the following resources: You can check out the Next.js GitHub repository - your feedback and contributions are welcome! Different branches correspond to different environments The easiest way to deploy your Next.js app is to use the Vercel Platform from the creators of Next.js. Check out our Next.js deployment documentation for more details. You can start editing the page by modifying pages/index.js. The page auto-updates as you edit the file. API routes can be accessed on http://127.0.0.1:3000/api/hello. This endpoint can be edited in pages/api/hello.js. The pages/api directory is mapped to /api/*. Files in this directory are treated as API routes instead of React pages.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8xc9h/screenshots/cdu42/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8xc9h/screenshots/z2tdx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8xc9h/screenshots/kcyxt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8xc9h/screenshots/w3qch/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8xc9h/screenshots/nt9c9/default.jpg"
        ],
        "live_demo": "http://vercel.app",
        "source_code": "https://github.com/ChainxLabs/Cross3",
        "link": "https://ethglobal.com/showcase/cross3-8xc9h"
    },
    {
        "title": "ZkScholar",
        "brief_description": "A revolutionary decentralized app  that makes financial aid applications faster and more private using zk-SNARKs, World ID, and USDC. Students bulk apply to schools without revealing sensitive information, schools verify eligibility privately, and funds are disbursed on-chain.",
        "long_description": "Project Name: ZkScholar\nProject Overview:\nZkScholar is a decentralized platform that transforms the way financial aid is distributed to students. Built on blockchain technology, the platform employs zero-knowledge proofs (zk-SNARKs) to ensure that students can apply for financial aid securely, while their personal and financial information remains completely private. By integrating World ID for identity verification and Mina Protocol for privacy-preserving computations, ZkScholar eliminates the inefficiencies, privacy concerns, and security risks associated with traditional financial aid systems.\nThe platform also leverages Circle's USDC to provide near-instant, conditional disbursements to students' wallets. With a fully on-chain process, ZkScholar ensures transparency and accuracy in the management and distribution of student aid funds while protecting user data.\nProblem:\nEach year, over $250 billion in financial aid is distributed to students through outdated, bureaucratic systems that are slow, cumbersome, and insecure. Students must submit sensitive personal and financial information to multiple institutions, risking data breaches. Additionally, the process for determining aid eligibility is often slow, and disbursement of funds can be delayed, affecting students\u2019 ability to manage their finances and continue their education.\nSolution:\nZkScholar introduces a streamlined, fast, and private way for students to apply for financial aid. Using zk-SNARKs technology, the platform allows students to submit proof of financial need without revealing sensitive data. Colleges can set financial aid criteria, and the platform uses zero-knowledge proofs to match students with qualifying financial aid options without exposing personal information.\nZkScholar ensures a transparent yet private verification process where:\nColleges set their aid criteria using a simple UI, and can only see anonymized results of student eligibility.\nStudents submit their financial data through a privacy-preserving mechanism and receive feedback on their aid eligibility in real time.\nHow it Works:\nColleges Set Aid Criteria: Colleges log into ZkScholar using World ID for secure authentication. They then define their financial aid criteria, which can include financial need, academic performance, geographic location, or other custom factors. Students Apply for Aid: Students log into ZkScholar using World ID and upload the required financial documents and acceptance letters from the colleges they\u2019ve applied to. The platform uses zk-SNARKs to verify student eligibility privately without revealing underlying data to the schools. Eligibility Check & Match: ZkScholar uses Mina Protocol\u2019s privacy-preserving technology to run eligibility checks based on the criteria set by the colleges. Students then receive an Eligible or Not Eligible status for each of their selected schools.\nAid Disbursement: Colleges view a list of eligible students (identified only by a serial number to protect privacy) and can click a \u201cDisburse\u201d button to transfer aid funds in USDC. These funds are disbursed conditionally, and students receive payments in installments, typically at the end of each semester, based on continued enrollment.\nTransaction & Conversion: Students see the incoming transaction in their wallets, and using Circle\u2019s integration, they can convert USDC into local currency (e.g., SGD) seamlessly.\nCore Technologies:\nWorld ID: Used for decentralized and secure identity verification for both students and institutions.\nMina Protocol (zk-SNARKs): Ensures zero-knowledge proof computations, allowing financial data verification without exposing personal details.\nCircle USDC: Used for fast, secure, and borderless financial aid disbursement, allowing easy conversion to local currencies.\nSmart Contracts: ZkScholar uses smart contracts to enforce conditional aid disbursements, ensuring funds are only sent when specific criteria (such as continued enrollment) are met. Key Features:\nPrivacy-Preserving: Using zk-SNARKs, students' sensitive financial information is never revealed during the eligibility verification process.\nInstant Payments: With USDC, funds can be disbursed to students instantly, removing delays and inefficiencies of traditional aid systems. With our automatic routing protocol, we aim to allow USDC to be converted into any currency of the user's choice in the cheapest way possible. Transparent & Secure: All transactions, eligibility criteria, and disbursements are recorded on-chain for full transparency while preserving user privacy.\nAutomated Conditional Aid: Disbursements are managed via smart contracts, ensuring that funds are released in phases (e.g., per semester) based on continued eligibility.\nGlobal Reach: Students can receive aid from institutions worldwide and easily convert USDC into their local currency using our auto-routing protocol. User Flow:\nColleges:\nLog into the platform using World ID.\nDefine financial aid criteria (income brackets, merit-based criteria, etc.).\nView a list of anonymized students who meet the aid criteria.\nDisburse aid to eligible students using USDC at the end of each semester.\nStudents:\nLog into the platform using World ID.\nUpload financial documents and college offer letters.\nWait for the zk-SNARK-based verification process to match their profile with eligible aid.\nReceive an eligibility status for each college and apply for financial aid from the schools of their choice.\nOnce the aid is approved, receive USDC in their wallet, convert to local currency, and view the transaction history on-chain.\nImpact:\nZkScholar makes a significant impact by addressing the inefficiencies of the traditional financial aid process, ensuring student privacy, and providing a transparent, decentralized solution for aid disbursement. With the growing importance of protecting personal data and ensuring financial inclusion, ZkScholar aligns with the values of Web3, ensuring access to education without compromising on security or privacy.\nBenefits:\nFor Students: Provides a secure, privacy-preserving method to apply for and receive financial aid. Enables students to maintain control of their data while accessing global financial resources.\nFor Colleges: Simplifies the financial aid process by allowing institutions to securely and efficiently manage aid distribution while ensuring the privacy of applicants.\nFor the Ecosystem: ZkScholar represents a significant step forward in the Web3 public goods movement, leveraging decentralized technologies to solve real-world problems in education finance. Vision:\nZkScholar aims to create a future where students can access financial aid privately, efficiently, and securely, removing barriers to education funding and fostering global opportunities for academic success. By empowering both students and institutions with decentralized tools, ZkScholar reshapes financial aid into a more equitable, transparent, and secure system. For ZkScholar's frontend, we used Material UI and typescript. For our login process, we used Worldcoin's World IDs for decentralized and secure identity verification. Following that, we made stored and queries on-chain data on Mina Protocol using Protokit, which served as the backend and database for ZkScholar's application. After USDC is disbursed, we want to provide a seamless process to convert USDC tokens to fiat through our smart-routing protocol that quickly identifies and pieces together the best conversion route across all decentralized apps. The smart contract that simulated the swap was deployed on Ethereum Sepolia using nodes from Infura, and we deployed the contract using Hardhat. We then used ethers.js to allow our frontend to interact with the blockchain.",
        "how_its_made": "For ZkScholar's frontend, we used Material UI and typescript. For our login process, we used Worldcoin's World IDs for decentralized and secure identity verification. Following that, we made stored and queries on-chain data on Mina Protocol using Protokit, which served as the backend and database for ZkScholar's application. After USDC is disbursed, we want to provide a seamless process to convert USDC tokens to fiat through our smart-routing protocol that quickly identifies and pieces together the best conversion route across all decentralized apps. The smart contract that simulated the swap was deployed on Ethereum Sepolia using nodes from Infura, and we deployed the contract using Hardhat. We then used ethers.js to allow our frontend to interact with the blockchain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yiqo9/screenshots/17byj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yiqo9/screenshots/cqwxa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yiqo9/screenshots/0771c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yiqo9/screenshots/nag8h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yiqo9/screenshots/kgqqw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yiqo9/screenshots/5b0ad/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/joshuan98/eth-global ",
        "link": "https://ethglobal.com/showcase/zkscholar-yiqo9"
    },
    {
        "title": "Price Game",
        "brief_description": "Our project is a daily crypto price prediction game designed for the Web3 community. Participants can submit their predictions for the price of a selected cryptocurrency (such as Bitcoin or Ethereum), and the person whose guess is closest to the actual price will win a prize.",
        "long_description": "The game leverages Worldcoin for identity verification to ensure that only humans (no bots) can participate, enhancing fairness. We use Chainlink and Pyth oracles to securely and accurately confirm the crypto price at a specific, predetermined time. The Crypto prices that player guessed is a valuable data set for applications like AI/ML models for trading strategies, products like perpetual and futures. They reflect people's confidence of the market. Key Features:\nDaily Game: Each day, participants predict the price of a specified cryptocurrency.\nPrize Pool: Players contribute a small entry fee of 0.001 ETH to join. The game starts when the total prize pool reaches 0.1 ETH.\nWinner: The player with the closest price prediction wins 50% of the prize pool.\nFair Verification: Worldcoin verifies participants' humanity, while Chainlink and Pyth ensure secure and accurate price confirmation.\nThis game offers a fun and engaging way for users to test their market knowledge, with a chance to earn rewards daily! To build the architecture for the crypto price prediction game, we need several Web3 tools and technologies to handle smart contracts, identity verification, data oracles, and front-end integration. Here's a breakdown of what we used: Smart Contracts (Ethereum)\nEthereum Blockchain: we deploy the game as a smart contract on Ethereum. This is where the logic for participation, prize pool management, and winner selection will be implemented.\nSolidity: Use Solidity to write the smart contracts that govern the game logic, prize distribution, and interaction with oracles (Chainlink, Pyth).\nOpenZeppelin: For security, use OpenZeppelin\u2019s libraries for access control, token handling, and overall contract security to minimize vulnerabilities. Worldcoin for Humanity Verification\nWorld ID SDK: Integrate Worldcoin\u2019s World ID SDK to verify that participants are humans. The SDK allows to connect with the Worldcoin identity layer to ensure fairness by blocking bots from entering the game.\nWorld App or Browser Extension: Players can use the Worldcoin app or a browser extension to verify their identity and interact with our smart contract. Data Oracles for Accurate Price Feeds\nChainlink: Use Chainlink\u2019s Price Feed oracles to obtain secure and accurate real-time cryptocurrency prices. Chainlink will ensure the final price is correct at the prediction cutoff time.\nPyth Network: we use the Pyth Network as an additional oracle for price verification. Pyth specializes in providing real-time price data for crypto and other assets, ensuring the game data is reliable. Smart Contract Interactions\nFlutter'sWeb3Dart: To interact with our Ethereum smart contracts, we use Web3Dart in the front end. This will allow participants to connect their wallet (e.g., MetaMask) and submit their predictions, pay the entry fee, and claim prizes.\nMetamask: Allow users to connect their wallets via MetaMask to submit their ETH entry fees and claim rewards. Game Logic\nSmart Contract Logic:\nStore player predictions on-chain.\nCollect ETH entry fees and maintain the prize pool.\nTrigger the price check (from Chainlink and Pyth) at the daily cutoff time.\nCalculate the winner based on the closest prediction.\nDistribute 50% of the prize pool to the winner, with the rest rolling over or allocated elsewhere. Front-end Development\nFlutter app really simplifies the application but introduced a lot of problems integrating to worldcoin, chainlink and pyth.",
        "how_its_made": "To build the architecture for the crypto price prediction game, we need several Web3 tools and technologies to handle smart contracts, identity verification, data oracles, and front-end integration. Here's a breakdown of what we used: Smart Contracts (Ethereum)\nEthereum Blockchain: we deploy the game as a smart contract on Ethereum. This is where the logic for participation, prize pool management, and winner selection will be implemented.\nSolidity: Use Solidity to write the smart contracts that govern the game logic, prize distribution, and interaction with oracles (Chainlink, Pyth).\nOpenZeppelin: For security, use OpenZeppelin\u2019s libraries for access control, token handling, and overall contract security to minimize vulnerabilities. Worldcoin for Humanity Verification\nWorld ID SDK: Integrate Worldcoin\u2019s World ID SDK to verify that participants are humans. The SDK allows to connect with the Worldcoin identity layer to ensure fairness by blocking bots from entering the game.\nWorld App or Browser Extension: Players can use the Worldcoin app or a browser extension to verify their identity and interact with our smart contract. Data Oracles for Accurate Price Feeds\nChainlink: Use Chainlink\u2019s Price Feed oracles to obtain secure and accurate real-time cryptocurrency prices. Chainlink will ensure the final price is correct at the prediction cutoff time.\nPyth Network: we use the Pyth Network as an additional oracle for price verification. Pyth specializes in providing real-time price data for crypto and other assets, ensuring the game data is reliable. Smart Contract Interactions\nFlutter'sWeb3Dart: To interact with our Ethereum smart contracts, we use Web3Dart in the front end. This will allow participants to connect their wallet (e.g., MetaMask) and submit their predictions, pay the entry fee, and claim prizes.\nMetamask: Allow users to connect their wallets via MetaMask to submit their ETH entry fees and claim rewards. Game Logic\nSmart Contract Logic:\nStore player predictions on-chain.\nCollect ETH entry fees and maintain the prize pool.\nTrigger the price check (from Chainlink and Pyth) at the daily cutoff time.\nCalculate the winner based on the closest prediction.\nDistribute 50% of the prize pool to the winner, with the rest rolling over or allocated elsewhere. Front-end Development\nFlutter app really simplifies the application but introduced a lot of problems integrating to worldcoin, chainlink and pyth.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/aqhys/screenshots/hgkex/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aqhys/screenshots/mwofm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aqhys/screenshots/nz7j0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/liubosdzl33/ethsg-cryptopricegame",
        "link": "https://ethglobal.com/showcase/price-game-aqhys"
    },
    {
        "title": "Mini Safe",
        "brief_description": "Mini Safe is your friendly team multisig wallet integrated on Telegram for simplifying P2P payments.",
        "long_description": "Live demo: https://t.me/MiniSafeBot Mini Safe is the Revolut Team Business of Web3, where you and your team members can interact with a team multisig wallet directly on Telegram, with a monthly spendable amount (starting at $1,000 for no approval required). We are using Telegram to improve user experience and create mass adoption for multisig wallets, then we want to be secured using a spendable amount. Features 1\ufe0f\u20e3\u00a0Interact with a Telegram bot and a mini Telegram app 2\ufe0f\u20e3\u00a0Onboarding new members with Safe module 3\ufe0f\u20e3\u00a0Start spending on different apps or send money to another Telegram ID / ENS 4\ufe0f\u20e3\u00a0Cross-chain payments using CCTP (Cross-Chain Transfer Protocol) 5\ufe0f\u20e3\u00a0Verification system using Dynamic 6\ufe0f\u20e3 Granular Security We are fixing a limit of $1,000 spendable by month using Telegram (customizable), it\u2019s enough to be able to use P2P payments in Web3. Otherwise, if you want to use Telegram to spend more, we are setting up a granular security to do it. For example: 7\ufe0f\u20e3\u00a0Telegram Notification System When one of the signers is using the multisig wallet, other members are alerted with a notification, like for Revolut Business. 8\ufe0f\u20e3\u00a0Multisig Invitations by Telegram Roles If you install the bot in a Telegram group, roles on the multisig reflect the roles on the Telegram group. To add people to the multisig, you can simply invite them to the Telegram group. 9\ufe0f\u20e3\u00a0Gasless onboarding We are sponsoring transaction fees using a paymaster to onboard people easily via Telegram. \ud83d\udd1f\u00a0Social Recovery Take advantage of the powerful social trust on Telegram to define 3 guardians (trustworthy contacts) who will be able to help you in case you lose access to your multisig wallet. What you can do with a multisig wallet on Telegram? As a team member As an individual Smart contract Front-end & backend",
        "how_its_made": "Smart contract Front-end & backend",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mztrv/screenshots/8fpm8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mztrv/screenshots/ci9ae/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mztrv/screenshots/bp6yt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mztrv/screenshots/mzak0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/EthGlobalSing/mini-safe-core",
        "link": "https://ethglobal.com/showcase/mini-safe-mztrv"
    },
    {
        "title": "Mini Safe",
        "brief_description": "Mini Safe is your friendly team multisig wallet integrated on Telegram for simplifying P2P payments.",
        "long_description": "Live demo: https://t.me/MiniSafeBot Mini Safe is the Revolut Team Business of Web3, where you and your team members can interact with a team multisig wallet directly on Telegram, with a monthly spendable amount (starting at $1,000 for no approval required). We are using Telegram to improve user experience and create mass adoption for multisig wallets, then we want to be secured using a spendable amount. Features 1\ufe0f\u20e3\u00a0Interact with a Telegram bot and a mini Telegram app 2\ufe0f\u20e3\u00a0Onboarding new members with Safe module 3\ufe0f\u20e3\u00a0Start spending on different apps or send money to another Telegram ID / ENS 4\ufe0f\u20e3\u00a0Cross-chain payments using CCTP (Cross-Chain Transfer Protocol) 5\ufe0f\u20e3\u00a0Verification system using Dynamic 6\ufe0f\u20e3 Granular Security We are fixing a limit of $1,000 spendable by month using Telegram (customizable), it\u2019s enough to be able to use P2P payments in Web3. Otherwise, if you want to use Telegram to spend more, we are setting up a granular security to do it. For example: 7\ufe0f\u20e3\u00a0Telegram Notification System When one of the signers is using the multisig wallet, other members are alerted with a notification, like for Revolut Business. 8\ufe0f\u20e3\u00a0Multisig Invitations by Telegram Roles If you install the bot in a Telegram group, roles on the multisig reflect the roles on the Telegram group. To add people to the multisig, you can simply invite them to the Telegram group. 9\ufe0f\u20e3\u00a0Gasless onboarding We are sponsoring transaction fees using a paymaster to onboard people easily via Telegram. \ud83d\udd1f\u00a0Social Recovery Take advantage of the powerful social trust on Telegram to define 3 guardians (trustworthy contacts) who will be able to help you in case you lose access to your multisig wallet. What you can do with a multisig wallet on Telegram? As a team member As an individual Smart contract Front-end & backend",
        "how_its_made": "Smart contract Front-end & backend",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mztrv/screenshots/8fpm8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mztrv/screenshots/ci9ae/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mztrv/screenshots/bp6yt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mztrv/screenshots/mzak0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/EthGlobalSing/mini-safe-core",
        "link": "https://ethglobal.com/showcase/mini-safe-mztrv"
    },
    {
        "title": "Notsoawesomeproject",
        "brief_description": "Not so Awesome Project zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
        "long_description": "Not so Awesome Project zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz Not so Awesome Project zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
        "how_its_made": "Not so Awesome Project zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wnarn/screenshots/psabx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wnarn/screenshots/7qpwj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wnarn/screenshots/gnocu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shanzson/TheOtherSideofAwesome",
        "link": "https://ethglobal.com/showcase/notsoawesomeproject-wnarn"
    },
    {
        "title": "pump.delight",
        "brief_description": "Pump your favorite meme coins with Pump.Delight! Join coordinated community efforts to boost token values through strategic buying and real-time alerts. \ud83d\ude80\ud83d\udcb8 #MemeCoins #CryptoPump #PumpAndProfit",
        "long_description": "Pump.Delight is a platform that enables users to coordinate and execute pumps for meme coins. By gathering a community of like-minded crypto enthusiasts, the platform helps users strategically buy specific meme coins to drive up their value. Pump.Delight provides real-time alerts, market analysis, and social coordination tools to maximize the impact of each pump, helping users make the most out of short-term market movements in the meme coin space. Pump.Delight uses a combination of real-time data aggregation and community-driven coordination tools. The platform connects to major crypto exchanges to monitor and analyze meme coin performance in real-time. It also integrates with social media channels and messaging platforms to allow seamless communication between users. For the backend, it uses a robust framework built to handle high traffic during pump events, and the frontend is designed to be simple and intuitive, allowing users to participate in pumps with just a few clicks.",
        "how_its_made": "Pump.Delight uses a combination of real-time data aggregation and community-driven coordination tools. The platform connects to major crypto exchanges to monitor and analyze meme coin performance in real-time. It also integrates with social media channels and messaging platforms to allow seamless communication between users. For the backend, it uses a robust framework built to handle high traffic during pump events, and the frontend is designed to be simple and intuitive, allowing users to participate in pumps with just a few clicks.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/drmbz/screenshots/j313u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/drmbz/screenshots/eaart/default.jpg",
            "https://ethglobal.b-cdn.net/projects/drmbz/screenshots/z3mbu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Tsatsch/pump.delight",
        "link": "https://ethglobal.com/showcase/pump-delight-drmbz"
    },
    {
        "title": "XChain Investments",
        "brief_description": "With privacy, xchain functionality, and AI-driven management, We offer a secure env for participants to join investment pools, contribute funds, and bid privately. Key features include private bidding with Worldcoin\u2019s anonymous authenticationdynamic liquidity management",
        "long_description": "XChain Pool Investments is a decentralized platform designed to modernize community-based investments with advanced blockchain integrations, private bidding, and cross-chain functionalities. The platform allows participants to join pools, make contributions, and bid on funds, maintaining privacy and minimizing biases. -Private Bidding: Secure, private bids with Sapphire's privacy layer, promoting unbiased participation.\n-Cross-Chain Swaps: Utilize 1inch Fusion+ for swapping assets across Ethereum-based chains during deposits.\n-Dynamic Liquidity Management: Manage liquidity within user-defined ranges on Uniswap v4 with dynamic fee adjustments.\n-Anonymous Authentication: Worldcoin's anonymous authentication supports unbiased, private bidding.\n-Cross-Chain Interoperability: ChainLink\u2019s CCIP enables seamless cross-chain transactions and messaging.\n-Data Management: TheGraph handles data fetching from various sources, including CCIP.\n-AI Agents: Phala hosts AI agents that manage proof verification and execute smart contracts efficiently.\n-Sign Protocol Integration: Use Sign Protocol, an omni-chain attestation protocol, to sign and store winning bid details at the end of each cycle.\n-Investment of Remaining Funds: After withdrawals, remaining pool funds are invested using AI Agents in the best DeFi opportunities across multiple chains, utilizing CCIP for easy swaps.\n-Secure Withdrawals: Members receive their withdrawals at the end of all cycles, ensuring proper distribution of funds.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/4fu2t/screenshots/axd73/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4fu2t/screenshots/7qfjn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4fu2t/screenshots/rb25y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4fu2t/screenshots/fs7q9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4fu2t/screenshots/njpvi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4fu2t/screenshots/3zajp/default.jpg"
        ],
        "live_demo": "https://xchain-investments.vercel.app/",
        "source_code": "https://github.com/kamalbuilds/xchain-Investments/",
        "link": "https://ethglobal.com/showcase/xchain-investments-4fu2t"
    },
    {
        "title": "AlphaHook",
        "brief_description": "AlphaHook is an attempt to leverage Uniswap V4 hooks to generate dynamic pool fees by using Chainlink Oracles.",
        "long_description": "In Uniswap V3, fees are set for a given pool. Therefore, when a pair becomes more or less risky for liquidity providers, the fees can't be adjust and they have to manually withdraw and deposit to the pool with the right fees. Moreover, the current architecture allows only 4 - discrete - pools fees: 0.01%, 0.05%, 0.3% and 1%. Uniswap V4 hooks allow developers to create custom - dynamic - fees for a pool. Such architecture can use a wide array of variables to generate a pool fee that makes the most sense at a given time. One can think about the volatility of a pool, its liquidity, activity, age, etc. Things get even better when we connect oracles such as Chainlink. The great price feed and rate and volatility feeds are a perfect match. Our project is based on the Uniswap V4 template. We have create a custom hook contract which computes the fees according to different variables. The hook contracts relies on Chainlink Oracles (price / rate and volatility fees) to compute the final values. We have also experimented with a frontend (/frontend  folder) as we believe that if the contract exposes the right variables and functions, we can build a great UI for both traders and liquidity providers (to understand how the fee is calculated, etc.). However, we didn't have time to connect it to the contract and to deploy it.",
        "how_its_made": "Our project is based on the Uniswap V4 template. We have create a custom hook contract which computes the fees according to different variables. The hook contracts relies on Chainlink Oracles (price / rate and volatility fees) to compute the final values. We have also experimented with a frontend (/frontend  folder) as we believe that if the contract exposes the right variables and functions, we can build a great UI for both traders and liquidity providers (to understand how the fee is calculated, etc.). However, we didn't have time to connect it to the contract and to deploy it.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rqd6q/screenshots/qujwc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rqd6q/screenshots/oyveu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rqd6q/screenshots/pt0ba/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/CJ42/ethsingapore-hackathon-2024",
        "link": "https://ethglobal.com/showcase/alphahook-rqd6q"
    },
    {
        "title": "Minion",
        "brief_description": "Introducing Minion! \ud83d\ude80 An AI-powered wallet for Telegram & web. Scan on-chain liquidity & staking pools to pick the best trading strategies. Trade smarter & make a difference by donating to causes like @FreedomofPress with every trade! \ud83d\udca1\ud83d\udcc8 #DeFi #AI #Crypto #Minion",
        "long_description": "Minion is a smart wallet designed for mass adoption, supporting iOS, Android, web app, and Telegram. It leverages AI to analyze on-chain liquidity pools, staking pools, and other financial data, helping users select trading strategies tailored to their holdings and experience. By utilizing data from The Graph Protocol\u2014such as pool_id, timestamp, pairs, liquidity, 24h trading volume, fee rates, prices, and APY\u2014Minion's AI makes optimal degen decisions based on your wallet and trading history. After each trade, users can choose to donate to the Freedom of Press foundation, with a shareable banner provided for social media. Minion was built with a focus on accessibility, scalability, and seamless user experience, leveraging several key technologies: Telegram API & Bot Integration: Minion's core platform is built on Telegram, providing an easy-to-use interface directly within users' favorite messaging app. This was essential for mass adoption, allowing users to interact with the wallet without downloading additional software. AI & Machine Learning: The AI engine that powers Minion\u2019s trading recommendations was trained using a variety of on-chain data from liquidity pools, staking pools, and trading history. By utilizing historical trading data and pattern recognition, the AI is optimized to suggest trading strategies that align with users' wallet holdings and trading behavior. The Graph Protocol: Minion pulls real-time data from The Graph Protocol, including pool_id, timestamp, liquidity, trading volume, fee rates, and more. This data enables the AI to continuously scan and assess on-chain pools for the most up-to-date insights. Cross-Platform Support (iOS, Android, Web App): The wallet was designed with mass adoption in mind, ensuring compatibility across all major platforms. This was achieved using responsive web technologies like React and React Native, providing seamless integration across iOS, Android, and web. Donation Mechanism: To encourage positive impact, Minion includes a donation feature where users can support NGOs like the Freedom of Press foundation after each trade. This was integrated using smart contracts that automatically trigger a donation and generate a shareable banner for social media. Hacky Elements: A notable hack was minimizing latency for real-time data processing. Since Minion relies on multiple data sources (e.g., The Graph Protocol), we built a lightweight middleware layer to streamline data aggregation, ensuring users get quick and reliable recommendations without excessive lag. This setup ensures a smooth, intelligent, and impactful trading experience across multiple platforms.",
        "how_its_made": "Minion was built with a focus on accessibility, scalability, and seamless user experience, leveraging several key technologies: Telegram API & Bot Integration: Minion's core platform is built on Telegram, providing an easy-to-use interface directly within users' favorite messaging app. This was essential for mass adoption, allowing users to interact with the wallet without downloading additional software. AI & Machine Learning: The AI engine that powers Minion\u2019s trading recommendations was trained using a variety of on-chain data from liquidity pools, staking pools, and trading history. By utilizing historical trading data and pattern recognition, the AI is optimized to suggest trading strategies that align with users' wallet holdings and trading behavior. The Graph Protocol: Minion pulls real-time data from The Graph Protocol, including pool_id, timestamp, liquidity, trading volume, fee rates, and more. This data enables the AI to continuously scan and assess on-chain pools for the most up-to-date insights. Cross-Platform Support (iOS, Android, Web App): The wallet was designed with mass adoption in mind, ensuring compatibility across all major platforms. This was achieved using responsive web technologies like React and React Native, providing seamless integration across iOS, Android, and web. Donation Mechanism: To encourage positive impact, Minion includes a donation feature where users can support NGOs like the Freedom of Press foundation after each trade. This was integrated using smart contracts that automatically trigger a donation and generate a shareable banner for social media. Hacky Elements: A notable hack was minimizing latency for real-time data processing. Since Minion relies on multiple data sources (e.g., The Graph Protocol), we built a lightweight middleware layer to streamline data aggregation, ensuring users get quick and reliable recommendations without excessive lag. This setup ensures a smooth, intelligent, and impactful trading experience across multiple platforms.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ik1uc/screenshots/jvahd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ik1uc/screenshots/jmshr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ik1uc/screenshots/g8tfi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ik1uc/screenshots/3byor/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ik1uc/screenshots/jxw4y/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/SpectreMercury/Minion",
        "link": "https://ethglobal.com/showcase/minion-ik1uc"
    },
    {
        "title": "NomNomPay",
        "brief_description": "NomNomPay: The Tastiest Way to Send USDC on Telegram \ud83c\udf55\ud83c\udf7a\ud83d\ude95\ud83d\udcb0",
        "long_description": "NomNomPay is an AI-powered social payment app built on Telegram, utilizing Circle's programmable wallet for seamless and enjoyable peer-to-peer payments in USDC. This project integrates Circle\u2019s programmable wallet technology with a large language model (LLM) within the Telegram chat environment, enabling effortless payments through both direct peer-to-peer interactions and group chats using only recipients' telegram handle. Inspired by TXT2TXN, an open-source web app that pairs user intents with LLMs to facilitate blockchain transactions, NomNomPay aims to streamline the everyday use of USDC stablecoins for the average user. With Circle\u2019s developer-controlled wallet, users do not need to create wallets from scratch or manage their own wallets. The AI-powered payment bot interface simplifies the payment process, especially for those who are new to crypto and unfamiliar with reading transactions. This project is particularly valuable for individuals lacking access to traditional banking systems or living in countries with high inflation, making it a meaningful public good initiative. Product Features: The project is written in python and based on python-telegram-bot to create the bot backend. Every user that signs up get assigned a smart contract wallet created via Circles developer controlled wallets. The user can send transactions via natural language which is parsed by GPT into a json schema that can be used in code. This setup supports sending to telegram usernames, ens names and wallet addresses. Users can mention a currency which will automatically be converted to USDC based on the current rates, e.g., Send 100k dong to @alice will result in a transaction to the wallet address of @alice with 4.07 USDC (100000 VND). Users are presented with a confirmation message showing which transaction would be executed. Splitting payments between multiple users is also supported via natural language, e.g. Split 20$ between @bob and alice.eth will send 10 USDC to each user.\nWhen users have their wallets on different chains, a cross-chain transfer using Circles CTTP will automatically be used without any special user interaction. For the user it works like any other transfer receiving just takes a bit longer than usual. The multiple transactions required are run automatically in the backend.\nUsers receive notifications on incoming payments after they are confirmed by utilizing webhook and Circles notification system.\nWallets can be funded easily by a generated payment link/qr code following EIP681 to make sure the user sends the expected token on the correct chain.",
        "how_its_made": "The project is written in python and based on python-telegram-bot to create the bot backend. Every user that signs up get assigned a smart contract wallet created via Circles developer controlled wallets. The user can send transactions via natural language which is parsed by GPT into a json schema that can be used in code. This setup supports sending to telegram usernames, ens names and wallet addresses. Users can mention a currency which will automatically be converted to USDC based on the current rates, e.g., Send 100k dong to @alice will result in a transaction to the wallet address of @alice with 4.07 USDC (100000 VND). Users are presented with a confirmation message showing which transaction would be executed. Splitting payments between multiple users is also supported via natural language, e.g. Split 20$ between @bob and alice.eth will send 10 USDC to each user.\nWhen users have their wallets on different chains, a cross-chain transfer using Circles CTTP will automatically be used without any special user interaction. For the user it works like any other transfer receiving just takes a bit longer than usual. The multiple transactions required are run automatically in the backend.\nUsers receive notifications on incoming payments after they are confirmed by utilizing webhook and Circles notification system.\nWallets can be funded easily by a generated payment link/qr code following EIP681 to make sure the user sends the expected token on the correct chain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/a3n7z/screenshots/qoxxt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a3n7z/screenshots/u6k7g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a3n7z/screenshots/isrxb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a3n7z/screenshots/h2t7a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a3n7z/screenshots/xy42h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a3n7z/screenshots/0dqoc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xAkuti/nomnompay",
        "link": "https://ethglobal.com/showcase/nomnompay-a3n7z"
    },
    {
        "title": "Gacha Hook",
        "brief_description": "The Gacha Hook addresses high entry barriers, illiquidity, and inefficient revenue models in the NFT market by enabling fractionalization and cross-chain support for a more accessible and dynamic trading experience.",
        "long_description": "Problem 1: High Entry Barriers Problem 2: Illiquidity Problem 3: Inefficient Revenue Models For our project, we used the Uniswap Base Hook template as a foundation. We implemented a custom beforeInitialized function to ensure that the trading pairs adhere to specific rules. Additionally, we created an afterSwap function to verify the swapper's balance and integrated Chainlink VRF to generate true random numbers, enabling NFT redemption for the swapper. To enhance the user experience, we incorporated CCIP, allowing swappers and traders to seamlessly bridge assets to another chain after the swap, ensuring smoother cross-chain functionality.",
        "how_its_made": "For our project, we used the Uniswap Base Hook template as a foundation. We implemented a custom beforeInitialized function to ensure that the trading pairs adhere to specific rules. Additionally, we created an afterSwap function to verify the swapper's balance and integrated Chainlink VRF to generate true random numbers, enabling NFT redemption for the swapper. To enhance the user experience, we incorporated CCIP, allowing swappers and traders to seamlessly bridge assets to another chain after the swap, ensuring smoother cross-chain functionality.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0qd8p/screenshots/6zy7g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0qd8p/screenshots/3r3po/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0qd8p/screenshots/3eg6s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0qd8p/screenshots/wpagu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0qd8p/screenshots/x80yc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0qd8p/screenshots/it4xr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/andrew1004aa/24-singapore-eth-global-hook-project",
        "link": "https://ethglobal.com/showcase/gacha-hook-0qd8p"
    },
    {
        "title": "zkElect",
        "brief_description": "zkElect is a blockchain-based platform that revolutionizes elections and surveys with zk-SNARKs and MACI. It ensures secure, anonymous, and transparent voting, preventing tampering, coercion, or bribery.",
        "long_description": "zkElect: Redefining Elections & Surveys with Blockchain and Zero-Knowledge Proofs \u26a1\ufe0f Imagine a world where every vote and survey is fully anonymous, immune to corruption, and completely tamper-proof. While some countries successfully run free and fair elections, many still struggle with maintaining election integrity, spending millions to ensure transparency. Yet, even with these efforts, votes can often be influenced by bribery \ud83d\udcb8 or tampered with by powerful individuals. In such cases, the essence of democracy is compromised, particularly in parliamentary elections, where voters may feel pressured or coerced, making it difficult for citizens to freely exercise their rights. In workplaces, companies with large numbers of employees may want to run surveys to collect feedback on management performance. However, if employees believe their responses can be traced back to them, they may hesitate to offer honest, negative feedback. Similarly, companies wanting to survey verified customers may find that people are reluctant to share personal details, leading to incomplete data and results. This is where zkElect steps in, offering a revolutionary solution \ud83d\ude80.\nzkElect is a blockchain-based platform designed to transform the way elections and surveys are conducted. By utilizing zk-SNARK proofs and Minimal Anti-Collusion Infrastructure (MACI), originally proposed by Vitalik Buterin, zkElect ensures complete privacy and transparency. Voters can submit their votes on-chain, and every vote is securely encrypted, guaranteeing that no one\u2014not even the system\u2014can see who cast which vote. This removes any possibility of coercion or bribery, allowing users to vote or provide feedback freely, without fear of repercussions. So how does zkElect work?\nBy leveraging the immutable power of blockchain technology, votes and survey responses are recorded transparently and securely on-chain. Privacy, however, goes beyond encryption. zk-SNARKs ensure that no details about a user\u2019s vote or survey response are ever revealed, even as the data is counted and verified. This creates a system where voter anonymity is absolute, guaranteeing that participants can cast their vote without revealing their choices to anyone. zkElect empowers a variety of scenarios, whether in national elections, workplace surveys, or community voting. It gives people the freedom to express their opinions without fear of coercion or manipulation, promoting truly democratic participation. A few of the advantages of zkElect include: 1.) Integrity Preservation: zkElect safeguards the integrity of elections by ensuring that every vote is counted accurately and transparently on the blockchain. Voters can trust the results without worrying about tampering or fraud. 2.) Resource Efficiency: Traditional voting systems often require vast amounts of resources\u2014money, time, and labour. zkElect reduces these costs by conducting elections and surveys on-chain, streamlining the process and minimizing resource expenditure. 3.) Enhanced Anonymity: With zk-SNARKs and MACI in place, voters\u2019 choices remain completely anonymous. This eliminates the possibility of coercion or bribery since no one can see who a voter chose, not even the system itself \ud83d\udee1\ufe0f. 4.) Protection from Bad Actors: Powerful individuals or entities can no longer manipulate the voting process. zkElect prevents anyone from pressuring voters, allowing them to make decisions without fear of retaliation or external influence, especially in high-stakes environments like parliamentary elections. 5.) Global Applicability & Availability: zkElect\u2019s anonymous, secure, and decentralized voting system is flexible and can be applied to a wide range of contexts. Whether it's a national election, a corporate survey, a community vote, or customer feedback, zkElect is built to enhance the voting process in any country, company, or organization \ud83c\udf0d. By protecting election integrity and promoting anonymous voting and surveys, zkElect is poised to transform election processes globally. In a world where democratic integrity is increasingly under threat, zkElect provides a future where every vote is secure, anonymous, and fearless \ud83d\uddf3\ufe0f. Join us on this journey toward building a world where the true voice of the people is always heard, free from corruption and manipulation.\nExplore zkElect and be part of the revolution in secure, private, and decentralized voting. I developed ZkElect using MACI, leveraging Cairom circuits along with multiple SDKs and frameworks. The platform allows users to submit their votes on-chain without revealing their choices. The front end is built with Next.js, and the smart contracts are written in Solidity. I've also integrated the Optimism Sepolia network, with all deployed contract addresses provided. The entire codebase is hosted in a GitHub repository.",
        "how_its_made": "I developed ZkElect using MACI, leveraging Cairom circuits along with multiple SDKs and frameworks. The platform allows users to submit their votes on-chain without revealing their choices. The front end is built with Next.js, and the smart contracts are written in Solidity. I've also integrated the Optimism Sepolia network, with all deployed contract addresses provided. The entire codebase is hosted in a GitHub repository.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/31ho6/screenshots/f6xz7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/31ho6/screenshots/q8huh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/31ho6/screenshots/4k2fy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/31ho6/screenshots/hac2j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/31ho6/screenshots/ex568/default.jpg",
            "https://ethglobal.b-cdn.net/projects/31ho6/screenshots/ze810/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/anvats/zkElect",
        "link": "https://ethglobal.com/showcase/zkelect-31ho6"
    },
    {
        "title": "AirBots",
        "brief_description": "A Telegram bot that provides real-time crypto data, simplifies token swaps with instant cross-chain functionality, and offers easy token creation tools\u2014all in one platform.",
        "long_description": "Our product is an all-in-one Telegram bot designed to empower crypto traders with advanced, real-time data and seamless transaction functionality. It offers users the ability to gather valuable insights about any token by simply providing the token\u2019s address. With its connection to the GeckoTerminal API, users can access up-to-the-minute data on a vast range of cryptocurrencies, making it easier to make informed trading decisions. The bot doesn\u2019t just stop at providing data. It also tracks large transactions made by whales, alerting users to significant market moves as they happen. Additionally, the bot provides real-time updates on cryptocurrency news, ensuring users are aware of crucial events or developments that could impact their investments. These features are aimed at eliminating the fragmented access to crypto information that traders typically experience by consolidating all necessary data into one platform. Furthermore, our Telegram bot integrates Fusion+, a cutting-edge cross-chain swapping protocol that enables users to perform token swaps instantly without the hassle of bridging between chains. This solution dramatically reduces the complexity and time required to swap tokens, allowing users to take action faster when they see favorable conditions. No more manual bridging or lengthy transfer times \u2013 the bot automates this process, making token swaps as smooth as possible. Additionally, our product introduces a new feature that simplifies the token creation process. With just a few clicks, users can create their own tokens or meme coins, streamlining what has traditionally been a complex and technical process. This feature democratizes token creation, allowing anyone, regardless of their technical background, to enter the world of tokenomics and bring their ideas to life with ease. Our project is built on a robust set of modern technologies that come together to create a seamless, real-time trading and token creation experience, all within a simple Telegram bot interface. At the core of the project is the Telegram Bot Framework, powered by node-telegram-bot-api. This framework allows the bot to interact with Telegram\u2019s API, handling user inputs, executing token swaps, and sending important alerts. The bot operates in real-time, processing commands and executing backend API calls based on the information users provide. It acts as the central interface through which users can manage their token-related activities. To ensure users have access to the most accurate and up-to-date information, we\u2019ve integrated the GeckoTerminal API using Axios. This allows the bot to retrieve real-time token data, including critical metrics like price, market cap, and trading volume. Users simply provide a token address, and the bot responds with actionable insights, giving them an instant overview of the market\u2019s state. The GeckoTerminal integration ensures that the bot can cover multiple tokens across different chains, enabling traders to make informed decisions across the entire crypto market. One of the standout features of the bot is its ability to send whale transaction alerts, made possible by the integration of the Whale Alert API. This functionality monitors the blockchain for large transactions, often referred to as whale trades, that could influence market behavior. When a significant trade is detected, users are notified in real-time, enabling them to stay ahead of the market and react promptly to these high-impact transactions. In addition to market alerts, the bot is equipped with real-time news updates sourced from the CryptoPanic API. This integration ensures that users are always informed about the latest developments in the cryptocurrency world, including regulatory changes, macroeconomic events, and other breaking news that could affect the market. By combining both data and news, the bot serves as a comprehensive tool for keeping users well-informed. Another key functionality is cross-chain token swapping, made possible by the Fusion+ protocol. This integration eliminates the traditionally complex and cumbersome process of bridging tokens between chains by offering seamless, instant cross-chain swaps. Users can swap tokens between different blockchains with minimal effort, without the need for multiple transactions or manual steps. This feature is designed to streamline the trading experience, making it faster, simpler, and more user-friendly. In addition to its trading capabilities, the bot also offers a unique token creation feature. Using custom scripts and predefined smart contract templates, users can create their own tokens or meme coins with a single command. The tool allows for on-the-go customization of token parameters such as supply, name, and symbol, simplifying the typically complex process of token creation. This makes token development accessible even to those without deep technical knowledge, empowering a wider audience to participate in the cryptocurrency space. Overall, this project brings together real-time data, cross-chain swapping, market alerts, news updates, and token creation into a single, easy-to-use platform, providing users with all the tools they need to navigate the complex world of cryptocurrency directly from Telegram.",
        "how_its_made": "Our project is built on a robust set of modern technologies that come together to create a seamless, real-time trading and token creation experience, all within a simple Telegram bot interface. At the core of the project is the Telegram Bot Framework, powered by node-telegram-bot-api. This framework allows the bot to interact with Telegram\u2019s API, handling user inputs, executing token swaps, and sending important alerts. The bot operates in real-time, processing commands and executing backend API calls based on the information users provide. It acts as the central interface through which users can manage their token-related activities. To ensure users have access to the most accurate and up-to-date information, we\u2019ve integrated the GeckoTerminal API using Axios. This allows the bot to retrieve real-time token data, including critical metrics like price, market cap, and trading volume. Users simply provide a token address, and the bot responds with actionable insights, giving them an instant overview of the market\u2019s state. The GeckoTerminal integration ensures that the bot can cover multiple tokens across different chains, enabling traders to make informed decisions across the entire crypto market. One of the standout features of the bot is its ability to send whale transaction alerts, made possible by the integration of the Whale Alert API. This functionality monitors the blockchain for large transactions, often referred to as whale trades, that could influence market behavior. When a significant trade is detected, users are notified in real-time, enabling them to stay ahead of the market and react promptly to these high-impact transactions. In addition to market alerts, the bot is equipped with real-time news updates sourced from the CryptoPanic API. This integration ensures that users are always informed about the latest developments in the cryptocurrency world, including regulatory changes, macroeconomic events, and other breaking news that could affect the market. By combining both data and news, the bot serves as a comprehensive tool for keeping users well-informed. Another key functionality is cross-chain token swapping, made possible by the Fusion+ protocol. This integration eliminates the traditionally complex and cumbersome process of bridging tokens between chains by offering seamless, instant cross-chain swaps. Users can swap tokens between different blockchains with minimal effort, without the need for multiple transactions or manual steps. This feature is designed to streamline the trading experience, making it faster, simpler, and more user-friendly. In addition to its trading capabilities, the bot also offers a unique token creation feature. Using custom scripts and predefined smart contract templates, users can create their own tokens or meme coins with a single command. The tool allows for on-the-go customization of token parameters such as supply, name, and symbol, simplifying the typically complex process of token creation. This makes token development accessible even to those without deep technical knowledge, empowering a wider audience to participate in the cryptocurrency space. Overall, this project brings together real-time data, cross-chain swapping, market alerts, news updates, and token creation into a single, easy-to-use platform, providing users with all the tools they need to navigate the complex world of cryptocurrency directly from Telegram.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/040yk/screenshots/u0y8r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/040yk/screenshots/89tvk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/040yk/screenshots/q71rt/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/NotJohn04/airdao-telegram-bot",
        "link": "https://ethglobal.com/showcase/airbots-040yk"
    },
    {
        "title": "streetcredits.io",
        "brief_description": "Accumulate street credits by going for events and become a certified degen",
        "long_description": "This project will be deployed on Hedera Testnet and features a design language borrowed from NounsDAO. The intention is to help generate a NFT onchain whenever an user successfully attends a Luma Event. We want to help Luma degens generate a provable reputation onchain so that this feature can be extended by other service providers/projects who might want to reward their userbase with priority on true degens. We started with a problem statement: During periods of high traffic, companies/projects face a hard choice to award/approve registrations. Although hosts can filter registrations via LinkedIn, Twitter and via the registrant's work title, there is no guarantee they will actually show up or are the demographic that they want to reach out to. This project used Hedera's HTS and NounsDAO's design assets. HTS made it easy to mint NFTs on Hedera Network. We first checked out Luma's API documentations here: https://docs.lu.ma/reference/getting-started-with-your-api and looked at the data we can request off of Luma. Next we created a script that mints an NFT on Hedera where its attributes are dependent on the event details and the ratio of checked-in users to total number of approved users for any particular event. Whenever a user successfully attends an event (by checking in through QR code), this triggers our NFT script to run an mint the event NFT to the user's onchain wallet. Lastly, we created a dashboard for Luma users to login and check the NFTs they've collected so far.",
        "how_its_made": "This project used Hedera's HTS and NounsDAO's design assets. HTS made it easy to mint NFTs on Hedera Network. We first checked out Luma's API documentations here: https://docs.lu.ma/reference/getting-started-with-your-api and looked at the data we can request off of Luma. Next we created a script that mints an NFT on Hedera where its attributes are dependent on the event details and the ratio of checked-in users to total number of approved users for any particular event. Whenever a user successfully attends an event (by checking in through QR code), this triggers our NFT script to run an mint the event NFT to the user's onchain wallet. Lastly, we created a dashboard for Luma users to login and check the NFTs they've collected so far.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/avhq3/screenshots/m6nc7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/avhq3/screenshots/95qwd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/avhq3/screenshots/501rz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/avhq3/screenshots/wk3bt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/avhq3/screenshots/a5wsf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/avhq3/screenshots/f7jnd/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xMailMan/street-credits",
        "link": "https://ethglobal.com/showcase/streetcredits-io-avhq3"
    },
    {
        "title": "Proof-of-Ivan",
        "brief_description": "Minimal submission, failed to actually hack. This is just a repo and some readme and there's not much to it.",
        "long_description": "I want mainnet scaled. Ask vitalik.eth about zk stuff in mainnet (or other scaling solutions that are not smart wallets or more L2s) when you see him please. I'm also focusing on BitTensor Rao game testnet right now which is more important, innovations really happen in BitTensor while Ethereum is just VC money poored into L2 and other weird stuff. Like really, the ethereum tech used to be cool, now it starts to stagnate. Wen Scale Mainnet??? My hackerhouse mates didn't make it easy and work events took much time. I failed to connect with a good team and my idea came late and I'm writing this while watching vitalik movie. Whatever, I'll come to Bangkok better prepped. The repo is just readme, there's not much in it. BitTensor seems to be the future, and I had much more fun at Polkadot events, not many free drinks but then again not many unfriendly people in it for the money. Ivan is in it for the Tech{no}!",
        "how_its_made": "My hackerhouse mates didn't make it easy and work events took much time. I failed to connect with a good team and my idea came late and I'm writing this while watching vitalik movie. Whatever, I'll come to Bangkok better prepped. The repo is just readme, there's not much in it. BitTensor seems to be the future, and I had much more fun at Polkadot events, not many free drinks but then again not many unfriendly people in it for the money. Ivan is in it for the Tech{no}!",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xznxf/screenshots/c3jni/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xznxf/screenshots/hfu6t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xznxf/screenshots/g6ct5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AgorismLabs/shiny-chainsaw",
        "link": "https://ethglobal.com/showcase/proof-of-ivan-xznxf"
    },
    {
        "title": "FileBeam",
        "brief_description": "FileBeam beams petabytes of multichain dApp data into the open data economy!",
        "long_description": "\ud83d\udca1 The opportunity The dApp market is surging, with data-heavy sectors like AI and Gaming taking the forefront, estimated at 50 to 100 petabytes of dApp data generated across major blockchain networks. With 600 petabytes of data available on Filecoin's decentralized storage network, there is a huge opportunity to bring that data onboard and achieve a truly decentralized ecosystem. \ud83d\ude80 The solution FileBeam brings exponential growth to the open data economy, by BEAMING hundreds of petabytes of dApp data, across multiple chains, onto Filecoin. This opens up new opportunities for decentralized data ownership and the open data economy. Key use cases include incentivized uploads of high quality data for AI model training (upload-to-earn), rewarding users directly for data contributions and more. \ud83d\udcaf Demo of a upload-to-earn Telegram mini app in the video above! FileBeam uses Filecoin and IPFS as its decentralized storage layer, using Axelar for cross-chain messaging to allow data to be stored from dApps across various chains such as Linea, Hedera and Flow. FileBeam is integrated with the Dynamic Wallet to unlock economic flows for data management.",
        "how_its_made": "FileBeam uses Filecoin and IPFS as its decentralized storage layer, using Axelar for cross-chain messaging to allow data to be stored from dApps across various chains such as Linea, Hedera and Flow. FileBeam is integrated with the Dynamic Wallet to unlock economic flows for data management.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/4g61n/screenshots/z59a8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4g61n/screenshots/y5dqd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4g61n/screenshots/m4d71/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4g61n/screenshots/mif6s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4g61n/screenshots/wkhcp/default.jpg"
        ],
        "live_demo": "https://t.me/FILBeamBot & https://fil-beam.vercel.app/",
        "source_code": "https://github.com/rk-rishikesh/FILBeam",
        "link": "https://ethglobal.com/showcase/filebeam-4g61n"
    },
    {
        "title": "TeleBlackjack",
        "brief_description": "Interactive telegram bot that allows you to play blackjack on it.",
        "long_description": "This project works on building a telegram bot that allows users to play blackjack on it. It is one of the most popular casino card games worldwide and the objective of the game is for players to have a hand value as close to 21 as possible without exceeding it, competing against a dealer. This app serves as a way to learn more about the game and also have a go at playing it. It uses a GameHandler class that is responsible for managing instances of a Blackjack game in a Telegram bot. This structure is helpful when managing multiple games across different chats in Telegram. Each game is identified by a unique ID or chat, and the Singleton pattern ensures that the game state is consistent throughout the bot\u2019s operation. bot.py sets up and runs a Telegram bot that interacts with users to play Blackjack. The bot is flexible, supporting both webhook and polling for update handling, and uses job scheduling to maintain the state of games by cleaning up stale ones. The logging system ensures comprehensive tracking of bot operations and errors, while the configuration file makes it easy to adjust settings without changing the code.",
        "how_its_made": "It uses a GameHandler class that is responsible for managing instances of a Blackjack game in a Telegram bot. This structure is helpful when managing multiple games across different chats in Telegram. Each game is identified by a unique ID or chat, and the Singleton pattern ensures that the game state is consistent throughout the bot\u2019s operation. bot.py sets up and runs a Telegram bot that interacts with users to play Blackjack. The bot is flexible, supporting both webhook and polling for update handling, and uses job scheduling to maintain the state of games by cleaning up stale ones. The logging system ensures comprehensive tracking of bot operations and errors, while the configuration file makes it easy to adjust settings without changing the code.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1kwfn/screenshots/bgrx7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1kwfn/screenshots/squj0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1kwfn/screenshots/t7mh7/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/evanjw2/telegram-bot",
        "link": "https://ethglobal.com/showcase/teleblackjack-1kwfn"
    },
    {
        "title": "Taskify",
        "brief_description": "Outsourcing daily tasks just got easier with Web3 technology. Want someone to help with dog walking? Or would you like to walk dogs to earn some money in your free time? Taskify is the solution.",
        "long_description": "This project enables users to connect with others to efficiently outsource or assist with routine tasks, leveraging the security and transparency of blockchain technology and smart contracts. By integrating these decentralized technologies, the platform ensures trust and accountability between users. The process is straightforward: users can either request help with tasks or offer to assist others. When creating a profile, users will be asked for their first name and role selection\u2014whether they need assistance or want to become a helper. After signing in, the platform automatically provides a secure wallet for each user. Additionally, new users are verified through World ID by Worldcoin to enhance trust and security by verifying it as unique human. Once verified, users are ready to either request help for their tasks or post their availability to assist others. The seamless interface makes task management in a decentralized environment both user-friendly and secure. Once any user accepts the offer made by another user, USDC token are transferred to the smart contract to act as an Escrow. After work completion task creator can just mark it as completed and tokens will be transferred to the tasker. This project utilizes a modern tech stack, featuring Solidity for Smart Contracts,  React for the frontend, Node.js for the backend, and MongoDB for data storage. In addition, we leverage The Graph for querying blockchain data from smart contracts. On the Web3 side, Worldcoin is integrated to verify users, ensuring a secure and decentralized identity layer. User onboarding and wallet integration is handled by Dynamic, providing seamless crypto wallet functionality. We have used Circle's Web3 services for contract deployment and management Task management and payments are both facilitated through smart contracts, ensuring secure, automated processes. For payments, transactions are conducted using USDC. The project operates on the Sepolia testnet, allowing us to test and deploy the decentralized components efficiently.",
        "how_its_made": "This project utilizes a modern tech stack, featuring Solidity for Smart Contracts,  React for the frontend, Node.js for the backend, and MongoDB for data storage. In addition, we leverage The Graph for querying blockchain data from smart contracts. On the Web3 side, Worldcoin is integrated to verify users, ensuring a secure and decentralized identity layer. User onboarding and wallet integration is handled by Dynamic, providing seamless crypto wallet functionality. We have used Circle's Web3 services for contract deployment and management Task management and payments are both facilitated through smart contracts, ensuring secure, automated processes. For payments, transactions are conducted using USDC. The project operates on the Sepolia testnet, allowing us to test and deploy the decentralized components efficiently.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/kuo2c/screenshots/qjrf6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kuo2c/screenshots/e8jh1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kuo2c/screenshots/a2rjo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kuo2c/screenshots/q02dx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kuo2c/screenshots/2rj1k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kuo2c/screenshots/cwben/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/akhemraj/ethglobalSG-easytasks",
        "link": "https://ethglobal.com/showcase/taskify-kuo2c"
    },
    {
        "title": "Consulaite",
        "brief_description": "Chat for CEOs simplifies decision-making in the crypto & Web3 space by providing tailored, data-driven recommendations for tools, platforms, and companies based on CEO requirements and budgets. Avoid costly consultants with real-time insights into the latest solutions",
        "long_description": "Consulaite is an intelligent assistant designed to help CEOs and decision-makers in the fast-paced crypto and Web3 sectors choose the right tools, platforms, or services to implement their ideas. The AI takes into account the CEO\u2019s requirements\u2014such as features, budget, and technical constraints\u2014and suggests a curated selection of solutions from a vast dataset of crypto/Web3 companies and tools. By doing so, it saves time, reduces costs, and ensures CEOs stay ahead of market trends without needing to hire expensive consultants. It also interacts with the user via a conversational interface, asking follow-up questions to gather specific requirements and refining recommendations accordingly. With freemium and subscription models, Consulaite offers both basic and premium insights The project is built on OpenAI\u2019s GPT-4 model, fine-tuned with a custom dataset of crypto and Web3 companies, tools, and platforms. The dataset is created by scraping data from sources like CoinTelegraph, Crunchbase, GitHub, and API integrations (e.g., CoinGecko, DefiLlama). The data is stored in a PostgreSQL database and indexed using a vector database (Pinecone or FAISS) for fast retrieval of relevant solutions based on user queries. We integrate the GPT-4 API with a conversational logic system that leverages session memory to store and reference previous inputs, ensuring a smooth user experience with personalized recommendations. Web scraping automation is handled by tools like Scrapy, while APIs provide real-time market insights (e.g., market caps, TVL). We also incorporated payment gateways (Stripe or crypto) for monetization, including freemium access and premium features. One particularly hacky aspect is the use of embeddings in a vector database to semantically match the CEO's query with relevant tools. This allows for accurate, real-time recommendations even as the crypto/Web3 space evolves. The project leverages a combination of modern AI, data scraping, and dynamic market analysis to deliver cutting-edge solutions to business leaders.",
        "how_its_made": "The project is built on OpenAI\u2019s GPT-4 model, fine-tuned with a custom dataset of crypto and Web3 companies, tools, and platforms. The dataset is created by scraping data from sources like CoinTelegraph, Crunchbase, GitHub, and API integrations (e.g., CoinGecko, DefiLlama). The data is stored in a PostgreSQL database and indexed using a vector database (Pinecone or FAISS) for fast retrieval of relevant solutions based on user queries. We integrate the GPT-4 API with a conversational logic system that leverages session memory to store and reference previous inputs, ensuring a smooth user experience with personalized recommendations. Web scraping automation is handled by tools like Scrapy, while APIs provide real-time market insights (e.g., market caps, TVL). We also incorporated payment gateways (Stripe or crypto) for monetization, including freemium access and premium features. One particularly hacky aspect is the use of embeddings in a vector database to semantically match the CEO's query with relevant tools. This allows for accurate, real-time recommendations even as the crypto/Web3 space evolves. The project leverages a combination of modern AI, data scraping, and dynamic market analysis to deliver cutting-edge solutions to business leaders.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/75z9b/screenshots/xviur/default.jpg",
            "https://ethglobal.b-cdn.net/projects/75z9b/screenshots/hh9yp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/75z9b/screenshots/hvbbk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/YD811/consulaite",
        "link": "https://ethglobal.com/showcase/consulaite-75z9b"
    },
    {
        "title": "HarvestReward",
        "brief_description": "HarvestReward is a blockchain platform that enhances agriculture by enabling transparent supply chains, automating contracts, offering DeFi for farmers, and tokenizing assets and data\u2014boosting efficiency, traceability, and market access for farmers and agribusinesses globally.",
        "long_description": "HarvestReward is a decentralized platform built on Hedera Hashgraph to digitize and optimize the agricultural supply chain. It enables farmers, cooperatives, buyers, and regulators to securely share information, track goods, and automate financial transactions, improving transparency and efficiency from farm to table. By leveraging smart contracts, HarvestReward automates agreements between stakeholders, ensuring seamless payments, delivery, and logistics without intermediaries. It integrates Worldcoin\u2019s decentralized identity (DID), allowing smallholder farmers to create secure digital identities, improving access to financial services and markets. The platform offers DeFi tools, enabling farmers to secure microloans and insurance using tokenized assets, such as future crop yields. It also incorporates IoT devices to collect real-time farm data, helping stakeholders make informed decisions. HarvestReward is built using Hedera Hashgraph, leveraging its high throughput, low-cost, and eco-friendly consensus for secure, real-time tracking of agricultural products. Smart contracts are developed in Solidity for automation, while Worldcoin provides decentralized identity verification to ensure trust and inclusion for farmers. IoT devices collect real-time farm data, which is integrated into the blockchain through oracles like Chainlink, and tokenized assets are used for DeFi services, enabling loans, insurance, and payments. Hedera\u2019s carbon-negative infrastructure also supports tokenizing sustainability efforts, such as carbon credits.",
        "how_its_made": "HarvestReward is built using Hedera Hashgraph, leveraging its high throughput, low-cost, and eco-friendly consensus for secure, real-time tracking of agricultural products. Smart contracts are developed in Solidity for automation, while Worldcoin provides decentralized identity verification to ensure trust and inclusion for farmers. IoT devices collect real-time farm data, which is integrated into the blockchain through oracles like Chainlink, and tokenized assets are used for DeFi services, enabling loans, insurance, and payments. Hedera\u2019s carbon-negative infrastructure also supports tokenizing sustainability efforts, such as carbon credits.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tjqc6/screenshots/d9b5h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tjqc6/screenshots/xcsxx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tjqc6/screenshots/8gw8y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tjqc6/screenshots/xbodd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tjqc6/screenshots/4j0zj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tjqc6/screenshots/nv0wo/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/DarkBlue2021/ethglobalsg",
        "link": "https://ethglobal.com/showcase/harvestreward-tjqc6"
    },
    {
        "title": "APEY Fi",
        "brief_description": "Monkey around with APY. Our platform allows trading on whether the interest earned from staking (APY) for platforms like Lido will increase or decrease. You can use EVM locked Bitcoin (RBTC) to bet on the largest project in the space with the largest crypto in the market",
        "long_description": "APEY is a perpetual trading protocol for APY (Annual Percentage Yield). We built a decentralized financial system enabling users to trade perpetual contracts (derivatives without an expiration date) based on APY rates of various financial instruments. Here\u2019s a breakdown of how this protocol works: These contracts do not expire, meaning traders can hold their positions indefinitely, benefiting from either an increase or decrease in APY depending on their position (long or short). Underlying APY Sources:\nThe APY for these contracts could be based on a wide range of yield-bearing activities:\nDeFi lending platforms (e.g., Compound, Aave)\nStaking pools (e.g., Ethereum 2.0 staking)\nYield farms (e.g., liquidity provider returns)\nReal-time data on APY is pulled from oracles, which are trusted third-party services that provide reliable data feeds.\nCurrently we just use Lido data for this. Leverage:\nTraders can use leverage to amplify their positions on future APY movements. For example, if a user believes a certain APY will increase, they can take a leveraged long position to maximize their returns, but at the risk of liquidation if the APY moves against them. Funding Rates:\nIn a perpetual trading protocol, the positions of long and short traders must remain balanced. Funding rates are periodically exchanged between long and short positions to incentivize this balance.\nIf there are more long positions (traders betting on APY increasing), longs pay a funding rate to shorts, and vice versa. This mechanism keeps the contract price close to the spot APY rate. Liquidation:\nIf the APY moves significantly against a trader's position (especially leveraged positions), their position can be liquidated to ensure the protocol's solvency. This protects the platform from becoming under-collateralized. Collateral and Margin:\nUsers are required to deposit collateral to open positions. The amount of collateral required depends on the leverage used and the volatility of the APY. Use Cases:\nSpeculation: Traders can profit from predicting APY movements.\nHedging: Yield farmers or DeFi stakers can hedge their exposure to falling APY by taking short positions.\nLeverage Yield Farming: Users can use leverage to amplify their exposure to high APY DeFi protocols without directly interacting with the underlying platforms. This perpetual APY trading protocol offers traders a flexible way to gain exposure to yield fluctuations across the decentralized financial landscape without the need to lock capital into staking or lending protocols themselves. On run, Staked ETH lido API is used to create a yield fi perpetual program that allows users to bet on yields of other staking protocols. APEY Fi brings a new market to life. By tapping into the yield/interest markets we can effectively incentivize users to solve the Lido centralization problem, by betting on the yield market, winners get the chance to increase their principal and earn interest, while losing bets are liquidated. The front end is mostly built on the \u201cmain\u201d branch which is a dashboard displaying the current Lido APY along with long and short buttons with a leverage slider for users to be able to bet on whether that APY will go up or down over time as a perpetual derivative\nThe Lido APY is pulled using a Rust program (src/main.rs) that pulls the data from a Lido API and simulates a trusted oracle providing the data but in our case is just signed by our deploying wallet to push the data into the smart contract (deployed in Remix, \u201cbackend\u201d branch:/contracts/LidoAPYPerpetual.sol)\nThe data then gets pushed on init (cargo run) which calls the updateAPY function in the smart contract and listens on a heartbeat every 5 seconds\nThis smart contract allows users to take perpetual, leveraged positions on whether the Lido APY increases or decreases, using RBTC as the financial instrument at stake in order to utilize the largest asset in crypto giving it exposure to a new financial derivative based on one of the largest TVL protocols in the world\nFor communicating the state of the smart contract to the front end, we deployed a subgraph that can reference the underlying APY data from and use it to push the user requests for derivative trading to the smart contract",
        "how_its_made": "The front end is mostly built on the \u201cmain\u201d branch which is a dashboard displaying the current Lido APY along with long and short buttons with a leverage slider for users to be able to bet on whether that APY will go up or down over time as a perpetual derivative\nThe Lido APY is pulled using a Rust program (src/main.rs) that pulls the data from a Lido API and simulates a trusted oracle providing the data but in our case is just signed by our deploying wallet to push the data into the smart contract (deployed in Remix, \u201cbackend\u201d branch:/contracts/LidoAPYPerpetual.sol)\nThe data then gets pushed on init (cargo run) which calls the updateAPY function in the smart contract and listens on a heartbeat every 5 seconds\nThis smart contract allows users to take perpetual, leveraged positions on whether the Lido APY increases or decreases, using RBTC as the financial instrument at stake in order to utilize the largest asset in crypto giving it exposure to a new financial derivative based on one of the largest TVL protocols in the world\nFor communicating the state of the smart contract to the front end, we deployed a subgraph that can reference the underlying APY data from and use it to push the user requests for derivative trading to the smart contract",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/72in3/screenshots/y0g0a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/72in3/screenshots/t5wh8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/72in3/screenshots/2g5i1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/72in3/screenshots/at7vu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/72in3/screenshots/1i728/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ABusyHippie/ETHGlobalSingapore",
        "link": "https://ethglobal.com/showcase/apey-fi-72in3"
    },
    {
        "title": "HyperWallet",
        "brief_description": "HyperWallet is a chain abstracted wallet powered by Hyperlane",
        "long_description": "HyperWallet is a chain abstracted wallet that empowers users to interact with multiple blockchains using Interchain Accounts. Users only need to transaction on one chain but can manage assets and permissions across many chains. This enables easy onboarding of users to new chains especially as Hyperlane supports self-deployment on many L2s. Key Features Use Cases We used a combination of existing tech from sponsors, industry standard libraries, and new innovations we quickly developed to power HyperWallet. The goal was to quickly get an MVP that can interact with any DApp on Scroll while relaying messages from an EOA on Binance Smart Chain using Hyperlane. Existing Tech New Tech",
        "how_its_made": "We used a combination of existing tech from sponsors, industry standard libraries, and new innovations we quickly developed to power HyperWallet. The goal was to quickly get an MVP that can interact with any DApp on Scroll while relaying messages from an EOA on Binance Smart Chain using Hyperlane. Existing Tech New Tech",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ye9zz/screenshots/4um0p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ye9zz/screenshots/p6wzp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ye9zz/screenshots/kbs7e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ye9zz/screenshots/eghg2/default.jpg"
        ],
        "live_demo": "https://hyper-wallet.vercel.app/",
        "source_code": "https://github.com/owlprotocol/hyper-wallet/",
        "link": "https://ethglobal.com/showcase/hyperwallet-ye9zz"
    },
    {
        "title": "Vibezer",
        "brief_description": "The decentralized platform where travelers and brands connect through matching vibes, powered by dynamic event creation",
        "long_description": "Vibezer is revolutionizing the way travelers, content creators, and Web3 enthusiasts connect, explore, and engage with the world. As a cutting-edge decentralized platform, Vibezer seamlessly blends community building, event creation, and brand engagement into one dynamic ecosystem. At the heart of Vibezer are its three core features: Cults, Raids, and Brands. Each component is designed to offer unique experiences and opportunities for users to express themselves, connect with like-minded individuals, and embark on unforgettable adventures. Cults, Vibezer's community hubs, are where users find their tribe. These vibrant spaces cater to diverse interests and passions, allowing members to organize fundraising events, create exclusive NFT-gated groups Cults foster a sense of belonging and shared purpose, making it easy for users to find and engage with communities that resonate with their interests. Raids represent the adventurous spirit of Vibezer. These user-organized activities come in various exciting forms. Solo Raids connect lone travelers with local guides or fellow explorers, fostering unique cultural exchanges. Event Raids empower users to launch physical events complete with NFT ticket sales and crowdfunding goals, perfect for concerts, workshops, or festivals. The innovative \"Welcome To The Den\" feature reimagines couchsurfing for the crypto age, allowing NFT holders to stake cryptocurrency for long-term stays while earning rewards. For those seeking knowledge and engagement, Wizards Opinions provides a forum-like space where curiosity is rewarded, and top-voted answers earn recognition. The Brands section of Vibezer opens up new possibilities for product launches and tokenization. Here, businesses and creators can introduce Real World Assets (RWA) as Vibezer Tokenized Assets (VTA), leveraging NFC chip technology to bridge the physical and digital realms. This feature not only provides new avenues for brand engagement but also introduces innovative ways for communities to interact with products and experiences. Vibezer's commitment to inclusivity is reflected in its tiered access model. While Solo Raids and Event Raids are free for all to enjoy, premium features require cryptocurrency staking, offering additional benefits and rewards to engaged users. Looking to the future, Vibezer has ambitious plans to further enhance its ecosystem. These include introducing smart contract vaults for optimized travel savings, aggregating chats from various social media platforms for seamless community engagement, implementing a privacy-focused ZK Map for discovering social activities, and launching random chat rooms for spontaneous connections. Vibezer is more than just a platform; it's a gateway to a world where digital innovation meets real-world experiences. Whether you're a solo traveler seeking authentic local encounters, a content creator looking to build a dedicated following, or a brand aiming to connect with Web3 communities, Vibezer provides the tools and spaces to make it happen. Join us in forging the future of decentralized community engagement, where every interaction is an opportunity for discovery, and every connection has the potential to spark something extraordinary. Vibezer leverages a cutting-edge tech stack to deliver a seamless, decentralized platform: Frontend: Built with Next.js, a React framework, ensuring fast, server-side rendered pages for optimal performance. Tailwind CSS provides a utility-first approach for rapid, responsive design implementation. Backend: Powered by Supabase, offering real-time database capabilities, authentication, and serverless functions. This allows for scalable, secure data management and user interactions. Blockchain Integration: Utilizes Solidity for smart contract development, with Hardhat as the development environment. This combination enables robust, secure implementation of decentralized features like NFT gating and crypto staking. Deployment: Hosted on Vercel, providing continuous deployment, automatic SSL, and global CDN distribution for lightning-fast load times across the world. This carefully chosen stack ensures Vibezer's ability to handle complex decentralized operations while maintaining a smooth, responsive user experience.",
        "how_its_made": "Vibezer leverages a cutting-edge tech stack to deliver a seamless, decentralized platform: Frontend: Built with Next.js, a React framework, ensuring fast, server-side rendered pages for optimal performance. Tailwind CSS provides a utility-first approach for rapid, responsive design implementation. Backend: Powered by Supabase, offering real-time database capabilities, authentication, and serverless functions. This allows for scalable, secure data management and user interactions. Blockchain Integration: Utilizes Solidity for smart contract development, with Hardhat as the development environment. This combination enables robust, secure implementation of decentralized features like NFT gating and crypto staking. Deployment: Hosted on Vercel, providing continuous deployment, automatic SSL, and global CDN distribution for lightning-fast load times across the world. This carefully chosen stack ensures Vibezer's ability to handle complex decentralized operations while maintaining a smooth, responsive user experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/892z3/screenshots/jm6hk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/892z3/screenshots/qhads/default.jpg",
            "https://ethglobal.b-cdn.net/projects/892z3/screenshots/xqaz7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/892z3/screenshots/0c2c2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/892z3/screenshots/69uxr/default.jpg"
        ],
        "live_demo": "https://vibezer.vercel.app/",
        "source_code": "https://github.com/sharleneofficial/vibezer",
        "link": "https://ethglobal.com/showcase/vibezer-892z3"
    },
    {
        "title": "Movie",
        "brief_description": "UNI Bridge for All BlockChains User can launch a new ERC404 token by any movie (need to pay 100 $BST)  User can buy SBT of any movie  which can access the SBT permission discord channel for the movie",
        "long_description": "User can buy SBT of any movie\nwhich can access the SBT permission discord channel for the movie\nUser can buy Coin of any movie\nwhich can access the coin permission discord channel for the movie, can setup differnt amount of coins with different channel.\nUser can buy NFT of any movie\nwhich can access the NFT permission discord channel for the movie\nUser can unlock posts / blogs if they owned NFT/ Specify amount of coin or SBT. The condition can be different from different posts/blogs.\nNFT can be trade on opensea\nFT can be trade on opensea\nNFT owner can edit NFT avatar, which shows on opensea nuxt, solidity, supabase User can launch a new ERC404 token by any movie (need to pay 100 $BST)\nUser can buy SBT of any movie\nwhich can access the SBT permission discord channel for the movie User can buy Coin of any movie\nwhich can access the coin permission discord channel for the movie, can setup differnt amount of coins with different channel.\nUser can buy NFT of any movie\nwhich can access the NFT permission discord channel for the movie\nUser can unlock posts / blogs if they owned NFT/ Specify amount of coin or SBT. The condition can be different from different posts/blogs.\nNFT can be trade on opensea\nFT can be trade on opensea\nNFT owner can edit NFT avatar, which shows on opensea",
        "how_its_made": "nuxt, solidity, supabase User can launch a new ERC404 token by any movie (need to pay 100 $BST)\nUser can buy SBT of any movie\nwhich can access the SBT permission discord channel for the movie User can buy Coin of any movie\nwhich can access the coin permission discord channel for the movie, can setup differnt amount of coins with different channel.\nUser can buy NFT of any movie\nwhich can access the NFT permission discord channel for the movie\nUser can unlock posts / blogs if they owned NFT/ Specify amount of coin or SBT. The condition can be different from different posts/blogs.\nNFT can be trade on opensea\nFT can be trade on opensea\nNFT owner can edit NFT avatar, which shows on opensea",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jbiy0/screenshots/3xwdo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jbiy0/screenshots/ipnjm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jbiy0/screenshots/9uswn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/HelloRWA/ERC404-RWA-Movie",
        "link": "https://ethglobal.com/showcase/movie-jbiy0"
    },
    {
        "title": "La Vaca Vampiro",
        "brief_description": "La Vaca Vampiro is a set of token lists that work with CoW Swap widget to make it easy to vampire attack projects",
        "long_description": "La Vaca Vampiro is a comprehensive set of token lists specifically designed to integrate seamlessly with the CoW Swap widget, enabling projects to execute efficient \"vampire attacks.\" By leveraging CoW Swap\u2019s decentralized trading infrastructure, La Vaca Vampiro allows users to effortlessly siphon liquidity from rival platforms by offering optimized token pairs and incentives. This strategic tool empowers projects to attract users from competing ecosystems by providing better trading conditions, lower slippage, and improved user experience, thus fueling rapid adoption and liquidity migration. We built La Vaca Vampiro with a combination of decentralized technology and modular integrations, carefully piecing together several components to create a cohesive tool. CoW Swap Integration: The project revolves around CoW Swap, specifically using their widget (https://widget.cow.fi/) to facilitate decentralized trading. CoW Swap\u2019s infrastructure was ideal for this project because it offers seamless on-chain execution and sophisticated order matching, which helps mitigate slippage. Additionally, the widget configurator allowed us to tailor the swap interface for our targeted token lists, streamlining the process of siphoning liquidity from competing platforms. Token Lists Standard: The project takes full advantage of the token lists standard to dynamically load specific tokens that are part of other protocols\u2019 liquidity pools or vaults. By targeting exotic tokens\u2014such as LP tokens from yield farms or vaults\u2014La Vaca Vampiro can vampire attack projects that have attracted a lot of liquidity into these niche assets. The token lists are structured to ensure maximum compatibility with both CoW Swap and the wide range of assets they support. Backend & Frontend Stack: Frontend: The frontend integrates directly with the CoW Swap widget. We used React for a streamlined user interface, ensuring that users can easily view and interact with token lists to conduct swaps.\nBackend: The backend processes involve loading token metadata dynamically based on the token lists standard. We used Node.js for managing token list updates and API interactions, allowing for real-time updates to token liquidity and pricing.\nPartner Technologies & Benefits: Leveraging CoW Swap's decentralized infrastructure was key to avoiding the need for our own liquidity pools. Instead, we utilized CoW Swap\u2019s solvers to find the best prices across multiple liquidity sources, which helped increase efficiency and reduced the technical overhead of managing our own AMM (automated market maker). CoW Swap\u2019s unique batching system also reduced gas fees, which is a crucial benefit for executing vampire attacks with low-cost trades.",
        "how_its_made": "We built La Vaca Vampiro with a combination of decentralized technology and modular integrations, carefully piecing together several components to create a cohesive tool. CoW Swap Integration: The project revolves around CoW Swap, specifically using their widget (https://widget.cow.fi/) to facilitate decentralized trading. CoW Swap\u2019s infrastructure was ideal for this project because it offers seamless on-chain execution and sophisticated order matching, which helps mitigate slippage. Additionally, the widget configurator allowed us to tailor the swap interface for our targeted token lists, streamlining the process of siphoning liquidity from competing platforms. Token Lists Standard: The project takes full advantage of the token lists standard to dynamically load specific tokens that are part of other protocols\u2019 liquidity pools or vaults. By targeting exotic tokens\u2014such as LP tokens from yield farms or vaults\u2014La Vaca Vampiro can vampire attack projects that have attracted a lot of liquidity into these niche assets. The token lists are structured to ensure maximum compatibility with both CoW Swap and the wide range of assets they support. Backend & Frontend Stack: Frontend: The frontend integrates directly with the CoW Swap widget. We used React for a streamlined user interface, ensuring that users can easily view and interact with token lists to conduct swaps.\nBackend: The backend processes involve loading token metadata dynamically based on the token lists standard. We used Node.js for managing token list updates and API interactions, allowing for real-time updates to token liquidity and pricing.\nPartner Technologies & Benefits: Leveraging CoW Swap's decentralized infrastructure was key to avoiding the need for our own liquidity pools. Instead, we utilized CoW Swap\u2019s solvers to find the best prices across multiple liquidity sources, which helped increase efficiency and reduced the technical overhead of managing our own AMM (automated market maker). CoW Swap\u2019s unique batching system also reduced gas fees, which is a crucial benefit for executing vampire attacks with low-cost trades.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/n5715/screenshots/0no3k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n5715/screenshots/9ii2f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n5715/screenshots/wts0v/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/cowmarketing/cowidget-custom-token-lists/tree/main",
        "link": "https://ethglobal.com/showcase/la-vaca-vampiro-n5715"
    },
    {
        "title": "LendMarket",
        "brief_description": "Marketplace for custom lending and borrowing offerings. It allows user to post, accept, update, repay and reclaim their loan proporsals",
        "long_description": "Marketplace for Custom Lending and Borrowing Offerings Welcome to our innovative Marketplace for Custom Lending and Borrowing, where financial flexibility meets personalized solutions. Our platform connects borrowers and lenders, allowing users to create tailored lending agreements that fit their unique needs and circumstances. Key Features: Customizable Terms: Set your own interest rates, repayment schedules, and loan amounts, ensuring that every agreement suits your financial situation. Diverse Offerings: Explore a wide range of lending options, from personal loans to business financing, catering to various needs and preferences. Secure Transactions: Enjoy peace of mind with our secure payment processing and verification systems, ensuring that both parties are protected throughout the transaction. Community Reviews: Build trust with transparent reviews and ratings from previous users, helping you make informed decisions. User-Friendly Interface: Easily navigate our platform with an intuitive design that streamlines the lending and borrowing process. Join our Marketplace today and experience a new era of financial collaboration\u2014where your lending and borrowing needs are met with flexibility and trust. Whether you\u2019re looking to lend your resources or secure the funds you need, our platform empowers you to take control of your financial journey. This project uses Rainbow wallet connect kit, with MERN stack, and Solidity in smart contract. Smart Contract take the deposit of the collateral, in the meantime of the loan. It facilitates the transfer of funds. It uses gasless creation of listings, whose signature are verified when the listing is accepted. It has Reclaim and Repay functionality for borrower and lender, based on the expiry timeline. This allows users to give riskier loans on memecoins' and earn ton of money in apr as the given collateral and loan tokens are highly risky nature.",
        "how_its_made": "This project uses Rainbow wallet connect kit, with MERN stack, and Solidity in smart contract. Smart Contract take the deposit of the collateral, in the meantime of the loan. It facilitates the transfer of funds. It uses gasless creation of listings, whose signature are verified when the listing is accepted. It has Reclaim and Repay functionality for borrower and lender, based on the expiry timeline. This allows users to give riskier loans on memecoins' and earn ton of money in apr as the given collateral and loan tokens are highly risky nature.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mmqe4/screenshots/1b5je/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mmqe4/screenshots/fmbcj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mmqe4/screenshots/ijwts/default.jpg"
        ],
        "live_demo": "https://lend-market-front-end-eeox.vercel.app/",
        "source_code": "https://github.com/bhavya0911/LendMarket",
        "link": "https://ethglobal.com/showcase/lendmarket-mmqe4"
    },
    {
        "title": "Story Chain",
        "brief_description": "A marketplace where authors publish and own their stories as NFTs. Readers discover, enjoy, and support writers through direct donations. Featuring transparent ownership & ease of publication, StoryChain revolutionizes digital literature content ownership & delivery.",
        "long_description": "StoryChain is an innovative blockchain-powered marketplace that revolutionizes the way authors publish, own, and monetize their literary works while providing readers with a transparent and engaging platform to discover and support their favorite writers.\nAt its core, StoryChain leverages blockchain technology to create a decentralized ecosystem that addresses key challenges in the traditional publishing industry. Each story or book published on the platform is minted as a unique non-fungible token (NFT), establishing clear and indisputable ownership rights for the author. This blockchain-based ownership model ensures that creators retain full control over their intellectual property while providing an immutable record of publication dates and authorship.\nThe platform's user-friendly interface allows authors to easily upload their works, input metadata, and mint their stories as NFTs. To publish, authors pay a gas fee, which not only covers the blockchain transaction costs but also serves as proof of ownership. StoryChain provides clear explanations of these fees and the associated benefits, ensuring authors understand the value of blockchain-based ownership.\nFor readers, StoryChain offers a rich library of diverse content across various genres. The platform's intuitive discovery features, including advanced search functionality and genre-based browsing, make it easy for readers to find new and exciting stories. A seamless reading interface enhances the user experience, allowing readers to immerse themselves in their chosen works.\nOne of StoryChain's standout features is its direct donation mechanism. Readers can support authors they appreciate by making cryptocurrency or traditional currency donations directly through the platform. This system bypasses traditional intermediaries, ensuring that a higher percentage of the contribution reaches the author. The platform provides transparency by displaying donation amounts received by each author, fostering a sense of community and direct support between readers and writers.\nStoryChain takes a proactive approach to protecting intellectual property rights. The platform incorporates a sophisticated plagiarism prevention system that utilizes blockchain timestamps and content hashing. Each new submission is cross-referenced against existing blockchain records, making it virtually impossible for plagiarized content to be published under a different author's name.\nSecurity and transparency are paramount in StoryChain's design. The decentralized nature of blockchain technology ensures high levels of security for both transactions and data storage. All blockchain-related actions, including ownership transfers, donations, and publication records, are easily accessible and verifiable by users, promoting trust and accountability within the community.\nThe platform also features separate dashboards for authors and readers. Authors can track their publications, view real-time analytics on readership and donations, and manage their earnings. Readers can curate their library, manage their donation history, and engage with their favorite authors.\nTo aid user adoption, StoryChain provides comprehensive documentation, including user guides and FAQs that explain blockchain concepts, gas fees, and platform usage in accessible language. This educational aspect helps bridge the gap between traditional publishing and the Web3 ecosystem.\nLooking to the future, StoryChain plans to introduce additional features such as a native token economy to incentivize participation, expanded blockchain integration for faster and cheaper transactions, and enhanced social features to build a thriving community of writers and readers.\nBy combining the security and transparency of blockchain technology with a user-friendly interface and direct support mechanisms, StoryChain aims to empower authors, delight readers, and usher in a new era of digital literature where creativity is fairly rewarded and intellectual property is securely protected. This project uses scaffold-eth as a project template. It was very useful for quickly building out the prototype as it includes hardhat for smart contracts. It also has scripted transferring over ABI. We then worked out the smart contract & used NextJS for the frontend. We use Pinata for IPFS storage.",
        "how_its_made": "This project uses scaffold-eth as a project template. It was very useful for quickly building out the prototype as it includes hardhat for smart contracts. It also has scripted transferring over ABI. We then worked out the smart contract & used NextJS for the frontend. We use Pinata for IPFS storage.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/d4r02/screenshots/ms5zf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d4r02/screenshots/yeszj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d4r02/screenshots/mbspt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d4r02/screenshots/m56bn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d4r02/screenshots/ze3ne/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d4r02/screenshots/1gttk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/khairultruestory/StoryChain",
        "link": "https://ethglobal.com/showcase/story-chain-d4r02"
    },
    {
        "title": "zkBlackjack",
        "brief_description": "zkNoidBlackjack is a trustless, provably fair Blackjack game using Mina Protocol's zkNoid platform. Play anonymously with on-chain proof that cards are dealt fairly!",
        "long_description": "zkNoidBlackjack is a zero-knowledge (ZK) Blackjack game built on Mina Protocol\u2019s zkNoid platform. It leverages ZK proofs to ensure provably fair gameplay without revealing sensitive data. The core benefit is the ability to provide players with cryptographic proof that the deck is shuffled fairly, the cards are dealt correctly, and the odds are not manipulated by the platform\u2014all without exposing the actual card values until the appropriate time. In this game, the fairness of every round is verified, ensuring trustless and tamper-proof execution. Mina Protocol's zkNoid allows this with minimal on-chain data, enabling a lightweight and scalable solution. zkNoidBlackjack offers a transparent, secure, and fair experience where users can confidently play without fear of rigging or unfair practices. zkNoidBlackjack is built using Mina Protocol\u2019s zkNoid platform, which provides a framework for integrating zero-knowledge proofs into decentralized applications. We utilize Mina\u2019s highly efficient blockchain, which ensures that the entire game logic is provably fair through cryptographic proofs, reducing the risk of manipulation.\nHere\u2019s a breakdown of the tech stack:",
        "how_its_made": "zkNoidBlackjack is built using Mina Protocol\u2019s zkNoid platform, which provides a framework for integrating zero-knowledge proofs into decentralized applications. We utilize Mina\u2019s highly efficient blockchain, which ensures that the entire game logic is provably fair through cryptographic proofs, reducing the risk of manipulation.\nHere\u2019s a breakdown of the tech stack:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hjrpn/screenshots/5tbts/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hjrpn/screenshots/oo3aa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hjrpn/screenshots/r7r9o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hjrpn/screenshots/izk82/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/CantonmentCode/zkNoidBlackjack",
        "link": "https://ethglobal.com/showcase/zkblackjack-hjrpn"
    },
    {
        "title": "Product_Attestation",
        "brief_description": "Decentralized Marketplace Verification for Instagram Sellers",
        "long_description": "Problem: Trust issues exist when buying products through social media platforms like Instagram. Buyers are often uncertain about the legitimacy of sellers and the authenticity of products. Solution: Build a decentralized application where Instagram sellers can create verifiable attestations of their products using  \"Sign Protocol\". Buyers can then verify these attestations to ensure they are purchasing from legitimate sellers with authentic products. This project uses sign protocol to attest the product and te seller.\n-Using react for the frontrnd and hardhat to deploy the projec.\n-Using sigh protocol to attest the product and the seller helped gain the buyer trust the authenticity of the product and the product owner(instagram account holder to be particular).",
        "how_its_made": "This project uses sign protocol to attest the product and te seller.\n-Using react for the frontrnd and hardhat to deploy the projec.\n-Using sigh protocol to attest the product and the seller helped gain the buyer trust the authenticity of the product and the product owner(instagram account holder to be particular).",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wig6g/screenshots/54tce/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wig6g/screenshots/hh619/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wig6g/screenshots/cv2g1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/hi-Soumya/ProductAttestation/",
        "link": "https://ethglobal.com/showcase/product-attestation-wig6g"
    },
    {
        "title": "Ollie Cookies",
        "brief_description": "A privacy-preserving Chrome extension that lets users monetize their browsing data. Using World ID for authentication and Oasis Sapphire for secure data handling, it creates a fair marketplace where users earn from their data while buyers access quality information.",
        "long_description": "Ollie Cookies is an innovative Chrome extension that revolutionizes the way internet users interact with their browsing data. Our project addresses the longstanding issue of users giving away valuable data for free, often unknowingly, to large tech companies who profit from it.\nKey features: The process is simple: Ollie Cookies aims to create a more equitable internet ecosystem where users have control over their data and can benefit from its value, while providing businesses with access to high-quality, verified information. Ollie Cookies is built using a combination of cutting-edge technologies to ensure security, privacy, and efficiency: One particularly innovative aspect is our use of Oasis Sapphire's confidential smart contracts. This allows us to perform data aggregation and transactions while keeping individual user data encrypted and private, even from us as the platform operators.\nWe also implemented a custom anonymization process in the Chrome extension, using techniques like URL parsing and user agent hashing to collect meaningful data without compromising user privacy. The integration of World ID not only provides secure authentication but also adds a layer of trust to our marketplace, assuring data buyers of the quality and authenticity of the information they're purchasing. By leveraging these technologies, we've created a secure, efficient, and user-centric platform that reimagines the relationship between internet users and their data.",
        "how_its_made": "Ollie Cookies is built using a combination of cutting-edge technologies to ensure security, privacy, and efficiency: One particularly innovative aspect is our use of Oasis Sapphire's confidential smart contracts. This allows us to perform data aggregation and transactions while keeping individual user data encrypted and private, even from us as the platform operators.\nWe also implemented a custom anonymization process in the Chrome extension, using techniques like URL parsing and user agent hashing to collect meaningful data without compromising user privacy. The integration of World ID not only provides secure authentication but also adds a layer of trust to our marketplace, assuring data buyers of the quality and authenticity of the information they're purchasing. By leveraging these technologies, we've created a secure, efficient, and user-centric platform that reimagines the relationship between internet users and their data.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t632w/screenshots/27e0z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t632w/screenshots/9x8zv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t632w/screenshots/cp7ba/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t632w/screenshots/1g3j1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t632w/screenshots/9fyoz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t632w/screenshots/839j3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/tanhanwei/ollie-data",
        "link": "https://ethglobal.com/showcase/ollie-cookies-t632w"
    },
    {
        "title": "Proof Of Dev",
        "brief_description": "A sybil resistant Web3 Builder reputation protocol.Endorse and get recognized for your on-chain work.",
        "long_description": "Proof of dev is a sybil resistant Web3 Builder reputation protocol. Endorse and get recognized for your on-chain work.\nFeatures:\nSeamless user onbaording using Dynamic wallet integration\nSybil resistance using World ID verification for humaness proofs\nEndorsement attestations using Sign Protocol We have used Worldcoin for Humaness proof verification when onboarding a user on the platform.\nSign protocol is used to attest all the endorsements given by one user to a builder. We have integrated dynamic wallet for easy user onboarding.\nProof of Dev smart contracts handles user registeration after successful humaness proof verification.",
        "how_its_made": "We have used Worldcoin for Humaness proof verification when onboarding a user on the platform.\nSign protocol is used to attest all the endorsements given by one user to a builder. We have integrated dynamic wallet for easy user onboarding.\nProof of Dev smart contracts handles user registeration after successful humaness proof verification.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5pbdh/screenshots/0e29t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5pbdh/screenshots/wmtq2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5pbdh/screenshots/fu6cf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5pbdh/screenshots/i6rjh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5pbdh/screenshots/3f0f4/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xAlphaDevs/proof-of-dev",
        "link": "https://ethglobal.com/showcase/proof-of-dev-5pbdh"
    },
    {
        "title": "Super Loud",
        "brief_description": "Super Loud: A cross-platform Tapp built on ENS NFTs. Chat, connect, and earn tokens across social media, wallets, and marketplaces. Features friend requests, E2E encrypted messaging, and token rewards. Showcasing the power of Tapps: build once, run anywhere!",
        "long_description": "Super Loud is an innovative cross-platform mini-application (Tapp) built on top of ENS name NFTs. It leverages the Tapp framework, combining ERC-7738, ERC-5169, and TokenScript to create a versatile and portable application that can be accessed across multiple platforms without requiring separate installations.\nKey Features: An ENS Tapp: The mini app is linked with ENS NFTs via ERC-7738. Users can easily find the mini app from the 7738 script registration contract.\nFriend Requests: Users can send and receive friend requests to other ENS users. These requests can optionally include ETH attachments, adding a financial dimension to social connections.\nE2E Encrypted Messaging: Once users accept friend requests, they can engage in end-to-end encrypted messaging, ensuring privacy and security in their communications.\nToken Rewards: The app introduces Super Loud Tokens (SLT), which users earn through successful connections and transactions. Each successful friend request grants both parties 100 SLT, incentivizing network growth.\nBase Blockchain Integration: Super Loud utilizes the Base blockchain for efficient, low-cost transactions, enhancing the user experience.\nCross-Platform Accessibility: As a Tapp, Super Loud can be accessed from various platforms, including social media (Twitter, Farcaster), messaging apps (Telegram), smart token viewers, wallet interfaces, and NFT marketplaces. Technical Implementation: The project implements ERC-7738 for permissionless script registry, allowing for decentralized script management and execution.\nERC-5169 is used to make the ENS name NFTs scriptable, enabling the integration of Super Loud functionality.\nTokenScript defines the behavior and interface of Super Loud, registered with the ERC-7738 contract for easy access by wallets and dApps. Token Utility:\nSLT tokens have multiple uses within the ecosystem: Voting rights in protocol decisions\nBuilding reputation within the Super Loud community\nPotential future use for paying for additional services How It Works: ENS users initiate friend requests, optionally attaching ETH.\nRecipients can accept or refuse these requests.\nAccepted requests enable E2E encrypted messaging between parties.\nBoth parties receive 100 SLT for each successful connection.\nIf ETH is included in the request, the protocol takes a 1% fee.\nAdditional SLT are awarded based on the ETH amount: (ETH amount * 3000) * 1000 SLT. Super Loud represents a significant step forward in the integration of ENS names with social and financial applications. By leveraging the Tapp framework, it demonstrates how web3 technologies can create portable, user-centric applications that seamlessly integrate across various platforms. This project not only enhances the utility of ENS names but also showcases the potential for creating rich, interactive experiences in the decentralized web.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/eywc7/screenshots/tjz8e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/eywc7/screenshots/wbos2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/eywc7/screenshots/64s9p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/eywc7/screenshots/t6wsd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/eywc7/screenshots/v57uo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/eywc7/screenshots/a3hvd/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/zhangzhongnan928/Super-Loud-An-ENS-Chat-Tapp",
        "link": "https://ethglobal.com/showcase/super-loud-eywc7"
    },
    {
        "title": "Best Governance App",
        "brief_description": "governance one-stop-shop tool that caters to DAO members, token holders and delegates",
        "long_description": "This governance one-stop-shop tool allows for the aggregation of governance proposals for token holders to view at one glance the proposals that they may be interested in and also the profiles of delegates. With token protocols being viewed as speculative investments, we hope that our project can bring more legitimacy to the DAO governance process. We worked on the front end and back end with javascript and the help of existing resources as well as AI tools, but due to personal reasons, we could not fully implement the infrastructure that we had envisaged. while our project is not meant for any specific DAOs, any DAO that has a focus on DAO governance and engagement of DAO members can choose to be onboarded onto this potential game-changer.",
        "how_its_made": "We worked on the front end and back end with javascript and the help of existing resources as well as AI tools, but due to personal reasons, we could not fully implement the infrastructure that we had envisaged. while our project is not meant for any specific DAOs, any DAO that has a focus on DAO governance and engagement of DAO members can choose to be onboarded onto this potential game-changer.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/j1j09/screenshots/jfn9m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j1j09/screenshots/dpx8f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j1j09/screenshots/q8dzz/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/nicholastan9797/Governance-App",
        "link": "https://ethglobal.com/showcase/best-governance-app-j1j09"
    },
    {
        "title": "Clarity",
        "brief_description": "Clarity is a payment gateway designed to tackle the multibillion-dollar problem of fake reviews by enabling seamless, verifiable on-chain payments and reviews.",
        "long_description": "Store dashboard demo Checkout demo Fake reviews mislead consumers, create unfair competition, erode trust in online platforms, and distort marketplace dynamics, leading to financial and reputational harm for both businesses and customers. Fake reviews are widespread, with estimates suggesting that up to 42% of reviews on major platforms like Amazon could be fake, costing global businesses over $152 billion annually. Consumers are increasingly aware of the issue, with 62% believing they've encountered fake reviews in the past year. Clarity is a highly usable online payment gateway SDK that can be integrated with any online and physical merchant easily. It aims to solve the following issues: Clarity aims to solve the issues of trust between consumers and merchants using payment and review attestations through Sign Protocol and proof of personhood via WorldID. This ensures that every review is created by a real person. Clarity also rewards each user a Clarity token regardless of their Ethereum address. This helps guard against sybils and multi-accounters Review attestations also help build trust in merchants. Additionally, Clarity seamlessly mints an ENS address for merchants, making merchants address easily identifiable by users. Similar to a web 2.0 domain, this makes it familiar for users to pay and trust merchants. Web3 transactions are transparent to users, and anyone can verify the legitimacy of transactions and their corresponding reviews. Shifting payments on-chain would thereby allow users to verify how our review mechanism works, while also allowing merchants to enjoy the benefit of reduced transaction costs on layer 2 networks. Clarity therefore aspires to accelerate the shift to decentralized payments, by being the next-gen payment gateway to onboard web2 users to web3 with superior user experience.. Clarity enables any user to seamlessly create a smart wallet simply by using Google to log in through Dynamic, without needing to know anything about wallets, transactions or gas. The main Clarity manages all cash flow from order payments between customers and merchants while enabling reviews through Sign Protocol\u2019s attestations. To enable the best flexibility and convenience for users, the contract integrates multi-token swaps via OneInchSwapHelper to facilitate payment settlement in different currencies. The Clarity main contract integrates the Sign Protocol to leverage its review schema and custom hook instance (ClaritySPHook) for enhanced attestation capabilities. This integration ensures that reviews are not only verified but also tied to specific users through privacy-preserving methods such as WorldID. We created an SDK for merchants to implement into their own sites. We also built a UI for merchants to view their reviews and other statistics. By leveraging WorldID's incognito actions for private proof of personhood, we ensure that all purchases and reviews are made by real verified users, not bots. WorldID's privacy-preserving proof allows linking multiple ETH addresses to 1 person, enabling accurate collection of loyalty points while preserving privacy. This integration enhances the integrity of our platform and provides greater flexibility for blockchain-based financial services. Additionally, WorldID\u2019s proof of personhood can help combat concert ticket botters by ensuring that 1 worldID user can only buy 1 ticket. Sign protocol\u2019s attestation has the perfect synergy with integrating with WorldID\u2019s proof of personhood enabling us to verify a real person made a transaction. Coupled with the immutability and censorship resistance of public blockchains, Clarity chose SignProtocol to be the default attestation platform for review attestation, efficient data indexing and enabling merchants to leverage on these to issue points, cashback, or bonuses to real persons based on real transactions. All purchases and transactions made by the user are being attested, and all reviews done by the user are being attested. This ensures that reviews can only be made by a user who made a purchase and the review is real on the public blockchain, improving trust amongst merchants and users. Sign Protocol\u2019s instance also enables custom hook integration that enables the flexibility for advanced implementation on top of just a simple attestation feature. Here, Clarity leverages Sign Protocol for review attestations to guarantee immutability and censorship resistance while gelling with WorldID\u2019s humanhood verification to ensure the authenticity and fairness of its native loyalty program based on genuine proactiveness. Thanks to TheGraph Protocol, Clarity has near-instantaneous access to blockchain data through a developer-friendly API. With real-time listening capability, Clarity can track firstly all its cash flow activities (from its main contract), secondly the respective on-chain review attestations from Sign Protocol & thirdly its human hood verification tracking & attestation loyalty point system in an efficient manner without the need for complex infrastructure set-up. With the help of abstracting complex data structures, this not only services for simplifying blockchain data analytics but also ensures that scalability requirements can be effectively met as the amount of data generated increases exponentially. Dynamic is a core integration which allows provides a seamless end-to-end experience. Our users first log in with traditional methods like Gmail etc. We integrated Biconomy\u2019s Account Abstraction SDK which allowed us to bundle multiple transactions together like our approve and pay transactions, allowing a one click checkout process. To take things further, we sponsored all our users\u2019 transactions, removing the need for users to understand anything about gas. All of these combined allow for Web3 transactions with Web2 experiences, something that we think is important to onboard the next 1M users. We utilised 1Inch dev APIs for displaying the price of assets. We also integrated the 1INCH Swap Aggregator V6 on our contracts. This allows users to pay in any token of their choice, while merchants always receive USDC. In the future, we plan to use the 1Inch fusion API, to provide cross-chain swaps as well. We offer merchants a streamlined process to mint their own ENS addresses during registration, providing their customers with user-friendly, memorable nicknames instead of complex addresses. This feature simplifies communication and transactions, making Web3 payments more accessible to mainstream users. Nouns is a fun addition we have for our project, Nouns help our users create fun profile pictures so that they each have a unique profile avatar yet maintain anonymity. We used nouns as a general design system to guide our loading and error states. We utilised account abstraction by integrating Biconomy with Dynamic as explained earlier. This makes it easier for users to deal with the Web3 transactions. We used AWS Lambda for our server and Supabase as the database for our Clarity server. It interacts with our payments smart contracts to facilitate order creation and payment verification. Our servers abstract complexity and act as a payment gateway for merchants who want to integrate our payment solution. It contains built-in protection against duplicate payments, enhancing security for both merchants and customers.",
        "how_its_made": "The main Clarity manages all cash flow from order payments between customers and merchants while enabling reviews through Sign Protocol\u2019s attestations. To enable the best flexibility and convenience for users, the contract integrates multi-token swaps via OneInchSwapHelper to facilitate payment settlement in different currencies. The Clarity main contract integrates the Sign Protocol to leverage its review schema and custom hook instance (ClaritySPHook) for enhanced attestation capabilities. This integration ensures that reviews are not only verified but also tied to specific users through privacy-preserving methods such as WorldID. We created an SDK for merchants to implement into their own sites. We also built a UI for merchants to view their reviews and other statistics. By leveraging WorldID's incognito actions for private proof of personhood, we ensure that all purchases and reviews are made by real verified users, not bots. WorldID's privacy-preserving proof allows linking multiple ETH addresses to 1 person, enabling accurate collection of loyalty points while preserving privacy. This integration enhances the integrity of our platform and provides greater flexibility for blockchain-based financial services. Additionally, WorldID\u2019s proof of personhood can help combat concert ticket botters by ensuring that 1 worldID user can only buy 1 ticket. Sign protocol\u2019s attestation has the perfect synergy with integrating with WorldID\u2019s proof of personhood enabling us to verify a real person made a transaction. Coupled with the immutability and censorship resistance of public blockchains, Clarity chose SignProtocol to be the default attestation platform for review attestation, efficient data indexing and enabling merchants to leverage on these to issue points, cashback, or bonuses to real persons based on real transactions. All purchases and transactions made by the user are being attested, and all reviews done by the user are being attested. This ensures that reviews can only be made by a user who made a purchase and the review is real on the public blockchain, improving trust amongst merchants and users. Sign Protocol\u2019s instance also enables custom hook integration that enables the flexibility for advanced implementation on top of just a simple attestation feature. Here, Clarity leverages Sign Protocol for review attestations to guarantee immutability and censorship resistance while gelling with WorldID\u2019s humanhood verification to ensure the authenticity and fairness of its native loyalty program based on genuine proactiveness. Thanks to TheGraph Protocol, Clarity has near-instantaneous access to blockchain data through a developer-friendly API. With real-time listening capability, Clarity can track firstly all its cash flow activities (from its main contract), secondly the respective on-chain review attestations from Sign Protocol & thirdly its human hood verification tracking & attestation loyalty point system in an efficient manner without the need for complex infrastructure set-up. With the help of abstracting complex data structures, this not only services for simplifying blockchain data analytics but also ensures that scalability requirements can be effectively met as the amount of data generated increases exponentially. Dynamic is a core integration which allows provides a seamless end-to-end experience. Our users first log in with traditional methods like Gmail etc. We integrated Biconomy\u2019s Account Abstraction SDK which allowed us to bundle multiple transactions together like our approve and pay transactions, allowing a one click checkout process. To take things further, we sponsored all our users\u2019 transactions, removing the need for users to understand anything about gas. All of these combined allow for Web3 transactions with Web2 experiences, something that we think is important to onboard the next 1M users. We utilised 1Inch dev APIs for displaying the price of assets. We also integrated the 1INCH Swap Aggregator V6 on our contracts. This allows users to pay in any token of their choice, while merchants always receive USDC. In the future, we plan to use the 1Inch fusion API, to provide cross-chain swaps as well. We offer merchants a streamlined process to mint their own ENS addresses during registration, providing their customers with user-friendly, memorable nicknames instead of complex addresses. This feature simplifies communication and transactions, making Web3 payments more accessible to mainstream users. Nouns is a fun addition we have for our project, Nouns help our users create fun profile pictures so that they each have a unique profile avatar yet maintain anonymity. We used nouns as a general design system to guide our loading and error states. We utilised account abstraction by integrating Biconomy with Dynamic as explained earlier. This makes it easier for users to deal with the Web3 transactions. We used AWS Lambda for our server and Supabase as the database for our Clarity server. It interacts with our payments smart contracts to facilitate order creation and payment verification. Our servers abstract complexity and act as a payment gateway for merchants who want to integrate our payment solution. It contains built-in protection against duplicate payments, enhancing security for both merchants and customers.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/c2us8/screenshots/fmszb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c2us8/screenshots/zg1u2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c2us8/screenshots/dadxi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c2us8/screenshots/m8tf4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c2us8/screenshots/6ek1h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c2us8/screenshots/6b4w2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Royleong31/Clarity",
        "link": "https://ethglobal.com/showcase/clarity-c2us8"
    },
    {
        "title": "TeleWallet",
        "brief_description": "Sign up, login, paying with multiple wallets all in a mini app of Telegram",
        "long_description": "platform for you to manage your ENS domains and seamless multi-chain wallet management system using Telegram's user-friendly interface, Telegram being a very familiar platform in the web3 community has made many beginners such as us ponder, why telegram? What does it have to do with web3? That's why we wanted to a solution for us beginners to have a simple link between Telegram and blockchain. We made a tool to create and manage your ENS identity using Dynamic's multi-chain wallet to connect to. All done in the mini app of Telegram. This project uses next.js as our framework for most of the features while using telegraf for the telegram bot implementation, our libraries include dynamic, ENS, REcaptcha and also MongoDB. These were chosen because the idea of a name to represent our web3 identity really appealing to new users of Web3 and the ease of Dynamic to create a wallets, REcaptcha to authorize against bots and ENS giving a strong sense of Identity made it a clear choice for people entering the blockchain web space.",
        "how_its_made": "This project uses next.js as our framework for most of the features while using telegraf for the telegram bot implementation, our libraries include dynamic, ENS, REcaptcha and also MongoDB. These were chosen because the idea of a name to represent our web3 identity really appealing to new users of Web3 and the ease of Dynamic to create a wallets, REcaptcha to authorize against bots and ENS giving a strong sense of Identity made it a clear choice for people entering the blockchain web space.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wdt8t/screenshots/xqhh5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wdt8t/screenshots/3m41b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wdt8t/screenshots/ma44t/default.jpg"
        ],
        "live_demo": "https://ens-tg-bot.vercel.app",
        "source_code": "https://github.com/lewislee42/ENS-tg-bot",
        "link": "https://ethglobal.com/showcase/telewallet-wdt8t"
    },
    {
        "title": "Hodl Habits",
        "brief_description": "Imagine getting rewarded for building better habits. Meet HODL HABITS. You don\u2019t just set goals\u2014you build greatness. Stake tokens to join, complete your habits, and earn rewards. Slip up, and you lose a little. Top players get extra prizes from sponsors. Ready to level up?",
        "long_description": "Hodl Habits\nis a decentralized application (dApp) built on blockchain technology that gamifies personal development by incentivizing users to build and maintain good habits. Core Concept:\nThe dApp allows users to set up habit challenges that they commit to for a set period, with specific goals they must achieve consistently. Users join these challenges by staking cryptocurrency tokens as a commitment to the challenge. Completing the challenge results in rewards, while failing to meet goals leads to a proportional loss of the staked tokens. Top performers in the challenge can earn additional rewards, including special prizes funded by sponsors. Web3 Integration & Wallet-Based Login:\nThe dApp integrates Web3 wallets, utilizing Worldcoin for seamless identity verification and Dynamic for enhanced functionality. This Web3 framework ensures decentralized, secure, and transparent management of user assets, while giving users privacy and control over their data and transactions. Skin in the Game! How Challenges Work?:\nCreating Challenges: Users can create a habit challenge, specifying key details such as: Challenge Name & Description: A clear purpose for the habit they want to build.\nStart Date and Duration: The challenge runs for a set number of days or weeks.\nSchedule & Repetitions: How often the habit needs to be completed (e.g., daily, every other day, or specific days of the week).\nSkin in the Game! (Stake Amount): A certain amount of cryptocurrency that participants must stake to join the challenge. This creates a financial incentive to stick with the habit.\nJoining Challenges: Other users can browse and join public challenges. Upon joining, they stake the desired token amount and commit to the same schedule and goals. Their progress is tracked within the app, which automatically verifies whether habits are completed or not. Habit Completion & Tracking: The app provides daily reminders based on the user's schedule. Users must check in to mark a habit as completed within a designated window (e.g., 1 hour after the scheduled time). If the user misses this, a proportional amount of their stake is deducted and redistributed to the pool. Penalty for Missing Habits: If a user fails to complete a habit within the specified time frame, a proportional portion of their staked tokens is deducted. This amount is redistributed to the penalty pool and shared among those who successfully complete the challenge, incentivizing consistent performance. Reward System: Users who complete the challenge earn rewards. Rewards are structured in various ways: Full Refund: Users get their entire staked amount back.\nBonus for Consistency: Users with the highest success rate (e.g., 100% completion) may receive a 90% share of the penalties from those who missed habits, the other 10% is destined to the sustainability of Hodl Habits .\nAdditional Token Prizes: Extra rewards may be distributed based on leaderboard rankings or performance tiers. Sponsors use Sign\u2019s attestation flow to verify the winners, ensuring they meet all the requirements and conditions for receiving the prize. Sponsorship Models:\nPerformance-Based: Sponsors may offer rewards to participants who achieve a perfect score or finish in the top percentage.\nRandom Draw: Sponsors can also offer random prizes to participants who complete a certain percentage of the challenge.\nSponsor Dashboard: Sponsors can track the progress of the challenges they fund, get visibility into user engagement, attest the winners with Sign and offer more prizes based on challenge outcomes. Attestation Flow: Step 1: Sponsor Sign-In: The sponsor logs into the platform using their Web3 wallet they used to sponsor the challenge.\nStep 2: Challenge Data Review: The sponsor reviews the winners, which are auto-generated based on the performance tracked by the app\u2019s smart contracts.\nStep 3: Attestation: The sponsor initiates the attestation using Sign, generating a cryptographic proof that validates the winners.\nStep 4: Distribution: After the attestation is completed, the smart contract releases the rewards, ensuring they are distributed fairly based on the verified attestation. Gamification & Social Elements:\nLeaderboards: The app features a leaderboard where users can see how they rank compared to other participants based on their habit completion rate. This promotes friendly competition and further incentivizes users to stay consistent.\nAchievement Badges & Streaks: Users earn badges for hitting milestones (e.g., 7 days in a row, 30 days streaks) or for completing multiple challenges in a row. These badges can boost a user\u2019s profile and be displayed publicly.\nSocial Sharing: Users can share their progress on social media or within the app\u2019s community to motivate others and showcase their accomplishments. Smart Contracts & Automation:\nThe app is powered by smart contracts on the blockchain, ensuring transparency, security, and automation. The smart contract handles:\nToken Staking: Automatically managing the staked tokens for each user and ensuring fairness in the system.\nPenalty Distribution: Automatically deducting tokens from users who miss habits and redistributing them to those who complete their goals.\nReward Payouts: Calculating and distributing rewards to top performers based on their completion rate and sponsor contributions, some rewards require the attestation of the sponsor.\nImmutable Rules: Once a challenge is created, the smart contract locks in the rules, preventing any tampering or changes to the conditions. User Profile & Progress Tracking:\nPersonal Dashboard: Users can track all their active, completed, and upcoming challenges in one place. It shows their overall habit streaks, challenge history, and rewards earned.\nProfile Metrics: The app tracks key stats like total habits completed, success rate, and total tokens earned or lost.\nGoal Setting & Growth: Over time, users can set more challenging goals and track their progress, making the app not just a tool for building habits but also a way to visually see their growth. Community & Long-Term Vision:\nThe app creates a community of like-minded individuals committed to self-improvement, with the added incentive of financial rewards. Users can follow each other, join challenges together, and share tips and motivation.\nFuture Expansion: The app could expand into other wellness categories, like fitness, mental health, or learning, offering tailored habit challenges and specialized sponsor opportunities via influencers and businesses\n. Security & Privacy:\nDecentralization: As a Web3 dApp, the app emphasizes privacy, decentralization, and user control.\nSecure Transactions: All token staking, penalties, and rewards are handled via smart contracts, reducing the risk of fraud or manipulation. Summary:\nIn essence, the Web3  Hodl Habit Crypto Challenges dApp is a next-generation platform for personal development, merging the world of habit-building with decentralized finance (DeFi). Users are incentivized to improve themselves through a staking model that rewards consistency and success, while introducing a fun and engaging element through gamification, social features, and sponsor-backed rewards. It\u2019s a unique combination of self-improvement, accountability, and the power of blockchain to create a decentralized ecosystem where building better habits leads to tangible rewards. Partner technologies\nLogin in with\nDynamic\n:\nDynamic simplified complex wallet interactions and user profile management, giving users more control and flexibility while interacting with their Web3 assets. This enhanced the overall UX, making Web3 technology accessible to less tech-savvy users. Login in with\nWorld Coin\n:\nWorldcoin provided a reliable way to verify that participants are real, unique individuals. This was essential for both preventing fraud and making sponsors feel comfortable backing the project. By ensuring users aren\u2019t using multiple wallets to game the system, the app fosters a genuine community. In a future update, not only sponsors will attest winners, users will also attest other users only if they are identified via World Coin. Sign Protocol: The attestation process is seamlessly integrated with the smart contracts, ensuring that reward payouts are only triggered once attestation is complete. The Sign protocol added a critical layer of trust to the sponsor interactions. The ability to attest winners before distributing rewards makes sponsors feel secure in knowing that they are supporting legitimate participants who\u2019ve met the challenge goals. Automated Stake Adjustment\n:\nA smart contract feature was implemented that dynamically adjusts user stakes based on their performance. If users consistently meet their habits, they can increase their stake and potential reward mid-challenge, providing extra motivation to maintain streaks.",
        "how_its_made": "Partner technologies\nLogin in with\nDynamic\n:\nDynamic simplified complex wallet interactions and user profile management, giving users more control and flexibility while interacting with their Web3 assets. This enhanced the overall UX, making Web3 technology accessible to less tech-savvy users. Login in with\nWorld Coin\n:\nWorldcoin provided a reliable way to verify that participants are real, unique individuals. This was essential for both preventing fraud and making sponsors feel comfortable backing the project. By ensuring users aren\u2019t using multiple wallets to game the system, the app fosters a genuine community. In a future update, not only sponsors will attest winners, users will also attest other users only if they are identified via World Coin. Sign Protocol: The attestation process is seamlessly integrated with the smart contracts, ensuring that reward payouts are only triggered once attestation is complete. The Sign protocol added a critical layer of trust to the sponsor interactions. The ability to attest winners before distributing rewards makes sponsors feel secure in knowing that they are supporting legitimate participants who\u2019ve met the challenge goals. Automated Stake Adjustment\n:\nA smart contract feature was implemented that dynamically adjusts user stakes based on their performance. If users consistently meet their habits, they can increase their stake and potential reward mid-challenge, providing extra motivation to maintain streaks.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fcqti/screenshots/qzgao/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fcqti/screenshots/7pghg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fcqti/screenshots/x7v2z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fcqti/screenshots/n29q9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fcqti/screenshots/h3afc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fcqti/screenshots/pubst/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/apps-camelot/HodlHabits",
        "link": "https://ethglobal.com/showcase/hodl-habits-fcqti"
    },
    {
        "title": "Hodl Habits",
        "brief_description": "Imagine getting rewarded for building better habits. Meet HODL HABITS. You don\u2019t just set goals\u2014you build greatness. Stake tokens to join, complete your habits, and earn rewards. Slip up, and you lose a little. Top players get extra prizes from sponsors. Ready to level up?",
        "long_description": "Hodl Habits\nis a decentralized application (dApp) built on blockchain technology that gamifies personal development by incentivizing users to build and maintain good habits. Core Concept:\nThe dApp allows users to set up habit challenges that they commit to for a set period, with specific goals they must achieve consistently. Users join these challenges by staking cryptocurrency tokens as a commitment to the challenge. Completing the challenge results in rewards, while failing to meet goals leads to a proportional loss of the staked tokens. Top performers in the challenge can earn additional rewards, including special prizes funded by sponsors. Web3 Integration & Wallet-Based Login:\nThe dApp integrates Web3 wallets, utilizing Worldcoin for seamless identity verification and Dynamic for enhanced functionality. This Web3 framework ensures decentralized, secure, and transparent management of user assets, while giving users privacy and control over their data and transactions. Skin in the Game! How Challenges Work?:\nCreating Challenges: Users can create a habit challenge, specifying key details such as: Challenge Name & Description: A clear purpose for the habit they want to build.\nStart Date and Duration: The challenge runs for a set number of days or weeks.\nSchedule & Repetitions: How often the habit needs to be completed (e.g., daily, every other day, or specific days of the week).\nSkin in the Game! (Stake Amount): A certain amount of cryptocurrency that participants must stake to join the challenge. This creates a financial incentive to stick with the habit.\nJoining Challenges: Other users can browse and join public challenges. Upon joining, they stake the desired token amount and commit to the same schedule and goals. Their progress is tracked within the app, which automatically verifies whether habits are completed or not. Habit Completion & Tracking: The app provides daily reminders based on the user's schedule. Users must check in to mark a habit as completed within a designated window (e.g., 1 hour after the scheduled time). If the user misses this, a proportional amount of their stake is deducted and redistributed to the pool. Penalty for Missing Habits: If a user fails to complete a habit within the specified time frame, a proportional portion of their staked tokens is deducted. This amount is redistributed to the penalty pool and shared among those who successfully complete the challenge, incentivizing consistent performance. Reward System: Users who complete the challenge earn rewards. Rewards are structured in various ways: Full Refund: Users get their entire staked amount back.\nBonus for Consistency: Users with the highest success rate (e.g., 100% completion) may receive a 90% share of the penalties from those who missed habits, the other 10% is destined to the sustainability of Hodl Habits .\nAdditional Token Prizes: Extra rewards may be distributed based on leaderboard rankings or performance tiers. Sponsors use Sign\u2019s attestation flow to verify the winners, ensuring they meet all the requirements and conditions for receiving the prize. Sponsorship Models:\nPerformance-Based: Sponsors may offer rewards to participants who achieve a perfect score or finish in the top percentage.\nRandom Draw: Sponsors can also offer random prizes to participants who complete a certain percentage of the challenge.\nSponsor Dashboard: Sponsors can track the progress of the challenges they fund, get visibility into user engagement, attest the winners with Sign and offer more prizes based on challenge outcomes. Attestation Flow: Step 1: Sponsor Sign-In: The sponsor logs into the platform using their Web3 wallet they used to sponsor the challenge.\nStep 2: Challenge Data Review: The sponsor reviews the winners, which are auto-generated based on the performance tracked by the app\u2019s smart contracts.\nStep 3: Attestation: The sponsor initiates the attestation using Sign, generating a cryptographic proof that validates the winners.\nStep 4: Distribution: After the attestation is completed, the smart contract releases the rewards, ensuring they are distributed fairly based on the verified attestation. Gamification & Social Elements:\nLeaderboards: The app features a leaderboard where users can see how they rank compared to other participants based on their habit completion rate. This promotes friendly competition and further incentivizes users to stay consistent.\nAchievement Badges & Streaks: Users earn badges for hitting milestones (e.g., 7 days in a row, 30 days streaks) or for completing multiple challenges in a row. These badges can boost a user\u2019s profile and be displayed publicly.\nSocial Sharing: Users can share their progress on social media or within the app\u2019s community to motivate others and showcase their accomplishments. Smart Contracts & Automation:\nThe app is powered by smart contracts on the blockchain, ensuring transparency, security, and automation. The smart contract handles:\nToken Staking: Automatically managing the staked tokens for each user and ensuring fairness in the system.\nPenalty Distribution: Automatically deducting tokens from users who miss habits and redistributing them to those who complete their goals.\nReward Payouts: Calculating and distributing rewards to top performers based on their completion rate and sponsor contributions, some rewards require the attestation of the sponsor.\nImmutable Rules: Once a challenge is created, the smart contract locks in the rules, preventing any tampering or changes to the conditions. User Profile & Progress Tracking:\nPersonal Dashboard: Users can track all their active, completed, and upcoming challenges in one place. It shows their overall habit streaks, challenge history, and rewards earned.\nProfile Metrics: The app tracks key stats like total habits completed, success rate, and total tokens earned or lost.\nGoal Setting & Growth: Over time, users can set more challenging goals and track their progress, making the app not just a tool for building habits but also a way to visually see their growth. Community & Long-Term Vision:\nThe app creates a community of like-minded individuals committed to self-improvement, with the added incentive of financial rewards. Users can follow each other, join challenges together, and share tips and motivation.\nFuture Expansion: The app could expand into other wellness categories, like fitness, mental health, or learning, offering tailored habit challenges and specialized sponsor opportunities via influencers and businesses\n. Security & Privacy:\nDecentralization: As a Web3 dApp, the app emphasizes privacy, decentralization, and user control.\nSecure Transactions: All token staking, penalties, and rewards are handled via smart contracts, reducing the risk of fraud or manipulation. Summary:\nIn essence, the Web3  Hodl Habit Crypto Challenges dApp is a next-generation platform for personal development, merging the world of habit-building with decentralized finance (DeFi). Users are incentivized to improve themselves through a staking model that rewards consistency and success, while introducing a fun and engaging element through gamification, social features, and sponsor-backed rewards. It\u2019s a unique combination of self-improvement, accountability, and the power of blockchain to create a decentralized ecosystem where building better habits leads to tangible rewards. Partner technologies\nLogin in with\nDynamic\n:\nDynamic simplified complex wallet interactions and user profile management, giving users more control and flexibility while interacting with their Web3 assets. This enhanced the overall UX, making Web3 technology accessible to less tech-savvy users. Login in with\nWorld Coin\n:\nWorldcoin provided a reliable way to verify that participants are real, unique individuals. This was essential for both preventing fraud and making sponsors feel comfortable backing the project. By ensuring users aren\u2019t using multiple wallets to game the system, the app fosters a genuine community. In a future update, not only sponsors will attest winners, users will also attest other users only if they are identified via World Coin. Sign Protocol: The attestation process is seamlessly integrated with the smart contracts, ensuring that reward payouts are only triggered once attestation is complete. The Sign protocol added a critical layer of trust to the sponsor interactions. The ability to attest winners before distributing rewards makes sponsors feel secure in knowing that they are supporting legitimate participants who\u2019ve met the challenge goals. Automated Stake Adjustment\n:\nA smart contract feature was implemented that dynamically adjusts user stakes based on their performance. If users consistently meet their habits, they can increase their stake and potential reward mid-challenge, providing extra motivation to maintain streaks.",
        "how_its_made": "Partner technologies\nLogin in with\nDynamic\n:\nDynamic simplified complex wallet interactions and user profile management, giving users more control and flexibility while interacting with their Web3 assets. This enhanced the overall UX, making Web3 technology accessible to less tech-savvy users. Login in with\nWorld Coin\n:\nWorldcoin provided a reliable way to verify that participants are real, unique individuals. This was essential for both preventing fraud and making sponsors feel comfortable backing the project. By ensuring users aren\u2019t using multiple wallets to game the system, the app fosters a genuine community. In a future update, not only sponsors will attest winners, users will also attest other users only if they are identified via World Coin. Sign Protocol: The attestation process is seamlessly integrated with the smart contracts, ensuring that reward payouts are only triggered once attestation is complete. The Sign protocol added a critical layer of trust to the sponsor interactions. The ability to attest winners before distributing rewards makes sponsors feel secure in knowing that they are supporting legitimate participants who\u2019ve met the challenge goals. Automated Stake Adjustment\n:\nA smart contract feature was implemented that dynamically adjusts user stakes based on their performance. If users consistently meet their habits, they can increase their stake and potential reward mid-challenge, providing extra motivation to maintain streaks.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fcqti/screenshots/qzgao/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fcqti/screenshots/7pghg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fcqti/screenshots/x7v2z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fcqti/screenshots/n29q9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fcqti/screenshots/h3afc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fcqti/screenshots/pubst/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/apps-camelot/HodlHabits",
        "link": "https://ethglobal.com/showcase/hodl-habits-fcqti"
    },
    {
        "title": "Inspector AI",
        "brief_description": "Inspector AI: A Chrome extension that analyzes smart contracts to make the web3 a more secure and user-friendly place using the power of AI and builder community. It provides risk assessments, integrates market data, and includes community reviews.",
        "long_description": "Inspector AI is a tool designed to improve security and understanding in decentralized finance (DeFi). We've created a Chrome extension that helps users assess the risks of smart contracts before interacting with them. Key Features: User Flow: Background Process: Viewing Results: Users see a summary of the AI's findings, including: Adding Reviews: Users can contribute their own reviews: Receiving Rewards: After submitting a review, users receive a unique NounsDAO character as a reward.\nExploring Further: Users can access a detailed contract analysis page on the web app for more comprehensive information. Inspector AI aims to make DeFi more accessible and secure. By combining AI technology with community insights, we help users make more informed decisions about their investments. Our goal is to create a tool that's useful for both experienced DeFi users and newcomers, contributing to a safer and more transparent blockchain ecosystem. Inspector AI is a multi-chain smart contract analyzer enhancing DeFi security across various blockchains. Our integration with Rootstock provides risk assessments and market data analysis on Bitcoin's layer 2, expanding our reach to Bitcoin-based DeFi applications. We leverage Morph's optimistic zkEVM for real-time, AI-powered smart contract analysis on Ethereum Layer 2, taking advantage of its fast transaction speeds. Similarly, our deployment on Linea's high-performance zkEVM rollup enables efficient and cost-effective analysis for Ethereum-compatible chains. Chainlink's CCIP is crucial for our cross-chain functionality, enabling omnichain reviews and analysis. This allows users to access comprehensive contract assessments aggregated from different blockchains. To enhance user trust and engagement, we've integrated several identity and security features. Worldcoin's World ID prevents Sybil attacks in our review system. We highlight reviews from Ledger hardware wallet users, promoting security best practices. ENS integration improves user experience by replacing complex addresses with human-readable names. Our AI model, fine-tuned on recent vulnerability data, is powered by market data from 1inch's Developer Portal APIs. This combination allows us to provide accurate and up-to-date risk assessments. The model, developed using GaiaNet's ERC20 vulnerability AI (based on LLAMA 3.1), runs efficiently on consumer hardware and integrates seamlessly with our Chrome extension.\nTo make the review process more engaging, we use Cloud Nouns' API to generate visually appealing attestation graphics. This enhances user experience and promotes transparency in the Web3 ecosystem. We've integrated the Sign protocol to generate blockchain attestations for user reviews, adding an extra layer of credibility and permanence to community feedback.\nOur platform is built with MetaMask compatibility, ensuring seamless wallet connection and interaction for users. Lastly, we've developed tools using Hedera's Smart Contract Service and Consensus Service, streamlining the development and deployment processes for projects on the Hedera network.\nBy integrating these diverse technologies, Inspector AI offers a comprehensive, secure, and user-friendly platform for smart contract analysis across multiple blockchains, addressing real-world security concerns in the evolving DeFi landscape.",
        "how_its_made": "Inspector AI is a multi-chain smart contract analyzer enhancing DeFi security across various blockchains. Our integration with Rootstock provides risk assessments and market data analysis on Bitcoin's layer 2, expanding our reach to Bitcoin-based DeFi applications. We leverage Morph's optimistic zkEVM for real-time, AI-powered smart contract analysis on Ethereum Layer 2, taking advantage of its fast transaction speeds. Similarly, our deployment on Linea's high-performance zkEVM rollup enables efficient and cost-effective analysis for Ethereum-compatible chains. Chainlink's CCIP is crucial for our cross-chain functionality, enabling omnichain reviews and analysis. This allows users to access comprehensive contract assessments aggregated from different blockchains. To enhance user trust and engagement, we've integrated several identity and security features. Worldcoin's World ID prevents Sybil attacks in our review system. We highlight reviews from Ledger hardware wallet users, promoting security best practices. ENS integration improves user experience by replacing complex addresses with human-readable names. Our AI model, fine-tuned on recent vulnerability data, is powered by market data from 1inch's Developer Portal APIs. This combination allows us to provide accurate and up-to-date risk assessments. The model, developed using GaiaNet's ERC20 vulnerability AI (based on LLAMA 3.1), runs efficiently on consumer hardware and integrates seamlessly with our Chrome extension.\nTo make the review process more engaging, we use Cloud Nouns' API to generate visually appealing attestation graphics. This enhances user experience and promotes transparency in the Web3 ecosystem. We've integrated the Sign protocol to generate blockchain attestations for user reviews, adding an extra layer of credibility and permanence to community feedback.\nOur platform is built with MetaMask compatibility, ensuring seamless wallet connection and interaction for users. Lastly, we've developed tools using Hedera's Smart Contract Service and Consensus Service, streamlining the development and deployment processes for projects on the Hedera network.\nBy integrating these diverse technologies, Inspector AI offers a comprehensive, secure, and user-friendly platform for smart contract analysis across multiple blockchains, addressing real-world security concerns in the evolving DeFi landscape.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/s5mw5/screenshots/ybm82/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s5mw5/screenshots/fs20o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s5mw5/screenshots/yfnhg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s5mw5/screenshots/7w95v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s5mw5/screenshots/2jiy5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s5mw5/screenshots/p3ivx/default.jpg"
        ],
        "live_demo": "https://inspector-ai-wine.vercel.app/",
        "source_code": "https://github.com/Krane-Apps/inspector-ai-eth-singapore-2024",
        "link": "https://ethglobal.com/showcase/inspector-ai-s5mw5"
    },
    {
        "title": "FortunaPool",
        "brief_description": "A decentralized stablecoin application utilizing Worldcoin for identity verification and Flow blockchain for verifiable random number generation, allowing users to securely deposit USDC, invest in DeFi opportunities, and receive fair and transparent rewards.",
        "long_description": "This decentralized stablecoin application leverages cutting-edge technologies like Worldcoin and the Flow blockchain to provide a secure, transparent, and fair way for users to deposit USDC (stablecoin), participate in decentralized finance (DeFi) investment opportunities, and receive rewards. World ID Integration: A key feature of the system is the integration with Worldcoin, which ensures robust identity verification and prevents Sybil attacks. Verified users benefit from gas subsidies, reducing transaction costs and enhancing the overall user experience. This identity verification layer guarantees that only legitimate users can participate, increasing trust in the reward distribution process. Random Number Generator (Flow-based RNG): The application uses a Flow-based random number generator (RNG) to ensure fairness and transparency in reward distribution. By leveraging the Flow blockchain, the system generates verifiable randomness, making prize outcomes impossible to manipulate. The integration with Flow ensures that reward distribution is decentralized and tamper-proof, adding an additional layer of security. Stablecoin Vault: Users deposit USDC into a secure vault managed by a smart contract. Over time, the deposited stablecoins generate yield through decentralized investments managed by the integrated smart contract. The system operates on the ERC4626 tokenized asset standard, ensuring security and compatibility with DeFi protocols. Investment Management: The deposited USDC stablecoins are invested in DeFi opportunities, generating yield that is distributed back to users as rewards. The vault operates on the ERC4626 standard, ensuring secure management of funds and fair distribution of yield among participants. The system\u2019s backend is built using Solidity smart contracts for investment management, reward distribution, and identity verification, creating a seamless, secure, and transparent user experience. This project leverages several technologies to build a robust and secure decentralized prize vault system. Random Number Generator (Flow-based RNG): The random number generator is based on the Flow blockchain, where randomness is securely and verifiably generated. The prize distribution and the core logic revolve around the Flow ecosystem, ensuring a decentralized, transparent, and fair reward system. This integration with Flow ensures that the RNG cannot be manipulated and adds an additional layer of trust and security. API Integration (Worldcoin API): We integrated the Worldcoin API for identity verification. Through this API, users\u2019 identities are verified, ensuring that only legitimate users can participate and receive rewards. Additionally, the Worldcoin integration provides gas subsidies, reducing transaction costs for users. Backend (Golang): The backend is implemented using Golang, chosen for its efficiency in handling concurrent operations and speed. Golang enables us to handle smart contract interactions and cryptographic operations efficiently, ensuring the prize vault runs smoothly and securely. Smart Contracts (Solidity): The core smart contracts are developed in Solidity, managing investment flows, random number generation, and reward distribution. These contracts are deployed on Ethereum, and the prize vault adheres to the ERC4626 standard for tokenized vaults, ensuring seamless interaction with DeFi protocols. Prize Pool Logic: The prize pool consists of first, second, and third prizes, where the amount of rewards and the number of winners dynamically change based on the total number of participants and the amount deposited. As long as participants deposit the required amount of USDC to qualify, they are guaranteed to win a prize. The reward distribution is not directly tied to the individual amount deposited, meaning every qualified participant receives a reward. Metamask Wallet Integration: Users interact with the prize vault through the Metamask browser wallet. Metamask provides a secure and user-friendly way to manage cryptocurrency and facilitates deposits and withdrawals of USDC. Frontend (React + MobX): The frontend is designed using React for its flexibility and component-based architecture. We used MobX for state management to ensure a responsive and intuitive user experience. The UI allows users to deposit USDC, view their investment status, and track their potential rewards in real-time.",
        "how_its_made": "This project leverages several technologies to build a robust and secure decentralized prize vault system. Random Number Generator (Flow-based RNG): The random number generator is based on the Flow blockchain, where randomness is securely and verifiably generated. The prize distribution and the core logic revolve around the Flow ecosystem, ensuring a decentralized, transparent, and fair reward system. This integration with Flow ensures that the RNG cannot be manipulated and adds an additional layer of trust and security. API Integration (Worldcoin API): We integrated the Worldcoin API for identity verification. Through this API, users\u2019 identities are verified, ensuring that only legitimate users can participate and receive rewards. Additionally, the Worldcoin integration provides gas subsidies, reducing transaction costs for users. Backend (Golang): The backend is implemented using Golang, chosen for its efficiency in handling concurrent operations and speed. Golang enables us to handle smart contract interactions and cryptographic operations efficiently, ensuring the prize vault runs smoothly and securely. Smart Contracts (Solidity): The core smart contracts are developed in Solidity, managing investment flows, random number generation, and reward distribution. These contracts are deployed on Ethereum, and the prize vault adheres to the ERC4626 standard for tokenized vaults, ensuring seamless interaction with DeFi protocols. Prize Pool Logic: The prize pool consists of first, second, and third prizes, where the amount of rewards and the number of winners dynamically change based on the total number of participants and the amount deposited. As long as participants deposit the required amount of USDC to qualify, they are guaranteed to win a prize. The reward distribution is not directly tied to the individual amount deposited, meaning every qualified participant receives a reward. Metamask Wallet Integration: Users interact with the prize vault through the Metamask browser wallet. Metamask provides a secure and user-friendly way to manage cryptocurrency and facilitates deposits and withdrawals of USDC. Frontend (React + MobX): The frontend is designed using React for its flexibility and component-based architecture. We used MobX for state management to ensure a responsive and intuitive user experience. The UI allows users to deposit USDC, view their investment status, and track their potential rewards in real-time.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/eq80j/screenshots/ctpfg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/eq80j/screenshots/tvda2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/eq80j/screenshots/vrfuu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/lanigon/ETH_Global",
        "link": "https://ethglobal.com/showcase/fortunapool-eq80j"
    },
    {
        "title": "C10N",
        "brief_description": "c10n revolutionizes payroll by harnessing Web3 tech, offering instant, secure payments via Stablecoins and multi-chain solutions. ENS and stealth accounts ensure a seamless and private payroll experience.",
        "long_description": "In many industries, payroll constitutes a significant portion of total operating expenses (PTOE), reaching as high as 70% in sectors like science and technology services, hospitality, insurance, and healthcare. Even in industries with lower PTOE, such as construction, manufacturing, restaurants, and retail, payroll still accounts for 10-20% of operational costs. Managing the high volume of payroll transactions and money movement is crucial for business efficiency. Existing Issues in the Payroll Industry: Incorrect Banking Information Causing Delays\nOne of the recurring challenges in payroll processing arises when employees provide incorrect banking details. The diversity of global banking standards (such as SWIFT codes, routing numbers, and bank codes) further complicates this. Payroll teams must dedicate significant time to data cleaning and validation, and during this process, mistakes may occur. These errors inevitably cause payment delays, disrupting employee trust. Inefficient Cross-Border Payments\nThe current payment infrastructure is especially slow for cross-border transactions, affecting expatriates and employees working on overseas projects. The traditional payment chain involving remitter banks, intermediary banks, and beneficiary banks introduces multiple layers of delay. For example, offshore workers on oil rigs often list family members as beneficiaries, making it difficult for employers to ensure timely salary disbursements. In many cases, families are forced to reach out to employers, creating additional friction. Trust Account Setup with Traditional Banks\nPayroll providers often face delays when setting up trust accounts for employers. The process with traditional banks can be time-consuming, with additional costs incurred for account maintenance. This delay hinders payroll providers from quickly moving money, causing further complications in the payroll cycle. Manual Payment Proof Requests\nEmployees frequently need to request proof of payment from employers, as they lack real-time visibility into whether their net salary has been credited. The manual process of verifying and communicating payment status leads to inefficiencies and wastes time for both employers and payroll processors. This delay in communication erodes trust between employees and employers, as employees are left uncertain about when or if they\u2019ve been paid. Our solution C10N (Short ofCompensatioN) leverages Web3 technology to disburse payments via Stablecoin, enhancing transparency for individuals while maintaining the privacy and confidentiality of sensitive payroll data. This approach ensures that businesses can offer secure, seamless, and private payroll experiences, without compromising on clarity or trust. Industry Value Our Solution Brings to Traditional Payroll: Faster and More Efficient Payments\nOur solution leverages Stablecoins and multi-chain technology to enable near-instant payroll processing, eliminating delays in cross-border payments. This makes it easier for businesses to offer flexible payroll cycles, improving employee satisfaction. Incentives for Payroll Providers\nJust like traditional banks offer overnight interest for large payroll sums, Stablecoin issuers can provide similar perks. Payroll providers can benefit financially from parking large sums temporarily, incentivizing the adoption of Stablecoins for payroll disbursements. Expanding Web3 and Multi-Chain Use Cases\nUsing Near chain abstraction, our solution enhances cross-chain capabilities and identity management, making blockchain payroll more versatile and globally scalable. This also broadens the use case for Web3 applications within traditional payroll. Transparency with Privacy\nThrough stealth accounts, employees can track payments on the blockchain in real-time without compromising their privacy. This increases trust while maintaining confidentiality, a critical factor in payroll operations. Cost Savings and Global Scalability\nBy eliminating the need for costly trust accounts and intermediaries, our solution reduces operational costs and speeds up payroll for large, multinational businesses. The use of Stablecoins makes payroll more affordable, while the multi-chain capability ensures seamless global transactions. To support multi chain transfer support and to ease control without switching chains, we use Near account abstraction flow to generate EVM transaction signature with MPC contract in Near\nThis way, we can offer flexibility to the employee on the L2 chains that they would prefer to receive their USDC payments\nAnd we send the compensation package to generated stealth addresses of the employee from the stored meta address URI for the employee to retain privacy of sensitive compensation information",
        "how_its_made": "To support multi chain transfer support and to ease control without switching chains, we use Near account abstraction flow to generate EVM transaction signature with MPC contract in Near\nThis way, we can offer flexibility to the employee on the L2 chains that they would prefer to receive their USDC payments\nAnd we send the compensation package to generated stealth addresses of the employee from the stored meta address URI for the employee to retain privacy of sensitive compensation information",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5ifrr/screenshots/xzkb7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5ifrr/screenshots/7z9sh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5ifrr/screenshots/ry250/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5ifrr/screenshots/wp8f2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/majin-land/c10n",
        "link": "https://ethglobal.com/showcase/c10n-5ifrr"
    },
    {
        "title": "FHE dark forest",
        "brief_description": "Dark forest game built with FHE. Use FHE to simulate the universe to verify operations while reveal nothing about the information",
        "long_description": "Special FHE Attributes Utilized Encrypted Coordinates: Secure Distance Calculations: Hidden State Updates: Encrypted Comparisons: Selective Disclosure: Homomorphic Operations:",
        "how_its_made": "Special FHE Attributes Utilized Encrypted Coordinates: Secure Distance Calculations: Hidden State Updates: Encrypted Comparisons: Selective Disclosure: Homomorphic Operations:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mhfak/screenshots/kubij/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mhfak/screenshots/go2ab/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mhfak/screenshots/d9c3z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mhfak/screenshots/kvoue/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/hcheng826/fhenix-dark-forest",
        "link": "https://ethglobal.com/showcase/fhe-dark-forest-mhfak"
    },
    {
        "title": "Angpao.money",
        "brief_description": "Angpao.money is a magic-link utility to make receiving crypto as intuitive as handing over cash in an envelope.  Absolute zero dependency: install nothing and gas-free, Angpao.money hyper-charge onboarding by bridging the UX gap, making every transfer fun, personal and memorable.",
        "long_description": "\"Simplicity is the ultimate sophistication.\" -- Leonardo da Vinci Angpao.money is a simple yet powerful utility that creates magic links, allowing everyone, anyone to receive crypto effortlessly. Here\u2019s how it works: Sender: Deposit -> Personalize -> Share\n1.\u2060 The sender deposits the assets into a smart contract.\n2.\u2060 The sender personalizes the envelope.\n3.\u2060 The sender obtains a link, which would be shared to the recipient. Recipient: Access -> Connect -> Receive\n1.\u2060 The recipient accesses the link.\n2.\u2060 The recipient can either connect an existing wallet or create a new one via social login.\n3.\u2060 The recipient signs to receive the asset without paying gas fees. Angpao.money is three things:\n1.\u2060 The most accessible onboarding solution.\n2.\u2060 The most intuitive UX pattern to boost crypto adoption.\n3.\u2060 A personalized crypto transfer experience that fosters emotional connection. As an onboarding solution, Angpao.money differentiates itself by being the most accessible: come with nothing, install nothing, just click the link. With zero dependencies, users can claim their first ETH in seconds, 10x the time taken to get onboard. As a concept, Angpao.money is intuitive. The notion of passing money in an envelop is native to humanity, unlike copy-pasting wallet address. Angpao.money accelerate crypto adoption by building on top of this universal pattern, for it is the natural way of how things works in life. As an experience, Angpao.money adds emotional connection to each transfer. People stay when they feel a connection, and Angpao.money makes every transfer not \"only a transfer\u201d\u2014it becomes a memorable and positive experience. Through customizable envelope designs and personalized messages, each transfer carries not only economic but also sentimental value. Additionally, all senders receive a free ENS subdomain, allowing recipients to see a human-friendly name instead of a cold hexadecimal address. Angpao.money is made possible by technologies from ENS, The Graph, Worldcoin, Reown, Nouns Dao. Built with simplicity in mind, now everyone and anyone can receive crypto with Angpao.money. The core Angpao.money is composed of 2 process: Creating Angpao\nComponents: The Graph Substream, Application Database\nIn this stage, user\u2019s Angpao configuration will be save into Application Database with draft status. After the user signs a transaction with Angpao Creator to deposit assets into contract, we wait for Substream to update the entry\u2019s status. Once the entry has been updated to active status, the link is returned to the user at the website. Claiming Angpao (Gasless)\nComponents:  The Graph Substream, Application Database, Server Backend\nIn this stage, the Recipient that visit the Angpao.money link will be prompted sign a message to prove authenticity. Then, the signature is sent to the Backend to be verified. Upon successful verification, the backend triggers a transfer into the recipient\u2019s address. Similarly, we use the Graph Substream to monitor the transaction status and update the App Database\u2019s entry to prevent double claims. Other components:",
        "how_its_made": "The core Angpao.money is composed of 2 process: Creating Angpao\nComponents: The Graph Substream, Application Database\nIn this stage, user\u2019s Angpao configuration will be save into Application Database with draft status. After the user signs a transaction with Angpao Creator to deposit assets into contract, we wait for Substream to update the entry\u2019s status. Once the entry has been updated to active status, the link is returned to the user at the website. Claiming Angpao (Gasless)\nComponents:  The Graph Substream, Application Database, Server Backend\nIn this stage, the Recipient that visit the Angpao.money link will be prompted sign a message to prove authenticity. Then, the signature is sent to the Backend to be verified. Upon successful verification, the backend triggers a transfer into the recipient\u2019s address. Similarly, we use the Graph Substream to monitor the transaction status and update the App Database\u2019s entry to prevent double claims. Other components:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1mn7c/screenshots/cgzo9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1mn7c/screenshots/k02dy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1mn7c/screenshots/8pit6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1mn7c/screenshots/swqs7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1mn7c/screenshots/1mit3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1mn7c/screenshots/eb1wj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/angpow-money/angpow",
        "link": "https://ethglobal.com/showcase/angpao-money-1mn7c"
    },
    {
        "title": "StealthTradeDAO",
        "brief_description": "Empowering the Future of Perpetual Markets with Unmatched Trust, Transparent Solvency Proofs, and Decentralized Governance. Harnessing the Power of Cross-Chain Technology to Redefine Trading, Ensure Privacy, and Restore Confidence in a Truly Open and Secure Financial Ecosystem.",
        "long_description": "The cumulative trading volume of perpetual contracts since 2020 has surpassed $60 trillion, which is much higher than the trading volume of the underlying cryptocurrencies and conventional futures contracts Read More.\nFor A primer on how perpetual contracts work and what is option trading please look into this The Problems\nOpen Order Books: Challenges in Perpetual Markets\nPerpetual markets with open order books provide transparency, but they also come with significant challenges: Front Running: Traders can exploit the visibility of pending orders, executing trades before others, taking advantage of transaction ordering. Copy Trading Exploitation: Similarly, the visibility of trades allows competitors to duplicate strategies and profit unfairly. Lack of Privacy: Open order books expose traders\u2019 strategies and positions, allowing market analysis to be exploited by competitors. Market Manipulation: Open order books can be gamed by actors who use this transparency to manipulate markets and liquidity. Private Order Books: A Double-Edged Sword\nPrivate order books come with their own set of problems: Trust Deficit: Users cannot verify the platform\u2019s financial solvency, leading to doubts about whether enough assets back the open positions. Hidden Liquidity: With no visibility into the market depth, traders face uncertainty about whether their orders will be executed, or at what price. Manipulation Risk: The platform or privileged users can manipulate the market without detection, undermining the integrity of the system. User Trust: Lack of transparency can cause users to question the platform\u2019s stability, especially during volatile periods, driving away both new and existing users. How we solve the Problem\nWe address these issues by adopting a private order book system enhanced with access proofs and proof of solvency to foster user trust. While part of the market data remains public to prevent a \u201cgambling-like\u201d environment, the core of the system ensures that transparency and trust are maintained in a decentralized manner. Our approach is powered by a Chain Abstracted DAO, enabling users to propose and vote on changes to the perpetual contracts and platform structure. This cross-chain voting architecture ensures that all stakeholders have a say in the platform's evolution, adding further trust and transparency to the ecosystem. It is made with help of mina's protokit for the core peprpetaul contracts logic.\nThe circuits like proof of solvency were written in a truly scalable way with help of recursive zk snarks Chain Signatures-Based Cross-Chain Voting Architecture high Level Architecture\nThis architecture is designed to support a cross-chain flow where transactions are signed on Bitcoin, NEAR, and Ethereum using Chain Signatures. It allows seamless interaction between these networks for decentralized voting within a DAO that exists primarily on Ethereum. The architecture aims to offer secure and efficient transaction management for a multi-chain DAO by integrating BTC -> NEAR -> EVM flow. How the DAO works\nKey Components:\nMPC Contract: Contract Address: v1.signer-dev.testnet Purpose: Used to sign both NEAR and Ethereum transactions. Main Contract (lib.rs): This contract handles the promises and logic for cross-chain transactions. It calls the MPC contract to sign NEAR and Ethereum transactions. NEAR Transaction: A simple token transfer on the NEAR blockchain, initiated after a BTC transaction is signed. Ethereum Transaction: A voting transaction for a DAO on Ethereum, signed and broadcasted using the MPC contract. DAO on Ethereum: Main contract for the DAO resides on Ethereum. It tracks votes, stablecoins, and each member's account, including a token that represents the identity of the member. The Ethereum transaction settles here after NEAR and Bitcoin interactions. Architecture Flow\nBTC -> NEAR Transaction: A Bitcoin transaction is signed using Chain Signatures. The flow triggers a NEAR transaction via the MPC contract, which uses the FunctionCall parameter to sign the NEAR transaction (e.g., token transfer). The NEAR transaction is signed and one promise is returned for the signed NEAR transaction. NEAR -> Ethereum Transaction: After the NEAR transaction is signed, the same flow continues to trigger an Ethereum transaction. The Ethereum transaction payload (raw-coded for now) is derived and passed to the MPC contract for signing. The second promise is returned for the signed Ethereum transaction. Broadcast: Both signed NEAR and Ethereum transactions are broadcasted to their respective networks. Once the Ethereum transaction is completed, it triggers voting in the DAO on Ethereum, where the member's identity and vote are recorded. Limitations\nSerialization Issues: While calling the MPC contract directly for FunctionCall transactions, Borsh serialization faces inconsistencies, especially with incorrect argument types. Spelling discrepancies for parameters (like FunctionCall) have caused issues during the serialization process. Direct Function Calls: Direct calls to the MPC contract\u2019s sign function often fail due to type mismatches in the arguments (e.g., number not being recognized correctly). Raw-Coding of Ethereum Payload: The Ethereum transaction payload is currently hardcoded. This could lead to inflexibility and might require frequent updates when Ethereum transaction formats change. Keyversion and Path Derivation: The derivation of Keyversion and path has been complex, and ensuring consistent behavior across NEAR and Ethereum has been challenging. Dual Promise Handling: Managing two promises (one for NEAR and one for Ethereum) requires a robust handling mechanism to ensure that transactions are broadcasted correctly, even if one fails or is delayed.",
        "how_its_made": "It is made with help of mina's protokit for the core peprpetaul contracts logic.\nThe circuits like proof of solvency were written in a truly scalable way with help of recursive zk snarks Chain Signatures-Based Cross-Chain Voting Architecture high Level Architecture\nThis architecture is designed to support a cross-chain flow where transactions are signed on Bitcoin, NEAR, and Ethereum using Chain Signatures. It allows seamless interaction between these networks for decentralized voting within a DAO that exists primarily on Ethereum. The architecture aims to offer secure and efficient transaction management for a multi-chain DAO by integrating BTC -> NEAR -> EVM flow. How the DAO works\nKey Components:\nMPC Contract: Contract Address: v1.signer-dev.testnet Purpose: Used to sign both NEAR and Ethereum transactions. Main Contract (lib.rs): This contract handles the promises and logic for cross-chain transactions. It calls the MPC contract to sign NEAR and Ethereum transactions. NEAR Transaction: A simple token transfer on the NEAR blockchain, initiated after a BTC transaction is signed. Ethereum Transaction: A voting transaction for a DAO on Ethereum, signed and broadcasted using the MPC contract. DAO on Ethereum: Main contract for the DAO resides on Ethereum. It tracks votes, stablecoins, and each member's account, including a token that represents the identity of the member. The Ethereum transaction settles here after NEAR and Bitcoin interactions. Architecture Flow\nBTC -> NEAR Transaction: A Bitcoin transaction is signed using Chain Signatures. The flow triggers a NEAR transaction via the MPC contract, which uses the FunctionCall parameter to sign the NEAR transaction (e.g., token transfer). The NEAR transaction is signed and one promise is returned for the signed NEAR transaction. NEAR -> Ethereum Transaction: After the NEAR transaction is signed, the same flow continues to trigger an Ethereum transaction. The Ethereum transaction payload (raw-coded for now) is derived and passed to the MPC contract for signing. The second promise is returned for the signed Ethereum transaction. Broadcast: Both signed NEAR and Ethereum transactions are broadcasted to their respective networks. Once the Ethereum transaction is completed, it triggers voting in the DAO on Ethereum, where the member's identity and vote are recorded. Limitations\nSerialization Issues: While calling the MPC contract directly for FunctionCall transactions, Borsh serialization faces inconsistencies, especially with incorrect argument types. Spelling discrepancies for parameters (like FunctionCall) have caused issues during the serialization process. Direct Function Calls: Direct calls to the MPC contract\u2019s sign function often fail due to type mismatches in the arguments (e.g., number not being recognized correctly). Raw-Coding of Ethereum Payload: The Ethereum transaction payload is currently hardcoded. This could lead to inflexibility and might require frequent updates when Ethereum transaction formats change. Keyversion and Path Derivation: The derivation of Keyversion and path has been complex, and ensuring consistent behavior across NEAR and Ethereum has been challenging. Dual Promise Handling: Managing two promises (one for NEAR and one for Ethereum) requires a robust handling mechanism to ensure that transactions are broadcasted correctly, even if one fails or is delayed.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8jt17/screenshots/k8zyj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jt17/screenshots/7r3z7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jt17/screenshots/r8nbb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jt17/screenshots/rcdv5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jt17/screenshots/wjkfm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jt17/screenshots/ey9iy/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/utkarshdagoat/StealthTradeDAO",
        "link": "https://ethglobal.com/showcase/stealthtradedao-8jt17"
    },
    {
        "title": "Trebek!",
        "brief_description": "TREBEK! is reverse Jeopardy! with an AI twist. Instead of guessing the answer, players are given the answer and must create a prompt that generates that answer exactly, word for word.",
        "long_description": "i.e. Answer: Elon Musk / Correct prompt: CEO of Tesla\nFinal round will give a new topic, then contestants wager an amount of points they have, then the answer is given. They have 60 seconds to get the prompt. 3 rounds (2 normal and the final) 3 contestants Money from sponsors Daily Doubles (Randomness) System prompt is public. Models are private/random No text manipulation to derive answer no mathematical manipulation Audience votes on any split judgement Can you get the prompts? Sponsors pay-in to host a game, payouts go to winning contestantsSponsors pay-in to host a game, payouts go to winning contestantsSponsors pay-in to host a game, payouts go to winning contestantsSponsors pay-in to host a game, payouts go to winning contestantsSponsors pay-in to host a game, payouts go to winning contestants",
        "how_its_made": "Can you get the prompts? Sponsors pay-in to host a game, payouts go to winning contestantsSponsors pay-in to host a game, payouts go to winning contestantsSponsors pay-in to host a game, payouts go to winning contestantsSponsors pay-in to host a game, payouts go to winning contestantsSponsors pay-in to host a game, payouts go to winning contestants",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/97qcj/screenshots/5dmw4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/97qcj/screenshots/ajq35/default.jpg",
            "https://ethglobal.b-cdn.net/projects/97qcj/screenshots/ckkoc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/34r7h/trebek",
        "link": "https://ethglobal.com/showcase/trebek-97qcj"
    },
    {
        "title": "Grand Nouns Auto",
        "brief_description": "Grand Nouns Auto is a gangster-themed game blending action gameplay with DeFi education. Players complete missions involving real DeFi tasks, tracked by AI NPCs. Success yields attestations on the Gnosis Chain, featuring characters from the Nouns DAO and the NFT ecosystem.",
        "long_description": "Overview:\n\"Grand Nouns Auto\" is an innovative gangster-themed game that fuses action-packed gameplay with decentralized finance (DeFi) education. The player assumes the role of a rising city figure aiming to overthrow the current kingpin and take control of the streets. Throughout the game, players complete missions by executing DeFi actions and answering DeFi-related questions, helping them learn and master complex decentralized financial concepts through engaging, gamified experiences. The game makes use of advanced AI, blockchain integration, and NFTs, all working together to create a one-of-a-kind \"Earn While You Learn\" platform. Core Features: Protagonist Journey:\nPlayers take on the role of an ambitious gangster looking to rise to power by challenging the city\u2019s underworld kingpin. Through a series of missions, users navigate through scenarios involving DeFi operations, combining financial education with action-packed, story-driven gameplay. Gamified DeFi Education:\nEach mission in the game revolves around the completion of various DeFi tasks such as swapping tokens, staking, placing limit orders, cross-chain transactions, and more. By succeeding in these tasks, players not only advance in the storyline but also learn intermediate to advanced DeFi concepts. AI-Powered NPCs:\nAll non-playable characters (NPCs) in the game are powered by AI via the Phala Network using the AI Agent Template. These AI-driven NPCs create a dynamic and responsive environment, giving players a lifelike gaming experience. They also guide players through the DeFi process by giving hints or challenges based on the game\u2019s progress. Web3 & Blockchain Integration: DeFi Transaction Analysis & Attestation:\nAfter completing missions, the player\u2019s recent wallet transactions are reviewed to verify whether they\u2019ve completed the assigned DeFi tasks correctly. This verification process is carried out via the 1inch Fusion Plus SDK.\nIf the player successfully performs the required task, an attestation is created using Sign Protocol on the Gnosis Chain, further linking the gaming experience with real-world decentralized finance operations. Nouns DAO Integration:\nAll game characters are based on NFTs from the Nouns DAO collection, giving the game a unique visual identity and tapping into the broader NFT ecosystem. The use of Nouns adds a layer of community-driven governance, making the game both entertaining and collectible. AI Assistant \u2013 Satoshi:\nThe player is accompanied by an AI assistant named Satoshi, who serves as a guide throughout the game. Satoshi helps users understand complex DeFi tasks and is always available for answering questions related to decentralized finance. This allows players to receive real-time support and improve their DeFi knowledge. Hardware Wallet Integration:\nThe game requires players to connect their Ledger hardware wallet for all in-game transactions. This ensures enhanced security and introduces users to real-world blockchain practices in a safe, interactive manner. All in-game transactions take place on the Gnosis Chain, ensuring seamless and low-cost DeFi operations. Unique Selling Points: Learn and Earn: Grand Nouns Auto offers a unique \"Learn and Earn\" model where players enhance their DeFi skills while progressing through the game, making financial literacy an engaging and rewarding experience. Immersive DeFi Training: By blending the excitement of action-packed gameplay with real-world DeFi concepts, the game acts as a training ground for users who want to master decentralized finance in a hands-on, practical way. AI & Blockchain Fusion: Leveraging AI-driven NPCs, Web3 hosting on Phala, and blockchain interaction via Gnosis, the game merges cutting-edge technology to deliver an unprecedented gaming/learning experience. Nouns DAO Characters: Featuring characters from Nouns DAO, Grand Nouns Auto aligns itself with a vibrant NFT ecosystem, appealing to both crypto enthusiasts and gamers. Secure and Transparent: By requiring the use of Ledger hardware wallets and integrating with trusted platforms like Gnosis and 1inch, the game ensures security, transparency, and a direct connection between in-game actions and blockchain transactions. Target Audience: Conclusion:\nGrand Nouns Auto is not just a game; it's a learning platform that uses the thrill of a gangster story to make complex financial concepts accessible and fun. With its innovative use of AI, blockchain, and DeFi tasks, it provides users a chance to earn while they learn, all while offering an immersive, action-packed experience. By integrating NFTs from Nouns DAO and using advanced AI and secure DeFi protocols, the game stands out as the first of its kind in the intersection of education, gaming, and decentralized finance. Building Grand Nouns Auto involved leveraging a mix of technologies, primarily using React and Phaser for an engaging and responsive gaming experience. Here\u2019s a detailed look at how the project came together: Technologies Used\nReact: This framework facilitated a dynamic user interface, allowing for seamless updates and interactions within the game. It helped manage the game's state effectively and provided a responsive experience for players. Phaser: We chose Phaser as our game engine for its powerful 2D capabilities, which allowed us to create immersive action gameplay. Its flexibility made it easy to integrate various game mechanics and animations. AI-Powered NPCs: Non-playable characters are driven by AI via the Phala Network using the Redpill API. This integration enables NPCs to interact intelligently with players, providing hints and challenges based on their progress. Blockchain Integration: Gnosis Chain: Selected for its low transaction costs and quick processing times, it supports secure in-game transactions.\n1inch Fusion Plus SDK: This SDK was integrated to track player wallet addresses and facilitate DeFi actions like token swaps and staking.\nSign Protocol: After completing missions, we used this to create attestations for successful DeFi actions, linking gameplay to real-world finance.\nNFT Integration: Characters are sourced from the Nouns DAO collection, giving the game a unique visual identity and connecting it to the NFT ecosystem. Hardware Wallet Support: We integrated Ledger hardware wallets to ensure secure transactions, enhancing player safety and introducing them to blockchain practices. How Technologies Are Pieced Together:\nThe React frontend communicates with the Phaser game engine to manage gameplay, while smart contracts handle mission logic and attestations. Player interactions with AI NPCs are powered by the Phala Network for which we used the Redpill AI agent Templated, creating a dynamic and engaging experience. Partner Technologies:\nThe collaboration with the Phala Network and the 1inch APIs greatly enhanced our capabilities. Phala allowed for privacy-preserving AI interactions, while 1inch facilitated smooth DeFi transactions, making complex tasks accessible to players. Notable Hacky Solutions\nA standout feature was the creation of a real-time feedback loop for players\u2019 DeFi tasks. We developed a system that analyzes wallet transactions dynamically, enabling instant attestations. This involved a clever combination of smart contract triggers and off-chain data processing, ensuring that players received immediate feedback on their actions. Overall, the combination of React, Phaser, AI, and blockchain technologies makes Grand Nouns Auto a unique project at the intersection of education and entertainment, offering players an engaging way to master DeFi concepts.",
        "how_its_made": "Building Grand Nouns Auto involved leveraging a mix of technologies, primarily using React and Phaser for an engaging and responsive gaming experience. Here\u2019s a detailed look at how the project came together: Technologies Used\nReact: This framework facilitated a dynamic user interface, allowing for seamless updates and interactions within the game. It helped manage the game's state effectively and provided a responsive experience for players. Phaser: We chose Phaser as our game engine for its powerful 2D capabilities, which allowed us to create immersive action gameplay. Its flexibility made it easy to integrate various game mechanics and animations. AI-Powered NPCs: Non-playable characters are driven by AI via the Phala Network using the Redpill API. This integration enables NPCs to interact intelligently with players, providing hints and challenges based on their progress. Blockchain Integration: Gnosis Chain: Selected for its low transaction costs and quick processing times, it supports secure in-game transactions.\n1inch Fusion Plus SDK: This SDK was integrated to track player wallet addresses and facilitate DeFi actions like token swaps and staking.\nSign Protocol: After completing missions, we used this to create attestations for successful DeFi actions, linking gameplay to real-world finance.\nNFT Integration: Characters are sourced from the Nouns DAO collection, giving the game a unique visual identity and connecting it to the NFT ecosystem. Hardware Wallet Support: We integrated Ledger hardware wallets to ensure secure transactions, enhancing player safety and introducing them to blockchain practices. How Technologies Are Pieced Together:\nThe React frontend communicates with the Phaser game engine to manage gameplay, while smart contracts handle mission logic and attestations. Player interactions with AI NPCs are powered by the Phala Network for which we used the Redpill AI agent Templated, creating a dynamic and engaging experience. Partner Technologies:\nThe collaboration with the Phala Network and the 1inch APIs greatly enhanced our capabilities. Phala allowed for privacy-preserving AI interactions, while 1inch facilitated smooth DeFi transactions, making complex tasks accessible to players. Notable Hacky Solutions\nA standout feature was the creation of a real-time feedback loop for players\u2019 DeFi tasks. We developed a system that analyzes wallet transactions dynamically, enabling instant attestations. This involved a clever combination of smart contract triggers and off-chain data processing, ensuring that players received immediate feedback on their actions. Overall, the combination of React, Phaser, AI, and blockchain technologies makes Grand Nouns Auto a unique project at the intersection of education and entertainment, offering players an engaging way to master DeFi concepts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tw1ut/screenshots/ftcfi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tw1ut/screenshots/ryjo4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tw1ut/screenshots/kz9rh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tw1ut/screenshots/r9jdc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tw1ut/screenshots/9weha/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tw1ut/screenshots/skddn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/gabrielantonyxaviour/gna.git",
        "link": "https://ethglobal.com/showcase/grand-nouns-auto-tw1ut"
    },
    {
        "title": "Gecko",
        "brief_description": "Gecko is an autonomous multi-agent AI auditor that combines LLM\u2019s with custom security tools like fuzzers and static analysers to simulate a hacker's intuition and detect vulnerabilities in Solidity and Cairo smart contracts.",
        "long_description": "Gecko overcomes the drawbacks of traditional AI auditors by providing enhanced context and deeper analysis for smart contract vulnerabilities. Unlike existing projects, Gecko uses custom security tools to increase code coverage, and enable it to discover harder to find bugs and reduce false positives by exploiting the potential vulnerabilities. It simulates a hacker's intuition through a novel vulnerability mining engine powered by LLMs, requiring no pre-built knowledge base or fine-tuning. The system can analyze both Solidity and Cairo smart contracts, by using a custom static analyser and parser with an LLM interface. This interface provides context to the auditing agents, helping them uncover bugs that lie deep in contract execution. Gecko uses an autonomous, stateful hybrid fuzzer that combines symbolic execution with traditional fuzzing techniques. This fuzzer, guided by LLMs, generates relevant inputs and writes test cases autonomously to further increase code coverage. Gecko lowers the barrier to comprehensive and high-coverage audits, which are traditionally very expensive. It provides a scalable, continuous, and transparent solution for identifying vulnerabilities at scale. We benchmark Gecko against existing tools and show that it\u2019s capable of uncovering logical bugs that other methods often miss. Gecko is an autonomous multi-agent AI auditor built using OpenAI\u2019s GPT-4o-mini for vulnerability detection in Solidity and Cairo smart contracts. It integrates custom security tools, including a static analyser, a custom Solidity grammar parser, and a modified Crytic Caracal for Cairo, with an LLM-powered hybrid fuzzer that combines symbolic execution and traditional fuzzing. PostgreSQL is used for backend storage. The LLMs autonomously generate test cases and inputs, increasing code coverage and reducing false positives without requiring a pre-built knowledge base. The frontend, built with next.js, provides a user interface for contract uploads and report viewing.",
        "how_its_made": "Gecko is an autonomous multi-agent AI auditor built using OpenAI\u2019s GPT-4o-mini for vulnerability detection in Solidity and Cairo smart contracts. It integrates custom security tools, including a static analyser, a custom Solidity grammar parser, and a modified Crytic Caracal for Cairo, with an LLM-powered hybrid fuzzer that combines symbolic execution and traditional fuzzing. PostgreSQL is used for backend storage. The LLMs autonomously generate test cases and inputs, increasing code coverage and reducing false positives without requiring a pre-built knowledge base. The frontend, built with next.js, provides a user interface for contract uploads and report viewing.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/m5ezr/screenshots/n4mrk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m5ezr/screenshots/2ygfp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m5ezr/screenshots/2qwz9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m5ezr/screenshots/st4yf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m5ezr/screenshots/6sbss/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/nkoorty/gecko-singapore",
        "link": "https://ethglobal.com/showcase/gecko-m5ezr"
    },
    {
        "title": "D-Trust",
        "brief_description": "A movement against the monopolization of truth. By joining D-Trust, you become part of a community dedicated to transparency, accountability, and the collective pursuit of knowledge",
        "long_description": "Introduction In an era where misinformation spreads faster than facts and censorship stifles diverse voices, the truth has become a contested commodity. Traditional fact-checking mechanisms are often centralized, vulnerable to biases, and limited by geopolitical or financial influences. But what if there was a way to democratize the process of fact-checking, putting the power back into the hands of the people? Enter D-Trust\u2014a decentralized platform leveraging blockchain technology to create a transparent, censorship-resistant environment for validating real-world events and information. The Problem: Centralized Truth in a Decentralized World Misinformation and censorship are not just buzzwords; they are critical issues undermining trust in media, governance, and even science. Platforms that control the flow of information can manipulate narratives, suppress dissenting voices, and prioritize profit over the public good. As a result, the public's ability to discern truth from falsehood diminishes, leading to polarized societies and misinformed decisions. Traditional fact-checking organizations, while essential, often face questions about their impartiality and reach. Their centralized nature makes them susceptible to external pressures and biases, further complicating the quest for a universally accepted truth. The need for a decentralized solution has never been more urgent. Introducing D-Trust: The Decentralized Fact-Checking Revolution D-Trust is not just another blockchain project; it's a movement to reclaim the truth. By utilizing blockchain\u2019s inherent transparency, immutability, and decentralized structure, D-Trust offers a platform where anyone can contribute to or challenge information in a structured, transparent, and unbiased manner. At its core, D-Trust employs a community-driven voting mechanism to validate claims. Each claim\u2014whether it\u2019s about a current event, a public statement, or the status of a real-world asset\u2014is subjected to a decentralized voting process. Participants, incentivized by the system, can vote on the accuracy of information, creating a public consensus that is transparent and verifiable on the blockchain. This project uses the following tech stack:",
        "how_its_made": "This project uses the following tech stack:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2et9y/screenshots/qp5ek/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2et9y/screenshots/x6cqm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2et9y/screenshots/n5ns1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2et9y/screenshots/ovox9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2et9y/screenshots/xmq8x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2et9y/screenshots/o1oa8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jjhbk/dtrust",
        "link": "https://ethglobal.com/showcase/d-trust-2et9y"
    },
    {
        "title": "Diver",
        "brief_description": "It's an application for divers to keep dive logs on a blockchain.",
        "long_description": "Scenario 1 - Logging Dives of Diver\nDivers login with wallet (Metamask) to Diver Mobile App, input dive information and send for Dive master approval.\nDive master also login with wallet (Metamask) to Diver Mobile App, lists pending approvals, then choose apropriate dive record and approve it. After approval dive log is written to the blockchain as a dive record of diver's logbook.\nScenario 2 - Top Diver\nDiver can able to see Top Diver (who has the most log in the blockchain) in the Diver Mobile app. Scenario 1 - Logging Dives of Diver\nDivers login with wallet (Metamask) to Diver Mobile App, We use wallet connect with Metamask. Mobile app is developed by flutter/dart (android).\nInput dive information (diving place from select box and dive master public address. Afterward send data for Dive master approval. (Springboot, mysql)\nDive master also login with wallet (Metamask) to Diver Mobile App,(same app, different user) lists pending approvals, then choose apropriate dive record and approve it. After approval dive log is written to the blockchain as a dive record of diver's logbook. (Sepholia test net, we have a smart contract written by solidity. We use remix ide. Scenario 2 - Top Diver\nDiver can able to see Top Diver (who has the most log in the blockchain) in the Diver Mobile app. (Same mobile app) we use The Graph to access and index blockchain data. We define a subgraph, we create and run it. We show the query result on our mobile app.",
        "how_its_made": "Scenario 1 - Logging Dives of Diver\nDivers login with wallet (Metamask) to Diver Mobile App, We use wallet connect with Metamask. Mobile app is developed by flutter/dart (android).\nInput dive information (diving place from select box and dive master public address. Afterward send data for Dive master approval. (Springboot, mysql)\nDive master also login with wallet (Metamask) to Diver Mobile App,(same app, different user) lists pending approvals, then choose apropriate dive record and approve it. After approval dive log is written to the blockchain as a dive record of diver's logbook. (Sepholia test net, we have a smart contract written by solidity. We use remix ide. Scenario 2 - Top Diver\nDiver can able to see Top Diver (who has the most log in the blockchain) in the Diver Mobile app. (Same mobile app) we use The Graph to access and index blockchain data. We define a subgraph, we create and run it. We show the query result on our mobile app.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tu97t/screenshots/qv3os/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tu97t/screenshots/vt9iy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tu97t/screenshots/qezom/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tu97t/screenshots/hogs5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tu97t/screenshots/59cnv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/mbdemirkan/ethGlobalSingapore",
        "link": "https://ethglobal.com/showcase/diver-tu97t"
    },
    {
        "title": "HawkEye",
        "brief_description": "A Web3 x AI solution proving human gameplay by extracting keystrokes from key input video using AI models, matching them with in-game actions. Proofs are pushed on-chain and secured using TEEs, letting players prove they're real humans on any gaming platform. #Web3 #AI #Gaming",
        "long_description": "Our project, HawkEye, is a Web3 and AI-powered solution designed to authenticate human gameplay in online gaming environments. In an era where bots and automated scripts undermine the integrity of gaming platforms, our solution provides a robust method to verify that an actual human is playing the game, enhancing trust and fairness in the gaming community. Problem Statement: The rise of bots and automation in gaming has led to unfair advantages, disrupted in-game economies, and diminished player experiences. Traditional methods of bot detection are often reactive and can be circumvented. There's a pressing need for a proactive, reliable, and universally acceptable method to verify human players. Solution Overview\nWe address this challenge by capturing and analyzing keystroke data from two sources: Data Comparison using Dynamic Time Warping (DTW) On-Chain Proof Generation Use Cases Future Development Plans Conclusion: Our project aims to alter human verification in the gaming industry. Combining AI-driven keystroke detection with blockchain technology, we offer a novel solution that enhances security, fairness, and trust in online gaming. We think that HawkEye has the potential to become a standard for human verification across gaming platforms worldwide. Keywords: Dynamic Time Warping, Human Verification, Gaming Security, Keystroke Detection, On-Chain Proof. Our project, HawkEye, is a fusion of AI, blockchain, and mobile technologies, carefully staged to create a seamless and secure human verification system for online gaming. Here's a detailed breakdown of how we built it: User behaviour monitoring (Frontend): AI Model: Blockchain Integration: Partner Technologies and Their Benefits: Some Innovative Aspects:",
        "how_its_made": "Our project, HawkEye, is a fusion of AI, blockchain, and mobile technologies, carefully staged to create a seamless and secure human verification system for online gaming. Here's a detailed breakdown of how we built it: User behaviour monitoring (Frontend): AI Model: Blockchain Integration: Partner Technologies and Their Benefits: Some Innovative Aspects:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/uitr4/screenshots/5pf5u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uitr4/screenshots/97fz7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uitr4/screenshots/irbo1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/TUM-Blockchain-Club/proof-of-gameplay",
        "link": "https://ethglobal.com/showcase/hawkeye-uitr4"
    },
    {
        "title": "Threeer",
        "brief_description": "A decentralized marketplace for digital services using blockchain and AI verification. Clients post tasks with bounties in smart contracts. Workers submit work; AI approves quality. If approved, funds release. No intermediaries\u2014secure and efficient.",
        "long_description": "Our hackathon project introduces a peer-to-peer, trustless platform for trading digital services by leveraging blockchain technology, decentralized storage, and AI verification. Drawing inspiration from platforms like Fiverr but operating in a decentralized manner, the system enables clients to post service requests in text format and attach a bounty (e.g., 0.1 xDAI). This bounty is securely locked within a smart contract on the blockchain, ensuring transparency and trust between parties. When a worker decides to accept a task, they complete the requested service\u2014such as writing a cover letter for a job application\u2014and submit it through our portal. The submitted work is then uploaded to the InterPlanetary File System (IPFS), a decentralized storage network that ensures the data is securely stored and distributed across multiple nodes. This approach enhances security and prevents reliance on centralized servers. An AI agent is triggered to read the text directly from IPFS. This agent evaluates the quality and relevance of the work by comparing it against the client\u2019s specifications and predefined quality standards. If the AI verification confirms that the work meets all required criteria, it communicates this approval back to the smart contract. The smart contract then automatically unlocks the bounty and transfers the funds to the worker\u2019s account. This automated process ensures that workers are fairly compensated without delays, and clients receive the quality of work they expect. By integrating blockchain escrow with AI verification and decentralized storage, our platform creates a secure and efficient ecosystem for digital service transactions. It reduces risks associated with fraud and disputes, lowers transaction costs by eliminating intermediaries, and accelerates the fulfillment process. This innovation aims to revolutionize the way digital services are exchanged, fostering a more decentralized and equitable online economy where trust is built into the system itself. Our platform integrates several cutting-edge technologies to achieve this functionality:",
        "how_its_made": "Our platform integrates several cutting-edge technologies to achieve this functionality:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2xgz4/screenshots/4g4qo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2xgz4/screenshots/0qxde/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2xgz4/screenshots/806yv/default.jpg"
        ],
        "live_demo": "https://phala-playground.vercel.app",
        "source_code": "https://github.com/tricodex/phala-playground",
        "link": "https://ethglobal.com/showcase/threeer-2xgz4"
    },
    {
        "title": "1cmBot",
        "brief_description": "1cmBot is a Telegram bot that offers easy trading on Telegram by leveraging 1inch API to support swaps on multiple chains and get the best rates with 1inch's aggregation router.",
        "long_description": "1cmBot is a Telegram bot that offers users an intuitive trading experience by leveraging the 1inch API for seamless swapping on their preferred network, such as Ethereum, Polygon and Base. Users can manage their trades efficiently by first customizing the bot with their preferred settings as follows:\n- Select chain to trade on\n- Select any pair of tokens to perform swaps\n- Specify slippage tolerance level (preconfigured default of 0.3%) The general setup process for a new user is as follows: Before performing swaps, users will have to deposit Token0/Token1 selected during setup, and also deposit the token used for gas in their selected chain (e.g. POL for Polygon). Once the above steps are done, users are ready to swap their way to huge profits! Buying/selling will then be a straightforward process, with users being able to perform transactions with two taps by first choosing \"Buy\" or \"Sell\", and then choosing from a predefined set of amounts to swap (i.e. 25%, 50%, 75%, 100%). For the users' reference, the default prompt (main menu) will contain a graph of the selected token pair, which can be refreshed easily with one tap of the \"Refresh\" button. This allows users to be constantly updated with the token pairing's latest trend and make smart trading decisions all within the Telegram bot interface, enabling users to trade ahead of others and always get the best rates with the power of 1inch's smart routing. Ultimately, this bot simplifies decentralized trading by offering essential controls in Telegram's user-friendly and familiar interface, making it accessible for both beginner and advanced traders. This project utilizes Telegram as the frontend. To interface with the Telegram bot API, we decided to use python-telegram-bot library as it has a long history and is used by many developers in the community, making it easier to get solutions from the community for common issues. We use Prisma ORM for database management, as making updates to the database structure is made easy with Prisma Schema Language (PSL). Migrations also make it easy for us two team members to work together and incrementally make changes to the database. Prisma also comes with Prisma Studio, a web-based UI for managing database records, similar to phpMyAdmin. This made debugging database-related issues a breeze. All components of our application, including development-related components such as above-mentioned Prisma Studio, are hosted using Docker, making it easy to switch between databases as necessary. This came in handy when we realized that it was easier to interact with a MySQL database using mysql-connector-python library instead of Postgres - the switch from Postgres to MySQL was finished within 3 minutes. For generating wallet addresses, we assign a unique auto-increment integer field in the database for each user and use the derivation path concept to use the unique integer and a master key to generate a unique wallet address and private key for each user. This is done by using the eth_account library. The blockchain interaction in our application is completely powered by the 1inch API - getting swap quotes, getting token balance, getting chart data, getting token info, performing swaps. Unfortunately for development purposes, we had to implement a 1-second delay between API calls to work around the free API key's 1 RPS limit, making the interaction a bit less smooth than its supposed to be.",
        "how_its_made": "This project utilizes Telegram as the frontend. To interface with the Telegram bot API, we decided to use python-telegram-bot library as it has a long history and is used by many developers in the community, making it easier to get solutions from the community for common issues. We use Prisma ORM for database management, as making updates to the database structure is made easy with Prisma Schema Language (PSL). Migrations also make it easy for us two team members to work together and incrementally make changes to the database. Prisma also comes with Prisma Studio, a web-based UI for managing database records, similar to phpMyAdmin. This made debugging database-related issues a breeze. All components of our application, including development-related components such as above-mentioned Prisma Studio, are hosted using Docker, making it easy to switch between databases as necessary. This came in handy when we realized that it was easier to interact with a MySQL database using mysql-connector-python library instead of Postgres - the switch from Postgres to MySQL was finished within 3 minutes. For generating wallet addresses, we assign a unique auto-increment integer field in the database for each user and use the derivation path concept to use the unique integer and a master key to generate a unique wallet address and private key for each user. This is done by using the eth_account library. The blockchain interaction in our application is completely powered by the 1inch API - getting swap quotes, getting token balance, getting chart data, getting token info, performing swaps. Unfortunately for development purposes, we had to implement a 1-second delay between API calls to work around the free API key's 1 RPS limit, making the interaction a bit less smooth than its supposed to be.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gqv7t/screenshots/gvpg2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gqv7t/screenshots/y97yc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gqv7t/screenshots/fpqst/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/georgeneokq/1cmBot",
        "link": "https://ethglobal.com/showcase/1cmbot-gqv7t"
    },
    {
        "title": "Mirage",
        "brief_description": "Mirage: Decentralized email with USDC transfers, encrypted messaging, and IPFS attachments. Cross-chain via Chainlink CCIP and Circle CCTP. Blends Web3 tech with familiar email UI for seamless use. Secure, innovative communication meets blockchain functionality.",
        "long_description": "Mirage is a decentralized transactional mail service that combines the familiarity of traditional email with the power and security of blockchain technology. At its core, Mirage offers a user-friendly interface reminiscent of popular email clients, but with a crucial difference: all communications are secured and verified on the blockchain. Our main application is built using Next.js, providing a smooth and responsive experience for our users using Dynamic wallet interface.\nOne of our key features is the ability to send messages with attachments and even include USDC transfers within the same transaction. This is made possible through our integration with Chainlink's Cross-Chain Interoperability Protocol (CCIP) and Circle's CCTP, allowing for seamless cross-chain communication and asset transfers. We've partnered with several industry leaders to enhance our platform: 2.NounsDAO: Our collaboration with NounsDAO has influenced our unique visual style, incorporating playful and distinctive iconography throughout our interface. 3.Sign Protocol: We've implemented Sign Protocol for creating verifiable attestations, adding an extra layer of trust to our email communications Chainlink: As mentioned earlier, we use Chainlink's CCIP for cross-chain functionality, enabling our users to send messages and assets across different blockchain networks. Circle: Our integration with Circle allows for seamless USDC transfers within our platform, adding a financial dimension to our messaging service. We've also developed smart contracts to handle the core functionality of our platform. Our Mirage contract, for example, manages messages, contacts, and verification requests.",
        "how_its_made": "We've partnered with several industry leaders to enhance our platform: 2.NounsDAO: Our collaboration with NounsDAO has influenced our unique visual style, incorporating playful and distinctive iconography throughout our interface. 3.Sign Protocol: We've implemented Sign Protocol for creating verifiable attestations, adding an extra layer of trust to our email communications Chainlink: As mentioned earlier, we use Chainlink's CCIP for cross-chain functionality, enabling our users to send messages and assets across different blockchain networks. Circle: Our integration with Circle allows for seamless USDC transfers within our platform, adding a financial dimension to our messaging service. We've also developed smart contracts to handle the core functionality of our platform. Our Mirage contract, for example, manages messages, contacts, and verification requests.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tz65j/screenshots/3tufz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tz65j/screenshots/y8wat/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tz65j/screenshots/xo235/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tz65j/screenshots/6d8ng/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tz65j/screenshots/7nuta/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/JuinSoft/Mirage",
        "link": "https://ethglobal.com/showcase/mirage-tz65j"
    },
    {
        "title": "OmniForward",
        "brief_description": "cross chain lend/borrow by fixed rate and term bring arbitrage, looping, aggregating and much more opportunity, and as long as much asset pick fixed rate and term, the market would growth much faster than it used to.",
        "long_description": "By cross chain fixed rate lending borrowing, users could able to comparing different rate crossing multiple chains, and given by fixed rate and tenors, the risk and profit is expectable, which make users or insitutions much preffering for longer term lend or borrow.\nWhich bring more advantages: This project is built using Circle CCTP and ChainLink CCIP for cross-chain capabilities, leveraging WalletConnect and Ledger for wallet management. The frontend is developed with React, while the backend, written in Python, operates as the order-matching engine. It assists users by interacting with smart contracts to match orders based on zero coupon bond, ensuring fairness and automating the process of managing zero-coupon bonds and fixed-rate calculations",
        "how_its_made": "This project is built using Circle CCTP and ChainLink CCIP for cross-chain capabilities, leveraging WalletConnect and Ledger for wallet management. The frontend is developed with React, while the backend, written in Python, operates as the order-matching engine. It assists users by interacting with smart contracts to match orders based on zero coupon bond, ensuring fairness and automating the process of managing zero-coupon bonds and fixed-rate calculations",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vmq9m/screenshots/fc9dq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vmq9m/screenshots/z010m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vmq9m/screenshots/rwr62/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vmq9m/screenshots/a7vtf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vmq9m/screenshots/az8dw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vmq9m/screenshots/jh81u/default.jpg"
        ],
        "live_demo": "https://omni-forward.vercel.app/",
        "source_code": "https://github.com/imfeng/omni-forward-contract",
        "link": "https://ethglobal.com/showcase/omniforward-vmq9m"
    },
    {
        "title": "Duckbot",
        "brief_description": "Building a prediction market Telegram bot that lets users bet on real-world events directly within the app. Utilizing blockchain for transparent and verifiable outcomes, ensuring fairness and security. Bet, track, and win \u2013 on-chain!",
        "long_description": "The bot operates a prediction market, where users can wager on the outcomes of events (e.g., sports games, elections, crypto prices). Predictions are created for a specific event, and users place their bets by interacting with the bot via Telegram messages. Each prediction market has a closing time (after which no more bets are accepted) and a resolution time (when the outcome of the event is known and winners are determined). Furthermore, users can explore the chain, inspect users and send funds to any wallet, all of which are conducted on the telegram interface We\u2019re currently building on AirDAO with a unique architecture that leverages both on-chain and off-chain technologies for seamless integration. The project primarily revolves around a Telegram bot, which acts as the user interface for prediction market interactions. Technologies Used & Architecture:\nTelegram Integration: The bot is the primary gateway for users to engage with the platform. We\u2019ve used the Python-Telegram-Bot library to manage conversations, group alerts, and interactions. It facilitates wallet management and placing predictions in a user-friendly way. Wallet Generation & Encryption: On the backend, we generate and manage wallets server-side. To ensure security, we implemented AES-256 encryption for wallet keys, ensuring that neither the bot nor any other third party has access to the server-side keys. This encryption process is fully transparent to the user, providing security without compromising user experience. Off-Chain Matching Engine: We\u2019ve designed an off-chain matching engine for prediction markets, which operates like a central limit order book. It handles the matching of predictions to streamline execution without the bottleneck of on-chain latency. This was a critical design decision for ensuring low-latency, high-throughput trading. Partner Technologies: Building on AirDAO's Layer 1 infrastructure gave us access to its secure blockchain and token management capabilities. The decentralised nature of the platform allowed us to create a secure, transparent system for users to engage with the prediction market.",
        "how_its_made": "We\u2019re currently building on AirDAO with a unique architecture that leverages both on-chain and off-chain technologies for seamless integration. The project primarily revolves around a Telegram bot, which acts as the user interface for prediction market interactions. Technologies Used & Architecture:\nTelegram Integration: The bot is the primary gateway for users to engage with the platform. We\u2019ve used the Python-Telegram-Bot library to manage conversations, group alerts, and interactions. It facilitates wallet management and placing predictions in a user-friendly way. Wallet Generation & Encryption: On the backend, we generate and manage wallets server-side. To ensure security, we implemented AES-256 encryption for wallet keys, ensuring that neither the bot nor any other third party has access to the server-side keys. This encryption process is fully transparent to the user, providing security without compromising user experience. Off-Chain Matching Engine: We\u2019ve designed an off-chain matching engine for prediction markets, which operates like a central limit order book. It handles the matching of predictions to streamline execution without the bottleneck of on-chain latency. This was a critical design decision for ensuring low-latency, high-throughput trading. Partner Technologies: Building on AirDAO's Layer 1 infrastructure gave us access to its secure blockchain and token management capabilities. The decentralised nature of the platform allowed us to create a secure, transparent system for users to engage with the prediction market.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/m8o1a/screenshots/3p4f9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m8o1a/screenshots/ponre/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m8o1a/screenshots/qpc23/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m8o1a/screenshots/u1ygx/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sendcapital/duckbot",
        "link": "https://ethglobal.com/showcase/duckbot-m8o1a"
    },
    {
        "title": "Attornato",
        "brief_description": "Marketplace for tokenized boats. List, tokenize, request attestation, send binding orders and buy boats.",
        "long_description": "Sellers can list their boat for sale. The boat gets tokenized. Interested buyers can send an offer and request attestation. It works like a binding if the attestation was positive. Surveyor inspects the boat, and if the condition of the boat matches the description, the order goes through. Frontend uses Wagmi/Viem and Dynamic. It serves 3 user types: sellers, buyers and surveyors. We use Chainlink to tokenize RWAs (boats). To attest the condition of the boat we want to use Sign protocol. Buyer funds are stored in an escrow contract during the attestation period.",
        "how_its_made": "Frontend uses Wagmi/Viem and Dynamic. It serves 3 user types: sellers, buyers and surveyors. We use Chainlink to tokenize RWAs (boats). To attest the condition of the boat we want to use Sign protocol. Buyer funds are stored in an escrow contract during the attestation period.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2nku7/screenshots/7yfuq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2nku7/screenshots/0w7v2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2nku7/screenshots/i04dy/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Blankeeir/ethglobalsingapore",
        "link": "https://ethglobal.com/showcase/attornato-2nku7"
    },
    {
        "title": "fheProxies",
        "brief_description": "fheVPN (Proxies) is a decentralized Proxy-as-a-Service (PaaS) enabling anonymous web browsing via nodes from global operators. Fully Homomorphic Encryption (FHE) ensures only clients who pay on-chain through the Fhenix network can securely access node details.",
        "long_description": "fheVPN (Proxies) leverages the power of Fully Homomorphic Encryption (FHE) to provide secure, anonymous web browsing through a decentralized Proxy-as-a-Service (PaaS) model. Node operators can spin up proxy nodes in various regions and set a price for access. The details of these nodes are encrypted using FHE, ensuring that only authorized clients who have paid through the Fhenix network can access them. Even in the event of IP leaks, unauthorized users are blocked by a whitelisting mechanism. This removes the need for passwords, as the client\u2019s IP is encrypted and shared with the node provider for whitelisting after payment. This creates a secure, anonymous browsing experience powered by blockchain. fheVPN (Proxies) leverages the Fhenix network\u2019s integration of Fully Homomorphic Encryption (FHE) with smart contracts to provide secure access control. The backend allows node operators to deploy proxy nodes and encrypt their details using FHE, ensuring that sensitive data like IP addresses remain confidential. Clients make payments on-chain using the ethers.js library, and their IP addresses are encrypted through the Fhenix network. This information is only visible to the node providers, who whitelist clients for access. On the frontend, we used Next.js for the interface, enabling users to seamlessly manage and connect to proxies. We also integrated fhenix.js for encrypted interactions with the network. The platform was deployed on a local devnet to facilitate testing and development in a secure environment, ensuring the privacy and security of all transactions and proxy connections.",
        "how_its_made": "fheVPN (Proxies) leverages the Fhenix network\u2019s integration of Fully Homomorphic Encryption (FHE) with smart contracts to provide secure access control. The backend allows node operators to deploy proxy nodes and encrypt their details using FHE, ensuring that sensitive data like IP addresses remain confidential. Clients make payments on-chain using the ethers.js library, and their IP addresses are encrypted through the Fhenix network. This information is only visible to the node providers, who whitelist clients for access. On the frontend, we used Next.js for the interface, enabling users to seamlessly manage and connect to proxies. We also integrated fhenix.js for encrypted interactions with the network. The platform was deployed on a local devnet to facilitate testing and development in a secure environment, ensuring the privacy and security of all transactions and proxy connections.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vwsiy/screenshots/bfiqf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vwsiy/screenshots/qfn0a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vwsiy/screenshots/wzqfd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vwsiy/screenshots/kxdan/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xjunwei/fheVPN",
        "link": "https://ethglobal.com/showcase/fheproxies-vwsiy"
    },
    {
        "title": "Factify",
        "brief_description": "Factify is dedicated to ensuring authentic research is accessible for all. By leveraging WorldCoin's unique ID and Sign protocol, we aim to reduce publication bias and connect all stakeholders\u2014researchers, funders, and verifiers. with a token system rewarding ethical publishing:)",
        "long_description": "Project \"Factify\", creates with the purpose of reducing publication bias as much as possible by using the benefits of WorldCoin uniqueID and Sign protocol applying schemas to all the parties related to the research publishing such as the fund-raiser, the researcher, the document-verifier or even the research instruments to sign the signature to see all the relations whether are there any chances of the publication bias. Core benefits that we aim: to bring the various types of off-chain data in form of the research documents to the on-chain for the further public good uses. In a long run, We are planning to create the tokenomic as reward to the research publisher and all the publication relates as a credibility so they can gain more trust by the reader, plus as an incentive to all the contributors (to publish the papers with ethics and for the good uses). Additionally, using a smart contract to automatically score the bias scoring to each paper  and sign in to the schema for more trust of each research. Using Scaffold + Foundry as a dApp helper (NextJS, Tailwind CSS, Daisy UI for the frontend)\nWorldcoin for the UniqueID\nVerifies with Go as a backend of proof verification (with Hexagonal Architecture, Resty + Echo for client side in Go)\nSigning with the schemas on Sign protocol\nwith the research paper to base64 stores on Arweave.\nPlanning on using Gnosis shattered network encrypt on the Privacy data.\nAll of these making with love and enthusiasm.| :-)",
        "how_its_made": "Using Scaffold + Foundry as a dApp helper (NextJS, Tailwind CSS, Daisy UI for the frontend)\nWorldcoin for the UniqueID\nVerifies with Go as a backend of proof verification (with Hexagonal Architecture, Resty + Echo for client side in Go)\nSigning with the schemas on Sign protocol\nwith the research paper to base64 stores on Arweave.\nPlanning on using Gnosis shattered network encrypt on the Privacy data.\nAll of these making with love and enthusiasm.| :-)",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/7x8ja/screenshots/yh9cb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7x8ja/screenshots/i4nzf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7x8ja/screenshots/cog8g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7x8ja/screenshots/py8je/default.jpg"
        ],
        "live_demo": "https://factify-alpha.vercel.app/",
        "source_code": "https://github.com/thachawit/factify",
        "link": "https://ethglobal.com/showcase/factify-7x8ja"
    },
    {
        "title": "clr.wiki",
        "brief_description": "Collusion resistant information dispute resolution tool using MACI",
        "long_description": "Wikipedia is the predominant information source for the majority of the global population. However, it has come under criticism for a variety of issues in terms of admin control and subjectivity of articles. We propose a collusion resistant dispute resolution method for articles that go into the DRN flow of Wikipedia. Currently, a volunteer accepts to take the lead in a DRN request and then it is either resolved or failed, but vested interests. corporations can take advantage of this and push false narratives. see - https://en.wikipedia.org/wiki/List_of_Wikipedia_controversies With clr.wiki we are proposing a tool that can be used by wikipedia or other organizations that can pipe DRN requests and get back a commitment of the votes. This can be gate keeped, such that for example, only a particularly demographic can edit and update a certain type of articles and so forth. We made use of the MACI wrapper and modified it by adding a contract that has the mapping of the slug and its latest information & commitment proofs. All articles are stored in ipfs, and the ipfs hashes are updated into a solidity contract called CLR.  CLR keeps track of the latest version of the slug for eg. Singapore could be the topic and a proposer can choose to propose an edit. A volunteer could then perform the duties of the coordinator and create a poll to add the amendments. If accepted the new proposed version becomes the latest information.",
        "how_its_made": "We made use of the MACI wrapper and modified it by adding a contract that has the mapping of the slug and its latest information & commitment proofs. All articles are stored in ipfs, and the ipfs hashes are updated into a solidity contract called CLR.  CLR keeps track of the latest version of the slug for eg. Singapore could be the topic and a proposer can choose to propose an edit. A volunteer could then perform the duties of the coordinator and create a poll to add the amendments. If accepted the new proposed version becomes the latest information.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8bk7z/screenshots/yi0cm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8bk7z/screenshots/9e7zm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8bk7z/screenshots/un5rc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8bk7z/screenshots/2415a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8bk7z/screenshots/qbpqm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8bk7z/screenshots/wekbh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/seigneur/clr-wiki",
        "link": "https://ethglobal.com/showcase/clr-wiki-8bk7z"
    },
    {
        "title": "MooDeng Arbitrageurs",
        "brief_description": "An automated arbitrage bot that operates across multiple EVM-compatible chains, with a user-friendly interface for setup, monitoring, and profit distribution.",
        "long_description": null,
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/a85ke/screenshots/nx70p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a85ke/screenshots/901im/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a85ke/screenshots/62zhq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a85ke/screenshots/0ipsj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a85ke/screenshots/vmmp1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a85ke/screenshots/4jo7e/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/korrio/one-punch-bot",
        "link": "https://ethglobal.com/showcase/moodeng-arbitrageurs-a85ke"
    },
    {
        "title": "Voting with UBI",
        "brief_description": "Equal rights voting mechanism for DAO based on constant emission rate token",
        "long_description": "We want to build a dapp to provide equal rights voting mechanism for everyone. The dapp is applicable for important decision such as to have a consensus decision on what features to be included in future product, or even everyday little thing like voting for where to go for lunch among your colleague. There are 3 roles in the voting mechanism. When a vote is casted, the same amount of token has to be transferred to the voting contract. The token transferred will be locked in the pool for rewards. At the end of the voting round, the proposal with the highest vote will be calculated. 70% of the rewards will be awarded to the proposer and 30% of the reward will be awarded to one of the randomly chosen voter. The project utilises CirclesUBI by Gnosis as the basis for our voting mechanism. Circles provides these features out of the box that suit our use case We uses Circles SDK to create group and invite people into the group via its trust / untrust mechanism. The participants in the group can then use their Circles Currency (CRC) to mint the group token and use that as the voting currency for voting in the group. When a vote is casted, the group token will be sent to our voting contract to be included in the reward pool. The contract is deployed at https://gnosisscan.io/address/0xf85f0661f172128fc55b741e3581009a76eeea85#writeContract. We built a UI using react to facilitate the above. In the admin view, the admin can start or end a vote. In the participant view, the participant can propose an idea. The metadata of the proposal such as the description will be recorded in the contract. The participants can also view the proposed ideas so far and vote for their favourite.",
        "how_its_made": "The project utilises CirclesUBI by Gnosis as the basis for our voting mechanism. Circles provides these features out of the box that suit our use case We uses Circles SDK to create group and invite people into the group via its trust / untrust mechanism. The participants in the group can then use their Circles Currency (CRC) to mint the group token and use that as the voting currency for voting in the group. When a vote is casted, the group token will be sent to our voting contract to be included in the reward pool. The contract is deployed at https://gnosisscan.io/address/0xf85f0661f172128fc55b741e3581009a76eeea85#writeContract. We built a UI using react to facilitate the above. In the admin view, the admin can start or end a vote. In the participant view, the participant can propose an idea. The metadata of the proposal such as the description will be recorded in the contract. The participants can also view the proposed ideas so far and vote for their favourite.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/k56uu/screenshots/izdsy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k56uu/screenshots/q800w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k56uu/screenshots/hai23/default.jpg"
        ],
        "live_demo": "https://ethglobal-lunch.vercel.app/",
        "source_code": "https://github.com/zack-flowdesk/the-late-lunch-club",
        "link": "https://ethglobal.com/showcase/voting-with-ubi-k56uu"
    },
    {
        "title": "Waptcha",
        "brief_description": "Waptcha is a modern anti-bot solution using World ID to verify real humans, offering stronger protection than traditional CAPTCHAs. Easy to integrate with a 3-line JavaScript SDK, it's perfect for sites and apps needing robust security against advanced bots.",
        "long_description": "Waptcha is an innovative solution designed to address the growing challenge of bots infiltrating websites and applications. As traditional CAPTCHA systems like reCAPTCHA and Cloudflare Turnstile become less effective against increasingly sophisticated bots, Waptcha offers a modern, secure alternative by leveraging World ID\u2014a decentralized biometric verification system from Worldcoin. This ensures that the user interacting with a website or app is a real human, not a bot or automated script. Key Features: World ID Verification: Waptcha taps into Worldcoin's biometric technology to provide an additional layer of security. World ID verifies that each user is a unique human through privacy-preserving biometric data. This significantly raises the bar in preventing bots from bypassing verification methods that are easily manipulated by automated systems. JavaScript SDK: Waptcha offers a streamlined integration process with a lightweight JavaScript SDK. Developers can add Waptcha to their applications with only three lines of code, making it easy to adopt without requiring significant development overhead or changes to existing systems. Enhanced Security: Waptcha is particularly well-suited for sites and applications that deal with sensitive data or face high volumes of bot traffic. By using World ID for verification, it provides a more robust defense than traditional CAPTCHA solutions, which can often be bypassed by sophisticated bot networks. This makes Waptcha ideal for businesses and platforms that need to ensure secure, bot-free environments. Privacy-Preserving: While using biometric verification, Waptcha ensures that user privacy is fully protected. World ID operates on a zero-knowledge proof basis, meaning no personal data or biometric information is shared directly with the website or app using Waptcha. This combination of security and privacy creates a trusted, safe interaction environment for users. Applications: High-Security Websites & Apps: Platforms handling sensitive data, financial transactions, or personal information, such as banking or healthcare, benefit from Waptcha's high-security verification. Bot-Prone Platforms: Sites or apps frequently targeted by bots, such as e-commerce, ticketing, or online gaming platforms, can utilize Waptcha to prevent bot-generated fraud, spam, and manipulation. Decentralized Applications (dApps): Given its integration with Worldcoin, Waptcha is well-suited for Web3 applications requiring both high security and privacy. Why Waptcha? As bots evolve, so must security systems. Traditional CAPTCHAs are becoming less reliable, especially as bots can increasingly mimic human behavior. Waptcha offers a next-gen solution, utilizing biometric verification for far more effective bot prevention. Its integration simplicity, combined with enhanced security and privacy protection, makes it a superior choice for modern applications. In a world where security threats are constantly evolving, Waptcha delivers a future-proof solution, ensuring that businesses can maintain the integrity of their platforms without compromising user experience or privacy. Waptcha is a platform designed to prevent bot traffic by utilizing advanced verification technologies. The key components of the platform include Worldcoin's IDKit, Dynamic's SDK, Next.js, and Supabase, all working in harmony to offer a seamless and secure user verification process. All applications integrated with Waptcha will have their requests first verified by the Waptcha platform. This verification process leverages Worldcoin's incognito actions, which are valid for a configurable duration of 24 hours, eliminating the need for users to repeatedly verify through their World App. Once the verification is complete, users are automatically redirected back to the originating application. Waptcha is primarily designed for app developers. Developers can sign up or log in to the Waptcha platform using various authentication mechanisms supported by Dynamic's SDK. Once logged in, they can easily create and manage their Waptchas. Each Waptcha includes a unique waptcha-id and a redirect-to URL, which are used by the Waptcha SDK to handle verification requests. Currently, Waptcha offers a JavaScript SDK, making it easy to integrate into web applications. However, as an API-driven platform, developers are free to build wrapper libraries in other programming languages, further extending its flexibility and reach. For its visual identity, the Waptcha platform leverages the Nouns design system, ensuring a clean, modern, and user-friendly interface that aligns with contemporary design standards.\nIn summary, Waptcha is an innovative and robust solution for developers looking to safeguard their applications from bot activity while providing a frictionless user verification experience.",
        "how_its_made": "Waptcha is a platform designed to prevent bot traffic by utilizing advanced verification technologies. The key components of the platform include Worldcoin's IDKit, Dynamic's SDK, Next.js, and Supabase, all working in harmony to offer a seamless and secure user verification process. All applications integrated with Waptcha will have their requests first verified by the Waptcha platform. This verification process leverages Worldcoin's incognito actions, which are valid for a configurable duration of 24 hours, eliminating the need for users to repeatedly verify through their World App. Once the verification is complete, users are automatically redirected back to the originating application. Waptcha is primarily designed for app developers. Developers can sign up or log in to the Waptcha platform using various authentication mechanisms supported by Dynamic's SDK. Once logged in, they can easily create and manage their Waptchas. Each Waptcha includes a unique waptcha-id and a redirect-to URL, which are used by the Waptcha SDK to handle verification requests. Currently, Waptcha offers a JavaScript SDK, making it easy to integrate into web applications. However, as an API-driven platform, developers are free to build wrapper libraries in other programming languages, further extending its flexibility and reach. For its visual identity, the Waptcha platform leverages the Nouns design system, ensuring a clean, modern, and user-friendly interface that aligns with contemporary design standards.\nIn summary, Waptcha is an innovative and robust solution for developers looking to safeguard their applications from bot activity while providing a frictionless user verification experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/q1aqy/screenshots/ji8vk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q1aqy/screenshots/jbawd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q1aqy/screenshots/m91a3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q1aqy/screenshots/jj2si/default.jpg"
        ],
        "live_demo": "https://waptcha.vercel.app/",
        "source_code": "https://github.com/omnimarket-eth/waptcha",
        "link": "https://ethglobal.com/showcase/waptcha-q1aqy"
    },
    {
        "title": "NTUNouns",
        "brief_description": "As beginners, we worked on a project related to NFT, using nounsDao and our school's art materials, and deployed contracts on the Flow chain. Finally, we deployed our NFT casting page on the website. On the page, you can connect to the wallet, cast our NFT, and transfer it",
        "long_description": "This project is a Non-Fungible Token (NFT) initiative developed on the Flow EVM testnet, adhering to the ERC721 standard. The artistic style draws inspiration from the NounsDAO community, known for its unique and vibrant visual aesthetics. Users can engage in various interactions with the smart contract through a decentralized application (DApp), enhancing the overall user experience and functionality. The smart contract is developed by solidity on Remix IDE,  a typical ERC721 based standard, and deployed on the flow testnet (EVM), enables lower GAS consumptions, faster transactions and better security. Fully decentralized application for primary market selling, which allows users to freemint their NTU-PASS tokens using metamask (whitelisted users can access to the presale), providing more convenience and better experience on assets tracking. As for frontend, our project use NounsDao font and web3.js to interact with smart contract. And we choose metamask as wallet together with Tailwind CSS, particles.js, flask to give a good scene. Finanlly we deploy all these to Render to publish. All the metadatas are constructed using Nouns-art generator and hosted on the decentralized file storage system IPFS. This project is motivated by the fantasitic arts style of NounsDAO community.",
        "how_its_made": "The smart contract is developed by solidity on Remix IDE,  a typical ERC721 based standard, and deployed on the flow testnet (EVM), enables lower GAS consumptions, faster transactions and better security. Fully decentralized application for primary market selling, which allows users to freemint their NTU-PASS tokens using metamask (whitelisted users can access to the presale), providing more convenience and better experience on assets tracking. As for frontend, our project use NounsDao font and web3.js to interact with smart contract. And we choose metamask as wallet together with Tailwind CSS, particles.js, flask to give a good scene. Finanlly we deploy all these to Render to publish. All the metadatas are constructed using Nouns-art generator and hosted on the decentralized file storage system IPFS. This project is motivated by the fantasitic arts style of NounsDAO community.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3q6i0/screenshots/bzxu8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3q6i0/screenshots/96rvp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3q6i0/screenshots/fj9y7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3q6i0/screenshots/zqfu3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/FoeverA0/NTUNouns",
        "link": "https://ethglobal.com/showcase/ntunouns-3q6i0"
    },
    {
        "title": "Fill Me Up",
        "brief_description": "Never worry about gas fees again! Approve funds on one chain and all chains are automatically refilled.",
        "long_description": "Gas cost is annoying!\nYou need to maintain gas on every chain you interact with, and eventually, you'll run out on some of them.\nWith this project, you can approve funds on a single chain. Whenever you're low on gas on any chain, your balance will automatically be filled up using those approved funds. This ensures you only spend the minimum necessary to keep just enough gas on all chains, saving you from the hassle of manual refills. This project utilizes an intermediary contract to which users approve their funds.\nA central service monitors the gas levels of users who have approved funds. When a user's gas is low, the service calls the intermediary contract, which uses the approved allowance to transfer some funds to itself. It then swaps and bridges the funds to the chain that is running low.\nSince the contract can only transfer funds to the same user address on another chain, users maintain complete control and security, with no risk of losing their assets.",
        "how_its_made": "This project utilizes an intermediary contract to which users approve their funds.\nA central service monitors the gas levels of users who have approved funds. When a user's gas is low, the service calls the intermediary contract, which uses the approved allowance to transfer some funds to itself. It then swaps and bridges the funds to the chain that is running low.\nSince the contract can only transfer funds to the same user address on another chain, users maintain complete control and security, with no risk of losing their assets.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9u13c/screenshots/i3t2u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9u13c/screenshots/tqsj4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9u13c/screenshots/b8ytb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9u13c/screenshots/gyhb2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9u13c/screenshots/6xig6/default.jpg"
        ],
        "live_demo": "https://fillmeup-two.vercel.app",
        "source_code": "https://github.com/pauldev20/fillmeup",
        "link": "https://ethglobal.com/showcase/fill-me-up-9u13c"
    },
    {
        "title": "Zkemon",
        "brief_description": "ZKEMON - A Zero-Knowledge Powered Pok\u00e9mon NFT Game. ZKEMON brings a unique fusion of privacy-focused blockchain gaming and advanced ZK cryptography, enabling secure, private, and exciting Pok\u00e9mon battles, breeding, and evolution.",
        "long_description": "ZKEMON is a blockchain-based Pok\u00e9mon NFT game leveraging advanced Zero-Knowledge (ZK) proofs for privacy and security. Players can buy, sell, and trade Pok\u00e9mon NFTs, each with hidden stats accessible only to the owner. Key features include: Evolutions: Pok\u00e9mon evolve over a 6-month period, enhancing their abilities.\nBreeding: Create new Pok\u00e9mon with mixed stats by breeding existing ones.\nBattles: Challenge other players to stat-concealed matches, where winners claim the loser\u2019s NFT.\nAdvanced Privacy: ZK proofs ensure that even the most skilled cryptographers can't trace or reveal hidden stats using EVM tracking.\nCross-Chain Marketplace: Trade Pok\u00e9mon NFTs securely across multiple blockchain networks.\nExperience a new era of gaming with ZKEMON, where strategy, privacy, and ownership intersect in a truly decentralized way. ZKEMON is developed on a blockchain infrastructure, leveraging advanced Zero-Knowledge (ZK) proofs for enhanced privacy and security. The game is built using Solidity, a popular language for writing smart contracts on the Ethereum blockchain, to manage the core game mechanics such as ownership, battles, breeding, and evolution. Each Pok\u00e9mon NFT in ZKEMON is a token that conforms to the ERC-721 standard, ensuring unique ownership and tradability across compatible platforms. The Pok\u00e9mon\u2019s stats (such as attack, defense, and speed) are hidden and stored off-chain using IPFS (InterPlanetary File System), while their visibility is controlled using ZK proofs. Only the rightful owner can view their Pok\u00e9mon\u2019s hidden stats.",
        "how_its_made": "ZKEMON is developed on a blockchain infrastructure, leveraging advanced Zero-Knowledge (ZK) proofs for enhanced privacy and security. The game is built using Solidity, a popular language for writing smart contracts on the Ethereum blockchain, to manage the core game mechanics such as ownership, battles, breeding, and evolution. Each Pok\u00e9mon NFT in ZKEMON is a token that conforms to the ERC-721 standard, ensuring unique ownership and tradability across compatible platforms. The Pok\u00e9mon\u2019s stats (such as attack, defense, and speed) are hidden and stored off-chain using IPFS (InterPlanetary File System), while their visibility is controlled using ZK proofs. Only the rightful owner can view their Pok\u00e9mon\u2019s hidden stats.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/okwef/screenshots/f64x0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/okwef/screenshots/rssrg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/okwef/screenshots/kfuwq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/okwef/screenshots/tt0o7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/okwef/screenshots/dwv9d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/okwef/screenshots/zrvgw/default.jpg"
        ],
        "live_demo": "https://zkemon-ne2rn5dqm-ravi-shankars-projects-cf50f2c9.vercel.app/",
        "source_code": "https://github.com/unspecifiedcoder/ZKMon",
        "link": "https://ethglobal.com/showcase/zkemon-okwef"
    },
    {
        "title": "Ozone Finance",
        "brief_description": "Ozone Protocol: A decentralized aggregation layer for cross-chain liquidity using FROST. Features AI-enhanced DeFi experiences and a complete darkpool based on FHE, TEE, and SGX. Trustless, private, and limitless blockchain interoperability for the future of DeFi",
        "long_description": "Ozone: A Comprehensive Solution for Blockchain Interoperability and Security Core Concept: Ozone is a pioneering platform that addresses two critical challenges in the blockchain ecosystem: security and cross-chain user experience. It serves as a unified solution, tackling these issues simultaneously. Chain Abstraction Service: At its core, Ozone functions as a chain abstraction service. This means it provides a layer that allows seamless interaction between different blockchain networks, abstracting away the complexities of individual chains for the end-user. Decentralized SMPC Network: The platform is built on a decentralized Secure Multi-Party Computation (SMPC) network. This network consists of nodes capable of performing Schnorr signatures on Ethereum Virtual Machine (EVM) compatible chains and other blockchain networks. FROST Implementation: Ozone utilizes a specific SMPC algorithm called FROST (Flexible Round-Optimized Schnorr Threshold Signatures). This threshold signature technique enhances security and efficiency in the decentralized signing process. Bitcoin Bridging Solution: As a proof of concept and initial application, Ozone has developed a Bitcoin bridging solution. This allows for the bridging of native Bitcoin to ten different blockchain networks, creating numerous trading pairs and enhancing liquidity across chains. AI-Enhanced User Experience: Ozone incorporates an AI feature called Natty. This AI bot serves as a guide and teacher for users throughout their cross-chain journey. Natty provides insights, news, and even assists in building orders, making the complex world of cross-chain interactions more accessible to users. Dark Pool Implementation: A key focus of Ozone is the development of a dark pool based on chain abstraction. This feature utilizes advanced technologies such as: TEE , FHE and SGX\nThe purpose of this dark pool is to eliminate order manipulation, front-running, and Miner Extractable Value (MEV) extraction by node operators. This ensures a fair and secure trading environment, particularly for large trades that could otherwise significantly impact the market. Front-end Components: Dashboard swap interface\nWallet connection for source and destination chains\nOrder initiation interface\nBack-end Services: a. Order Book Service: Validates incoming orders\nGenerates and returns deposit addresses for users b. Watcher Service: Monitors for new orders and fund deposits\nNotifies nodes to begin FROST process c. Coordinator Service: Communicates with Ozoners (nodes) using Fully Homomorphic Encryption (FHE)\nPerforms FROST signature aggregation\nCompletes orders and notifies the front-end d. Ozoners (Nodes): Run in Trusted Execution Environments (TEE) using Intel SGX\nPerform order validation\nExecute Schnorr signatures as part of the FROST process\nKey Technologies: FROST (Flexible Round-Optimized Schnorr Threshold Signatures)\nFully Homomorphic Encryption (FHE) for secure communication\nTrusted Execution Environments (TEE) with Intel SGX for secure node operations\nSchnorr signatures for cryptographic signing Process Flow: User initiates order through the front-end\nOrder Book validates and returns deposit address\nUser sends funds (triggered via MetaMask)\nWatcher service detects deposit and triggers FROST process\nOzoners validate and sign the transaction\nCoordinator aggregates signatures and completes the order\nUser is notified of completion AI feature is totally based on Gpt 4o\nI tried working with bert but didnt work out",
        "how_its_made": "Front-end Components: Dashboard swap interface\nWallet connection for source and destination chains\nOrder initiation interface\nBack-end Services: a. Order Book Service: Validates incoming orders\nGenerates and returns deposit addresses for users b. Watcher Service: Monitors for new orders and fund deposits\nNotifies nodes to begin FROST process c. Coordinator Service: Communicates with Ozoners (nodes) using Fully Homomorphic Encryption (FHE)\nPerforms FROST signature aggregation\nCompletes orders and notifies the front-end d. Ozoners (Nodes): Run in Trusted Execution Environments (TEE) using Intel SGX\nPerform order validation\nExecute Schnorr signatures as part of the FROST process\nKey Technologies: FROST (Flexible Round-Optimized Schnorr Threshold Signatures)\nFully Homomorphic Encryption (FHE) for secure communication\nTrusted Execution Environments (TEE) with Intel SGX for secure node operations\nSchnorr signatures for cryptographic signing Process Flow: User initiates order through the front-end\nOrder Book validates and returns deposit address\nUser sends funds (triggered via MetaMask)\nWatcher service detects deposit and triggers FROST process\nOzoners validate and sign the transaction\nCoordinator aggregates signatures and completes the order\nUser is notified of completion AI feature is totally based on Gpt 4o\nI tried working with bert but didnt work out",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ng3r6/screenshots/a9m3t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ng3r6/screenshots/1ouj1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ng3r6/screenshots/du1oq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ng3r6/screenshots/cdsua/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ng3r6/screenshots/w2ag4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ng3r6/screenshots/vwy9n/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jayendramadaram/ozone-front-end",
        "link": "https://ethglobal.com/showcase/ozone-finance-ng3r6"
    },
    {
        "title": "Bonsai",
        "brief_description": "Bonsai is a blockchain-based price prediction platform that allows users to stake cryptocurrency on future price points of various assets. The platform aims to create an engaging, fair, and rewarding environment for price prediction enthusiasts and market analysts.",
        "long_description": null,
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ceaqq/screenshots/tquor/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ceaqq/screenshots/3c19o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ceaqq/screenshots/p0qg4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ceaqq/screenshots/s0ms9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ceaqq/screenshots/exupj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ceaqq/screenshots/t360j/default.jpg"
        ],
        "live_demo": "https://bonsai-demo.vercel.app/",
        "source_code": "https://github.com/ethglobal",
        "link": "https://ethglobal.com/showcase/bonsai-ceaqq"
    },
    {
        "title": "Waste Protocol",
        "brief_description": "Waste Protocol is a blockchain platform enabling real-time tracking and trading of waste materials. Users earn USDC and Waste Tokens for recycling, while carbon emissions are verified and rewarded. Simple, transparent, and bridging Web2 to Web3 for sustainable waste management.",
        "long_description": "Waste Protocol Carbon Credit Marketplace The Waste Protocol Carbon Credit Marketplace is a decentralized platform built to incentivize waste reduction and carbon emission mitigation by creating an integrated ecosystem where waste is exchanged for Waste Coin. Waste Coin can then be used to purchase carbon credits, allowing individuals and organizations to offset their carbon footprint. This circular economy rewards environmentally conscious behavior by linking waste management to carbon offsetting, all powered by blockchain technology for transparency and efficiency. Use Cases:\nFor Households and Individuals:\nBy recycling and managing waste responsibly, individuals can earn Waste Coin, which can be used to buy carbon credits, helping them to offset their carbon footprint.\nThe platform encourages users to take direct action toward sustainability through waste reduction and responsible consumption. For Businesses and Organizations:\nCompanies looking to meet their carbon emission reduction goals can purchase carbon credits directly from the marketplace using Waste Coin.\nThis allows businesses to achieve carbon neutrality while supporting a sustainable waste management ecosystem. For Recyclers and Waste Management Companies:\nRecyclers can use the platform to buy waste materials directly from users and then process the waste responsibly, ensuring that valuable resources are reused rather than discarded. Waste Protocol Carbon Credit Marketplace is built on the Ethereum blockchain using Solidity smart contracts to automate waste transactions, carbon credit purchases, and rewards with Waste Coin. We integrated Chainlink oracles to provide real-time carbon emission data for accurate carbon credit pricing. The platform features a Next.js frontend for a seamless Web2-to-Web3 user experience, with MetaMask integration for easy access. Key Tech Stack: Gas optimization for cost-effective transactions.\nA hybrid approach combining blockchain with manual verification of waste quality.\nThis setup ensures a transparent, efficient, and user-friendly platform that bridges Web2 and Web3 while promoting environmental sustainability.",
        "how_its_made": "Waste Protocol Carbon Credit Marketplace is built on the Ethereum blockchain using Solidity smart contracts to automate waste transactions, carbon credit purchases, and rewards with Waste Coin. We integrated Chainlink oracles to provide real-time carbon emission data for accurate carbon credit pricing. The platform features a Next.js frontend for a seamless Web2-to-Web3 user experience, with MetaMask integration for easy access. Key Tech Stack: Gas optimization for cost-effective transactions.\nA hybrid approach combining blockchain with manual verification of waste quality.\nThis setup ensures a transparent, efficient, and user-friendly platform that bridges Web2 and Web3 while promoting environmental sustainability.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/f1b3o/screenshots/6wyg7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f1b3o/screenshots/e6dqq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f1b3o/screenshots/yoadx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f1b3o/screenshots/p7xiw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f1b3o/screenshots/g81mm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f1b3o/screenshots/iav66/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/WasteProtocol/waste-protocol-backend",
        "link": "https://ethglobal.com/showcase/waste-protocol-f1b3o"
    },
    {
        "title": "Memora",
        "brief_description": "A platform that lets users manage their digital footprints through blockchain-secured NFTs. Link accounts, set conditions for access or closure, and create time capsules. Event-driven actions (e.g., death) trigger automated responses like account deactivation or data transfer.",
        "long_description": "Our platform enables users to manage and preserve their digital footprints securely through blockchain-backed NFTs timecapsules. Users can link various digital accounts (social media, wallet addresses, email, cloud storage) and set specific conditions for transferring, preserving, or terminating access based on life events such as death, marriage, or even job change activity. With AI monitoring agents, the platform continuously tracks account activity, triggering automated actions when predefined events occur. Time capsule NFTs allow users to store digital content and assets that can be unlocked by people that where stetted previously by the owner. NFT (Non-Fungible Tokens ERC721): Time Capsule NFTs are minted on the blockchain to securely store digital assets and grant future access based on life events. These NFTs serve as the core of the digital legacy, with ownership and access rights stored immutably on the blockchain. Blockchain (deployed on Rootst): Smart Contracts written in Solidity enforce the conditions under which these time capsules can be unlocked. This allows for automatic triggers (e.g., a life event like passing away, or a marriage) based on farcaster activity to execute programmed actions such as granting access to this assets to designated individuals. AI Agents using (Gaia net on private node trained by us): AI agents are spawned to monitor life events (e.g., a wedding, passing away) on farcaster and verify that specific triggers occur. These agents act as monitoring systems, the AI models use RAG (Retrieval Augmented Generation) to find relevant events. Multi-Factor Authentication (MFA) with Worldcoin: Human Proof MFA: The process includes multi-factor authentication to confirm identity. This adds a layer of security to the system, ensuring that this NFT's are stamped as a real human NFT's. Event Triggers: The system responds to various event triggers (e.g., a wedding, passing away), which initiate actions in the smart contract. Once verified, actions like granting access to digital accounts or transferring control of the time capsule NFT are executed. Dynamic Account Abstraction: Through Dynamic, an account abstraction technology is likely used to simplify the user experience by allowing seamless interaction without needing users to manage private keys directly.",
        "how_its_made": "NFT (Non-Fungible Tokens ERC721): Time Capsule NFTs are minted on the blockchain to securely store digital assets and grant future access based on life events. These NFTs serve as the core of the digital legacy, with ownership and access rights stored immutably on the blockchain. Blockchain (deployed on Rootst): Smart Contracts written in Solidity enforce the conditions under which these time capsules can be unlocked. This allows for automatic triggers (e.g., a life event like passing away, or a marriage) based on farcaster activity to execute programmed actions such as granting access to this assets to designated individuals. AI Agents using (Gaia net on private node trained by us): AI agents are spawned to monitor life events (e.g., a wedding, passing away) on farcaster and verify that specific triggers occur. These agents act as monitoring systems, the AI models use RAG (Retrieval Augmented Generation) to find relevant events. Multi-Factor Authentication (MFA) with Worldcoin: Human Proof MFA: The process includes multi-factor authentication to confirm identity. This adds a layer of security to the system, ensuring that this NFT's are stamped as a real human NFT's. Event Triggers: The system responds to various event triggers (e.g., a wedding, passing away), which initiate actions in the smart contract. Once verified, actions like granting access to digital accounts or transferring control of the time capsule NFT are executed. Dynamic Account Abstraction: Through Dynamic, an account abstraction technology is likely used to simplify the user experience by allowing seamless interaction without needing users to manage private keys directly.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/77hf8/screenshots/e5f7p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/77hf8/screenshots/9nubs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/77hf8/screenshots/dfzz5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/77hf8/screenshots/b00ny/default.jpg",
            "https://ethglobal.b-cdn.net/projects/77hf8/screenshots/jszue/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Memora-eth",
        "link": "https://ethglobal.com/showcase/memora-77hf8"
    },
    {
        "title": "Snapture",
        "brief_description": "Multisig Smart Contract as a Service for construction. A revolutionary approach to enhancing transparency, and accountability in the construction industry.",
        "long_description": "The construction industry currently faces challenges, particularly in the areas of claim submission and ownership of work.\nOur project aims to build a platform where contractors truly own the work reports they\u2019ve submitted and the tasks they\u2019ve delivered. Consider a world where every claim submitted is securely tracked, with clear ownership and minimal disputes. Our platform introduces a system where client must deposit a specified amount as collateral before engaging contractors. Upon task completion, contractors submit their claims which are recorded using smart contract. We use Sign Protocol to establish our attestation schema and the hook feature to trigger our custom smart contract. The hook contract is implemented to require a predefined threshold of validator signatures. Once the required number of approvals is reached, the contract executes the payout in USDC to the contractor. This mitigates the risk of disputes and advocates trust amongst players since multiple validators contribute to the approval process. To enhance ownership, an NFT will be minted for each completed task. It maps the contractor's identity to the specific task performed, encapsulating essential metadata such as completion timestamps and detailed task descriptions. The NFT will also be a verifiable proof of work for the tender submission.",
        "how_its_made": "Our platform introduces a system where client must deposit a specified amount as collateral before engaging contractors. Upon task completion, contractors submit their claims which are recorded using smart contract. We use Sign Protocol to establish our attestation schema and the hook feature to trigger our custom smart contract. The hook contract is implemented to require a predefined threshold of validator signatures. Once the required number of approvals is reached, the contract executes the payout in USDC to the contractor. This mitigates the risk of disputes and advocates trust amongst players since multiple validators contribute to the approval process. To enhance ownership, an NFT will be minted for each completed task. It maps the contractor's identity to the specific task performed, encapsulating essential metadata such as completion timestamps and detailed task descriptions. The NFT will also be a verifiable proof of work for the tender submission.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fngbn/screenshots/qjesr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fngbn/screenshots/f67cf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fngbn/screenshots/j3zng/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jackht7/ethsg2024",
        "link": "https://ethglobal.com/showcase/snapture-fngbn"
    },
    {
        "title": "Snapture",
        "brief_description": "Multisig Smart Contract as a Service for construction. A revolutionary approach to enhancing transparency, and accountability in the construction industry.",
        "long_description": "The construction industry currently faces challenges, particularly in the areas of claim submission and ownership of work.\nOur project aims to build a platform where contractors truly own the work reports they\u2019ve submitted and the tasks they\u2019ve delivered. Consider a world where every claim submitted is securely tracked, with clear ownership and minimal disputes. Our platform introduces a system where client must deposit a specified amount as collateral before engaging contractors. Upon task completion, contractors submit their claims which are recorded using smart contract. We use Sign Protocol to establish our attestation schema and the hook feature to trigger our custom smart contract. The hook contract is implemented to require a predefined threshold of validator signatures. Once the required number of approvals is reached, the contract executes the payout in USDC to the contractor. This mitigates the risk of disputes and advocates trust amongst players since multiple validators contribute to the approval process. To enhance ownership, an NFT will be minted for each completed task. It maps the contractor's identity to the specific task performed, encapsulating essential metadata such as completion timestamps and detailed task descriptions. The NFT will also be a verifiable proof of work for the tender submission.",
        "how_its_made": "Our platform introduces a system where client must deposit a specified amount as collateral before engaging contractors. Upon task completion, contractors submit their claims which are recorded using smart contract. We use Sign Protocol to establish our attestation schema and the hook feature to trigger our custom smart contract. The hook contract is implemented to require a predefined threshold of validator signatures. Once the required number of approvals is reached, the contract executes the payout in USDC to the contractor. This mitigates the risk of disputes and advocates trust amongst players since multiple validators contribute to the approval process. To enhance ownership, an NFT will be minted for each completed task. It maps the contractor's identity to the specific task performed, encapsulating essential metadata such as completion timestamps and detailed task descriptions. The NFT will also be a verifiable proof of work for the tender submission.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fngbn/screenshots/qjesr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fngbn/screenshots/f67cf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fngbn/screenshots/j3zng/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jackht7/ethsg2024",
        "link": "https://ethglobal.com/showcase/snapture-fngbn"
    },
    {
        "title": "Equitoken",
        "brief_description": "Purchase tokenized stocks and equities from our platform. Buy fractionalized or complete tokenized shares at the best rates.",
        "long_description": "This project allows you to buy tokenized stocks and equities. These stocks are bought off-chain on a broker account and the corresponding number of tokens are minted on user's address on-chain. Users will first have to verify themselves through world-id and then login with their email/phone or their wallet. Users can buy any tokens of their choice and sell them anytime, while the minimum withdrawn amount should be greater than or equal to 50 USDC. Users will first have to verify themselves through World ID, proof of humanhood. Then they can either connect their socials like email/phone etc and generate a new wallet or connect their existing wallet to the project. This is handled by Dynamic Sdk. After that users can purchase any tokenized asset of their choice. These assets are purchased in Alpacca broker account from api calls through Chainlink's Functions and a collateral ration of 200% is maintained on smart contract level such that for every purchase of token there should be more than twice of liquidity should be present in broker's account. This validation is also handled through an on-chain API call. After that the corresponding number of tokens are minted on user's address and they can redeem these tokens whenever they want with a minimum withdrawl amount of 50 USDC.",
        "how_its_made": "Users will first have to verify themselves through World ID, proof of humanhood. Then they can either connect their socials like email/phone etc and generate a new wallet or connect their existing wallet to the project. This is handled by Dynamic Sdk. After that users can purchase any tokenized asset of their choice. These assets are purchased in Alpacca broker account from api calls through Chainlink's Functions and a collateral ration of 200% is maintained on smart contract level such that for every purchase of token there should be more than twice of liquidity should be present in broker's account. This validation is also handled through an on-chain API call. After that the corresponding number of tokens are minted on user's address and they can redeem these tokens whenever they want with a minimum withdrawl amount of 50 USDC.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/7kv6k/screenshots/599ix/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7kv6k/screenshots/3rr95/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7kv6k/screenshots/a9ps9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7kv6k/screenshots/gob51/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7kv6k/screenshots/btdme/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/varunsh20/Equitoken-ETH-Singapore",
        "link": "https://ethglobal.com/showcase/equitoken-7kv6k"
    },
    {
        "title": "BucketReel",
        "brief_description": "Influencer-Inspired Decentralised Travel - A web3 platform where users log in with Reown's AppKit, upload reels to decentralized Pinata, and mint NFTs on the Hedera chain. These NFTs offer travel discounts while users' bucket lists remain private, shared with travel agencies.",
        "long_description": "The project is a decentralised web3 platform that enables users to log in via Reown's AppKit social authentication and upload multimedia content such as reels to Pinata, a decentralized storage network. Each uploaded file's IPFS hash, along with its location coordinates, is used to mint NFTs on the Hedera chain using HTS. These NFTs serve as redeemable tokens for discounts on travel-related purchases from partnered agencies. As part of the platform's travel focus, users can save reels, which automatically adds the associated location\u2019s coordinates and name to a personalised bucket list using HSCS. This bucket list helps users plan trips more efficiently and allows the platform to collaborate with travel agencies by sharing this data, enabling them to better target and market their services using HCS for analytics while ensuring user privacy. This project seeks to combine social media engagement, decentralised content hosting, NFT utility, and travel service partnerships to create a seamless and privacy-centric travel planning experience. The project is built using a mix of decentralized tech and web development tools. Here's how: User Authentication - Reown AppKit: Users log in with social media via Reown AppKit, making onboarding simple without needing wallets. Decentralised Storage - Pinata: Uploaded reels are stored on Pinata using IPFS, ensuring secure, decentralised storage. NFT Minting - Hedera Hashgraph: Every reel upload mints an NFT on the eco-friendly Hedera network using the IPFS hash and location data. These NFTs give users discounts with travel partners. Bucket List: When users save reels, the location gets added to their bucket list, which is shared with travel agencies while protecting privacy. Frontend - React & Tailwind CSS: The interface is built with React for dynamic content and Tailwind CSS for responsive design. Notable Hacks:",
        "how_its_made": "The project is built using a mix of decentralized tech and web development tools. Here's how: User Authentication - Reown AppKit: Users log in with social media via Reown AppKit, making onboarding simple without needing wallets. Decentralised Storage - Pinata: Uploaded reels are stored on Pinata using IPFS, ensuring secure, decentralised storage. NFT Minting - Hedera Hashgraph: Every reel upload mints an NFT on the eco-friendly Hedera network using the IPFS hash and location data. These NFTs give users discounts with travel partners. Bucket List: When users save reels, the location gets added to their bucket list, which is shared with travel agencies while protecting privacy. Frontend - React & Tailwind CSS: The interface is built with React for dynamic content and Tailwind CSS for responsive design. Notable Hacks:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/caqr2/screenshots/g4m57/default.jpg",
            "https://ethglobal.b-cdn.net/projects/caqr2/screenshots/1wdak/default.jpg",
            "https://ethglobal.b-cdn.net/projects/caqr2/screenshots/0ng5s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/caqr2/screenshots/swuq0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/caqr2/screenshots/zmv55/default.jpg",
            "https://ethglobal.b-cdn.net/projects/caqr2/screenshots/jqujg/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Aakash074/bucketreel",
        "link": "https://ethglobal.com/showcase/bucketreel-caqr2"
    },
    {
        "title": "ETH.me",
        "brief_description": "ETH.me: A seamless gateway bridging web2 and web3, with a highly customizatable protocol. Easily link your web2 social profiles or build your business on web3 in a codeless portal. ETH.me is designed with an extra layer of decentralization and reliability.",
        "long_description": "ETH.me is: A seamless Web2 to Web3 Gateway: We provide a direct, seamless bridge between web2 and web3 environments, comparable to services like eth.limo and eth.link. It facilitates easy access to web3 contents directly through browsers. High customizability and web2 friendliness: We designed a customized protocol that personalizes ETH.me's entry points to either web2 URLs or web3 storage. This includes linking social media profiles such as Twitter and GitHub to ENS names or setting up web3 sites with user-selected IPFS gateways, offering freedom for users and businesses to mapping anything from Web2 to Web3 for their ENS names. Decentralized architecture: All interactions with ENS and data redirection are handled client-side, eliminating the need for server-side processing. This approach ensures that users do not have to rely on our platform for data integrity or the availability of backend services on blockchain data processing, enhancing trust and security. User-friendly and codeless: ETH.me is designed to be intuitive and easy to use, requiring no coding skills or client software installations. Users can access and manage their web3 content directly through a browser without a wallet extension, simplifying the transition from traditional web experiences to decentralized technologies. Enhancing the existing ecosystem: ETH.me enriches the Ethereum/ENS ecosystem by offering an alternative web3 portal, providing 1 more choice for users to manage their digital identities and decentralized content, while adding resilience and diversity of the ecosystem. The client side js utilized web3.js to access blockchain, through the Alchemy provider. All ENS data retrieval and redirection processes are executed through client-side JS, ensuring that neither blockchain data nor user browsing data is accessed from the server. This architecture upholds our commitment to decentralization. We integrate The Graph API for its decentralized indexing capabilities, which significantly enhances response times with an additional caching layer. To maintain compatibility with existing ENS gateways, ETH.me supports IPFS for decentralized file storage and access, hosting web3 pages. Additionally, we've developed a customized IPFS gateway, eth2.me, allowing browser access, though users can also opt for other gateways like Infura and IPFS.io.",
        "how_its_made": "The client side js utilized web3.js to access blockchain, through the Alchemy provider. All ENS data retrieval and redirection processes are executed through client-side JS, ensuring that neither blockchain data nor user browsing data is accessed from the server. This architecture upholds our commitment to decentralization. We integrate The Graph API for its decentralized indexing capabilities, which significantly enhances response times with an additional caching layer. To maintain compatibility with existing ENS gateways, ETH.me supports IPFS for decentralized file storage and access, hosting web3 pages. Additionally, we've developed a customized IPFS gateway, eth2.me, allowing browser access, though users can also opt for other gateways like Infura and IPFS.io.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/w2vga/screenshots/8vzrt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w2vga/screenshots/tvm54/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w2vga/screenshots/xucrr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/tf-taxa/ethme-ethglobal",
        "link": "https://ethglobal.com/showcase/eth-me-w2vga"
    },
    {
        "title": "Bucket.Foundation",
        "brief_description": "Bucket provides a research platform with free to read and paid to cite research.",
        "long_description": "Background\nBucket.Foundation is an idea that I have brainstormed in my head for quite some time while in school reading papers and doing independent research. Having an IP Management system was an integral puzzle piece to the fruition of the project so Story had the exact technology that I needed to complete a life project of mine that I deeply care about. Problem\nThere is a high barrier of entry into the research industry due to: Description\nBucket is a platform for free to read and paid to cite research. This allows for an freedom of knowledge that allows all students, curious individuals, or independent researchers to leverage a research system that is not owned by publishing companies that creates innovative inefficiencies. Bucket.foundation cares about the evolution of knowledge and a free to read, pay to cite platform does just that. In this project, I only built the free to read, paid to cite part of the platform, but there is more to come with a a pre-publish peer reviewing system, and a citation market price calculator.  One may wonder why, if the knowledge is available for free on the platform, someone wouldn't just download it and run with it, well, citations are NFT tokens that will have a market value and fluctuate in price based on dimensions such as the quality,  ingenuity, authors, demand (in terms of free nft downloads), and more. Tools and Functionality\nBucket uses Story, Walrus, Dynamic, and Supabase to build a hybrid platform hosted on Vercel.\nStory is used for: User Experience\nDynamic Auth\nButton for Dynamic Auth\nHome Tab\nThe home tab is an explanation of the Bucket Platform for users\nLibrary Tab\nThe Library Tab allows users to browse research IP Assets, mint a free noncommercial nft pdf to read, and mint a paid commercial citation token to be attached to other research IP Assets.\nResearch Tab\nThe Research Tab allows users to upload a title, description, research paper pdf, and citation tokens to a Research IP Asset and Mint/Register/Attach License.\nAssets Tab\nThe assets tab is where users can access all of their Story Protocol NFTs. These include Research IP Assets, Citation Tokens, and Read NFTs. Technologies Used\nNext.js: Chosen for its robust server-side rendering (SSR) capabilities and streamlined routing.\nWalrus: A decentralized storage service and SDK that facilitated efficient data handling in our application.\nDynamic: An incredibly straightforward library that made setup a breeze and greatly enhanced the development experience.\nStory: A powerful technology with some complexities, but with perseverance, we managed to build a solid use case.\nWeb3 & Blockchain: Essential for enabling decentralized features and enhancing security.\nIntegration of Partner Technologies\nDynamic: Setting up Dynamic was super easy, making it a fantastic addition to our stack. Its simplicity allowed us to focus on building features rather than wrestling with complex configurations.\nStory: While Story presented some challenges, with persistence, we navigated its complexities and extracted a solid build. It proved to be a very powerful technology, and I can see myself leveraging it in future projects.\nWalrus: Walrus was an excellent choice as a decentralized storage solution. Once I navigated the initial dense documentation, integrating it into our project was straightforward. While the documentation could be more approachable, the SDK\u2019s capabilities were impressive, and I\u2019d recommend enhancing the docs for better accessibility.\nNotable Hacky Solutions\nBuilding anything in 36 hours is inherently challenging, and our project ended up being a collection of quick fixes and workarounds. We had to throw together some database tables that were poorly designed just to maintain state. Additionally, our entire codebase felt rushed, lacking thorough planning. The UI also took a hit due to the time constraints, but we managed to deliver a functioning prototype despite these hurdles.",
        "how_its_made": "Technologies Used\nNext.js: Chosen for its robust server-side rendering (SSR) capabilities and streamlined routing.\nWalrus: A decentralized storage service and SDK that facilitated efficient data handling in our application.\nDynamic: An incredibly straightforward library that made setup a breeze and greatly enhanced the development experience.\nStory: A powerful technology with some complexities, but with perseverance, we managed to build a solid use case.\nWeb3 & Blockchain: Essential for enabling decentralized features and enhancing security.\nIntegration of Partner Technologies\nDynamic: Setting up Dynamic was super easy, making it a fantastic addition to our stack. Its simplicity allowed us to focus on building features rather than wrestling with complex configurations.\nStory: While Story presented some challenges, with persistence, we navigated its complexities and extracted a solid build. It proved to be a very powerful technology, and I can see myself leveraging it in future projects.\nWalrus: Walrus was an excellent choice as a decentralized storage solution. Once I navigated the initial dense documentation, integrating it into our project was straightforward. While the documentation could be more approachable, the SDK\u2019s capabilities were impressive, and I\u2019d recommend enhancing the docs for better accessibility.\nNotable Hacky Solutions\nBuilding anything in 36 hours is inherently challenging, and our project ended up being a collection of quick fixes and workarounds. We had to throw together some database tables that were poorly designed just to maintain state. Additionally, our entire codebase felt rushed, lacking thorough planning. The UI also took a hit due to the time constraints, but we managed to deliver a functioning prototype despite these hurdles.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/atgp0/screenshots/na63k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/atgp0/screenshots/qgoeh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/atgp0/screenshots/p3hh2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/atgp0/screenshots/p68ye/default.jpg",
            "https://ethglobal.b-cdn.net/projects/atgp0/screenshots/ow9du/default.jpg",
            "https://ethglobal.b-cdn.net/projects/atgp0/screenshots/np787/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/gianyrox/bucket-foundation",
        "link": "https://ethglobal.com/showcase/bucket-foundation-atgp0"
    },
    {
        "title": "zeroDrive",
        "brief_description": "A never-before-seen Web2 drive called zeroDrive. Store and Access your confidential data in purely non-custodial and trustless way.",
        "long_description": "zeroDrive is a web-based app designed to securely store and access users' Web2 confidential data in a trustless and non-custodial manner. When users secure their files, zeroDrive prompts them to provide their MetaMask signature via a browser extension or WalletConnect to encrypt and store the file data. We issue a Proof of Security on the Hedera blockchain, allowing users to verify and ensure the safety of their data. No one other than the user can view or access the file data, as it is encrypted using the user's MetaMask or WalletConnect wallet signature. We also utilize the Sign Protocol if a user wishes to notarize and share a file with another user. The user first authenticates with MetaMask or WalletConnect, and zeroDrive acts as a notary on the user's behalf. Web2 side MERN stack along with MetaMask, WalletConnect, Hedera Chain, Sign Protocol, and IPFS. Partner Technologies: MetaMask and WalletConnect:  Wallets are being used for user authentication and attestation. Whenever a user wants to secure their data, they first sign a unique message. The user's signature acts as a secret key when encrypting the file data using the AES protocol. This encrypted data is stored on IPFS. Hedera Smart Contract Service: The IPFS hash, along with the user's metadata, serves as input when issuing a Proof of Security on Hedera. Sign Protocol: This is used as an attestation protocol, allowing users to attest and verify shared files with each other. NOTE: zeroDrive is trustless and non-custodial, meaning it is fully owned by the users. No one other than the user can access or modify the data, as it is encrypted using the user's wallet unique signature. Even in the absence of the zeroDrive dApp, users will still be able to access their data by following these steps:",
        "how_its_made": "Web2 side MERN stack along with MetaMask, WalletConnect, Hedera Chain, Sign Protocol, and IPFS. Partner Technologies: MetaMask and WalletConnect:  Wallets are being used for user authentication and attestation. Whenever a user wants to secure their data, they first sign a unique message. The user's signature acts as a secret key when encrypting the file data using the AES protocol. This encrypted data is stored on IPFS. Hedera Smart Contract Service: The IPFS hash, along with the user's metadata, serves as input when issuing a Proof of Security on Hedera. Sign Protocol: This is used as an attestation protocol, allowing users to attest and verify shared files with each other. NOTE: zeroDrive is trustless and non-custodial, meaning it is fully owned by the users. No one other than the user can access or modify the data, as it is encrypted using the user's wallet unique signature. Even in the absence of the zeroDrive dApp, users will still be able to access their data by following these steps:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/o11hp/screenshots/txrn9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o11hp/screenshots/hvdmn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o11hp/screenshots/bxus6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o11hp/screenshots/m0zko/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o11hp/screenshots/qh7xo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o11hp/screenshots/4sykz/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/rahulEth/zeroDrive",
        "link": "https://ethglobal.com/showcase/zerodrive-o11hp"
    },
    {
        "title": "ETH_Singapore",
        "brief_description": "A Marketplace for Prompt Secured Through Cross Chain Protocols and Proof of Personhood.",
        "long_description": "This project makes use of proof of personhood to identify to secure and ensure that the prompt is indeed generated by a human. Generates a Proof from the prompt input, send the Prompt Proof along with the World ID and Owner Wallet Address Across multiple networks. Makes use of Mina Protocol to verify the proof. Upon Receiving the message from the target network, it then conducts AI Generated Content (AIGC), loads it up to IPFS and finally stores the information on the receiving network's contract. Because every prompt is tied to a unique human data analytics could be done on the network. We made use of Worldcoin so that we can accurately tell that every input was provided by a human. We made use of Wallet Connect to link the user's wallet. We made use of Layer0 and ChainLink to send the cross-chain message (Proof, World-ID, Wallet Address) over to multiple networks. We do an additional verification with MINA's ZK-Proof Protocol. Then the AIGC kicks in when the target network's contract receives the message. At this point we have locked in the relation of the prompt and the AIGC output. Anyone can purchase the prompt and pay back the owner on his original wallet address. We were running out of time, so we made use of a centralised database.",
        "how_its_made": "We made use of Worldcoin so that we can accurately tell that every input was provided by a human. We made use of Wallet Connect to link the user's wallet. We made use of Layer0 and ChainLink to send the cross-chain message (Proof, World-ID, Wallet Address) over to multiple networks. We do an additional verification with MINA's ZK-Proof Protocol. Then the AIGC kicks in when the target network's contract receives the message. At this point we have locked in the relation of the prompt and the AIGC output. Anyone can purchase the prompt and pay back the owner on his original wallet address. We were running out of time, so we made use of a centralised database.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/r6s8g/screenshots/5e10z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6s8g/screenshots/oea33/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6s8g/screenshots/qwkgh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6s8g/screenshots/92szn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6s8g/screenshots/juq8r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6s8g/screenshots/yxwap/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/9teMare/eth-global-sg-2024/",
        "link": "https://ethglobal.com/showcase/eth-singapore-r6s8g"
    },
    {
        "title": "Safe Wire",
        "brief_description": "SafeWire is a payment dispute infrastructure project. It aims to revolutionize the way online transactions are conducted by providing a secure, fair, and decentralized payment system with built-in dispute resolution mechanisms.",
        "long_description": "SafeWire is an innovative payment dispute infrastructure project developed for the ETHGlobal Hackathon 2024 in Singapore. It aims to revolutionize the way online transactions are conducted by providing a secure, fair, and decentralized payment system with built-in dispute resolution mechanisms.\nAt its core, SafeWire addresses the common issues of trust and security in online transactions. It creates a bridge between buyers and merchants, ensuring that both parties are protected throughout the transaction process. The platform holds payments in escrow for a short period, typically 3-7 days, allowing time for any potential disputes to be raised and resolved.\nKey features of SafeWire include: SafeWire is built using a combination of blockchain technologies, smart contracts, and modern web development frameworks. Here's a breakdown of the key components and technologies used:",
        "how_its_made": "SafeWire is built using a combination of blockchain technologies, smart contracts, and modern web development frameworks. Here's a breakdown of the key components and technologies used:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/foucc/screenshots/2fuf9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/foucc/screenshots/iayio/default.jpg",
            "https://ethglobal.b-cdn.net/projects/foucc/screenshots/47kcm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MrMarciaOng/ethglobal-sg",
        "link": "https://ethglobal.com/showcase/safe-wire-foucc"
    },
    {
        "title": "DecenTRUST",
        "brief_description": "DecenTrust is a decentralized hiring platform powered by Web3. It enables companies to find verified talent through merit-based assessments and rewards applicants with on-chain proof of success, ensuring transparency, fairness, and trust for both employers and employees.",
        "long_description": "Decentralised Transparent Recruitment Under Secure Technology - DecenTRUST DecenTrust revolutionizes the hiring process by eliminating biases, restoring transparency, and empowering applicants and companies alike. Leveraging blockchain technology, DecenTrust ensures every aspect of the job search and hiring process is transparent, verifiable, and fair. Applicants register on the platform, where they undergo skill-based assessments, eliminating traditional biases related to gender, ethnicity, or background. Results from the assessments are securely stored and shared, with the applicant in control of what information to share with potential employers. Successful applicants are rewarded with NFTs, on-chain proof of their skills, giving them undeniable credentials in the digital age. Companies benefit from access to a pool of verified candidates, and by participating in the platform, they build trust through transparent, data-driven hiring practices. The process doesn\u2019t end at hiring\u2014DecenTrust\u2019s smart contracts ensure both employer and employee satisfaction over time, with post-hire checks six months down the line. The platform is built using Web3 tools, ensuring that both sides engage in a trustworthy and merit-based hiring process. Additionally, we\u2019ve integrated a system that allows content creators to contribute and improve the assessments, ensuring relevance and quality over time. DecenTrust is a fusion of cutting-edge Web3 technologies designed to create a fair and transparent hiring ecosystem. By integrating these technologies, DecenTrust ensures the decentralization of data, transparency in hiring, and a reward system that incentivizes both fair hiring practices and merit-based success. The collaboration of blockchain networks enables high scalability and security, while the integration of NFT rewards for applicants adds a unique, verifiable layer of recognition to the job search process.",
        "how_its_made": "DecenTrust is a fusion of cutting-edge Web3 technologies designed to create a fair and transparent hiring ecosystem. By integrating these technologies, DecenTrust ensures the decentralization of data, transparency in hiring, and a reward system that incentivizes both fair hiring practices and merit-based success. The collaboration of blockchain networks enables high scalability and security, while the integration of NFT rewards for applicants adds a unique, verifiable layer of recognition to the job search process.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vwp81/screenshots/ds7wz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vwp81/screenshots/s8bhv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vwp81/screenshots/jjtzi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vwp81/screenshots/3kg65/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vwp81/screenshots/9nmey/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vwp81/screenshots/2rw4h/default.jpg"
        ],
        "live_demo": "https://test-eta-ten-26.vercel.app",
        "source_code": "https://github.com/eesuhn/decentrust",
        "link": "https://ethglobal.com/showcase/decentrust-vwp81"
    },
    {
        "title": "Sortes (ETH Sepolia)",
        "brief_description": "Sortes is a non-profit and trustless lottery build for the network states.",
        "long_description": "Sortes is an lottery built for public good and belongs to the people.\nTapping huge market & treasuries: The global game market is $200 billion, and the international legal/licensed lottery market is $300 billion; within this combined $500 billion, the lucky draw (or gacha) is the critical function that drives user traction, addiction, and payments. However, they all rely on trusted/centralized solutions to generate results, settle charges/rewards, and allocate to social welfare.\nThe people instead of the goveronment should decide how to use charity fund gathered from the lottery. Sortes differs from other lottery systems that are issued and operated by centralized organizations. It's built fully on chain. (Please ensure you're on ETH Sepolia) Uniswap depth WBTC/USDC is used in our protocol to make sure the pool is stable.\nChainlink VRF v2.5 is used to enough fair and transparent randomness source.\nUSDC is used for payment.\nMetamask is used for wallet connect. The generation of its prize pool is achieved in a completely decentralized way: any user can contribute to this prize pool by depositing Bitcoin (wBTC) on the Ethereum blockchain into the contract and directly obtaining the majority of the revenue from lottery sales. When a user deposits wBTC into the prize pool, the contract will issue a corresponding certificate X-WBTC based on the deposited amount. X-WBTC is a deposit certificate obtained after wBTC is deposited and an exchange certificate for withdrawing wBTC from the pool. It is a record-keeping certificate for depositing and withdrawing Bitcoin in the prize pool.",
        "how_its_made": "Sortes differs from other lottery systems that are issued and operated by centralized organizations. It's built fully on chain. (Please ensure you're on ETH Sepolia) Uniswap depth WBTC/USDC is used in our protocol to make sure the pool is stable.\nChainlink VRF v2.5 is used to enough fair and transparent randomness source.\nUSDC is used for payment.\nMetamask is used for wallet connect. The generation of its prize pool is achieved in a completely decentralized way: any user can contribute to this prize pool by depositing Bitcoin (wBTC) on the Ethereum blockchain into the contract and directly obtaining the majority of the revenue from lottery sales. When a user deposits wBTC into the prize pool, the contract will issue a corresponding certificate X-WBTC based on the deposited amount. X-WBTC is a deposit certificate obtained after wBTC is deposited and an exchange certificate for withdrawing wBTC from the pool. It is a record-keeping certificate for depositing and withdrawing Bitcoin in the prize pool.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1q6af/screenshots/oawa6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1q6af/screenshots/cz15g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1q6af/screenshots/2g1ux/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1q6af/screenshots/6do84/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1q6af/screenshots/rdhs8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/lott3ry/sortes",
        "link": "https://ethglobal.com/showcase/sortes-eth-sepolia-1q6af"
    },
    {
        "title": "Hanseek",
        "brief_description": "A blockchain-based verified video review platform for food lovers, rewarding real reviews by real people.",
        "long_description": "Hanseek is a blockchain-based video review platform that restores trust in restaurant recommendations. Reviewers are verified with World ID, ensuring that only real people can post reviews. Reviews are stored on Flow\u2019s blockchain, ensuring transparency and preventing tampering, while Dynamic enables seamless onboarding so users can easily engage in the real world. Demo Video: https://youtu.be/YXiSfdBZOxA\n(this is the real demo video, last project's video misuploaded in \"media upload) Users can browse short video reviews, book restaurants directly, and trust the recommendations they see. Creators earn rewards when users visit a restaurant based on their reviews, and restaurants attract more customers through verified, trusted feedback. We built Hanseek with a consumer experience-first mindset, using technology that ensures anyone can use it with ease in real-world scenarios. Our goal is to make the platform accessible, even for users unfamiliar with blockchain. Dynamic integration simplifies wallet creation, allowing users to sign up with social login and automatically generate a Flow wallet, removing barriers to entry.\nWe use World ID to verify that each review is from a real person, ensuring the authenticity of every review.\nReviews are stored on Flow\u2019s blockchain, guaranteeing transparency and security. Restaurant bookings and payments are processed through Flow\u2019s smart contracts, providing a smooth and familiar experience for all users, regardless of their Web3 knowledge. [Demo Video] https://youtu.be/YXiSfdBZOxA",
        "how_its_made": "We built Hanseek with a consumer experience-first mindset, using technology that ensures anyone can use it with ease in real-world scenarios. Our goal is to make the platform accessible, even for users unfamiliar with blockchain. Dynamic integration simplifies wallet creation, allowing users to sign up with social login and automatically generate a Flow wallet, removing barriers to entry.\nWe use World ID to verify that each review is from a real person, ensuring the authenticity of every review.\nReviews are stored on Flow\u2019s blockchain, guaranteeing transparency and security. Restaurant bookings and payments are processed through Flow\u2019s smart contracts, providing a smooth and familiar experience for all users, regardless of their Web3 knowledge. [Demo Video] https://youtu.be/YXiSfdBZOxA",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/brfdz/screenshots/60q50/default.jpg",
            "https://ethglobal.b-cdn.net/projects/brfdz/screenshots/juqjd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/brfdz/screenshots/hx0f5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/brfdz/screenshots/cs10j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/brfdz/screenshots/iatyg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/brfdz/screenshots/coib6/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Hanseek-crypto/Hanseek-frontend",
        "link": "https://ethglobal.com/showcase/hanseek-brfdz"
    },
    {
        "title": "Veri-Connect",
        "brief_description": "An on-chain business card service with badges that verify your on-chain record",
        "long_description": "Veri-Connect is an on-chain business card service designed for the crypto community. It allows users to verify their identities and wallet records, earn badges based on affiliations (e.g., World ID, ETHGlobal), and create social profiles that can be minted as NFTs. By fostering trusted connections through verifiable credentials, Veri-Connect helps users build credibility and trust within decentralized networks. Veri-Connect uses World ID for proof of humanity, ensuring that users are real individuals while maintaining privacy. Next, connect your wallet through Dynamic to demonstrate your on-chain records. Once your profile is complete, you can earn badges that verify your on-chain records. Each badge is a visualized attestation on the Sign protocol. Our frontend checks if the user is eligible to claim the badges. If eligible, users can claim them independently. These verified profiles can be minted as NFT, creating a secure, trust-based identity system that supports privacy and authenticity. This consumer app also allows users to interact seamlessly, exchange business cards, and form decentralized networks.",
        "how_its_made": "Veri-Connect uses World ID for proof of humanity, ensuring that users are real individuals while maintaining privacy. Next, connect your wallet through Dynamic to demonstrate your on-chain records. Once your profile is complete, you can earn badges that verify your on-chain records. Each badge is a visualized attestation on the Sign protocol. Our frontend checks if the user is eligible to claim the badges. If eligible, users can claim them independently. These verified profiles can be minted as NFT, creating a secure, trust-based identity system that supports privacy and authenticity. This consumer app also allows users to interact seamlessly, exchange business cards, and form decentralized networks.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/cqt04/screenshots/89tob/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cqt04/screenshots/dxw90/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cqt04/screenshots/b1p5o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cqt04/screenshots/ccxv1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cqt04/screenshots/x0sdy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cqt04/screenshots/g4f8j/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/junseom/Veri-Connect",
        "link": "https://ethglobal.com/showcase/veri-connect-cqt04"
    },
    {
        "title": "Traverse",
        "brief_description": "Distributed Reputation System",
        "long_description": "This project develops a blockchain-based rating and reputation system. This project uses Ethereum as a token to incentivize review in the reputation system.",
        "how_its_made": "This project uses Ethereum as a token to incentivize review in the reputation system.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gkjts/screenshots/jv74i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gkjts/screenshots/reqfk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gkjts/screenshots/b4vtw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/3Labs/Traverse",
        "link": "https://ethglobal.com/showcase/traverse-gkjts"
    },
    {
        "title": "AutoRetroFunding",
        "brief_description": "AutoRF is retro funding made simple. Project impact metrics are regularly indexed, which is used to configure on-chain splits contracts to reward projects over regular settlement periods. We launched \u201cThe Grinder\u2019s Fund\u201d, to reward the hardest working projects at ETHGlobal SF.",
        "long_description": "AutoRF is retro funding made simple. We are excited by the promise of retroactive public goods funding to simultaneously support critical public goods, while being a critical part of the growth strategy for crypto ecosystems. However to date, retro funding programs are exceptionally costly to run, which is why most of these programs operate off-chain. In Optimism Retrofunding round 3, it could take badgeholders over 100 hours to diligence and determine payouts. In retro funding round 4, voters started experimenting with using metrics to reduce badgeholder effort. In this hackathon project (AutoRF), we take this further by making retro funding a continuous on-chain process with humans in the loop. Funders can create a continuous funding pool in the app. Funders specify how they want to measure and reward impact, as well as the distribution schedule to eligible projects. Data indexers automatically calculate project impact metrics, which are used to adjust a 0xSplits contract for distributing rewards proportional to impact. We run distributions regularly, adjusting for impact weights as we index new data. We hope to make it trivially easy to operate and scale retro funding rounds for any ecosystem. To show how this can work in practice, we launched \u201cThe Grinder\u2019s Fund\u201d to retroactively reward the hardest working teams at ETHGlobal, with over 60 project signups already on Sunday morning! We index project commit history to calculate metrics that analyze frequency, timing, and size of commits. We lined up funding from Polygon to distribute real rewards ($1000) after the hackathon is over. The application consists of 4 major components:\nWeb application\nAutoRF SDK\nServer-side cron jobs\nOnchain funding contracts Web application:\nThe web app is a Next.js application powered by a Supabase database service. Users log in with GitHub OAuth in order to validate which repositories they have permissions to commit to. Through the app, users can create new / edit funding pools, join existing funding pools, and monitor progress. We introduced a referral link mechanism so that projects can help spread funding pool sign-ups. AutoRF SDK:\nWe implemented a JavaScript package for performing the actions associated with funding pools, including: Server-side cron job:\nThe AutoRF SDK is wrapped in a regular cron job, which regularly indexes data and builds a funding transaction to configure the Splits contract distribution weights. The server will then manage authorizations for the next distribution. Onchain funding contracts:\nWe predominantly use the 0xSplits contracts for custodying funds and managing fund distribution. We also plan to support other money streaming protocols in the future such as Drips and Superfluid.",
        "how_its_made": "The application consists of 4 major components:\nWeb application\nAutoRF SDK\nServer-side cron jobs\nOnchain funding contracts Web application:\nThe web app is a Next.js application powered by a Supabase database service. Users log in with GitHub OAuth in order to validate which repositories they have permissions to commit to. Through the app, users can create new / edit funding pools, join existing funding pools, and monitor progress. We introduced a referral link mechanism so that projects can help spread funding pool sign-ups. AutoRF SDK:\nWe implemented a JavaScript package for performing the actions associated with funding pools, including: Server-side cron job:\nThe AutoRF SDK is wrapped in a regular cron job, which regularly indexes data and builds a funding transaction to configure the Splits contract distribution weights. The server will then manage authorizations for the next distribution. Onchain funding contracts:\nWe predominantly use the 0xSplits contracts for custodying funds and managing fund distribution. We also plan to support other money streaming protocols in the future such as Drips and Superfluid.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bxy5k/screenshots/3fn43/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bxy5k/screenshots/0uxpe/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bxy5k/screenshots/dhsy4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bxy5k/screenshots/cpmtk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bxy5k/screenshots/9izv2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bxy5k/screenshots/5tmt0/default.jpg"
        ],
        "live_demo": "https://retrofunding.vercel.app",
        "source_code": "https://github.com/opensource-observer/ethglobal-sf-2024",
        "link": "https://ethglobal.com/showcase/autoretrofunding-bxy5k"
    },
    {
        "title": "Dextr",
        "brief_description": "A hybrid exchange that minimizes LVR and enables Dynamic Liquidity Rotation which can be used to settle any selected pair order.",
        "long_description": "Two of the main challenges that LPs and DEXs are facing right now are LVR (Loss-versus-Rebalancing) and liquidity which is being locked in a pool. For example, one of my assets can be locked in a pool with low trading volume which can't be used to settle market sectors with high trading volume. Dextr solves both problems by simply trading on the Oracle Price and not the price decided by a curve (as expected with CF-AMMs). Also, using a Singleton Contract allows users to select the price range and the secondary tokens they wish to trade with the primary token. The order matching is happening off-chain by Eigen Layer AVS operators (Othentic) which Brevis Network's on-chain ZK Proof monitors. Any malicious activity by the operators (usually wrong order matching) will result in a slashing of their stake. The LPs are matched based on the REP SBT which is earned by either staking the Protocol Token - DXTR or any other general activity, thus creating a demand for DXTR. I will divide the whole project into 3 parts - Smart Contract -> The smart contracts are built with the help of Foundry. There is a singleton contract that is in charge of all the tokens and liquidity positions of each LP.  The Orderbook maintains all the order-related tasks. There are also a few tokens that can be airdropped via the faucet. Dextr REP is an SBT that determines the LP's eligibility to settle a trade. Oracle Client is basically a mock contract that mimics Supra Oracle Contracts. Off-Chain Components -> There is a backend listener that listens to all the on-chain activity and saves that to the DB. The Oracle Cronjob regularly updates the token prices on the chain. Executioner Service is responsible for all the txs sent to the blockchain. On-Chain Computing -> With the help of Othentic, we can rely on a host of operators that will stake their tokens to the Eigen Protocol and help us settle trades in a decentralized way. While one of the operators settles the trade, other operators can run their algorithm to keep the executioner in check. With Brevis Network, we can prove any historical data on-chain and thus have a tighter grip on the operators.",
        "how_its_made": "I will divide the whole project into 3 parts - Smart Contract -> The smart contracts are built with the help of Foundry. There is a singleton contract that is in charge of all the tokens and liquidity positions of each LP.  The Orderbook maintains all the order-related tasks. There are also a few tokens that can be airdropped via the faucet. Dextr REP is an SBT that determines the LP's eligibility to settle a trade. Oracle Client is basically a mock contract that mimics Supra Oracle Contracts. Off-Chain Components -> There is a backend listener that listens to all the on-chain activity and saves that to the DB. The Oracle Cronjob regularly updates the token prices on the chain. Executioner Service is responsible for all the txs sent to the blockchain. On-Chain Computing -> With the help of Othentic, we can rely on a host of operators that will stake their tokens to the Eigen Protocol and help us settle trades in a decentralized way. While one of the operators settles the trade, other operators can run their algorithm to keep the executioner in check. With Brevis Network, we can prove any historical data on-chain and thus have a tighter grip on the operators.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rqa6t/screenshots/92nfh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rqa6t/screenshots/kdnzd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rqa6t/screenshots/prgm2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rqa6t/screenshots/ny6k7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rqa6t/screenshots/q3xf8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rqa6t/screenshots/vs7qe/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/iamyxsh/eth-singapore-2024/",
        "link": "https://ethglobal.com/showcase/dextr-rqa6t"
    },
    {
        "title": "ChainScore",
        "brief_description": "Our B2B solution tracks contracts and payments , assigning trust scores based on payment reliability to business entities. This boosts transparency, reduces payment risks, and helps businesses choose reliable partners.digital contracts use wallet-based signing and Worldcoin auth",
        "long_description": "This project is a B2B solution designed to build trust in business transactions by leveraging the transparency and reliability of blockchain technology, specifically Ethereum. At its core, the solution retrieves contract agreement data between businesses and tracks on-chain transactions related to payments. Based on the timeliness and reliability of these payments, a trust score is generated. This score reflects the payment behavior of the business, providing an objective and transparent metric for assessing their reliability in future partnerships. One of the key challenges in business-to-business relationships is the lack of transparency and trust regarding payment reliability. Businesses often enter agreements without a clear understanding of their partner's track record for fulfilling payment obligations. Late payments, defaults, and disputes over contract terms lead to financial stress and operational bottlenecks, harming cash flow and business relationships. Our product solves this problem by tracking contract fulfillment and payments in real time on the Ethereum blockchain, which provides an immutable and transparent record of each transaction. By assigning a trust score based on payment behavior, businesses can make more informed decisions when choosing partners, reducing the risk of delayed or missed payments. The trust score is essentially a blockchain-based rating system that reflects the financial reliability of the business. Moreover, the solution integrates digital contract signing features, allowing businesses to sign agreements using their digital wallet. To further enhance security and authenticity, the platform uses Worldcoin authentication, which provides a biometric-backed identity verification system. This ensures that the digital signature on contracts is far more authentic and trustworthy than traditional digital signatures. For Businesses: This solution offers a new way to ensure financial security in business relationships. By knowing a partner's trust score, businesses can minimize the risk of entering into unreliable agreements. It fosters a more transparent and accountable business environment. For Global Trade: In industries where cross-border transactions are common, this trust score can help businesses verify the credibility of overseas partners. It adds a new layer of due diligence that can speed up negotiations and decision-making processes, contributing to faster growth and smoother operations. For Small and Medium Enterprises (SMEs): SMEs often struggle with getting paid on time by larger corporations. This trust score gives them leverage by highlighting their own reliable payment behavior or exposing unreliable partners, helping level the playing field in negotiations. Blockchain provides the transparency and immutability necessary for a system like this. By tracking on-chain transactions, it ensures that trust scores are calculated based on verified data rather than self-reported information. This eliminates the risk of manipulation and provides a fair, objective assessment. The addition of Worldcoin authentication provides an innovative layer of security for contract signing. By using biometric-backed identities, businesses can be sure that contracts are signed by verified, legitimate parties, reducing the chances of fraud or misrepresentation. In summary, this project creates a reliable trust score system for B2B transactions, offering businesses the transparency they need to evaluate potential partners, secure payment obligations, and sign authentic digital contracts. This solution aims to revolutionize how trust is built in the world of business, creating more reliable and transparent business relationships. ChainScore represents a transformative step toward redefining business-to-business (B2B) trust, utilizing blockchain technology to bring transparency, reliability, and automation to transactions.\nCore Technologies Used Polygon was the obvious choice for ChainScore. It\u2019s designed to overcome the high gas fees and scalability issues associated with Ethereum, while still retaining the security and interoperability of Ethereum\u2019s network.\n2.\tSmart Contracts:\nThe entire backbone of ChainScore operates on smart contracts deployed on the Polygon network. These contracts are designed to handle the creation, signing, and verification of agreements between businesses.\n3.\tWorldcoin for Authentication:\nWe leveraged Worldcoin for authentication, allowing us to implement secure, decentralized identity verification.\n4.\tChainlink Automation:\nOne of the more challenging aspects of the project was ensuring that the smart contracts were triggered automatically, without manual intervention, based on external data and events. For this, we employed Chainlink\u2019s automation capabilities.\n5.\tFrontend Integration and User Experience:\nTo handle authentication via Worldcoin and interact with the Polygon blockchain, we utilized Web3.js and ethers.js, both essential libraries for blockchain-based applications.\nChallenges and Hacky Solutions\nBuilding ChainScore was not without its challenges. One notable hurdle was ensuring real-time performance in updating trust scores across a distributed network while minimizing gas costs. To address this, we used a hybrid approach. Trust score calculations are performed off-chain on a dedicated server, and only critical score updates are written to the blockchain. This drastically reduces the frequency of on-chain transactions and thus the associated gas costs.\nAnother hacky but effective solution was in automating contract signing and completion. Initially, we noticed that many businesses were slow to manually execute contracts on the blockchain. To solve this, we used Chainlink Keepers to automate contract execution at predetermined times. This removed the need for businesses to manually close out contracts, ensuring that trust scores were updated promptly.\nPartner Technologies and Their Impact\nUsing Polygon helped us scale while maintaining low transaction costs, allowing even small businesses to interact with the platform without concern over gas fees. Worldcoin simplified authentication by offering a decentralized, privacy-preserving method to onboard users globally without relying on cumbersome traditional KYC processes. And Chainlink\u2019s automation tools were invaluable in making the entire process run smoothly, from automating smart contracts to ensuring real-time trust score updates.\nIn conclusion, ChainScore\u2019s architecture reflects a carefully curated blend of technologies aimed at solving key challenges in the B2B space. The use of blockchain for transparency, automation for efficiency, and decentralized identity verification ensures that ChainScore is a powerful tool for any business looking to build trust in a decentralized economy.",
        "how_its_made": "ChainScore represents a transformative step toward redefining business-to-business (B2B) trust, utilizing blockchain technology to bring transparency, reliability, and automation to transactions.\nCore Technologies Used Polygon was the obvious choice for ChainScore. It\u2019s designed to overcome the high gas fees and scalability issues associated with Ethereum, while still retaining the security and interoperability of Ethereum\u2019s network.\n2.\tSmart Contracts:\nThe entire backbone of ChainScore operates on smart contracts deployed on the Polygon network. These contracts are designed to handle the creation, signing, and verification of agreements between businesses.\n3.\tWorldcoin for Authentication:\nWe leveraged Worldcoin for authentication, allowing us to implement secure, decentralized identity verification.\n4.\tChainlink Automation:\nOne of the more challenging aspects of the project was ensuring that the smart contracts were triggered automatically, without manual intervention, based on external data and events. For this, we employed Chainlink\u2019s automation capabilities.\n5.\tFrontend Integration and User Experience:\nTo handle authentication via Worldcoin and interact with the Polygon blockchain, we utilized Web3.js and ethers.js, both essential libraries for blockchain-based applications.\nChallenges and Hacky Solutions\nBuilding ChainScore was not without its challenges. One notable hurdle was ensuring real-time performance in updating trust scores across a distributed network while minimizing gas costs. To address this, we used a hybrid approach. Trust score calculations are performed off-chain on a dedicated server, and only critical score updates are written to the blockchain. This drastically reduces the frequency of on-chain transactions and thus the associated gas costs.\nAnother hacky but effective solution was in automating contract signing and completion. Initially, we noticed that many businesses were slow to manually execute contracts on the blockchain. To solve this, we used Chainlink Keepers to automate contract execution at predetermined times. This removed the need for businesses to manually close out contracts, ensuring that trust scores were updated promptly.\nPartner Technologies and Their Impact\nUsing Polygon helped us scale while maintaining low transaction costs, allowing even small businesses to interact with the platform without concern over gas fees. Worldcoin simplified authentication by offering a decentralized, privacy-preserving method to onboard users globally without relying on cumbersome traditional KYC processes. And Chainlink\u2019s automation tools were invaluable in making the entire process run smoothly, from automating smart contracts to ensuring real-time trust score updates.\nIn conclusion, ChainScore\u2019s architecture reflects a carefully curated blend of technologies aimed at solving key challenges in the B2B space. The use of blockchain for transparency, automation for efficiency, and decentralized identity verification ensures that ChainScore is a powerful tool for any business looking to build trust in a decentralized economy.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/oj6ja/screenshots/5cuhj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oj6ja/screenshots/vxno7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oj6ja/screenshots/uvqk4/default.jpg"
        ],
        "live_demo": "https://chain-score.vercel.app/",
        "source_code": "https://github.com/apium-io/chain-score",
        "link": "https://ethglobal.com/showcase/chainscore-oj6ja"
    },
    {
        "title": "Keyless",
        "brief_description": "Keyless AI is an AI-powered assistant that simplifies blockchain interactions. Users can perform token swaps, staking, and transfers using natural language. It leverages multi-agent systems to optimize transactions securely, integrating with smart accounts for seamless execution.",
        "long_description": "Keyless AI is an innovative personal assistant designed to make blockchain interactions simple and intuitive. It leverages AI and a multi-agent orchestration system to enable users to perform complex on-chain operations using natural language commands. Instead of interacting with technical blockchain interfaces, users can simply express their intentions in plain language, and Keyless AI translates these requests into a series of precise blockchain actions. At its core, Keyless AI has several key features: Intent-Based User Interface : Users interact with the system by describing their desired outcomes (e.g., \"Send 5 ETH to Alice,\" or \"Invest $1000 in DeFi tokens\"). The AI processes these requests and formulates a strategy for executing the required transactions on-chain. Multi-Agent Orchestration: A dynamic network of AI agents specializes in specific blockchain operations, such as token transfers, staking, swaps, and more. These agents collaborate in real-time, interpreting user intents and coordinating to execute optimized on-chain operations. Smart Account Integration: Currently, Keyless AI integrates with Coinbase smart accounts, allowing secure and flexible management of blockchain transactions. This enables secure custody of user funds while automating transaction management. On-Chain Transaction Batching: The system intelligently bundles multiple actions into optimized transaction sets, reducing gas fees and improving execution efficiency. This feature streamlines interactions, making it ideal for high-volume or complex operations in DeFi. Specialized Agents: Keyless AI comes equipped with a range of specialized agents designed to handle specific tasks like sending tokens, swapping tokens on decentralized exchanges (DEXs), bridging assets across chains, researching token metrics, and managing staking activities. Workflow:\nThe user submits a request using natural language. The system\u2019s Intent Parsing module interprets the input, and relevant AI agents collaborate through Autogen Group Chats to plan and execute the required transactions. These transactions are batched and proposed to the user\u2019s smart account, where they can review and approve them. Once approved, Keyless AI executes the transactions on-chain securely and efficiently. Keyless AI was developed with user security as a priority. It incorporates local private key storage or MPC wallets for signing transactions and includes mandatory user approval for every action before on-chain execution. The system also runs transaction simulations and provides gas estimates to avoid surprises in execution. Why is Keyless AI Important?\nBlockchain\u2019s complexity often presents a barrier to mass adoption, particularly in the DeFi space. Keyless AI aims to reduce this friction by abstracting away the technical details of on-chain operations, enabling both novice and experienced users to interact with decentralized finance (DeFi) and blockchain ecosystems effortlessly. By simplifying and automating processes like token management, staking, and cross-chain interactions, Keyless AI creates a more user-friendly experience, making DeFi and blockchain more accessible. What\u2019s Next?\nWe aim to extend Keyless AI\u2019s capabilities by integrating with additional smart account providers, expanding the ecosystem of specialized agents, and improving the natural language processing to handle even more complex user requests. Keyless AI is built to evolve alongside the rapidly changing blockchain space, becoming a versatile and indispensable tool for both casual and advanced users alike. Ultimately, Keyless AI bridges the gap between user intent and blockchain execution, paving the way for more seamless, intelligent, and accessible interactions within the decentralized economy. Keyless AI was developed using a combination of advanced technologies to create a seamless interaction between users and blockchain operations, focusing on simplicity, efficiency, and security. Here's a breakdown of the key components, technologies, and the structure behind the project: Natural Language Processing (NLP) and Intent Recognition: Keyless AI\u2019s user interface is driven by advanced NLP, enabling users to interact through natural language. By utilizing OpenAI's GPT models, user inputs like \"Send 5 ETH to Alice\" or \"Stake 100 tokens in Compound\" are seamlessly converted into blockchain transactions. This automation eliminates the need for manual navigation of complex blockchain tasks, streamlining the user experience. Tech Stack:\nOpenAI GPT-3/4 for natural language understanding and conversational AI.\nTypeScript for backend integration with blockchain tools.\nPlurality for multi-agent collaboration. Multi-Agent Orchestration System: Keyless AI employs a multi-agent orchestration framework, where specialized AI agents manage distinct blockchain tasks, such as token transfers, staking, or token swapping on decentralized exchanges (DEXs). Agents collaborate via Autogen Group Chats to process user requests efficiently in real-time. Tech Stack: Smart Contract Interaction: For blockchain interaction, Keyless AI integrates web3.js to handle smart contract execution. It supports popular DeFi protocols for token swaps, staking, and other financial services. The system's Coinbase Smart Accounts integration ensures secure and automated fund management, offering users full control of their assets. This streamlined structure enhances user experience by automating complex blockchain interactions while ensuring security and control over assets.\nWe implemented gas fee simulations to notify users of potential cost spikes before transaction approval, utilizing the Etherscan API for real-time gas price tracking. Partner Technologies:\nOpenAI: For NLP and intent recognition.\nCoinbase Smart Accounts: Streamlining blockchain interaction and transaction management.\nEthereum Layer 2 solutions Reducing transaction costs and enhancing scalability.\nMetaMask/WalletConnect: Ensuring secure wallet integration and transaction signing. Challenges Overcome:\nOne major challenge was ensuring that complex multi-step DeFi operations could be executed securely and accurately through natural language commands. To solve this, we created agent collaboration protocols that allowed multiple agents to work together in interpreting and executing the user\u2019s intent. In the end, Keyless AI is a powerful solution built on top of cutting-edge technologies, designed to abstract away the complexity of blockchain while ensuring that users retain full control and security over their transactions.",
        "how_its_made": "Keyless AI was developed using a combination of advanced technologies to create a seamless interaction between users and blockchain operations, focusing on simplicity, efficiency, and security. Here's a breakdown of the key components, technologies, and the structure behind the project: Natural Language Processing (NLP) and Intent Recognition: Keyless AI\u2019s user interface is driven by advanced NLP, enabling users to interact through natural language. By utilizing OpenAI's GPT models, user inputs like \"Send 5 ETH to Alice\" or \"Stake 100 tokens in Compound\" are seamlessly converted into blockchain transactions. This automation eliminates the need for manual navigation of complex blockchain tasks, streamlining the user experience. Tech Stack:\nOpenAI GPT-3/4 for natural language understanding and conversational AI.\nTypeScript for backend integration with blockchain tools.\nPlurality for multi-agent collaboration. Multi-Agent Orchestration System: Keyless AI employs a multi-agent orchestration framework, where specialized AI agents manage distinct blockchain tasks, such as token transfers, staking, or token swapping on decentralized exchanges (DEXs). Agents collaborate via Autogen Group Chats to process user requests efficiently in real-time. Tech Stack: Smart Contract Interaction: For blockchain interaction, Keyless AI integrates web3.js to handle smart contract execution. It supports popular DeFi protocols for token swaps, staking, and other financial services. The system's Coinbase Smart Accounts integration ensures secure and automated fund management, offering users full control of their assets. This streamlined structure enhances user experience by automating complex blockchain interactions while ensuring security and control over assets.\nWe implemented gas fee simulations to notify users of potential cost spikes before transaction approval, utilizing the Etherscan API for real-time gas price tracking. Partner Technologies:\nOpenAI: For NLP and intent recognition.\nCoinbase Smart Accounts: Streamlining blockchain interaction and transaction management.\nEthereum Layer 2 solutions Reducing transaction costs and enhancing scalability.\nMetaMask/WalletConnect: Ensuring secure wallet integration and transaction signing. Challenges Overcome:\nOne major challenge was ensuring that complex multi-step DeFi operations could be executed securely and accurately through natural language commands. To solve this, we created agent collaboration protocols that allowed multiple agents to work together in interpreting and executing the user\u2019s intent. In the end, Keyless AI is a powerful solution built on top of cutting-edge technologies, designed to abstract away the complexity of blockchain while ensuring that users retain full control and security over their transactions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/znz6x/screenshots/cckde/default.jpg",
            "https://ethglobal.b-cdn.net/projects/znz6x/screenshots/uvhed/default.jpg",
            "https://ethglobal.b-cdn.net/projects/znz6x/screenshots/mgp9m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/znz6x/screenshots/dtjrd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/znz6x/screenshots/ayau7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/znz6x/screenshots/vx39w/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/CITGuru/keyless-ai",
        "link": "https://ethglobal.com/showcase/keyless-znz6x"
    },
    {
        "title": "TgMiniApp",
        "brief_description": "This project aims to revolutionize the decentralized finance (DeFi) space by introducing a seamless, one-click DeFi experience through a Telegram mini-app.",
        "long_description": "This project aims to revolutionize the decentralized finance (DeFi) space by introducing a seamless, one-click DeFi experience through a Telegram mini-app. By leveraging the simplicity and convenience of Telegram's interface, users can easily access a wide range of DeFi services such as staking, yield farming, and token swaps without needing to navigate multiple platforms or understand complex blockchain processes. The mini-app simplifies the user journey, making it more accessible for both crypto enthusiasts and newcomers alike. This streamlined approach not only enhances usability but also improves the overall user experience by up to 10 times, reducing friction, saving time, and eliminating the steep learning curve often associated with DeFi products. The integration of DeFi functionalities into a familiar environment like Telegram ensures that users can manage their crypto assets effortlessly while maintaining a high level of security and privacy. This innovative solution is set to democratize DeFi and expand its reach to a broader audience, fostering wider adoption of decentralized financial services. This project aims to revolutionize the decentralized finance (DeFi) space by introducing a seamless, one-click DeFi experience through a Telegram mini-app. By leveraging the simplicity and convenience of Telegram's interface, users can easily access a wide range of DeFi services such as staking, yield farming, and token swaps without needing to navigate multiple platforms or understand complex blockchain processes. The mini-app simplifies the user journey, making it more accessible for both crypto enthusiasts and newcomers alike. This streamlined approach not only enhances usability but also improves the overall user experience by up to 10 times, reducing friction, saving time, and eliminating the steep learning curve often associated with DeFi products. The integration of DeFi functionalities into a familiar environment like Telegram ensures that users can manage their crypto assets effortlessly while maintaining a high level of security and privacy. This innovative solution is set to democratize DeFi and expand its reach to a broader audience, fostering wider adoption of decentralized financial services.",
        "how_its_made": "This project aims to revolutionize the decentralized finance (DeFi) space by introducing a seamless, one-click DeFi experience through a Telegram mini-app. By leveraging the simplicity and convenience of Telegram's interface, users can easily access a wide range of DeFi services such as staking, yield farming, and token swaps without needing to navigate multiple platforms or understand complex blockchain processes. The mini-app simplifies the user journey, making it more accessible for both crypto enthusiasts and newcomers alike. This streamlined approach not only enhances usability but also improves the overall user experience by up to 10 times, reducing friction, saving time, and eliminating the steep learning curve often associated with DeFi products. The integration of DeFi functionalities into a familiar environment like Telegram ensures that users can manage their crypto assets effortlessly while maintaining a high level of security and privacy. This innovative solution is set to democratize DeFi and expand its reach to a broader audience, fostering wider adoption of decentralized financial services.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/k3dt0/screenshots/7cwsm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k3dt0/screenshots/tccmy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k3dt0/screenshots/t8nnh/default.jpg"
        ],
        "live_demo": "https://3jocks.vercel.app/",
        "source_code": "https://github.com/Aman-Mandal/ethonline-mini-app",
        "link": "https://ethglobal.com/showcase/tgminiapp-k3dt0"
    },
    {
        "title": "test",
        "brief_description": "Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time",
        "long_description": "Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time",
        "how_its_made": "Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time Will build next time",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/n36mm/screenshots/ezvcw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n36mm/screenshots/f3vd9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n36mm/screenshots/4i62v/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kamalbuilds/echelon-sdk-aptosmanager",
        "link": "https://ethglobal.com/showcase/test-n36mm"
    },
    {
        "title": "EcoAttest",
        "brief_description": "EcoAttest is a decentralized platform that promotes eco-friendly practices by enabling organizations to host and manage genuine sustainability events. It ensures transparency and accountability through decentralized verification and attestation.",
        "long_description": "EcoAttest is a decentralized platform designed to integrate eco-friendly practices into daily life. It enables organizations to host and manage genuine, sustainable events and activities. Humans can survive 10 days without food, 3 days without water, but only minutes without air. This underscores the urgent need for collective environmental action. While most efforts have been at the individual level, EcoAttest empowers organizations to unite and drive a sustainable future, making eco-friendliness part of everyday life. Sub-organizers manage event attestations, verifying participation through Sign Protocol, ensuring cryptographic verification and transparency for each event participant.\nParticipants submit attestation requests via QR codes, and organizers approve them using schema hooks for secure, modular attestations. Carbon Credit Tokens as Rewards:\nParticipants earn Carbon Credit Tokens via the Hedera Token Service (HTS), representing their involvement in eco-friendly activities.\nThese tokens can be used to purchase eco-friendly items or accumulate for future rewards, incentivizing continued participation. Verifiable Organizations and Sub-Organizers:\nOrganizations and sub-organizers are verified using Schema Hooks on networks like Base Sepolia, ensuring only credible participants can host and manage events, thus preventing fraudulent claims. Computation for Participant Carbon Credit Scores:\nNillion Computation calculates participants' credit scores based on attestations from sub-organizers and event outcomes, ensuring a decentralized and fair reward system. Web3Auth: Simplifies user onboarding by allowing participants to create accounts using social media, such as Google, while securely managing access to the decentralized platform without the complexity of private key management. Hedera Smart Contract Service (HSCS): This is the platform's backbone, responsible for handling all smart contract interactions and transactions. HSCS ensures secure, decentralized management of events, participants, and organizations, maintaining transparent and tamper-proof records on the Hedera network. Sign Protocol: Facilitates cryptographically secure attestations by sub-organizers, verifying participants' involvement in eco-friendly events. This guarantees the authenticity and validity of user contributions, preventing fraudulent activity. Schema Hooks (Base Sepolia): Modular and flexible verification system that ensures sub-organizers and event data are properly vetted before being accepted into the ecosystem. This strengthens the trustworthiness of the platform. Hedera Token Service (HTS): Mints Carbon Credit Tokens as rewards for participants who complete eco-friendly activities. These tokens can purchase discounted eco-friendly items, creating a real-world incentive for sustainable behavior. Nillion: Aggregates data from attestations and uses it to calculate eco-credit scores for participants. This decentralized computation model ensures fairness and transparency in the assessment of users' environmental impact.",
        "how_its_made": "Web3Auth: Simplifies user onboarding by allowing participants to create accounts using social media, such as Google, while securely managing access to the decentralized platform without the complexity of private key management. Hedera Smart Contract Service (HSCS): This is the platform's backbone, responsible for handling all smart contract interactions and transactions. HSCS ensures secure, decentralized management of events, participants, and organizations, maintaining transparent and tamper-proof records on the Hedera network. Sign Protocol: Facilitates cryptographically secure attestations by sub-organizers, verifying participants' involvement in eco-friendly events. This guarantees the authenticity and validity of user contributions, preventing fraudulent activity. Schema Hooks (Base Sepolia): Modular and flexible verification system that ensures sub-organizers and event data are properly vetted before being accepted into the ecosystem. This strengthens the trustworthiness of the platform. Hedera Token Service (HTS): Mints Carbon Credit Tokens as rewards for participants who complete eco-friendly activities. These tokens can purchase discounted eco-friendly items, creating a real-world incentive for sustainable behavior. Nillion: Aggregates data from attestations and uses it to calculate eco-credit scores for participants. This decentralized computation model ensures fairness and transparency in the assessment of users' environmental impact.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wd3jg/screenshots/ermdo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wd3jg/screenshots/tnh80/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wd3jg/screenshots/g2fbj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wd3jg/screenshots/8k7bk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wd3jg/screenshots/mbfqd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wd3jg/screenshots/810x1/default.jpg"
        ],
        "live_demo": "https://eco-attest.vercel.app/",
        "source_code": "https://github.com/FidalMathew/EcoAttest",
        "link": "https://ethglobal.com/showcase/ecoattest-wd3jg"
    },
    {
        "title": "opinion-market",
        "brief_description": "Simple prediction market. It tries to gather user opinion using vanila prediction market.",
        "long_description": "Encrypted Prediction Markets on Fhenix\nDecentralized betting platform using Fully Homomorphic Encryption (FHE) on the Fhenix network.\nKey Features Privacy-preserving betting with FHE\nDecentralized market creation\nBinary outcome betting (support/oppose)\nAutomated settlement and fair payout distribution\nERC20 token integration for bets Tech Stack Solidity 0.8.24\nFhenix Protocol's FHE.sol\nHardhat deployment\nFhenix Testnet Process Deploy market with question and expiry\nUsers place encrypted bets\nSettlement triggered post-expiry\nOutcome determined via decrypted totals\nWinners claim proportional payouts Smart Contract (Solidity 0.8.24): Implements market logic, betting, and settlement\nUses OpenZeppelin for ERC20 interactions and safety checks Fully Homomorphic Encryption (FHE): Leverages Fhenix Protocol's FHE.sol for encrypted operations\nKeeps individual bets and votes private on-chain Custom ERC20 Token: Used for placing bets and distributing winnings Hardhat Development Environment: Compilation, testing, and deployment management\nCustom scripts for deployment and contract verification Fhenix Testnet Deployment: Targets Fhenix network for FHE capabilities\nEthers.js for contract interactions Encrypted Data Structures: Uses euint128 for encrypted integers\nCustom structs combine encrypted and decrypted data Automated Market Settlement: Time-based expiration trigger\nDecrypts totals only at settlement for fair resolution This implementation showcases advanced cryptographic techniques in DeFi,\nenabling private, tamper-resistant prediction markets on blockchain.",
        "how_its_made": "Smart Contract (Solidity 0.8.24): Implements market logic, betting, and settlement\nUses OpenZeppelin for ERC20 interactions and safety checks Fully Homomorphic Encryption (FHE): Leverages Fhenix Protocol's FHE.sol for encrypted operations\nKeeps individual bets and votes private on-chain Custom ERC20 Token: Used for placing bets and distributing winnings Hardhat Development Environment: Compilation, testing, and deployment management\nCustom scripts for deployment and contract verification Fhenix Testnet Deployment: Targets Fhenix network for FHE capabilities\nEthers.js for contract interactions Encrypted Data Structures: Uses euint128 for encrypted integers\nCustom structs combine encrypted and decrypted data Automated Market Settlement: Time-based expiration trigger\nDecrypts totals only at settlement for fair resolution This implementation showcases advanced cryptographic techniques in DeFi,\nenabling private, tamper-resistant prediction markets on blockchain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ikixs/screenshots/w454v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ikixs/screenshots/9uk1z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ikixs/screenshots/8htee/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ShubhamChndrvnshi/prediction-market",
        "link": "https://ethglobal.com/showcase/opinion-market-ikixs"
    },
    {
        "title": "XMTP-P2P",
        "brief_description": "P2P Onramp/Offramp Messaging Bot: Swap fiat and crypto seamlessly.",
        "long_description": "A P2P onramp/offramp messaging bot that enables seamless fiat-to-crypto and crypto-to-fiat swaps. Built using frames, integrated with MessageKit by Converse for secure messaging, and powered by XMTP for decentralized communication. The bot automates escrow handling, matches orders, and ensures secure transactions between users. Used:\n-frames\n-messagekit by converse\n-XMTP",
        "how_its_made": "Used:\n-frames\n-messagekit by converse\n-XMTP",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9dt8d/screenshots/w8k4u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9dt8d/screenshots/62pz2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9dt8d/screenshots/a291e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9dt8d/screenshots/ysokr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9dt8d/screenshots/jq9r6/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/anvaya-labs/xmtp-p2p",
        "link": "https://ethglobal.com/showcase/xmtp-p2p-9dt8d"
    },
    {
        "title": "EpheSafe",
        "brief_description": "EpheSafe: Secure Time-Locked NFT Capsules:- Secure your funds even during hacks!",
        "long_description": "EpheSafe Project Overview: Description: EpheSafe is a decentralized solution designed to enhance wallet security by allowing users to safeguard their assets temporarily in the form of NFTs (Non-Fungible Tokens). Users can lock their tokens or funds (like USDC) within these NFTs for a specified period, during which the assets remain untouchable by any party, including hackers, even if they gain access to the wallet's private key. The project introduces a \"safe\" concept that ensures assets are only claimable after an expiry date. In case of emergency or hacking incidents, the platform also offers an emergency unlock feature to recover funds through multi-signature approvals. Key Features and How it is Made: Safe NFT Creation: Users can create \"safe\" NFTs that lock specific assets (ERC-20 tokens or native currency) for a set duration.\nThe safe contains metadata, including the expiry date, the locked amount, and multi-signature (multi-sig) safe addresses.\nThe locked assets can only be claimed after the expiry period.\nMulti-Sig Approval Mechanism: During the safe NFT creation, the user specifies multiple addresses (multi-sig) to authorize critical actions such as emergency unlocks.\nA defined number of approvals from these addresses is required to perform certain actions, like emergency unlocks.\nEmergency Unlock: If a wallet is compromised, users can initiate an emergency unlock process.\nThis process allows users to transfer their locked assets to a secure address by gaining approvals from the multi-sig addresses.\nOnce the required approvals are met, the funds can be retrieved to a safe address even before the safe's expiry.\nSafe Expiry & Asset Claim: Once the safe reaches its expiry period, users can claim back their assets.\nThe assets can be transferred to the original owner's wallet or any other specified address.\nHacker Mitigation: Even if a hacker gains access to the user's private keys, they cannot transfer the locked NFTs or assets before the expiry period, providing an extra layer of security.\nEmergency Unlock Status Tracking: The emergency unlock mechanism tracks approval statuses and ensures that funds are only released when all required approvals are met.",
        "how_its_made": "Key Features and How it is Made: Safe NFT Creation: Users can create \"safe\" NFTs that lock specific assets (ERC-20 tokens or native currency) for a set duration.\nThe safe contains metadata, including the expiry date, the locked amount, and multi-signature (multi-sig) safe addresses.\nThe locked assets can only be claimed after the expiry period.\nMulti-Sig Approval Mechanism: During the safe NFT creation, the user specifies multiple addresses (multi-sig) to authorize critical actions such as emergency unlocks.\nA defined number of approvals from these addresses is required to perform certain actions, like emergency unlocks.\nEmergency Unlock: If a wallet is compromised, users can initiate an emergency unlock process.\nThis process allows users to transfer their locked assets to a secure address by gaining approvals from the multi-sig addresses.\nOnce the required approvals are met, the funds can be retrieved to a safe address even before the safe's expiry.\nSafe Expiry & Asset Claim: Once the safe reaches its expiry period, users can claim back their assets.\nThe assets can be transferred to the original owner's wallet or any other specified address.\nHacker Mitigation: Even if a hacker gains access to the user's private keys, they cannot transfer the locked NFTs or assets before the expiry period, providing an extra layer of security.\nEmergency Unlock Status Tracking: The emergency unlock mechanism tracks approval statuses and ensures that funds are only released when all required approvals are met.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/o4aab/screenshots/ftqzx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o4aab/screenshots/qizfn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/o4aab/screenshots/md8qe/default.jpg"
        ],
        "live_demo": "https://ephesafe.vercel.app/",
        "source_code": "https://github.com/mbcse/ephesafe",
        "link": "https://ethglobal.com/showcase/ephesafe-o4aab"
    },
    {
        "title": "TelegramHub",
        "brief_description": "Securely store and retrieve encrypted data on the Avail blockchain using a Telegram bot. Built with NestJS, Lit Protocol for encryption, and Polkadot.js for blockchain interactions. Simple, decentralized, and user-friendly! \ud83d\ude80\ud83d\udd12\ud83d\udcf1 #Blockchain #TelegramBot",
        "long_description": "This project is a backend service that facilitates interaction between users and the Avail blockchain via a Telegram bot. The main functionality of the service allows users to securely submit and retrieve encrypted data on the blockchain. Using Lit Protocol for encryption and decryption, the project ensures that data remains private and secure throughout the process. Users interact with the system through a Telegram bot, where they can submit data, encrypted with a public key, which is then stored on the Avail blockchain. Additionally, users can retrieve stored data by providing a transaction hash and decrypt it using their private key. The project integrates Polkadot.js API for communicating with the Avail network and leverages NestJS for the backend structure. Key features include secure data handling, blockchain-based storage, and retrieval, making this project a powerful tool for decentralized applications that require secure and reliable data management. This project was built using a combination of cutting-edge technologies to securely handle data submission and retrieval on the Avail blockchain, all orchestrated through a Telegram bot interface. Here's a breakdown of the key components and how they work together: Backend Framework: NestJS The core of the project is powered by NestJS, a progressive Node.js framework. NestJS was chosen for its modularity, scalability, and support for TypeScript. It helped structure the backend service efficiently, allowing for easy integration with external APIs and services. Blockchain Integration: Avail Blockchain & Polkadot.js API To interact with the Avail blockchain, we utilized the Polkadot.js API. This library enabled us to easily connect to Avail\u2019s decentralized network, submit transactions, and query data from the chain.\nSpecifically, we implemented functionality to:\nSubmit data using Avail's dataAvailability.submitData function.\nRetrieve stored data from the blockchain using transaction hashes. Data Encryption & Decryption: Lit Protocol Lit Protocol was integrated to handle encryption and decryption of the user-submitted data. This ensures that any data stored on the blockchain is encrypted using public keys, and only authorized users with the corresponding private key can decrypt it.\nKey encryption flow:\nUsers provide a public key to encrypt their data before submitting it.\nData is encrypted on the client side using Lit Protocol.\nWhen retrieving data, users provide their private key to decrypt the data after pulling it from the Avail blockchain. Telegram Bot: node-telegram-bot-api We used the node-telegram-bot-api library to create an interface where users can easily interact with the system through Telegram.\nThe bot allows users to:\nSubmit data by providing their public key.\nRetrieve stored data by providing the transaction hash and decrypt it using their private key.\nThis Telegram-based interaction provides a simple and familiar interface for users to interact with the blockchain without needing technical expertise. Hacky Workarounds & Challenges One of the hacky parts of the project was managing asynchronous transaction submissions on the blockchain while maintaining real-time interaction via the Telegram bot. Handling transaction states, including errors or blockchain rejections, and relaying that information back to the user in real-time through the bot required careful handling of async operations and error management.\nWe also had to implement a secure key management system for users to submit their public and private keys in a way that ensured the integrity of the encryption process and prevented any leaks or mishandling of sensitive information. Partner Technologies Lit Protocol was a key partner technology, enabling secure encryption and decryption of data without needing to expose private keys or secrets during the submission or retrieval process.\nAvail blockchain allowed for the decentralized, tamper-proof storage of data, ensuring the integrity and availability of information. By combining these technologies, the project provides a secure and decentralized way to store and retrieve data on the blockchain, all through an easy-to-use Telegram interface.",
        "how_its_made": "This project was built using a combination of cutting-edge technologies to securely handle data submission and retrieval on the Avail blockchain, all orchestrated through a Telegram bot interface. Here's a breakdown of the key components and how they work together: Backend Framework: NestJS The core of the project is powered by NestJS, a progressive Node.js framework. NestJS was chosen for its modularity, scalability, and support for TypeScript. It helped structure the backend service efficiently, allowing for easy integration with external APIs and services. Blockchain Integration: Avail Blockchain & Polkadot.js API To interact with the Avail blockchain, we utilized the Polkadot.js API. This library enabled us to easily connect to Avail\u2019s decentralized network, submit transactions, and query data from the chain.\nSpecifically, we implemented functionality to:\nSubmit data using Avail's dataAvailability.submitData function.\nRetrieve stored data from the blockchain using transaction hashes. Data Encryption & Decryption: Lit Protocol Lit Protocol was integrated to handle encryption and decryption of the user-submitted data. This ensures that any data stored on the blockchain is encrypted using public keys, and only authorized users with the corresponding private key can decrypt it.\nKey encryption flow:\nUsers provide a public key to encrypt their data before submitting it.\nData is encrypted on the client side using Lit Protocol.\nWhen retrieving data, users provide their private key to decrypt the data after pulling it from the Avail blockchain. Telegram Bot: node-telegram-bot-api We used the node-telegram-bot-api library to create an interface where users can easily interact with the system through Telegram.\nThe bot allows users to:\nSubmit data by providing their public key.\nRetrieve stored data by providing the transaction hash and decrypt it using their private key.\nThis Telegram-based interaction provides a simple and familiar interface for users to interact with the blockchain without needing technical expertise. Hacky Workarounds & Challenges One of the hacky parts of the project was managing asynchronous transaction submissions on the blockchain while maintaining real-time interaction via the Telegram bot. Handling transaction states, including errors or blockchain rejections, and relaying that information back to the user in real-time through the bot required careful handling of async operations and error management.\nWe also had to implement a secure key management system for users to submit their public and private keys in a way that ensured the integrity of the encryption process and prevented any leaks or mishandling of sensitive information. Partner Technologies Lit Protocol was a key partner technology, enabling secure encryption and decryption of data without needing to expose private keys or secrets during the submission or retrieval process.\nAvail blockchain allowed for the decentralized, tamper-proof storage of data, ensuring the integrity and availability of information. By combining these technologies, the project provides a secure and decentralized way to store and retrieve data on the blockchain, all through an easy-to-use Telegram interface.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/numqs/screenshots/2c96h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/numqs/screenshots/y9oeu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/numqs/screenshots/wrp29/default.jpg",
            "https://ethglobal.b-cdn.net/projects/numqs/screenshots/wecao/default.jpg",
            "https://ethglobal.b-cdn.net/projects/numqs/screenshots/38grz/default.jpg"
        ],
        "live_demo": "https://custom-auth-telegram-example-two.vercel.app/",
        "source_code": "https://github.com/shahryarbhm/telegram-hub",
        "link": "https://ethglobal.com/showcase/telegramhub-numqs"
    },
    {
        "title": "DigitalWill",
        "brief_description": "The Digital Will DApp allows users to securely manage and distribute their digital assets, such as cryptocurrencies and NFTs, after they pass away. Through this decentralized application, users can create a digital will by specifying assets and beneficiaries, appoint an execut",
        "long_description": "The Digital Will DApp is a decentralized application designed to facilitate the management and transfer of digital assets, such as cryptocurrencies and NFTs, in a secure and transparent manner after a user's death. Utilizing blockchain technology, the application allows users to create a digital will, detailing the allocation of their digital assets to designated beneficiaries. An appointed executor is responsible for carrying out the will\u2019s instructions. The system offers an efficient and tamper-proof solution to digital estate planning, providing peace of mind to users in the management of their online wealth. This innovative approach eliminates the need for intermediaries and ensures that assets are distributed according to the creator\u2019s exact wishes, while also offering privacy and immutability inherent in decentralized systems. What I\u2019ve built is a Digital Will DApp (Decentralized Application) that allows users to create, update, and execute wills for their digital assets on the blockchain. The DApp facilitates the secure transfer of ERC20 tokens (such as cryptocurrencies) and ERC721 tokens (like NFTs) to designated beneficiaries upon the owner's death or incapacitation.",
        "how_its_made": "What I\u2019ve built is a Digital Will DApp (Decentralized Application) that allows users to create, update, and execute wills for their digital assets on the blockchain. The DApp facilitates the secure transfer of ERC20 tokens (such as cryptocurrencies) and ERC721 tokens (like NFTs) to designated beneficiaries upon the owner's death or incapacitation.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/i8nsh/screenshots/be00b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/i8nsh/screenshots/tw1dh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/i8nsh/screenshots/qm019/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Alhibb/DigitalWill",
        "link": "https://ethglobal.com/showcase/digitalwill-i8nsh"
    },
    {
        "title": "Verifit",
        "brief_description": "Verifit: A blockchain-powered fitness app that uses zero-knowledge proofs to verify and tokenize your workout data. Set goals, make accountability bets, and earn NFTs for your achievements\u2014all with privacy-preserving, on-chain proof of your fitness progress.",
        "long_description": "Verifit is an innovative fitness application that leverages blockchain technology, zero-knowledge proofs, and smart contracts to create a trustless, privacy-preserving ecosystem for fitness tracking and goal achievement. User Authentication Data Retrieval with zkFetch On-Chain Attestation Smart Contract Integration NFT Minting Accountability Bets Bet Resolution Privacy Preservation: By using zero-knowledge proofs, Verifit allows users to verify their fitness achievements without revealing sensitive data. Trustless Verification: The use of blockchain and smart contracts eliminates the need for a trusted third party to verify fitness data or resolve bets. Gamification and Incentivization: The combination of NFT rewards and accountability bets creates strong motivators for users to achieve their fitness goals. Immutable Record Keeping: All verified achievements and bet resolutions are recorded on the blockchain, providing an tamper-proof history of user accomplishments. Community Building: The betting system encourages users to engage with each other, fostering a supportive and competitive fitness community. Verifit stands out for its novel application of zero-knowledge proofs in the fitness tracking domain. By combining zkFetch with blockchain technology, it creates a unique solution that addresses both data privacy and verifiability concerns in fitness tracking applications. The project demonstrates how advanced cryptographic techniques can be applied to real-world problems, potentially paving the way for similar privacy-preserving solutions in other domains where data verification is crucial but privacy is a concern. User: Initiates the process by logging in.\nGoogle Authentication: Handles user login.\nVerifit App: The main application interface.\nzkFetch: A tool similar to fetch that returns data with a verifiable ZK proof.\nFitness API: Provides the user's fitness data.\nSign Protocol: Used for attesting the ZK proof.\nBlockchain: Stores attestations, NFTs, and bet data.\nHook Contract: Checks proof verifiability.\nProof Verification: Verifies the ZK proof.\nMint NFT: Creates an NFT with steps count and timestamps.\nCreateBets Contract: Manages accountability bets.\nEnvio:An indexer to query bets",
        "how_its_made": "User: Initiates the process by logging in.\nGoogle Authentication: Handles user login.\nVerifit App: The main application interface.\nzkFetch: A tool similar to fetch that returns data with a verifiable ZK proof.\nFitness API: Provides the user's fitness data.\nSign Protocol: Used for attesting the ZK proof.\nBlockchain: Stores attestations, NFTs, and bet data.\nHook Contract: Checks proof verifiability.\nProof Verification: Verifies the ZK proof.\nMint NFT: Creates an NFT with steps count and timestamps.\nCreateBets Contract: Manages accountability bets.\nEnvio:An indexer to query bets",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dzchy/screenshots/kctq0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dzchy/screenshots/i8goj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dzchy/screenshots/phbr0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dzchy/screenshots/entfq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dzchy/screenshots/2ojdp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dzchy/screenshots/1boib/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AvinashNayak27/ethonline2024",
        "link": "https://ethglobal.com/showcase/verifit-dzchy"
    },
    {
        "title": "Cardits",
        "brief_description": "An application that makes accessing carbon credits easier through consolidating everything into 1 application instead of separate applications for separate countries.",
        "long_description": "An application that addresses both the regulatory and voluntary markets, with being a decentralized way to sell your unused carbon permits (issued by the government) to other blockchain-based companies. We had initially decided to utilize Vue.js for this application but ran into errors with routing. As a result, we pivoted to utilizing a React frontend with MetaMask SDK. MERN, Vue, React, Angular, Solidity, Rust, Python, HTML, CSS (Tailwind, bootstrap), Sepholia, JSON, MetaMask SDKs, NPM.\nWe built this primarily as a prototype and a lot of protocols still need to be added and will be done as time progresses. We plan to present this technology to many others and hopefully it will become an international standard one day.\nhttps://cardits.vercel.com/",
        "how_its_made": "MERN, Vue, React, Angular, Solidity, Rust, Python, HTML, CSS (Tailwind, bootstrap), Sepholia, JSON, MetaMask SDKs, NPM.\nWe built this primarily as a prototype and a lot of protocols still need to be added and will be done as time progresses. We plan to present this technology to many others and hopefully it will become an international standard one day.\nhttps://cardits.vercel.com/",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1nih5/screenshots/81w0n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1nih5/screenshots/nixtb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1nih5/screenshots/008js/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1nih5/screenshots/94np6/default.jpg"
        ],
        "live_demo": "https://cardits.vercel.app/",
        "source_code": "https://github.com/AnshTandon2/cardits",
        "link": "https://ethglobal.com/showcase/cardits-1nih5"
    },
    {
        "title": "MEVCheck",
        "brief_description": "The AI way of tracking MEV Transactions! We are using Graph Neural Networks to ensure better MEV tracking for fair reward distribution among Validators & for comprehensive statistical analysis.",
        "long_description": "We use Graph Neural Networks to track transactions happening on-chain. The project is a comprehensive one & involves 3 separately working parts linked to each other privately & securely using Lit Actions. The first part of the project is the dataset generation. We utilise Powerloom Snapshotters for this. The snapshotters take snap of the epoch from block 15615328 to block 15643187. The snapshotters generate transaction receipts of each transaction that was part of these blocks, the transactions are then sampled into a CSV and labelled as MEV & Non-MEV according to the algo mentioned here. The dataset is then archived onto filecoin using the py-ipfs-client library provided by Powerloom. We made several improvements to the library such as a documentation to use it, added 7 more tests, optimised the code, added error handling & retrying mechanisms & also optimised exceptions handling & logging. Then Lassie can be used by Clients to retrieve the data from Filecoin for training the GNN model. The second part of MEVSPy involves training the GNN using the dataset generated from Part 1. The clients using LIt Actions train securely on their own end the model & sends the results to the server who aggregates them & keeps updating the global parameters. The approach of Federated Learning is utilised here for decentralised training of GNN using Lit Actions & Filecoin. Used- Powerloom Snapshotter Lit Actions Filecoin Storage Galadriel Devnet The project is a comprehensive one & involves 3 separately working parts linked to each other privately & securely using Lit Actions. The first part of the project is the dataset generation. We utilise Powerloom Snapshotters for this. The snapshotters take snap of the epoch from block 15615328 to block 15643187. The snapshotters generate transaction receipts of each transaction that was part of these blocks, the transactions are then sampled into a CSV and labelled as MEV & Non-MEV according to the algo mentioned here. The dataset is then archived onto filecoin using the py-ipfs-client library provided by Powerloom. We made several improvements to the library such as a documentation to use it, added 7 more tests, optimised the code, added error handling & retrying mechanisms & also optimised exceptions handling & logging. Then Lassie can be used by Clients to retrieve the data from Filecoin for training the GNN model. The second part of MEVSPy involves training the GNN using the dataset generated from Part 1. The clients using LIt Actions train securely on their own end the model & sends the results to the server who aggregates them & keeps updating the global parameters. The approach of Federated Learning is utilised here for decentralised training of GNN using Lit Actions & Filecoin.",
        "how_its_made": "Used- Powerloom Snapshotter Lit Actions Filecoin Storage Galadriel Devnet The project is a comprehensive one & involves 3 separately working parts linked to each other privately & securely using Lit Actions. The first part of the project is the dataset generation. We utilise Powerloom Snapshotters for this. The snapshotters take snap of the epoch from block 15615328 to block 15643187. The snapshotters generate transaction receipts of each transaction that was part of these blocks, the transactions are then sampled into a CSV and labelled as MEV & Non-MEV according to the algo mentioned here. The dataset is then archived onto filecoin using the py-ipfs-client library provided by Powerloom. We made several improvements to the library such as a documentation to use it, added 7 more tests, optimised the code, added error handling & retrying mechanisms & also optimised exceptions handling & logging. Then Lassie can be used by Clients to retrieve the data from Filecoin for training the GNN model. The second part of MEVSPy involves training the GNN using the dataset generated from Part 1. The clients using LIt Actions train securely on their own end the model & sends the results to the server who aggregates them & keeps updating the global parameters. The approach of Federated Learning is utilised here for decentralised training of GNN using Lit Actions & Filecoin.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/q9u63/screenshots/aooro/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q9u63/screenshots/jfe0o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q9u63/screenshots/p43z0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/payalkanyan/MEVCheck",
        "link": "https://ethglobal.com/showcase/mevcheck-q9u63"
    },
    {
        "title": "zkAuthX",
        "brief_description": "Easy to integrate ZK Auth SDK powered by Stackr Micro-rollup",
        "long_description": "zkAuthX is an easy-to-integrate ZK Auth SDK powered by Stackr's Micro-rollup. Previously there were many attempts to build ZK-based authentication systems but were very complex and were never used in real-life cases. To bring ZK into mainstream authentication, we have built this ZK Auth SDK, which is very easy to integrate for devs and provides a similar web2 experience to users while using ZK proving systems at the backend. Micro-rollups are used to store all the details about the authentications. We have tried to build a modular infrastructure that can be used to plug in multiple proof markets making it very feasible and cheap. We have also used Plonky2 to generate efficient ZK proofs proving knowledge of passwords. The core ZK circuits were developed with the Plonky2 proving system, which is extremely efficient and generates authentication proofs in milliseconds. To expose these zk crates we have used Rocket API. The micro-rollup was built with Stackr's SDK, written in TS. We have used multiple actions like createService, createUser, newLogin, verifyLogin, etc in out micro-rollup. We have also used events-based tracking of actions to make the API responsive to the UI. The frontend was developed with the React framework.",
        "how_its_made": "The core ZK circuits were developed with the Plonky2 proving system, which is extremely efficient and generates authentication proofs in milliseconds. To expose these zk crates we have used Rocket API. The micro-rollup was built with Stackr's SDK, written in TS. We have used multiple actions like createService, createUser, newLogin, verifyLogin, etc in out micro-rollup. We have also used events-based tracking of actions to make the API responsive to the UI. The frontend was developed with the React framework.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wpbij/screenshots/bpxb6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wpbij/screenshots/1c1ev/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wpbij/screenshots/x2sut/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/armanthepythonguy/zkAuthX-ETHOnline2024",
        "link": "https://ethglobal.com/showcase/zkauthx-wpbij"
    },
    {
        "title": "Persona",
        "brief_description": "Persona makes web3 personalized! We build an infrastructure for web3 personalization, enabling users to create, develop, and leverage their on-chain reputation.",
        "long_description": "Reputation is a key concept deeply embedded in social interactions and relationships. It reflects the collective opinions, beliefs, or perceptions that others hold about an individual or organization, and it plays a crucial role in influencing trust, reliability, and success, especially in the digital age. As the Web3 space rapidly grows\u2014with millions of users, billions of transactions, and countless wallet addresses across various blockchains in a decentralized environment\u2014the need to assess and measure user reputation has become more important than ever. Just as our actions in the real world shape our identity and reputation, our on-chain behavior defines our on-chain identity and reputation. Persona analyzes your on-chain activities and provides a comprehensive dashboard, generating a reputation score using its own algorithm and representing it as a soulbound token. With this, you now have a Web3 identity. Users can leverage this Web3 identity for various purposes. Project owners and communities can utilize reputation scores to build well-qualified and active communities. DeFi protocols, such as lending and borrowing platforms, can assess users based on their on-chain reputation and offer them exclusive opportunities. While building Persona, we focused on several key aspects. A Web3 identity must include comprehensive data to effectively analyze users. It's crucial for us to access large volumes of data quickly and accurately. We prioritize data privacy and decentralized computation during the analysis process. Another important factor is ensuring that a Web3 identity is both verifiable and secure. Envio: We retrieve users' on-chain data in real-time using HyperSync, a feature of Envio. HyperSync is a highly specialized data node built in Rust, designed to massively improve data retrieval speeds while providing flexibility It allows us to receive millions of blocks, logs, and transactions across multiple chains in seconds. Lit Protocol: We use Lit's sealed and confidential hardware to decentralized computation and data privacy. This is accomplished through SEV-SNP, a security feature that AMD created to provide encryption for virtual machines. With this feature, each VM has its unique encryption key, which is managed by a secure processor within the CPU. This hardware encryption ensures that VMs are isolated from each other and from the host, protecting the data and applications running within them. Sign Protocol: We use the Sign Protocol to create on-chain attestations that provide verifiable and trustworthy identities.\nWhen creating soulbound tokens, we use Sign Protocol's schema hooks. If a successful attestation is created with Sign Protocol after all transactions are completed, the SBT contract will be executed through schema hooks. The user then owns a non-transferable NFT that represents their on-chain identity and reputation. If necessary, this can also be used in other chains. If a successful attestation cannot be created, the SBT contract will not be executed, and an ID will not be created for the user.",
        "how_its_made": "While building Persona, we focused on several key aspects. A Web3 identity must include comprehensive data to effectively analyze users. It's crucial for us to access large volumes of data quickly and accurately. We prioritize data privacy and decentralized computation during the analysis process. Another important factor is ensuring that a Web3 identity is both verifiable and secure. Envio: We retrieve users' on-chain data in real-time using HyperSync, a feature of Envio. HyperSync is a highly specialized data node built in Rust, designed to massively improve data retrieval speeds while providing flexibility It allows us to receive millions of blocks, logs, and transactions across multiple chains in seconds. Lit Protocol: We use Lit's sealed and confidential hardware to decentralized computation and data privacy. This is accomplished through SEV-SNP, a security feature that AMD created to provide encryption for virtual machines. With this feature, each VM has its unique encryption key, which is managed by a secure processor within the CPU. This hardware encryption ensures that VMs are isolated from each other and from the host, protecting the data and applications running within them. Sign Protocol: We use the Sign Protocol to create on-chain attestations that provide verifiable and trustworthy identities.\nWhen creating soulbound tokens, we use Sign Protocol's schema hooks. If a successful attestation is created with Sign Protocol after all transactions are completed, the SBT contract will be executed through schema hooks. The user then owns a non-transferable NFT that represents their on-chain identity and reputation. If necessary, this can also be used in other chains. If a successful attestation cannot be created, the SBT contract will not be executed, and an ID will not be created for the user.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/m7zjj/screenshots/m88ve/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m7zjj/screenshots/9fy37/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m7zjj/screenshots/yz2v7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m7zjj/screenshots/66995/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m7zjj/screenshots/amg09/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m7zjj/screenshots/drjj0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/itublockchain/ETHOnline24-1",
        "link": "https://ethglobal.com/showcase/persona-m7zjj"
    },
    {
        "title": "TitanFi",
        "brief_description": "TitanFi: Unlocking Bitcoin DeFi with self-repaying, zero-interest loans and no forced liquidations, empowering users to maximize their crypto assets' potential.",
        "long_description": "TitanFi is a groundbreaking decentralized finance (DeFi) protocol that introduces a paradigm shift in crypto-based lending. Built on the innovative concept of self-repaying loans, TitanFi offers a unique solution that combines the best aspects of traditional finance with the cutting-edge possibilities of blockchain technology. Key Features: Self-Repaying Loans: At the heart of TitanFi is the revolutionary concept of self-repaying loans. Users can borrow against their crypto assets without the burden of manual repayments, as the protocol automatically manages loan settlement over time. Zero Interest: Unlike traditional lending platforms, TitanFi eliminates interest charges, making borrowing more accessible and cost-effective for users by leveraging future yield. No Forced Liquidations: TitanFi provides a safety net for borrowers by removing the risk of forced liquidations, ensuring users maintain control over their assets even in volatile market conditions. Yield Generation: The protocol leverages deposited assets to generate yield, which is used to gradually repay the loans, creating a sustainable ecosystem that benefits both borrowers and liquidity providers. Flexible Collateral Options: TitanFi supports a wide range of crypto assets as collateral, allowing users to unlock the value of their diverse portfolios without selling their holdings. TitanFi aims to democratize access to crypto-based financing, enabling users to leverage their assets efficiently while minimizing risk and maximizing potential returns. TitanFi uses the following core components: TitanFi is built on the Rootstock blockchain, a smart contract platform secured by the Bitcoin network. We chose RSK for its unique combination of Bitcoin's security and Ethereum-compatible smart contracts. Integration details: Smart contracts deployed on RSK handle core functionalities like loan management, yield generation, and token interactions. We utilize RSK's merged mining with Bitcoin to ensure high security for user funds.\nThe platform leverages RSK's fast block times and low transaction fees to provide a smooth user experience. We used Foundry as our smart contract development framework. We have also created custom Foundry scripts to deploy and interact with our contracts on RSK. Our front-end is built with Next.js, providing a fast and SEO-friendly user interface. Integration with RSK: We use ethers.js and wagmi library within our Next.js app to interact with the RSK blockchain and smart contracts. We have also added Sovryn adapters to generate the yield on the deposited assets. Our smart contracts, internally deposit the collateral in the Sovryn Lending Pools to generate the yields which are then used to repay the loan for the user. Feedback for RSK Blockchain: It works seamlessly but sometimes the addresses shown on the RSK testnet explorer fail the address checksum validation when used with the ethers.js library.",
        "how_its_made": "TitanFi uses the following core components: TitanFi is built on the Rootstock blockchain, a smart contract platform secured by the Bitcoin network. We chose RSK for its unique combination of Bitcoin's security and Ethereum-compatible smart contracts. Integration details: Smart contracts deployed on RSK handle core functionalities like loan management, yield generation, and token interactions. We utilize RSK's merged mining with Bitcoin to ensure high security for user funds.\nThe platform leverages RSK's fast block times and low transaction fees to provide a smooth user experience. We used Foundry as our smart contract development framework. We have also created custom Foundry scripts to deploy and interact with our contracts on RSK. Our front-end is built with Next.js, providing a fast and SEO-friendly user interface. Integration with RSK: We use ethers.js and wagmi library within our Next.js app to interact with the RSK blockchain and smart contracts. We have also added Sovryn adapters to generate the yield on the deposited assets. Our smart contracts, internally deposit the collateral in the Sovryn Lending Pools to generate the yields which are then used to repay the loan for the user. Feedback for RSK Blockchain: It works seamlessly but sometimes the addresses shown on the RSK testnet explorer fail the address checksum validation when used with the ethers.js library.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/k1oj6/screenshots/wybf7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k1oj6/screenshots/1ukkd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k1oj6/screenshots/avpco/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k1oj6/screenshots/1ssm7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k1oj6/screenshots/nyzpz/default.jpg"
        ],
        "live_demo": "https://titan-finance.vercel.app/",
        "source_code": "https://github.com/RahulBansal123/titan-finance",
        "link": "https://ethglobal.com/showcase/titanfi-k1oj6"
    },
    {
        "title": "FPSA",
        "brief_description": "Conduct First-Price Sealed-Bid Auctions on-chain using Fhenix",
        "long_description": "The only way to conduct auction on Ethereum is to use commit-reveal method. This results in a liveness problem where the users can choose not to reveal and leave the system confused. Either there can be cut-off time period for revealing but it becomes tricky when conducting second-prize auctions.\nUsing FHE, the two-step process can be merged into one by committing a value as an encrypted bid. We have written a solidity contract to facilitate it. Using Fhenix's FHE library, took bids from users in encrypted form.\nThe contract can compare encrypted bids and declare the bid winner - ideal for sealed bid first price auctions.\nThis can easily be scaled to second-prize auctions and so on. some potential high-stakes use-cases may include on-chain PBS (proposer-builder separation)",
        "how_its_made": "Using Fhenix's FHE library, took bids from users in encrypted form.\nThe contract can compare encrypted bids and declare the bid winner - ideal for sealed bid first price auctions.\nThis can easily be scaled to second-prize auctions and so on. some potential high-stakes use-cases may include on-chain PBS (proposer-builder separation)",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dedqo/screenshots/3nic5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dedqo/screenshots/wnb8o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dedqo/screenshots/xc4ye/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Y5Yash/Fhenix-test",
        "link": "https://ethglobal.com/showcase/fpsa-dedqo"
    },
    {
        "title": "Betinho",
        "brief_description": "Betinho: The ultimate sports betting Telegram Mini App! Seamlessly onboard to Web3, place bets on your favorite teams, stay updated with latest sports news, and chat with fellow bettors - all within Telegram. Experience the future of social sports betting!",
        "long_description": "Betinho is a Telegram Mini App that revolutionizes the sports and entertainment betting experience by seamlessly integrating Web3 technology with the popular messaging platform. Our project aims to make sports betting more accessible, social, and engaging for both cryptocurrency enthusiasts and newcomers to the Web3 space. Core Concept:\nBetinho transforms Telegram into a comprehensive sports betting platform, allowing users to place bets, follow live updates, and interact with other bettors without ever leaving the app. By leveraging Telegram's vast user base and familiar interface, we're bridging the gap between traditional messaging and decentralized betting applications. Key Features: Seamless Web3 Onboarding:\nUtilizes Web3Auth for a frictionless entry into the world of cryptocurrency betting.\nUsers can log in using their existing Google accounts or other social login methods.\nAutomatic wallet creation and management, eliminating the need for users to handle complex crypto wallets. In-App Betting:\nA wide range of sports and entertainment events to bet on.\nReal-time odds updates and live event tracking. News and Updates:\nIntegrated sports news feed to keep users informed about the latest developments.\nPersonalized notifications for favorite teams, players, and upcoming events. Social Betting Experience:\nIn-app chat functionality powered by XMTP for secure, decentralized messaging.\nLeaderboards to gamify the betting experience. Technical Implementation:\nBuilt as a Telegram Mini App for seamless integration within the Telegram ecosystem.\nUtilizes the Chiliz blockchain for fast, low-cost transactions and token management.\nImplements Web3Auth for user authentication and wallet creation.\nIncorporates XMTP for decentralized, secure in-app messaging.\nSmart contracts deployed on the Chiliz Chain to manage bets, payouts, and user data.\nReact-based frontend for an intuitive user interface. User Experience:\nBetinho offers a streamlined user experience that combines the familiarity of Telegram with the excitement of sports betting. Users can easily navigate between chat conversations, betting interfaces, and news updates. The app's design focuses on simplicity, ensuring that even those new to cryptocurrency can participate without feeling overwhelmed by technical complexities. Impact and Potential:\nBy bringing Web3 sports betting to Telegram, Betinho has the potential to introduce millions of users to decentralized applications and cryptocurrency. It serves as a gateway for mainstream adoption of blockchain technology in the betting industry, offering increased transparency, security, and global accessibility. Betinho represents the future of social sports betting, combining the best of Web3 technology with the convenience and reach of Telegram. It's not just a betting app; it's a community-driven platform that makes the excitement of sports wagering accessible to everyone, anywhere in the world. How Betinho was built: Telegram Mini App Framework:\nDeveloped using the Telegram Mini App SDK to create a seamless in-app experience.\nUtilized Vite(React) for building the user interface, ensuring a responsive and interactive design.\nImplemented TailwindCSS for rapid styling and consistent UI components. Web3 Integration and Authentication:\nLeveraged Web3Auth for user onboarding and wallet creation.\nImplemented the Web3Auth PnP No Modal for a customized authentication flow.\nIntegrated the OpenloginAdapter for social login capabilities, allowing users to authenticate with their Google accounts. Blockchain Integration:\nDeployed smart contracts on the Chiliz Chain testnet (Spicy) for managing bets, user balances, and game logic.\nUtilized the Chiliz Chain's native CHZ token for all in-app transactions and betting activities.\nImplemented viem library for interacting with the Chiliz Chain, handling transactions, and reading contract states. Backend Infrastructure:\nDeveloped a Node.js backend to handle off-chain logic, user data management, and serve as an intermediary between the frontend and blockchain.\nUtilized Nitro for creating RESTful APIs to handle betting logic, user profiles, and game management. Real-time Communication:\nIntegrated XMTP (Extensible Message Transport Protocol) for decentralized, secure in-app messaging.\nImplemented real-time updates for live odds, game scores, and betting results using broadcast. Smart Contract Development:\nWrote smart contracts in Solidity, focusing on gas optimization for the Chiliz Chain.\nImplemented a factory pattern for creating individual game contracts, allowing for scalable and isolated betting environments.\nUsed OpenZeppelin libraries for standard token functionalities and security best practices. Frontend State Management:\nUtilized React Context API for global state management, particularly for user authentication status and wallet information.\nImplemented custom hooks (e.g., useAuth) for encapsulating Web3Auth and blockchain interaction logic. Faucet Implementation:\nCreated a custom faucet smart contract on the Chiliz Chain testnet to distribute initial CHZ tokens to new users. Testing and Deployment:\nUtilized Froundry for smart contract testing and deployment to the Chiliz Chain testnet. By leveraging the power of Web3Auth for seamless onboarding, the speed and efficiency of the Chiliz Chain for transactions, and the security of XMTP for messaging, we've created a robust and user-friendly sports betting platform within Telegram. The combination of these technologies allows us to offer a unique, blockchain-powered betting experience that's accessible to both crypto-native users and newcomers alike.",
        "how_its_made": "How Betinho was built: Telegram Mini App Framework:\nDeveloped using the Telegram Mini App SDK to create a seamless in-app experience.\nUtilized Vite(React) for building the user interface, ensuring a responsive and interactive design.\nImplemented TailwindCSS for rapid styling and consistent UI components. Web3 Integration and Authentication:\nLeveraged Web3Auth for user onboarding and wallet creation.\nImplemented the Web3Auth PnP No Modal for a customized authentication flow.\nIntegrated the OpenloginAdapter for social login capabilities, allowing users to authenticate with their Google accounts. Blockchain Integration:\nDeployed smart contracts on the Chiliz Chain testnet (Spicy) for managing bets, user balances, and game logic.\nUtilized the Chiliz Chain's native CHZ token for all in-app transactions and betting activities.\nImplemented viem library for interacting with the Chiliz Chain, handling transactions, and reading contract states. Backend Infrastructure:\nDeveloped a Node.js backend to handle off-chain logic, user data management, and serve as an intermediary between the frontend and blockchain.\nUtilized Nitro for creating RESTful APIs to handle betting logic, user profiles, and game management. Real-time Communication:\nIntegrated XMTP (Extensible Message Transport Protocol) for decentralized, secure in-app messaging.\nImplemented real-time updates for live odds, game scores, and betting results using broadcast. Smart Contract Development:\nWrote smart contracts in Solidity, focusing on gas optimization for the Chiliz Chain.\nImplemented a factory pattern for creating individual game contracts, allowing for scalable and isolated betting environments.\nUsed OpenZeppelin libraries for standard token functionalities and security best practices. Frontend State Management:\nUtilized React Context API for global state management, particularly for user authentication status and wallet information.\nImplemented custom hooks (e.g., useAuth) for encapsulating Web3Auth and blockchain interaction logic. Faucet Implementation:\nCreated a custom faucet smart contract on the Chiliz Chain testnet to distribute initial CHZ tokens to new users. Testing and Deployment:\nUtilized Froundry for smart contract testing and deployment to the Chiliz Chain testnet. By leveraging the power of Web3Auth for seamless onboarding, the speed and efficiency of the Chiliz Chain for transactions, and the security of XMTP for messaging, we've created a robust and user-friendly sports betting platform within Telegram. The combination of these technologies allows us to offer a unique, blockchain-powered betting experience that's accessible to both crypto-native users and newcomers alike.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qzhn3/screenshots/ew9m9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qzhn3/screenshots/at5if/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qzhn3/screenshots/uiw7j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qzhn3/screenshots/ohu3s/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/thiagorochatr/BetDosCria",
        "link": "https://ethglobal.com/showcase/betinho-qzhn3"
    },
    {
        "title": "Betinho",
        "brief_description": "Betinho: The ultimate sports betting Telegram Mini App! Seamlessly onboard to Web3, place bets on your favorite teams, stay updated with latest sports news, and chat with fellow bettors - all within Telegram. Experience the future of social sports betting!",
        "long_description": "Betinho is a Telegram Mini App that revolutionizes the sports and entertainment betting experience by seamlessly integrating Web3 technology with the popular messaging platform. Our project aims to make sports betting more accessible, social, and engaging for both cryptocurrency enthusiasts and newcomers to the Web3 space. Core Concept:\nBetinho transforms Telegram into a comprehensive sports betting platform, allowing users to place bets, follow live updates, and interact with other bettors without ever leaving the app. By leveraging Telegram's vast user base and familiar interface, we're bridging the gap between traditional messaging and decentralized betting applications. Key Features: Seamless Web3 Onboarding:\nUtilizes Web3Auth for a frictionless entry into the world of cryptocurrency betting.\nUsers can log in using their existing Google accounts or other social login methods.\nAutomatic wallet creation and management, eliminating the need for users to handle complex crypto wallets. In-App Betting:\nA wide range of sports and entertainment events to bet on.\nReal-time odds updates and live event tracking. News and Updates:\nIntegrated sports news feed to keep users informed about the latest developments.\nPersonalized notifications for favorite teams, players, and upcoming events. Social Betting Experience:\nIn-app chat functionality powered by XMTP for secure, decentralized messaging.\nLeaderboards to gamify the betting experience. Technical Implementation:\nBuilt as a Telegram Mini App for seamless integration within the Telegram ecosystem.\nUtilizes the Chiliz blockchain for fast, low-cost transactions and token management.\nImplements Web3Auth for user authentication and wallet creation.\nIncorporates XMTP for decentralized, secure in-app messaging.\nSmart contracts deployed on the Chiliz Chain to manage bets, payouts, and user data.\nReact-based frontend for an intuitive user interface. User Experience:\nBetinho offers a streamlined user experience that combines the familiarity of Telegram with the excitement of sports betting. Users can easily navigate between chat conversations, betting interfaces, and news updates. The app's design focuses on simplicity, ensuring that even those new to cryptocurrency can participate without feeling overwhelmed by technical complexities. Impact and Potential:\nBy bringing Web3 sports betting to Telegram, Betinho has the potential to introduce millions of users to decentralized applications and cryptocurrency. It serves as a gateway for mainstream adoption of blockchain technology in the betting industry, offering increased transparency, security, and global accessibility. Betinho represents the future of social sports betting, combining the best of Web3 technology with the convenience and reach of Telegram. It's not just a betting app; it's a community-driven platform that makes the excitement of sports wagering accessible to everyone, anywhere in the world. How Betinho was built: Telegram Mini App Framework:\nDeveloped using the Telegram Mini App SDK to create a seamless in-app experience.\nUtilized Vite(React) for building the user interface, ensuring a responsive and interactive design.\nImplemented TailwindCSS for rapid styling and consistent UI components. Web3 Integration and Authentication:\nLeveraged Web3Auth for user onboarding and wallet creation.\nImplemented the Web3Auth PnP No Modal for a customized authentication flow.\nIntegrated the OpenloginAdapter for social login capabilities, allowing users to authenticate with their Google accounts. Blockchain Integration:\nDeployed smart contracts on the Chiliz Chain testnet (Spicy) for managing bets, user balances, and game logic.\nUtilized the Chiliz Chain's native CHZ token for all in-app transactions and betting activities.\nImplemented viem library for interacting with the Chiliz Chain, handling transactions, and reading contract states. Backend Infrastructure:\nDeveloped a Node.js backend to handle off-chain logic, user data management, and serve as an intermediary between the frontend and blockchain.\nUtilized Nitro for creating RESTful APIs to handle betting logic, user profiles, and game management. Real-time Communication:\nIntegrated XMTP (Extensible Message Transport Protocol) for decentralized, secure in-app messaging.\nImplemented real-time updates for live odds, game scores, and betting results using broadcast. Smart Contract Development:\nWrote smart contracts in Solidity, focusing on gas optimization for the Chiliz Chain.\nImplemented a factory pattern for creating individual game contracts, allowing for scalable and isolated betting environments.\nUsed OpenZeppelin libraries for standard token functionalities and security best practices. Frontend State Management:\nUtilized React Context API for global state management, particularly for user authentication status and wallet information.\nImplemented custom hooks (e.g., useAuth) for encapsulating Web3Auth and blockchain interaction logic. Faucet Implementation:\nCreated a custom faucet smart contract on the Chiliz Chain testnet to distribute initial CHZ tokens to new users. Testing and Deployment:\nUtilized Froundry for smart contract testing and deployment to the Chiliz Chain testnet. By leveraging the power of Web3Auth for seamless onboarding, the speed and efficiency of the Chiliz Chain for transactions, and the security of XMTP for messaging, we've created a robust and user-friendly sports betting platform within Telegram. The combination of these technologies allows us to offer a unique, blockchain-powered betting experience that's accessible to both crypto-native users and newcomers alike.",
        "how_its_made": "How Betinho was built: Telegram Mini App Framework:\nDeveloped using the Telegram Mini App SDK to create a seamless in-app experience.\nUtilized Vite(React) for building the user interface, ensuring a responsive and interactive design.\nImplemented TailwindCSS for rapid styling and consistent UI components. Web3 Integration and Authentication:\nLeveraged Web3Auth for user onboarding and wallet creation.\nImplemented the Web3Auth PnP No Modal for a customized authentication flow.\nIntegrated the OpenloginAdapter for social login capabilities, allowing users to authenticate with their Google accounts. Blockchain Integration:\nDeployed smart contracts on the Chiliz Chain testnet (Spicy) for managing bets, user balances, and game logic.\nUtilized the Chiliz Chain's native CHZ token for all in-app transactions and betting activities.\nImplemented viem library for interacting with the Chiliz Chain, handling transactions, and reading contract states. Backend Infrastructure:\nDeveloped a Node.js backend to handle off-chain logic, user data management, and serve as an intermediary between the frontend and blockchain.\nUtilized Nitro for creating RESTful APIs to handle betting logic, user profiles, and game management. Real-time Communication:\nIntegrated XMTP (Extensible Message Transport Protocol) for decentralized, secure in-app messaging.\nImplemented real-time updates for live odds, game scores, and betting results using broadcast. Smart Contract Development:\nWrote smart contracts in Solidity, focusing on gas optimization for the Chiliz Chain.\nImplemented a factory pattern for creating individual game contracts, allowing for scalable and isolated betting environments.\nUsed OpenZeppelin libraries for standard token functionalities and security best practices. Frontend State Management:\nUtilized React Context API for global state management, particularly for user authentication status and wallet information.\nImplemented custom hooks (e.g., useAuth) for encapsulating Web3Auth and blockchain interaction logic. Faucet Implementation:\nCreated a custom faucet smart contract on the Chiliz Chain testnet to distribute initial CHZ tokens to new users. Testing and Deployment:\nUtilized Froundry for smart contract testing and deployment to the Chiliz Chain testnet. By leveraging the power of Web3Auth for seamless onboarding, the speed and efficiency of the Chiliz Chain for transactions, and the security of XMTP for messaging, we've created a robust and user-friendly sports betting platform within Telegram. The combination of these technologies allows us to offer a unique, blockchain-powered betting experience that's accessible to both crypto-native users and newcomers alike.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qzhn3/screenshots/ew9m9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qzhn3/screenshots/at5if/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qzhn3/screenshots/uiw7j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qzhn3/screenshots/ohu3s/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/thiagorochatr/BetDosCria",
        "link": "https://ethglobal.com/showcase/betinho-qzhn3"
    },
    {
        "title": "Memento app",
        "brief_description": "Memento lets user mint real world objects to an app and then flaunt it at sports events",
        "long_description": "Memento is an iOS app that lets users mint real world objects using NFC chips and add it to their collection.\nYou can then post your moments with these mementos on your social feed. Mementos are ERC-6551 tokenbound NFTs and can hold other sportsFi assets.\nThe backend is mostly Solidity code for the NFTs and registry contracts.\nThe wallet is generated using Web3Auth's Swift SDK. The app is written in Swift and adding an object is done by using a reprogrammable NFC chip. The smart contract involves an ERC 6551 registry contract deployed on the Chiliz Spicy Testnet as it is not native to the Chiliz blockchain so we had to deploy our own.\nFor embedded wallets we are using Web3Auth's Swift SDK to generate accounts.",
        "how_its_made": "The app is written in Swift and adding an object is done by using a reprogrammable NFC chip. The smart contract involves an ERC 6551 registry contract deployed on the Chiliz Spicy Testnet as it is not native to the Chiliz blockchain so we had to deploy our own.\nFor embedded wallets we are using Web3Auth's Swift SDK to generate accounts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sq3o0/screenshots/0jpcq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sq3o0/screenshots/f9ggs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sq3o0/screenshots/ee4t3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sq3o0/screenshots/chqf5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/aloksahay/ETHOnline2024",
        "link": "https://ethglobal.com/showcase/memento-app-sq3o0"
    },
    {
        "title": "Lit Alpha Box",
        "brief_description": "Lit Alpha Box let users submit encrypted predictions in order to gain access to AI aggregated insights from other users.",
        "long_description": "Lit Alpha Box is a decentralized application that harnesses the wisdom of crowds to generate collective predictions for cryptocurrency projects. Users submit encrypted predictions, and mint NFTs in order to unlock access to a Lit Action which uses OpenAI to aggregate insights from other users. The problem it tries to solve is addressing the fact that in public discourse people might be unwilling to share their opinions about markets, or opinion might be swayed by the loudest or most confident voices.  By allowing people to privately submit their predictions you hopefully can get a better picture of the true views of people.  Additional incentive mechanisms might be needed to properly incentivize users to submit honest input. The project lets users encrypt data using Lit Protocol, which is then stored in a Supabase database.  After encrypting data they can mint an NFT, which gives them access to make another Lit Protocol call which aggregates the predictions from multiple users and uses the OpenAI API to decrypt and aggregate the data inside a Lit action.",
        "how_its_made": "The project lets users encrypt data using Lit Protocol, which is then stored in a Supabase database.  After encrypting data they can mint an NFT, which gives them access to make another Lit Protocol call which aggregates the predictions from multiple users and uses the OpenAI API to decrypt and aggregate the data inside a Lit action.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3ws9q/screenshots/kgg4c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3ws9q/screenshots/pftdp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3ws9q/screenshots/dj8yz/default.jpg"
        ],
        "live_demo": "https://lit-alpha-box.vercel.app/",
        "source_code": "https://github.com/tms7331/lit-alpha-box",
        "link": "https://ethglobal.com/showcase/lit-alpha-box-3ws9q"
    },
    {
        "title": "CryptoQuest League",
        "brief_description": "XMTP-powered group chat bot for DeFi-themed riddles. Solve DeFi puzzles, form teams, compete on the global leaderboard and earn on-chain points.",
        "long_description": "CryptoQuest League is an interactive, educational group chatbot designed to make learning about decentralized finance (DeFi) fun and engaging. It turns the complex world of DeFi into an exciting game where players solve puzzles, compete in teams, and earn on-chain points. DeFi-Themed Puzzles: Regular crypto and DeFi-related riddles that challenge and educate players. Team-Based Competition: Users can form teams to collaborate on solving puzzles, fostering a community of learners and winning together. On-Chain Points System: Points earned from solving puzzles are recorded on the blockchain using Stack Network and can be later used to distribute rewards to the winning teams in a transparent manner. Real-Time Leaderboard: A live, blockchain-based leaderboard showcases top-performing teams and individuals. Daily DeFi Insights: Brief, educational snippets about various DeFi concepts are shared regularly, enhancing the learning experience. Group Chat Integration: Seamlessly works within group chats, making it easy for teams to discuss and solve puzzles together. NFT Rewards: Implement a system to mint and distribute NFTs as rewards for significant achievements. Defi-Track Rewards: Implement trackers that track the transactions of the users and reward them more points based on it. CryptoQuest League is heavily based on @xmtp. It utilises the MessageKit for building the group messaging bot on top of XMTP. XMTP Stack Network Converse Firebase",
        "how_its_made": "CryptoQuest League is heavily based on @xmtp. It utilises the MessageKit for building the group messaging bot on top of XMTP. XMTP Stack Network Converse Firebase",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/j27qf/screenshots/80o4k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j27qf/screenshots/k0w3o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j27qf/screenshots/w155q/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Architsharma7/ethonline-24",
        "link": "https://ethglobal.com/showcase/cryptoquest-league-j27qf"
    },
    {
        "title": "Fresh Finds Gardens",
        "brief_description": "Beginner here creating a dApp using a verified social login.",
        "long_description": "This project creates an opportunity for backyard gardeners to post vegetable produce.\nSocial login will add verification to the dApp for both gardeners and consumers wanting to purchase fresh produce.  This service will blend nicely with eco tourism as a garden tour feature can be an optional feature. This project uses Web3 Auth for social login to an app for backyard gardeners and consumers wanting to buy fresh produce.  A location service filter can be applied in the future to generalize the garden location until actual purchase is made.  This project will help the average person who is willing to sell their garden produce.  Since this dApp can be used anywhere in the world, it is perfect for eco tourism.  With blockchain tracking of transactions, a backyard gardener can build a social reputation which lends itself to trust.",
        "how_its_made": "This project uses Web3 Auth for social login to an app for backyard gardeners and consumers wanting to buy fresh produce.  A location service filter can be applied in the future to generalize the garden location until actual purchase is made.  This project will help the average person who is willing to sell their garden produce.  Since this dApp can be used anywhere in the world, it is perfect for eco tourism.  With blockchain tracking of transactions, a backyard gardener can build a social reputation which lends itself to trust.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t86au/screenshots/1b490/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t86au/screenshots/xmgdz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t86au/screenshots/bpuue/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ethglobal",
        "link": "https://ethglobal.com/showcase/fresh-finds-gardens-t86au"
    },
    {
        "title": "Fantoz",
        "brief_description": "Fantoz : Fan token gated flash drops powered by chiliz chain",
        "long_description": "This project is a blockchain-powered platform that introduces Token-Gated Flash Drops, a revolutionary way for clubs and organizations to engage with their most loyal fans. Built on the Chiliz blockchain, the platform allows fans to access exclusive, time-sensitive offers and rewards by owning specific fan tokens. These tokens unlock limited-time opportunities that can include rare merchandise, event tickets, exclusive content, and more. The platform aims to bridge the gap between clubs and their fan base by leveraging decentralization to offer transparent, secure, and verifiable fan engagement. Each fan token acts as a gateway to these exclusive drops, ensuring that only the most devoted supporters can claim the rewards. The use of smart contracts on the Chiliz blockchain ensures that all transactions are trustless, efficient, and immutable, providing a seamless experience for both fans and clubs. ~ Contract Address : [ 0xc7B4fEb57eaDDD5A48786daF64f191F258157aA1 ] For the frontend, we used Next.js, which ensures the website loads quickly and performs well even under heavy use. Tailwind CSS was used to style the website, helping us quickly build a clean and responsive design. To make the site more interactive, we added animations using Framer Motion, giving users a smooth and engaging experience. On the blockchain side, we developed the smart contracts using Solidity. These contracts manage the logic of fan tokens and determine who is eligible for the exclusive flash drops. We integrated Ethers.js to connect the frontend with the Chiliz blockchain, allowing us to handle transactions and check token balances easily and in real time. For secure storage of images, we chose IPFS. This decentralized storage solution ensures that images related to fan rewards are safely stored, without relying on traditional servers. This gives fans confidence that their media is protected.",
        "how_its_made": "~ Contract Address : [ 0xc7B4fEb57eaDDD5A48786daF64f191F258157aA1 ] For the frontend, we used Next.js, which ensures the website loads quickly and performs well even under heavy use. Tailwind CSS was used to style the website, helping us quickly build a clean and responsive design. To make the site more interactive, we added animations using Framer Motion, giving users a smooth and engaging experience. On the blockchain side, we developed the smart contracts using Solidity. These contracts manage the logic of fan tokens and determine who is eligible for the exclusive flash drops. We integrated Ethers.js to connect the frontend with the Chiliz blockchain, allowing us to handle transactions and check token balances easily and in real time. For secure storage of images, we chose IPFS. This decentralized storage solution ensures that images related to fan rewards are safely stored, without relying on traditional servers. This gives fans confidence that their media is protected.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t0wge/screenshots/c3xve/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t0wge/screenshots/88q79/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t0wge/screenshots/xxcgv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t0wge/screenshots/k3gb1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t0wge/screenshots/z69nt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t0wge/screenshots/jz21c/default.jpg"
        ],
        "live_demo": "https://fantoz-seven.vercel.app/",
        "source_code": "https://github.com/priyanshur66/fantoz",
        "link": "https://ethglobal.com/showcase/fantoz-t0wge"
    },
    {
        "title": "GroChi",
        "brief_description": "Want to protect your identity but still be a part of communities, GroChi is here for you!",
        "long_description": "Privacy is a right of every human being! In this centralized world, there is no privacy left. Hence, I have come up with a solution. You are a sports fan and want to share your opinions but sometimes your opinion can be different from others, so how would it be if your identity is kept anonymous? GroChi gives users an option to create communities related to sports where their identities will be kept anonymous and they can say whatever they want. The project relies on the bandada project, which is a public good infrastructure made by the pse team at Ethereum Foundation. Users can create groups using the bandada api and then be a part of the groups. Here, identities of the users will be kept anonymous and there is no fear of getting cancelled! I have used vite for the frontend and tailwind css for styling.",
        "how_its_made": "The project relies on the bandada project, which is a public good infrastructure made by the pse team at Ethereum Foundation. Users can create groups using the bandada api and then be a part of the groups. Here, identities of the users will be kept anonymous and there is no fear of getting cancelled! I have used vite for the frontend and tailwind css for styling.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/646qb/screenshots/ujjzh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/646qb/screenshots/ku4tc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/646qb/screenshots/roeym/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Akhil-2310/EthOnline",
        "link": "https://ethglobal.com/showcase/grochi-646qb"
    },
    {
        "title": "DriveBuddy",
        "brief_description": "It is a project for social networking among car owners where they can connect",
        "long_description": "We utilized DIMO for acquiring car data, blockless for computing that data, fhenix for homomorphic encryption and sign protocol for signing the data to ensure security. This is highly modern and will help a lot of DIMO users. Using DIMO's decentralized vehicular services as our main data, we used blockless for performing computations.",
        "how_its_made": "Using DIMO's decentralized vehicular services as our main data, we used blockless for performing computations.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0pokq/screenshots/1qnbw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pokq/screenshots/2wc83/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pokq/screenshots/ax45s/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ETHGlobalOnline/DriveBuddy",
        "link": "https://ethglobal.com/showcase/drivebuddy-0pokq"
    },
    {
        "title": "osmify",
        "brief_description": "An Ethereum ZK light client written in RISC0 VM is a lightweight Ethereum node that verifies block headers.",
        "long_description": "An Ethereum ZK light client written in RISC0 VM is a lightweight Ethereum node that verifies block headers using zero-knowledge proofs, all running on a RISC-V based virtual machine. It combines the efficiency of light clients with the security of ZK proofs, allowing for fast synchronization and reduced storage while maintaining cryptographic guarantees. This implementation is useful for resource-constrained devices or applications needing efficient, verifiable access to Ethereum state information. An Ethereum ZK light client in RISC0 VM is a compact Ethereum node that verifies block headers using zero-knowledge proofs. Built in Rust, it runs on a RISC-V based VM optimized for ZK operations. It combines light client efficiency with ZK security, allowing fast, low-storage Ethereum state verification for resource-limited devices.",
        "how_its_made": "An Ethereum ZK light client in RISC0 VM is a compact Ethereum node that verifies block headers using zero-knowledge proofs. Built in Rust, it runs on a RISC-V based VM optimized for ZK operations. It combines light client efficiency with ZK security, allowing fast, low-storage Ethereum state verification for resource-limited devices.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qmk64/screenshots/8ca2b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qmk64/screenshots/h3v9a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qmk64/screenshots/1tg7q/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/esciiee/zk-light-client",
        "link": "https://ethglobal.com/showcase/osmify-qmk64"
    },
    {
        "title": "CodeEngine",
        "brief_description": "CodeEngine: A student platform providing personalized tech journey roadmaps, empowering learners to navigate their path in the tech world.",
        "long_description": "At CodeEngine, we provide a wide range of resources and services to help engineering students learn how to code and succeed in the tech industry. Our offerings include: Step-by-step tutorials and guides covering a variety of programming languages and technologies\nExamples and projects to help students see how to apply their knowledge in real-world situations\nTools and resources to help students develop their skills and advance their careers\nA community forum where students can connect with each other, ask for help, and share their projects Technology Stack:Web-based application designed using HTML, CSS, and JavaScript. Utilized the CodeMirror library for syntax highlighting across multiple programming languages. Features:Responsive and user-friendly interface with features like code completion, auto-indentation, and line numbers.Integrated a compiler and runner for multiple programming languages, allowing users to write, compile, and run code in real-time. Hosting: Hosted using GitHub Pages for accessibility to a wider audience.Skills Demonstrated: Expertise in front-end development, problem-solving, and attention to detail.",
        "how_its_made": "Technology Stack:Web-based application designed using HTML, CSS, and JavaScript. Utilized the CodeMirror library for syntax highlighting across multiple programming languages. Features:Responsive and user-friendly interface with features like code completion, auto-indentation, and line numbers.Integrated a compiler and runner for multiple programming languages, allowing users to write, compile, and run code in real-time. Hosting: Hosted using GitHub Pages for accessibility to a wider audience.Skills Demonstrated: Expertise in front-end development, problem-solving, and attention to detail.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mi1ou/screenshots/cd5yf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mi1ou/screenshots/t154u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mi1ou/screenshots/9utga/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mi1ou/screenshots/cj3mg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mi1ou/screenshots/1d33e/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/NikhilRaikwar/codeengine.github.io",
        "link": "https://ethglobal.com/showcase/codeengine-mi1ou"
    },
    {
        "title": "Zid",
        "brief_description": "Decentralized identity management system that leverages AvailDA's expandable blobspace, Polygon CDK, RISC Zero zkVM, and light clients to create a secure, scalable, and privacy-preserving solution.",
        "long_description": "AvailDA Integration:\nUtilizes AvailDA's blobspace to store encrypted identity data, ensuring high availability and data integrity. Leverages AvailDA's expandable nature to accommodate growing identity datasets efficiently. Polygon CDK:\nBuild a custom rollup using Polygon CDK, optimized for identity management operations. Implements smart contracts for identity creation, verification, and management. RISC Zero zkVM:\nUse RISC Zero zkVM to generate zero-knowledge proofs for identity verification without revealing sensitive information. Implements privacy-preserving computations for identity attributes and claims. Light Client Verification:\nA light client for end-users to verify their identity data posted by the sequencer on AvailDA. Ensures quick and efficient verification of identity claims without downloading the entire dataset. Privacy: Zero-knowledge proofs ensure users can prove their identity without revealing unnecessary information. Scalability: AvailDA's expandable blob space allows the system to grow with increasing users and data. Security: A combination of AvailDA, zkVM, and light client verification provides multiple layers of security. Interoperability: Support for decentralized identity standards ensures compatibility with other systems. Cost-efficiency: Utilizes AvailDA's cheap data availability layer for storing large amounts of identity data.",
        "how_its_made": "Privacy: Zero-knowledge proofs ensure users can prove their identity without revealing unnecessary information. Scalability: AvailDA's expandable blob space allows the system to grow with increasing users and data. Security: A combination of AvailDA, zkVM, and light client verification provides multiple layers of security. Interoperability: Support for decentralized identity standards ensures compatibility with other systems. Cost-efficiency: Utilizes AvailDA's cheap data availability layer for storing large amounts of identity data.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qjocc/screenshots/o2rha/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qjocc/screenshots/m64no/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qjocc/screenshots/1h7eg/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/RajasreePonnada/ZSDK",
        "link": "https://ethglobal.com/showcase/zid-qjocc"
    },
    {
        "title": "CouncilHaus",
        "brief_description": "dApp that enables organizations to democratically allocate and distribute budget to grantees through a collaborative decision-making process",
        "long_description": "Council is an innovative system designed to democratize and streamline the process of allocating grants or funds within an organization. It's like a digital roundtable where designated council members can collaboratively decide how to distribute resources to various projects or individuals (called grantees). We could only code the smart contract during the hackathon. We will continue the project after the hackathon adding a frontend. The project is developed using solidity and the Superfluid General Distribution Agreement, which enables supertokens to be distributed among grantees in a very efficient manner.",
        "how_its_made": "We could only code the smart contract during the hackathon. We will continue the project after the hackathon adding a frontend. The project is developed using solidity and the Superfluid General Distribution Agreement, which enables supertokens to be distributed among grantees in a very efficient manner.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tudme/screenshots/qwc7b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tudme/screenshots/dr6gd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tudme/screenshots/r483i/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/blossomlabs/councilhaus",
        "link": "https://ethglobal.com/showcase/councilhaus-tudme"
    },
    {
        "title": "Shop Bot",
        "brief_description": "PriceAlert: Track Amazon, Walmart and more. Get XMTP alerts! Compare prices with Walmart, all in one sleek web app. Never miss a deal again. Built with Flask, Node.js, and XMTP for real-time messaging.",
        "long_description": "PriceAlert is an innovative web application designed to revolutionize the way online shoppers track and compare product prices. This project combines the power of web scraping, real-time messaging, and price comparison to provide users with a seamless and efficient shopping experience.\nKey Features and Functionality:\nAmazon Product Tracking:\nUsers can input any Amazon product URL into the system. The application then utilizes Selenium WebDriver to scrape essential product information, including the product name, current price, and image.\nReal-time Display:\nThe scraped information is immediately displayed on the web interface, giving users instant access to the product details they're interested in.\n3. XMTP Integration:\nOne of the standout features of PriceAlert is its integration with XMTP (Extensible Message Transport Protocol). This allows the system to send real-time alerts and updates directly to users.\nPrice Alerts:\nThe system sends an initial message via XMTP containing the product details and current price. This sets up the foundation for future price drop alerts.\nWalmart Price Comparison:\nTo provide users with more options, PriceAlert automatically generates a Walmart search link for the same product. After a short delay (10 seconds in the current implementation), it sends a follow-up XMTP message with this link, encouraging users to compare prices across platforms.\nUser-Friendly Interface:\nThe web interface, built with Flask, offers a clean and intuitive design. Users can easily input URLs, view product information, and understand the alerts they'll receive.\nScalable Architecture:\nThe project is split into two main components - a Flask server (app.py) for handling web requests and scraping, and a Node.js server (xmtp_service.js) for XMTP messaging. This separation of concerns allows for easier scaling and maintenance.\nTechnical Implementation:\nThe Flask server (app.py) handles the web interface and Amazon scraping. It uses Selenium for dynamic web scraping, ensuring accurate and up-to-date product information.\nThe Node.js server (xmtp_service.js) manages all XMTP communications. It creates random wallets for each message, ensuring user privacy and system flexibility.\nThe project leverages the power of both Python and JavaScript, showcasing the ability to integrate different technologies for optimal performance.\nFuture Potential:\nPriceAlert has significant potential for expansion. Future versions could include:\nSupport for more e-commerce platforms\nUser accounts for personalized tracking\nHistorical price data and trend analysis\nIntegration with cryptocurrency payments for direct purchases\nMobile app version for on-the-go price tracking\nIn summary, PriceAlert is not just a price tracker; it's a comprehensive shopping companion that leverages cutting-edge technologies to provide users with real-time, cross-platform price comparisons and alerts. By combining web scraping, decentralized messaging, and a user-friendly interface, PriceAlert stands out as an innovative solution in the e-commerce space. Core Technologies:",
        "how_its_made": "Core Technologies:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0d51g/screenshots/0v245/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0d51g/screenshots/tbxcq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0d51g/screenshots/x4km9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/BaibhavEth/XMTP-Price",
        "link": "https://ethglobal.com/showcase/shop-bot-0d51g"
    },
    {
        "title": "BondiX",
        "brief_description": "Create your own token, set a bonding curve, and raise funds. If the funding target is met, liquidity is deployed on Uniswap; otherwise, investors can reclaim their contributions.",
        "long_description": "With BondiX, creators and entrepreneurs who lack the ability to write smart contracts can easily create their own token and raise funds on their own terms. BondiX offers an open-source, verifiable smart contract that provides enough flexibility to meet various fundraising requirements. Token creation is streamlined. BondiX simplifies the process through an intuitive form where users can define essential token details, including the name, symbol, and optional image, as well as provide a link for more project information. Setting up the bonding curve and fundraising parameters is hassle-free and requires no coding skills. BondiX's user-friendly interface allows users to specify their fundraising goal, token supply, bonding curve, fundraising duration, and initial funding amount directly through a simple form. Token Creation: Users define their token's basic information (name, symbol, etc.) using an easy-to-use form, without needing to write code.\nBonding Curve Setup: A simple form allows users to configure the bonding curve, token supply, and fundraising parameters, including the funding goal, duration, and initial contribution.\nSmart Contract Deployment: An open-source, customizable smart contract is deployed to manage the fundraising process.\nFundraising Process: Investors buy tokens, and once the funding goal is reached, liquidity is automatically added to Uniswap.\nRefund Option: If the goal is not met within the timeframe, investors can reclaim their funds.",
        "how_its_made": "Token Creation: Users define their token's basic information (name, symbol, etc.) using an easy-to-use form, without needing to write code.\nBonding Curve Setup: A simple form allows users to configure the bonding curve, token supply, and fundraising parameters, including the funding goal, duration, and initial contribution.\nSmart Contract Deployment: An open-source, customizable smart contract is deployed to manage the fundraising process.\nFundraising Process: Investors buy tokens, and once the funding goal is reached, liquidity is automatically added to Uniswap.\nRefund Option: If the goal is not met within the timeframe, investors can reclaim their funds.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/w92aa/screenshots/6516n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w92aa/screenshots/bc4m5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w92aa/screenshots/523nh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w92aa/screenshots/ozuf9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w92aa/screenshots/nhq9g/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ctrlakshat/BondiX",
        "link": "https://ethglobal.com/showcase/bondix-w92aa"
    },
    {
        "title": "Multi Generative PFP",
        "brief_description": "It's a multichained dapp where users can mint an NFT for 0.001 ETH on Ethereum, Arbitrum or Avalanche C-Chain. Users who have registered on ENS can see their's domain name instead of wallet address.",
        "long_description": "Generative PFP is an innovative project that brings the world of NFTs and dynamic profile picture generation together, creating a unique and engaging experience for users in the Ethereum ecosystem. This project was built for the EthOnline 2024 Hackathon and focuses on leveraging generative art techniques to create fully customizable, algorithmically generated profile pictures (PFPs) as NFTs. Key Features:\nGenerative Art Engine: The core of the project is an art generation engine that uses pre-defined traits, colors, and elements to produce distinctive profile pictures. Each PFP is uniquely generated based on a combination of different attributes such as facial expressions, accessories, backgrounds, and color palettes. This ensures no two PFPs are identical, making each one a rare digital collectible. On-Chain Minting: Users can mint their generative PFP directly on-chain, ensuring immutability and ownership through Ethereum\u2019s smart contracts. Each PFP is minted as an ERC-721 compliant NFT, allowing seamless integration with popular NFT marketplaces and wallets. User Customization: Unlike traditional static PFP NFTs, Generative PFP allows users to customize and tweak the traits before minting. This creates a more personalized user experience where participants have partial control over their PFP\u2019s attributes while still relying on generative randomness for the final design. Decentralized Metadata Storage: All metadata and artwork are stored using decentralized storage solutions like IPFS (InterPlanetary File System). This ensures that the PFP assets are not only secure but also truly decentralized, maintaining the ethos of Web3. Smart Contract Integration: The project uses Solidity smart contracts for minting, managing, and transferring the NFTs. It also implements a token-gated mechanism, where users need to stake tokens or meet specific criteria to unlock certain exclusive PFP traits. Community and Governance: In the future roadmap, we aim to implement community-driven governance, allowing PFP holders to vote on new trait releases, updates to the generation engine, and possible future collaborations or features. This gives users a voice in the development and expansion of the project. Interoperability: Generative PFPs are designed to be interoperable across different chains and platforms. The project is currently deployed on the Ethereum mainnet, but future versions will integrate with Layer 2 solutions and multi-chain frameworks to reduce gas fees and increase scalability. Use Cases:\nNFT Collectibles: Users can mint and trade their unique PFPs as collectibles, with rarity determined by the random combination of traits.\nIdentity in the Metaverse: These generative PFPs can serve as digital avatars in the metaverse, representing the identity of users in decentralized social networks and virtual worlds.\nSocial Media Integration: Users can integrate their generative PFPs into platforms that support NFT-based profile pictures, further enhancing the ownership and expression of their digital identity.\nTech Stack:\nFrontend: Built using React.js with Next.js for the user interface, allowing for seamless and dynamic trait selection and NFT minting experience.\nBackend: The backend is powered by Node.js and integrates directly with the Ethereum blockchain for smart contract interaction.\nSmart Contracts: Written in Solidity and deployed using Hardhat for testing, deployment, and contract management.\nIPFS: Used for decentralized storage of PFP assets and metadata.\nGenerative PFP aims to push the boundaries of digital identity, NFTs, and user customization in the Web3 space. By combining algorithmic art generation with user participation and decentralized storage, this project paves the way for a new breed of dynamic and personal digital collectibles. Building Generative PFP was an exciting technical challenge that combined several cutting-edge technologies and development frameworks in both frontend and backend to create a seamless, dynamic NFT generation and minting experience. Here\u2019s an in-depth look at the process: Frontend:\nReact.js with Next.js: The frontend of the project is built using React.js with Next.js for server-side rendering, which allows for a dynamic and responsive user interface. This framework was chosen because it simplifies routing and state management, making the UI fast and scalable. Next.js also enhances SEO and load times by rendering the pages on the server before sending them to the client, which is critical when displaying NFT-related content. Backend:\nNode.js with Express: The backend is powered by Node.js and Express, which handles user interactions with the blockchain, trait selection, and NFT metadata generation. Using Node.js ensures that the backend can handle multiple requests concurrently, which is vital during high-traffic events like NFT minting. IPFS (InterPlanetary File System): For decentralized storage, all PFP images and metadata are uploaded to IPFS. This ensures that the assets are immutable and stored in a decentralized manner, adhering to the principles of Web3. IPFS's decentralized nature guarantees that even if the central server is down, the NFTs remain accessible, which enhances both security and permanence for the artwork. Pinata: Pinata is used as the IPFS pinning service, ensuring that the metadata and images remain persistent and easily retrievable. It simplifies IPFS management, helping ensure our files are reliably hosted, which is critical for an NFT project like Generative PFP where users need access to their assets at all times. Smart Contracts:\nSolidity: The smart contracts for minting the NFTs are written in Solidity and deployed on Ethereum. These contracts implement the ERC-721 standard for NFTs, ensuring full compatibility with popular NFT platforms like OpenSea and other wallets. The contracts handle the generation of metadata, randomization of traits, and linking each unique PFP to the user\u2019s wallet. Hardhat: For developing, testing, and deploying smart contracts, we used Hardhat. Hardhat's extensive plugin system helped in optimizing the gas fees, testing the contracts rigorously, and deploying them to the Ethereum mainnet seamlessly. Hardhat also allowed for continuous testing during development, ensuring our contract interactions were smooth and bug-free. Randomization and Trait Generation:\nCustom Trait Algorithm: One of the core challenges was generating unique, randomized PFPs while maintaining rarity. We wrote a custom algorithm that pulls from a predefined set of traits (e.g., background, accessories, colors) to ensure that each PFP is unique. The algorithm also factors in rarity scores, so some traits appear less frequently, creating more valuable NFTs. The hacky part here is using a weighted random function that ensures certain rare traits are only assigned to a small subset of NFTs while keeping the generation process efficient. Blockchain Integration:\nEthers.js: For blockchain interaction, we used Ethers.js in the frontend. Ethers.js allows users to easily connect their wallets (like MetaMask) to the dApp, sign transactions, and mint their NFTs directly from the browser. It simplifies communication with the Ethereum blockchain, enabling smooth integration between the user interface and the smart contracts.\nKey Integrations and Partner Technologies:\nOpenZeppelin Libraries: We integrated OpenZeppelin libraries for security and to implement standardized contracts. Using OpenZeppelin\u2019s pre-built contracts ensured that our ERC-721 tokens were secure and followed best practices, which saved time and reduced the risk of vulnerabilities. Alchemy: We leveraged Alchemy for Ethereum API access. Alchemy\u2019s infrastructure provided us with reliable and scalable access to Ethereum, helping us manage transactions and monitor the status of smart contract deployments efficiently. It also assisted in debugging transactions and reducing deployment friction, which was critical in a fast-paced hackathon environment. Hacky and Notable Elements:\nGas Optimization Techniques: Given Ethereum\u2019s notorious gas fees, we used Hardhat Gas Reporter and optimized the smart contracts by reducing unnecessary state changes and keeping metadata storage off-chain using IPFS. These optimizations helped lower the gas fees for users during the minting process, which is crucial in a project focused on user engagement. Conclusion:\nBuilding Generative PFP for the EthOnline 2024 Hackathon was a deeply rewarding experience. By combining React, Solidity, IPFS, and other blockchain tools, we created a fully decentralized, user-friendly, and customizable NFT platform. The integration of hacky elements like pre-mint trait preview and optimization for gas fees demonstrates the innovative approach we took to enhance user experience in the growing NFT space.",
        "how_its_made": "Building Generative PFP was an exciting technical challenge that combined several cutting-edge technologies and development frameworks in both frontend and backend to create a seamless, dynamic NFT generation and minting experience. Here\u2019s an in-depth look at the process: Frontend:\nReact.js with Next.js: The frontend of the project is built using React.js with Next.js for server-side rendering, which allows for a dynamic and responsive user interface. This framework was chosen because it simplifies routing and state management, making the UI fast and scalable. Next.js also enhances SEO and load times by rendering the pages on the server before sending them to the client, which is critical when displaying NFT-related content. Backend:\nNode.js with Express: The backend is powered by Node.js and Express, which handles user interactions with the blockchain, trait selection, and NFT metadata generation. Using Node.js ensures that the backend can handle multiple requests concurrently, which is vital during high-traffic events like NFT minting. IPFS (InterPlanetary File System): For decentralized storage, all PFP images and metadata are uploaded to IPFS. This ensures that the assets are immutable and stored in a decentralized manner, adhering to the principles of Web3. IPFS's decentralized nature guarantees that even if the central server is down, the NFTs remain accessible, which enhances both security and permanence for the artwork. Pinata: Pinata is used as the IPFS pinning service, ensuring that the metadata and images remain persistent and easily retrievable. It simplifies IPFS management, helping ensure our files are reliably hosted, which is critical for an NFT project like Generative PFP where users need access to their assets at all times. Smart Contracts:\nSolidity: The smart contracts for minting the NFTs are written in Solidity and deployed on Ethereum. These contracts implement the ERC-721 standard for NFTs, ensuring full compatibility with popular NFT platforms like OpenSea and other wallets. The contracts handle the generation of metadata, randomization of traits, and linking each unique PFP to the user\u2019s wallet. Hardhat: For developing, testing, and deploying smart contracts, we used Hardhat. Hardhat's extensive plugin system helped in optimizing the gas fees, testing the contracts rigorously, and deploying them to the Ethereum mainnet seamlessly. Hardhat also allowed for continuous testing during development, ensuring our contract interactions were smooth and bug-free. Randomization and Trait Generation:\nCustom Trait Algorithm: One of the core challenges was generating unique, randomized PFPs while maintaining rarity. We wrote a custom algorithm that pulls from a predefined set of traits (e.g., background, accessories, colors) to ensure that each PFP is unique. The algorithm also factors in rarity scores, so some traits appear less frequently, creating more valuable NFTs. The hacky part here is using a weighted random function that ensures certain rare traits are only assigned to a small subset of NFTs while keeping the generation process efficient. Blockchain Integration:\nEthers.js: For blockchain interaction, we used Ethers.js in the frontend. Ethers.js allows users to easily connect their wallets (like MetaMask) to the dApp, sign transactions, and mint their NFTs directly from the browser. It simplifies communication with the Ethereum blockchain, enabling smooth integration between the user interface and the smart contracts.\nKey Integrations and Partner Technologies:\nOpenZeppelin Libraries: We integrated OpenZeppelin libraries for security and to implement standardized contracts. Using OpenZeppelin\u2019s pre-built contracts ensured that our ERC-721 tokens were secure and followed best practices, which saved time and reduced the risk of vulnerabilities. Alchemy: We leveraged Alchemy for Ethereum API access. Alchemy\u2019s infrastructure provided us with reliable and scalable access to Ethereum, helping us manage transactions and monitor the status of smart contract deployments efficiently. It also assisted in debugging transactions and reducing deployment friction, which was critical in a fast-paced hackathon environment. Hacky and Notable Elements:\nGas Optimization Techniques: Given Ethereum\u2019s notorious gas fees, we used Hardhat Gas Reporter and optimized the smart contracts by reducing unnecessary state changes and keeping metadata storage off-chain using IPFS. These optimizations helped lower the gas fees for users during the minting process, which is crucial in a project focused on user engagement. Conclusion:\nBuilding Generative PFP for the EthOnline 2024 Hackathon was a deeply rewarding experience. By combining React, Solidity, IPFS, and other blockchain tools, we created a fully decentralized, user-friendly, and customizable NFT platform. The integration of hacky elements like pre-mint trait preview and optimization for gas fees demonstrates the innovative approach we took to enhance user experience in the growing NFT space.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/7sr5g/screenshots/5yjk5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7sr5g/screenshots/pki28/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7sr5g/screenshots/m4ga1/default.jpg"
        ],
        "live_demo": "https://generative-pfp.vercel.app/",
        "source_code": "https://github.com/ethglobal",
        "link": "https://ethglobal.com/showcase/multi-generative-pfp-7sr5g"
    },
    {
        "title": "AI Depression Check",
        "brief_description": "Private Mental Health AI: Users fill out a form to check for depression, securely uploaded to Nillion. A Neural Network provides a blind prediction. Trained on Kaggle's Depression Anxiety Stress Scales (95% accuracy), it predicts 5 classes. Deployed on Nillion.",
        "long_description": "Users fill in a form to diagnose depression, this form is securely uploaded to Nillion as a secret and a prediction blindly is given by a Neural Network also uploaded on Nillion. This allows people who might want to check whether they are suffering from depressive symptoms before going to a specialist yet, in a private way, where the app they use for it will not sell the fact that they have or they think they have depression to third parties. We use the https://www.kaggle.com/datasets/lucasgreenwell/depression-anxiety-stress-scales-responses dataset to train a simple but highly performant NN (95% accuracy) to predict 5 different classes: Normal, Mild, Moderate, Severe or Extremely Severe. We upload this model to the NIllion devnet on the working version, since the testnet is momentarily congested and storing even an integer costs levels of magnitude above what can be obtained on the faucet. I cant link the devnet branch of the repo below, make sure to examine that one please.",
        "how_its_made": "We use the https://www.kaggle.com/datasets/lucasgreenwell/depression-anxiety-stress-scales-responses dataset to train a simple but highly performant NN (95% accuracy) to predict 5 different classes: Normal, Mild, Moderate, Severe or Extremely Severe. We upload this model to the NIllion devnet on the working version, since the testnet is momentarily congested and storing even an integer costs levels of magnitude above what can be obtained on the faucet. I cant link the devnet branch of the repo below, make sure to examine that one please.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ic0ea/screenshots/bjdao/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ic0ea/screenshots/b105y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ic0ea/screenshots/qiiky/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Lucab95/ETH-Online-mental-health",
        "link": "https://ethglobal.com/showcase/ai-depression-check-ic0ea"
    },
    {
        "title": "Secret Polls",
        "brief_description": "Secret Polls: Securely participate in polls without anyone knowing what you voted for using Nillion Blind computation",
        "long_description": "Secret Polls, provides a novel mechanism for taking blind polls.\nExplained in full detail in the github read me. Welcome to Secret Polls where we can create polls of only which the end outcome is known. These polls are completely  blind/secret  in the sense that we can only see the end result of the polls without knowing the participants. Nobody but the person who participated in that poll will ever know what she/he voted for apart from themselves.  Neither the poll creator, nor any third can ever know this information How the platform works:\nPoll owners can create polls to resolve, questions, concerns etc. Polls can have a cap for participants and expiry periods in which no one else can participate again. Polls also have visibility, in the sense of whether the poll owners want the general populace to be able to access his/her poll and see the results or keep a poll private restricting access to only those that have a link (or even in the future passwords ). A Poll consists of a question and 4 options.\nOnce A poll has been concluded a poll owner can see the results. Poll participants can choose to participate in polls they have access to with the full knowledge that the knowledge of what they picked is secret will never be known. poll participants can also see the results to the polls they have access to This Project is solely built on top of Nillion. We use the Nillion Network as the privacy layer. That allows for people to create polls another people to anonymous answer these polls without any party being the wiser about what option a person picked. There are two main components in this project, a lightweight backend and the nillion javascript blind app. This project allows people to create polls which are blind computation programs behind the scenes without knowing in advance the parties that might wish to participate in the polls, we do this by generating nada programs only on demand i.e when a poll owner is ready to compute. The full flow goes like this.\nUser A creates a Poll configured with different options and visibility level, visibility governs who can participate in the poll. When a poll is created we only store the user id, the question and the poll options, as well as poll configs. Now other users B, C and D can gain access to a poll and choose to participate secretly, i.e they  do not want it known what option they picked but they want to participate. They choose an option an submit, under the hood this submission is a nillion secret integer storage operation where the interger stored is which option the user picked. When these participants vote on the poll, thier secret input ids and parties get stored on the backend server. Now when a poll has expired or all the max number of participants have interacted with poll, or if the owner decided to end the poll early, in other words, once we have a conclusion event. That is when we dynamically create a secret program that represents the poll, the inputs of the anonymous participants are then binded and the poll creator A, then uploads and computes the result of the poll, seeing which option won, what total votes each options gets, without knowing who actually participated.",
        "how_its_made": "This Project is solely built on top of Nillion. We use the Nillion Network as the privacy layer. That allows for people to create polls another people to anonymous answer these polls without any party being the wiser about what option a person picked. There are two main components in this project, a lightweight backend and the nillion javascript blind app. This project allows people to create polls which are blind computation programs behind the scenes without knowing in advance the parties that might wish to participate in the polls, we do this by generating nada programs only on demand i.e when a poll owner is ready to compute. The full flow goes like this.\nUser A creates a Poll configured with different options and visibility level, visibility governs who can participate in the poll. When a poll is created we only store the user id, the question and the poll options, as well as poll configs. Now other users B, C and D can gain access to a poll and choose to participate secretly, i.e they  do not want it known what option they picked but they want to participate. They choose an option an submit, under the hood this submission is a nillion secret integer storage operation where the interger stored is which option the user picked. When these participants vote on the poll, thier secret input ids and parties get stored on the backend server. Now when a poll has expired or all the max number of participants have interacted with poll, or if the owner decided to end the poll early, in other words, once we have a conclusion event. That is when we dynamically create a secret program that represents the poll, the inputs of the anonymous participants are then binded and the poll creator A, then uploads and computes the result of the poll, seeing which option won, what total votes each options gets, without knowing who actually participated.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9mk3y/screenshots/kpjbn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9mk3y/screenshots/exspj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9mk3y/screenshots/amahu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9mk3y/screenshots/35e09/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Thompsonmina/Secret_Polls-Powered-By-Nillion-",
        "link": "https://ethglobal.com/showcase/secret-polls-9mk3y"
    },
    {
        "title": "FrenAI",
        "brief_description": "FrenAI is a platform for creating and chatting with AI-powered characters that feel like real friends. Users can buy credits with ETH to interact with virtual friends, each represented as an NFT with an attached Bonding Curve for creator incentives.",
        "long_description": "FrenAI is an innovative platform that combines AI, blockchain technology, and social interaction to create a unique digital friendship experience. The project aims to solve loneliness by providing users with AI-powered characters that can engage in text-based conversations that feel like real friendships.\nKey features of FrenAI include:\nCreation of personalized AI buddies tailored to user interests\nText-based conversations with AI characters that simulate real friendships\nA variety of character types to choose from, including anime heroes and virtual companions\nAn easy-to-use character creation tool\nSmart AI that understands and adapts to user interactions\nA judgment-free environment for users to be themselves\nAccessibility to interact with AI friends anytime, anywhere\nThe platform operates on a credit system where users can purchase credits using ETH. These credits are then spent to interact with virtual friends. Each virtual friend is represented as an NFT contract, adding a layer of ownership and uniqueness to the characters.\nA key innovation in FrenAI is the implementation of Bonding Curves attached to each virtual friend. This mechanism serves as an incentive for creators to develop compelling and popular virtual friends, as they can profit from their creations. The most popular virtual friends generate higher rewards for their creators, encouraging quality and engagement. FrenAI is built using a modern tech stack that includes:\nNext.js 14 for the frontend framework\nTypeScript for type-safe development\nShadcn and Tailwind CSS for styling and UI components\nWagmi v2 and Viem v2 for Ethereum interactions\n@tanstack/react-query for efficient data fetching and caching\nReact Server Components (RSC)\nSolidity, Foundry and Morph L2 for Smart Contract\nFAL ai model for image generation\nGroq for LLM text model\nThe project leverages smart contracts deployed on the Holesky testnet:\nNFT Factory: 0xc59C04dA06CbE695a54d48cA929d3CBB9B8c947D\nCredits: 0xc3914bfD49e030B3a2c975B33947aDC338919A60\nBonding Curve: 0x3f0987bD62827afEeCBF038D99A3F20dfd7FA146",
        "how_its_made": "FrenAI is built using a modern tech stack that includes:\nNext.js 14 for the frontend framework\nTypeScript for type-safe development\nShadcn and Tailwind CSS for styling and UI components\nWagmi v2 and Viem v2 for Ethereum interactions\n@tanstack/react-query for efficient data fetching and caching\nReact Server Components (RSC)\nSolidity, Foundry and Morph L2 for Smart Contract\nFAL ai model for image generation\nGroq for LLM text model\nThe project leverages smart contracts deployed on the Holesky testnet:\nNFT Factory: 0xc59C04dA06CbE695a54d48cA929d3CBB9B8c947D\nCredits: 0xc3914bfD49e030B3a2c975B33947aDC338919A60\nBonding Curve: 0x3f0987bD62827afEeCBF038D99A3F20dfd7FA146",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/nnh7j/screenshots/sfw8t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nnh7j/screenshots/5etaj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nnh7j/screenshots/jrm8c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nnh7j/screenshots/y4t2e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nnh7j/screenshots/dthhu/default.jpg"
        ],
        "live_demo": "https://fren-ai-lemon.vercel.app/",
        "source_code": "https://github.com/aeither/FrenAI",
        "link": "https://ethglobal.com/showcase/frenai-nnh7j"
    },
    {
        "title": "Web3Auth-Wagmi",
        "brief_description": "Initially planned to build a crosschain staking project, ended up time constraint and only manage to connect web3auth.",
        "long_description": "Current Implementation\nIn the current state of the project, I've successfully integrated Web3Auth with wagmi to handle Web3 authentication. The integration allows users to authenticate via Web3Auth, which simplifies the login process by offering multiple options such as Google, Facebook, and other OAuth providers, along with traditional wallet-based authentication methods. Challenges and Limitations\nThe attempt to integrate the Lit Protocol into the project ultimately fell short, resulting in a failed implementation. The main challenge was the complexity of Lit Protocol's encryption and access control features, which required a deep understanding of both its SDK and the underlying cryptographic principles. Despite efforts to implement secure data sharing and decentralized access controls, the integration faced significant roadblocks. Issues arose with key management, compatibility with existing frameworks, and difficulties in debugging the protocol's interactions with other components. The combination of these challenges, coupled with the project's tight deadline, made it impossible to achieve a functional and reliable integration, leading to its failure within the scope of this project. Current Implementation\nIn the current state of the project, I've successfully integrated Web3Auth with wagmi to handle Web3 authentication. The integration allows users to authenticate via Web3Auth, which simplifies the login process by offering multiple options such as Google, Facebook, and other OAuth providers, along with traditional wallet-based authentication methods. Challenges and Limitations\nThe attempt to integrate the Lit Protocol into the project ultimately fell short, resulting in a failed implementation. The main challenge was the complexity of Lit Protocol's encryption and access control features, which required a deep understanding of both its SDK and the underlying cryptographic principles. Despite efforts to implement secure data sharing and decentralized access controls, the integration faced significant roadblocks. Issues arose with key management, compatibility with existing frameworks, and difficulties in debugging the protocol's interactions with other components. The combination of these challenges, coupled with the project's tight deadline, made it impossible to achieve a functional and reliable integration, leading to its failure within the scope of this project.",
        "how_its_made": "Current Implementation\nIn the current state of the project, I've successfully integrated Web3Auth with wagmi to handle Web3 authentication. The integration allows users to authenticate via Web3Auth, which simplifies the login process by offering multiple options such as Google, Facebook, and other OAuth providers, along with traditional wallet-based authentication methods. Challenges and Limitations\nThe attempt to integrate the Lit Protocol into the project ultimately fell short, resulting in a failed implementation. The main challenge was the complexity of Lit Protocol's encryption and access control features, which required a deep understanding of both its SDK and the underlying cryptographic principles. Despite efforts to implement secure data sharing and decentralized access controls, the integration faced significant roadblocks. Issues arose with key management, compatibility with existing frameworks, and difficulties in debugging the protocol's interactions with other components. The combination of these challenges, coupled with the project's tight deadline, made it impossible to achieve a functional and reliable integration, leading to its failure within the scope of this project.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3t1m2/screenshots/eoekd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3t1m2/screenshots/nhxj1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3t1m2/screenshots/a10vv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/SkyYap/Web3Auth-Wagmi",
        "link": "https://ethglobal.com/showcase/web3auth-wagmi-3t1m2"
    },
    {
        "title": "MemeMoney",
        "brief_description": "The Website is a  secure memecoin generator which solves the problem of rug pull and honeypot",
        "long_description": "The project aims to create a memecoin that addresses the prevalent issue of rug pulls in the crypto space. By integrating a decentralized, transparent smart contract system, the project ensures that funds are locked in liquidity pools, reducing the risk of malicious intent. Audited by third-party security firms, the smart contract also includes automatic liquidity locking and vesting schedules for team tokens. The community is empowered through decentralized governance, enabling voting on key decisions and project developments. This creates a fun, community-driven memecoin with strong security features, building trust and long-term sustainability in the crypto market The memecoin project is developed with a Vite and TypeScript frontend, providing a fast, lightweight, and efficient user interface. The Solidity smart contract forms the core of the token, handling key operations like token creation, transfers, liquidity locking, and governance mechanisms. The smart contract is deployed on the Ethereum blockchain (or another compatible network), ensuring decentralization and security. Vite compiles the TypeScript code for frontend interaction, integrating with Web3.js to communicate with the blockchain. This setup allows users to interact seamlessly with the meme coin, enabling token transactions and governance voting through a responsive and secure interface.",
        "how_its_made": "The memecoin project is developed with a Vite and TypeScript frontend, providing a fast, lightweight, and efficient user interface. The Solidity smart contract forms the core of the token, handling key operations like token creation, transfers, liquidity locking, and governance mechanisms. The smart contract is deployed on the Ethereum blockchain (or another compatible network), ensuring decentralization and security. Vite compiles the TypeScript code for frontend interaction, integrating with Web3.js to communicate with the blockchain. This setup allows users to interact seamlessly with the meme coin, enabling token transactions and governance voting through a responsive and secure interface.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bjc20/screenshots/32vdt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bjc20/screenshots/eixtn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bjc20/screenshots/0fr2a/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/rtb-12/MemeCoin",
        "link": "https://ethglobal.com/showcase/mememoney-bjc20"
    },
    {
        "title": "Trusty",
        "brief_description": "It is a snark based project for proving pairing in bn128 curve it is a part of elliptic curve cryptography, I am proving that when two group of different curve get paired will generate this group of ellptic curve.",
        "long_description": "Elliptic Curve Cryptography (ECC) is widely used in various cryptographic protocols, including Zero-Knowledge Proofs (ZKPs) and pairing-based cryptography, especially in schemes like Groth16 for generating and verifying proofs. Let\u2019s break down the concepts behind this and how they relate to your implementation: In cryptographic protocols like Groth16, elliptic curves are used for: Efficient key generation: Public-private key pairs are generated by selecting a point on the elliptic curve.\nSignature generation and verification: Proofs can be signed using private keys and verified using the corresponding public key.\n2. Pairing-Based Cryptography:\nPairing refers to a bilinear map, which is a special type of mathematical function that takes two points on an elliptic curve and maps them to a third point in a related group. This property is useful in cryptographic schemes like Groth16 because it allows you to efficiently check certain relationships between points, which is essential for verifying proofs. \ud835\udc54\n\ud835\udc47\ne(g\n1\n\u200b\n,g\n2\n\u200b\n)=g\nT\n\u200b for\n\ud835\udc54\n1\n\u2208\n\ud835\udc3a\n1\ng\n1\n\u200b\n\u2208G\n1\n\u200b\nand\n\ud835\udc54\n2\n\u2208\n\ud835\udc3a\n2\ng\n2\n\u200b\n\u2208G\n2\n\u200b\n. This bilinear property allows pairing-based schemes to verify cryptographic proofs. Generating pairings on an elliptic curve: You are likely using libraries that implement elliptic curve groups and pairing functions, such as BN254, which is popular for Groth16.\nGenerating proofs: Using the structured reference string (SRS), the prover encodes the witness (the secret input) and uses pairing to create a proof.\nVerifying proofs: The verifier uses the elliptic curve pairing and checks if the proof satisfies the cryptographic relation.",
        "how_its_made": "Generating pairings on an elliptic curve: You are likely using libraries that implement elliptic curve groups and pairing functions, such as BN254, which is popular for Groth16.\nGenerating proofs: Using the structured reference string (SRS), the prover encodes the witness (the secret input) and uses pairing to create a proof.\nVerifying proofs: The verifier uses the elliptic curve pairing and checks if the proof satisfies the cryptographic relation.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/b64xn/screenshots/45c34/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b64xn/screenshots/2zwk5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b64xn/screenshots/017du/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Muskan0511pandey/bn128_pairing",
        "link": "https://ethglobal.com/showcase/trusty-b64xn"
    },
    {
        "title": "Tempest Tactician",
        "brief_description": "Hide/Reveal Scheme with O1js, and attempting to use Acurast TEE Processors for Oracles",
        "long_description": "his is  Proof of Concept Game that uilizes  utilizes zero-knowledge proofs (ZKPs) implemented through O1js, a TypeScript library for zk-SNARK circuits. These ZKPs enable players to commit to strategies without revealing them, ensuring game-theoretic integrity. I also used O1js's new offchain storage API, allowing for efficient management of large game states without compromising on-chain efficiency or security. This offchain storage solution is pivotal in handling the complex, evolving nature of player strategies and game progression. The game's unique feature is the incorporation of real-time weather data as a decisive factor in battle outcomes. I explored Acurast, a decentralized oracle network, to fetch and integrate this data. Acurast's architecture, built on Trusted Execution Environments (TEEs), allows for the secure, confidential, and verifiable acquisition and on-chain submission of weather data. This implementation creates a trustless bridge between off-chain real-world conditions and on-chain game mechanics. Since I cannot upload pictures here- Here's a link to the architecure diagram of my project:\nhttps://github.com/enderNakamoto/battle_zkapp?tab=readme-ov-file#game-architecture The main parts of the game are:",
        "how_its_made": "Since I cannot upload pictures here- Here's a link to the architecure diagram of my project:\nhttps://github.com/enderNakamoto/battle_zkapp?tab=readme-ov-file#game-architecture The main parts of the game are:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xs9qz/screenshots/4sbxs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xs9qz/screenshots/0dbkp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xs9qz/screenshots/jnqet/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/enderNakamoto/castle_edo_sim_js",
        "link": "https://ethglobal.com/showcase/tempest-tactician-xs9qz"
    },
    {
        "title": "Tesseract",
        "brief_description": "Native ETH Restaking simplified without the hassle of running your own validators on eigenlayer with ssv.network",
        "long_description": "With tesseract, users can simply re-stake native ETH without getting involved in the complex process of running a validator and juggling around multiple process to provide economic security to the ETH ecosystem and the same time being able to earn rewards User don't need to run a validator for staking, worry about it's liveness and slashing of their stake. They can setup re-staking in just 5 clicks and earn rewards from Eigen layer for their restaked ETH without getting involved in the complex tech. Once the deposit if processed on the Beacon chain in about 24 hours, users can put it on restake from Eigenlayer dashboard and complete the process simply. We are using SSV Network and Eigenlayer to setup the whole process for demo purpose on the holesky testnet. The operators of the SSV network are the ones running Ethereum validators on users behalf in exchange of a fee in the SSV tokens for a certain period of time. It uses the Secret Shared Validator (SSV) technology to distribute the key shares among operators and using BLS signatures to create validator signature. This was implemented using the \"ssv-keys\" SDK , SSV APIs and network contracts to handle the distribution of keys and registering a validator. Furthermore, EigenLayer monitors and manages the balance and the withdrawal status using the EigenPOD which was created by the user using the \"EigenPODManager.sol\" and is the withdrawal address of the validator setup. This allows users to re stake their Native ETH and at the same time being able to earn rewards from EigenLayer as well. The deposit of 32 ETH is processed using the official beacon chain deposit contract on holesky. The key generation is currently done totally client side by the official CLI from ethereum but can be done with GUI as well. The whole process is done on the client side with no data or private info being leaked from our frontend interface developed using Next.js, Typescript, React-Query, Redux, Tailwind CSS, ShadCN UI & rainbowkit. Viem and wagmi are being used to handle the contract interactions as well.",
        "how_its_made": "We are using SSV Network and Eigenlayer to setup the whole process for demo purpose on the holesky testnet. The operators of the SSV network are the ones running Ethereum validators on users behalf in exchange of a fee in the SSV tokens for a certain period of time. It uses the Secret Shared Validator (SSV) technology to distribute the key shares among operators and using BLS signatures to create validator signature. This was implemented using the \"ssv-keys\" SDK , SSV APIs and network contracts to handle the distribution of keys and registering a validator. Furthermore, EigenLayer monitors and manages the balance and the withdrawal status using the EigenPOD which was created by the user using the \"EigenPODManager.sol\" and is the withdrawal address of the validator setup. This allows users to re stake their Native ETH and at the same time being able to earn rewards from EigenLayer as well. The deposit of 32 ETH is processed using the official beacon chain deposit contract on holesky. The key generation is currently done totally client side by the official CLI from ethereum but can be done with GUI as well. The whole process is done on the client side with no data or private info being leaked from our frontend interface developed using Next.js, Typescript, React-Query, Redux, Tailwind CSS, ShadCN UI & rainbowkit. Viem and wagmi are being used to handle the contract interactions as well.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/z3pxk/screenshots/jnq28/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z3pxk/screenshots/djssu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z3pxk/screenshots/pkq1b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z3pxk/screenshots/1xwcr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z3pxk/screenshots/9oadn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z3pxk/screenshots/02erv/default.jpg"
        ],
        "live_demo": "https://tesseract-ethonline.vercel.app/",
        "source_code": "https://github.com/kushagrasarathe/ethonline24",
        "link": "https://ethglobal.com/showcase/tesseract-z3pxk"
    },
    {
        "title": "Crypto PoS",
        "brief_description": "Crypto PoS is a Web3-ready Point of Sale system that uses NFC technology for fast, secure, and contactless cryptocurrency transactions. Supporting multiple blockchains, it simplifies payments for merchants and users, with features like zkVerify for privacy and ENS for trust.",
        "long_description": "Crypto PoS is a Web3-ready Point of Sale (PoS) system designed to revolutionize the way cryptocurrency transactions are conducted. By leveraging NFC (Near Field Communication) technology, it enables fast, secure, and contactless payments, making the process seamless and user-friendly for both merchants and customers. NFC Contactless Payments\nThe core innovation of Crypto PoS is its use of NFC technology, allowing users to tap NFC tags or cards to complete transactions. This eliminates the need for scanning QR codes, offering a more reliable and efficient alternative. Dual Protocol Modes Multi-chain Support\nCrypto PoS supports transactions across various blockchains, including Optimism Sepolia, Ethereum Sepolia, Celo Alfajores, Celo cUSD, and Zircuit Testnet. This ensures compatibility with a wide range of ecosystems, giving merchants the flexibility to accept payments from multiple chains. ENS (Ethereum Name Service) Integration\nCrypto PoS integrates ENS, displaying human-readable domain names associated with wallet addresses to provide trust and transparency during transactions. Invoice Generation\nMerchants can generate invoices using Request Network, streamlining the payment process and providing a comprehensive system for managing orders and receipts. Zero-Knowledge Proofs (zkVerify)\nTax reporting is simplified through zkVerify, which generates zero-knowledge proofs to report only the total amount handled by the merchant without revealing individual transaction details. This ensures both privacy and compliance when reporting to tax authorities. DBForest Integration for Transaction Storage\nTo further enhance privacy and ensure secure transaction storage, Crypto PoS utilizes DBForest, a decentralized storage solution. This ensures that transaction data remains tamper-proof and accessible for audit or reporting purposes. Traditional QR-based crypto payments, while useful, often suffer from scanning issues, delays, or potential misreads. Crypto PoS eliminates these problems by introducing NFC technology for contactless payments, ensuring a faster and more dependable user experience. This is particularly beneficial in busy retail environments where quick and seamless payments are essential. In addition to improving the payment process, Crypto PoS addresses concerns around privacy and regulatory compliance. The integration of zero-knowledge proofs ensures merchants can report their earnings without exposing sensitive transaction details. This offers a balance between transparency and privacy, addressing growing concerns in the crypto space. Crypto PoS is designed to be an all-encompassing, scalable, and secure solution for businesses looking to accept cryptocurrency payments while maintaining high levels of privacy and ease of use. It bridges the gap between traditional retail payment systems and the future of decentralized finance, offering a smooth, contactless transaction experience. How It's Made: Crypto PoS \u2013 The Nitty-Gritty Crypto PoS is the result of combining several cutting-edge Web3 technologies, NFC (Near Field Communication) protocols, and blockchain features to create a contactless Point of Sale system for cryptocurrency payments. The project revolves around integrating smart contracts, NFC readers, zero-knowledge proofs (zkProofs), and privacy-focused data storage solutions. Smart Contracts (Solidity)\nThe backbone of Crypto PoS is its smart contracts, written in Solidity, deployed on multiple blockchains: Optimism Sepolia, Ethereum Sepolia, Celo Alfajores, Celo cUSD, and Zircuit Testnet. The contracts manage balances, transfers, and transaction verifications. Each transaction is signed and confirmed through the contract, ensuring transparency and security. One interesting challenge was building the contract to handle NFC transactions efficiently. The card emulation mode needed to interact seamlessly with blockchain data to confirm on-chain payments. This was handled using BlockScout\u2019s API, which listens to transactions and triggers events within the PoS terminal. NFC Technology\nThe project utilizes NFC readers and tags/cards for seamless transactions. The system works in two modes: Handling communication between the PoS terminal and the blockchain was a tricky challenge. To overcome NFC limitations (such as short data transfer distances and low power availability), a custom Python script was written to handle low-level NFC communication efficiently. ENS Integration\nTo make payments more trustworthy, the system integrates Ethereum Name Service (ENS), allowing users and merchants to see human-readable wallet names instead of hexadecimal addresses. This integration was challenging due to compatibility issues with the system\u2019s HTML interface and web3.js, which I eventually worked around by using the ENS resolver library. Zero-Knowledge Proofs (zkVerify)\nOne of the standout features of Crypto PoS is its use of zkVerify for zero-knowledge proofs. This integration allows merchants to report transaction totals without revealing sensitive details. To implement this, I used Docker to containerize zkVerify\u2019s libraries, which had dependencies that were incompatible with my development environment (Ubuntu). Docker ensured a consistent environment for zkProof generation and verification. Breaking transaction hashes into smaller chunks (8 parts) to meet zkProof data limits was a particularly hacky solution. I had to split the data at the byte level and process it in pieces, then reconstruct it in the smart contract, ensuring everything aligned correctly. DBForest for Data Storage\nFor privacy-focused storage, DBForest was integrated into Crypto PoS to store transaction data securely. DBForest uses decentralized storage mechanisms, which was critical to ensure no single point of failure or data leakage. I implemented this for tax reporting, allowing merchants to store transaction data in a decentralized and encrypted way. This enabled zkProof-based privacy when reporting financial data. BlockScout API\nTo monitor on-chain transactions, Crypto PoS makes use of BlockScout\u2019s API. This API listens for confirmed transactions and triggers updates within the PoS system. I had to carefully manage transaction confirmations, balancing real-time updates with the necessary waiting time for finality on different blockchains. Request Network for Invoicing\nRequest Network was used to streamline the invoicing process for merchants. With its pre-built invoice templates and API integration, Crypto PoS allows merchants to automatically generate and send invoices for completed transactions. This eliminated the need to build a custom invoicing solution from scratch. Hacky Solutions\nSeveral hacky solutions were implemented during the development: Crypto PoS is built from the ground up with decentralized, privacy-focused solutions in mind. The use of NFC technology combined with multi-chain support and zero-knowledge proofs makes it a cutting-edge system for secure, contactless cryptocurrency payments. The project\u2019s modularity also allows it to be easily extended in the future, particularly with the planned custom smartcard and FIAT integration.",
        "how_its_made": "How It's Made: Crypto PoS \u2013 The Nitty-Gritty Crypto PoS is the result of combining several cutting-edge Web3 technologies, NFC (Near Field Communication) protocols, and blockchain features to create a contactless Point of Sale system for cryptocurrency payments. The project revolves around integrating smart contracts, NFC readers, zero-knowledge proofs (zkProofs), and privacy-focused data storage solutions. Smart Contracts (Solidity)\nThe backbone of Crypto PoS is its smart contracts, written in Solidity, deployed on multiple blockchains: Optimism Sepolia, Ethereum Sepolia, Celo Alfajores, Celo cUSD, and Zircuit Testnet. The contracts manage balances, transfers, and transaction verifications. Each transaction is signed and confirmed through the contract, ensuring transparency and security. One interesting challenge was building the contract to handle NFC transactions efficiently. The card emulation mode needed to interact seamlessly with blockchain data to confirm on-chain payments. This was handled using BlockScout\u2019s API, which listens to transactions and triggers events within the PoS terminal. NFC Technology\nThe project utilizes NFC readers and tags/cards for seamless transactions. The system works in two modes: Handling communication between the PoS terminal and the blockchain was a tricky challenge. To overcome NFC limitations (such as short data transfer distances and low power availability), a custom Python script was written to handle low-level NFC communication efficiently. ENS Integration\nTo make payments more trustworthy, the system integrates Ethereum Name Service (ENS), allowing users and merchants to see human-readable wallet names instead of hexadecimal addresses. This integration was challenging due to compatibility issues with the system\u2019s HTML interface and web3.js, which I eventually worked around by using the ENS resolver library. Zero-Knowledge Proofs (zkVerify)\nOne of the standout features of Crypto PoS is its use of zkVerify for zero-knowledge proofs. This integration allows merchants to report transaction totals without revealing sensitive details. To implement this, I used Docker to containerize zkVerify\u2019s libraries, which had dependencies that were incompatible with my development environment (Ubuntu). Docker ensured a consistent environment for zkProof generation and verification. Breaking transaction hashes into smaller chunks (8 parts) to meet zkProof data limits was a particularly hacky solution. I had to split the data at the byte level and process it in pieces, then reconstruct it in the smart contract, ensuring everything aligned correctly. DBForest for Data Storage\nFor privacy-focused storage, DBForest was integrated into Crypto PoS to store transaction data securely. DBForest uses decentralized storage mechanisms, which was critical to ensure no single point of failure or data leakage. I implemented this for tax reporting, allowing merchants to store transaction data in a decentralized and encrypted way. This enabled zkProof-based privacy when reporting financial data. BlockScout API\nTo monitor on-chain transactions, Crypto PoS makes use of BlockScout\u2019s API. This API listens for confirmed transactions and triggers updates within the PoS system. I had to carefully manage transaction confirmations, balancing real-time updates with the necessary waiting time for finality on different blockchains. Request Network for Invoicing\nRequest Network was used to streamline the invoicing process for merchants. With its pre-built invoice templates and API integration, Crypto PoS allows merchants to automatically generate and send invoices for completed transactions. This eliminated the need to build a custom invoicing solution from scratch. Hacky Solutions\nSeveral hacky solutions were implemented during the development: Crypto PoS is built from the ground up with decentralized, privacy-focused solutions in mind. The use of NFC technology combined with multi-chain support and zero-knowledge proofs makes it a cutting-edge system for secure, contactless cryptocurrency payments. The project\u2019s modularity also allows it to be easily extended in the future, particularly with the planned custom smartcard and FIAT integration.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3tjaj/screenshots/j9oxk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3tjaj/screenshots/jxwx1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3tjaj/screenshots/3cxni/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/albertoZurini/ETHOnline2024",
        "link": "https://ethglobal.com/showcase/crypto-pos-3tjaj"
    },
    {
        "title": "BlocFund",
        "brief_description": "BlocFund is a multichain decentralized fundraising platform that empowers users to support meaningful causes with transparency and trust across various blockchain networks.",
        "long_description": "BlocFund is a decentralized, multichain fundraising platform designed to connect users with meaningful causes through transparent and secure contributions. By leveraging blockchain technology, BlocFund enables users to create, manage, and contribute to fundraising campaigns with enhanced trust and accountability. The platform operates across multiple networks, including Celo, offering flexibility, low transaction costs, and broad accessibility. BlocFund integrates Sign Protocol, an omni-chain attestation protocol, to issue verifiable on-chain attestations for user contributions. This ensures structured, retrievable proof of participation, enhancing transparency and trust throughout the fundraising process. BlocFund is a multichain decentralized fundraising platform, designed to facilitate transparent and efficient charitable contributions across multiple blockchain networks. The platform allows users to create and manage campaigns, contribute funds, and track campaign progress using blockchain technology. Here's how the project was developed: Multichain Integration:\nWe integrated multiple blockchain networks, including Celo, to leverage scalability, low transaction costs, and broader access, making it an ideal choice for our decentralized application. Smart Contracts:\nThe core functionality of BlocFund is powered by smart contracts deployed on various blockchains. These contracts manage campaign creation, fund management, and contribution tracking, ensuring decentralized and trustless operation. Contract Verification:\nTo maintain transparency and trust, we used Blockscout (for Celo) and other blockchain explorers to verify the smart contracts. These explorers allow us to check transactions and provide a transparent view of contract interactions. Deployment:\nThe smart contracts for BlocFund were deployed across multiple testnets, including Celo Dango and Alfajores. These environments provide a safe space for development and testing before moving to the mainnets. Sign Protocol:\nAfter successful transactions, BlocFund utilizes the Sign Protocol to attest contributions for the user whenever a campaign is raised. This provides verifiable proof of participation, enhancing trust and accountability for contributors.",
        "how_its_made": "BlocFund is a multichain decentralized fundraising platform, designed to facilitate transparent and efficient charitable contributions across multiple blockchain networks. The platform allows users to create and manage campaigns, contribute funds, and track campaign progress using blockchain technology. Here's how the project was developed: Multichain Integration:\nWe integrated multiple blockchain networks, including Celo, to leverage scalability, low transaction costs, and broader access, making it an ideal choice for our decentralized application. Smart Contracts:\nThe core functionality of BlocFund is powered by smart contracts deployed on various blockchains. These contracts manage campaign creation, fund management, and contribution tracking, ensuring decentralized and trustless operation. Contract Verification:\nTo maintain transparency and trust, we used Blockscout (for Celo) and other blockchain explorers to verify the smart contracts. These explorers allow us to check transactions and provide a transparent view of contract interactions. Deployment:\nThe smart contracts for BlocFund were deployed across multiple testnets, including Celo Dango and Alfajores. These environments provide a safe space for development and testing before moving to the mainnets. Sign Protocol:\nAfter successful transactions, BlocFund utilizes the Sign Protocol to attest contributions for the user whenever a campaign is raised. This provides verifiable proof of participation, enhancing trust and accountability for contributors.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rqpwc/screenshots/vqz5a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rqpwc/screenshots/nebym/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rqpwc/screenshots/8euxa/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Yashaswini-Singh02/BlocFund",
        "link": "https://ethglobal.com/showcase/blocfund-rqpwc"
    },
    {
        "title": "NexArb",
        "brief_description": "Developing a ChatGPT plugin that leverages Chainlink's on-chain price oracle and Galadriel's computation for real-time trading data. It helps users identify and execute trades, even if they are inexperienced, with the results verified via the Sign Protocol.",
        "long_description": "This project aims to solve the limitations of ChatGPT in financial trading by creating a plugin that enables the platform to access external trading data and perform complex computations. Using Chainlink for real-time price data and Galadriel for on-chain computations, the plugin helps users identify trading opportunities. The target audience is people aged 20-45 who are interested in trading but lack the knowledge or tools to do so effectively. Once a user selects a trade, it is executed and verified through the Sign Protocol. The project integrates several technologies to create a seamless trading experience: Chainlink: Used for gathering real-time trading data via its price oracle.\nGaladriel: Handles complex computations, enabling the identification of trading opportunities.\nSign Protocol: Verifies the execution of trades. The system consists of a web app and a ChatGPT plugin. The app presents trade options to users, while the calculations are done on-chain.",
        "how_its_made": "The project integrates several technologies to create a seamless trading experience: Chainlink: Used for gathering real-time trading data via its price oracle.\nGaladriel: Handles complex computations, enabling the identification of trading opportunities.\nSign Protocol: Verifies the execution of trades. The system consists of a web app and a ChatGPT plugin. The app presents trade options to users, while the calculations are done on-chain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/f4gns/screenshots/spnf5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f4gns/screenshots/xs985/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f4gns/screenshots/zs4uz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f4gns/screenshots/wsdbk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f4gns/screenshots/dho9i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f4gns/screenshots/hevpz/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/FahriBilici/ETHOnline2024",
        "link": "https://ethglobal.com/showcase/nexarb-f4gns"
    },
    {
        "title": "MeMemagic",
        "brief_description": "MemeMagic is an AI-powered platform that lets you easily create, launch, and manage MemeCoins. Enter a keyword, and AI generates your token's name, symbol, and logo. Launch it on DEXs, manage liquidity, and bridge across blockchains\u2014no coding required!",
        "long_description": "Smart Contracts (Solidity): Bonding Curve Pricing: Uniswap & Liquidity Pools: Cross-Chain Bridging (LayerZero): AI & UI Integration:",
        "how_its_made": "Smart Contracts (Solidity): Bonding Curve Pricing: Uniswap & Liquidity Pools: Cross-Chain Bridging (LayerZero): AI & UI Integration:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/89tro/screenshots/7uw47/default.jpg",
            "https://ethglobal.b-cdn.net/projects/89tro/screenshots/xs9qr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/89tro/screenshots/ewhc8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/89tro/screenshots/s1jc9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Meme-Magic-AI/mememagic-contract",
        "link": "https://ethglobal.com/showcase/mememagic-89tro"
    },
    {
        "title": "ChainScan",
        "brief_description": "Create and manage attestations with a user-friendly form and view attested items in a dedicated tab.",
        "long_description": "This project is an advanced blockchain interface designed to manage and interact with cryptocurrency gratuities and digital attestations. It offers users a comprehensive view and control over their blockchain activities, including managing gratuities, creating attestations, and monitoring network and account statistics. Key Features: Gratuity Management: Attestation Management: Network and Account Statistics: NFT Details: Technical Details: Usage: This project leverages React for a dynamic frontend, styled with Tailwind CSS for a modern look. It uses Ethers.js and Wagmi to interact with Ethereum smart contracts deployed on the Sepolia testnet, handling transactions and state updates efficiently. The integration includes real-time notifications via React Hot Toast and employs custom hooks for streamlined contract interactions and error handling, ensuring a seamless and secure user experience for managing blockchain-based gratuities and attestations.",
        "how_its_made": "This project leverages React for a dynamic frontend, styled with Tailwind CSS for a modern look. It uses Ethers.js and Wagmi to interact with Ethereum smart contracts deployed on the Sepolia testnet, handling transactions and state updates efficiently. The integration includes real-time notifications via React Hot Toast and employs custom hooks for streamlined contract interactions and error handling, ensuring a seamless and secure user experience for managing blockchain-based gratuities and attestations.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/nfvs1/screenshots/ad3sn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nfvs1/screenshots/0kpa7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nfvs1/screenshots/njzw1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nfvs1/screenshots/j25vf/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sambitsargam/ChainScan",
        "link": "https://ethglobal.com/showcase/chainscan-nfvs1"
    },
    {
        "title": "Domino Wallet",
        "brief_description": "DominoWallet was created to provide the smoothest experience for visually impaired users. This was achieved by enabling voice-activated transfers and ensuring full accessibility throughout the application",
        "long_description": "DominoWallet was created to provide the smoothest experience for visually impaired users. This was achieved by enabling voice-activated transfers and ensuring full accessibility throughout the application. While developing the app, we utilized Lit Protocol's 'Sign with Action' feature, XMTP's in-app notifications, and Envion's blockscanner data integration capabilities. Our application targets all users who want to send cryptocurrency without physically interacting with their mobile devices in everyday situations. For example, your hands might be full, you're playing a game, cooking, or driving. In such scenarios, Domino Wallet comes into play, allowing you to complete transactions using voice commands. The wide range of use cases and fields is continuously expanding as people become more accustomed to and reliant on voice command technology. First, the user creates an account and funds it through transfers. Once the account is ready, they can transfer money using voice commands. The process starts when the user gives a voice command to Siri, which must include the transfer amount and the recipient\u2019s address. Siri then activates the phone, and the app opens. Using Lit Protocol\u2019s \"Sign with Action\" feature, the transaction is signed through the voice input. A unique claim link is generated and sent to the recipient via a notification using XMTP. The transaction amount is held in the app\u2019s pool. When the recipient opens the link, they are directed to the pool to claim the transferred funds. Finally, the transaction details are stored within the app using Envio's services.",
        "how_its_made": "First, the user creates an account and funds it through transfers. Once the account is ready, they can transfer money using voice commands. The process starts when the user gives a voice command to Siri, which must include the transfer amount and the recipient\u2019s address. Siri then activates the phone, and the app opens. Using Lit Protocol\u2019s \"Sign with Action\" feature, the transaction is signed through the voice input. A unique claim link is generated and sent to the recipient via a notification using XMTP. The transaction amount is held in the app\u2019s pool. When the recipient opens the link, they are directed to the pool to claim the transferred funds. Finally, the transaction details are stored within the app using Envio's services.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gb28e/screenshots/zv7qa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gb28e/screenshots/vzv04/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gb28e/screenshots/d8qas/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gb28e/screenshots/9mz01/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gb28e/screenshots/9srtq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gb28e/screenshots/8b85v/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/itublockchain/ETHOnline24-0",
        "link": "https://ethglobal.com/showcase/domino-wallet-gb28e"
    },
    {
        "title": "Freelance Forge",
        "brief_description": "The platform offers a Secure Payment Escrow, holding payments in a smart contract until work is completed, reducing fraud risk. It builds Trust and Transparency by automating payments, minimizing disputes, while Crypto Swap Features allow seamless exchanges, enhancing Utility.",
        "long_description": "Freelance Forge facilitates seamless project management by allowing clients and freelancers to: Create Binding Agreements: Establish a clear and secure escrow contract with predefined terms and conditions.\nEscrow and Fund Management: Clients can stake funds securely in an escrow contract, ensuring payment only upon successful completion of milestones.\nMilestone-Based Payments: The project is divided into milestones, with payments released as each milestone is completed.\nDispute Resolution: In case of disagreements, the contract can be canceled, with funds returned according to the terms of the agreement. And how does it work??\nFreelance Forge comprises two core smart contracts: And there are some accomplishments:\nRobust Smart Contracts: Developed secure and efficient smart contracts to manage the lifecycle of freelance projects.\nUser-Centric Design: Ensured that the platform is easy to use, with transparent operations that build trust between clients and freelancers.\nScalability: Successfully implemented a factory pattern to manage multiple freelance agreements, allowing the platform to scale effectively. Hence, Freelance Forge is a pioneering platform that leverages blockchain technology to create a secure, transparent, and efficient environment for freelance work. By automating key processes and ensuring trustless interactions, Freelance Forge sets a new standard for freelance project management. Freelance Forge leverages Solidity smart contracts to ensure trustless and transparent interactions between clients and freelancers. The platform\u2019s architecture consists of the following components: FreelanceAgreement: Handles individual project agreements, managing the lifecycle of the project, including state transitions, staking, milestone payments, and potential cancellations.\nFreelanceAgreementFactory: Manages the deployment of new agreements, ensuring each client-freelancer project is isolated within its own contract. Then, for the frontend and the backend, we used Next.js framework as it is more easy to use, and provide many libraries and packages, and correcting parsing and securing of data. Key Features:\nSecure Escrow: Funds are securely held in the contract until project milestones are completed.\nTransparent Project Management: Both parties can track the progress of the project and funds at any time.\nAutomated Payments: Payments are automatically released upon the successful completion of milestones.\nDispute Handling: Built-in mechanisms to handle cancellations and disputes, ensuring fairness for both parties. In developing, there were also challenges for us:\nComplex State Management: Managing the lifecycle of projects and ensuring that state transitions were secure and transparent required careful design and testing.\nStaking Mechanism: Ensuring that the staking and refund mechanisms worked flawlessly to prevent any fund mismanagement.\nScalability: Designing the platform to handle multiple agreements simultaneously while maintaining efficiency and security. Also we learnt a lot, few of the insights we gained are:\nAdvanced Solidity Concepts: Implementing complex state machines and handling financial transactions securely.\nFactory Design Pattern: Efficiently deploying and managing multiple instances of smart contracts.\nUser Trust: Building a platform that prioritizes transparency and fairness to foster trust between parties in a decentralized environment.",
        "how_its_made": "Freelance Forge leverages Solidity smart contracts to ensure trustless and transparent interactions between clients and freelancers. The platform\u2019s architecture consists of the following components: FreelanceAgreement: Handles individual project agreements, managing the lifecycle of the project, including state transitions, staking, milestone payments, and potential cancellations.\nFreelanceAgreementFactory: Manages the deployment of new agreements, ensuring each client-freelancer project is isolated within its own contract. Then, for the frontend and the backend, we used Next.js framework as it is more easy to use, and provide many libraries and packages, and correcting parsing and securing of data. Key Features:\nSecure Escrow: Funds are securely held in the contract until project milestones are completed.\nTransparent Project Management: Both parties can track the progress of the project and funds at any time.\nAutomated Payments: Payments are automatically released upon the successful completion of milestones.\nDispute Handling: Built-in mechanisms to handle cancellations and disputes, ensuring fairness for both parties. In developing, there were also challenges for us:\nComplex State Management: Managing the lifecycle of projects and ensuring that state transitions were secure and transparent required careful design and testing.\nStaking Mechanism: Ensuring that the staking and refund mechanisms worked flawlessly to prevent any fund mismanagement.\nScalability: Designing the platform to handle multiple agreements simultaneously while maintaining efficiency and security. Also we learnt a lot, few of the insights we gained are:\nAdvanced Solidity Concepts: Implementing complex state machines and handling financial transactions securely.\nFactory Design Pattern: Efficiently deploying and managing multiple instances of smart contracts.\nUser Trust: Building a platform that prioritizes transparency and fairness to foster trust between parties in a decentralized environment.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pr83s/screenshots/gq06k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pr83s/screenshots/3ag6a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pr83s/screenshots/p3cqw/default.jpg"
        ],
        "live_demo": "https://dapp-ashy-sigma.vercel.app/",
        "source_code": "https://github.com/WebThreee/BuildTheNewInternet",
        "link": "https://ethglobal.com/showcase/freelance-forge-pr83s"
    },
    {
        "title": "Private Auction",
        "brief_description": "Create open or closed auctions according to your own conditions",
        "long_description": "Most web3 auction platforms offer mainly public auctions, or auctions based on a simple whitelist system, while more complex systems require you to create your own platform. What if there were a platform open to all that allowed you to create auctions with your own access conditions? To achieve this, our platform is based on mina and its proof system. Thanks to the sideloading key, it's possible to use external proof systems as long as they respect our interface contract, a bit like using an api. So a private player could create an auction on our platform where only their customer could participate, or you could authorize only users who have already won an auction in the past...\nYou control your rules without disclosing them or your customers' sensitive information. This application is based on protokit and mina, the code is written in typescript and the interface in react. We use mina's sideloading key system to validate proofs created by users, so we rely on proofs for private auctions. When you create your auction, all you have to do is share the hash of your verification key, which will be used when someone bids on your auction to check that the proof he has submitted complies with your rules.",
        "how_its_made": "This application is based on protokit and mina, the code is written in typescript and the interface in react. We use mina's sideloading key system to validate proofs created by users, so we rely on proofs for private auctions. When you create your auction, all you have to do is share the hash of your verification key, which will be used when someone bids on your auction to check that the proof he has submitted complies with your rules.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/g8xzb/screenshots/9nbja/default.jpg",
            "https://ethglobal.b-cdn.net/projects/g8xzb/screenshots/igyky/default.jpg",
            "https://ethglobal.b-cdn.net/projects/g8xzb/screenshots/mqu9j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/g8xzb/screenshots/92jhb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/youtpout/private-auction",
        "link": "https://ethglobal.com/showcase/private-auction-g8xzb"
    },
    {
        "title": "VidEarn",
        "brief_description": "VidEarn: Empowering creators to own and monetize their content on Web3",
        "long_description": "VidEarn is a content platform designed for creators to showcase their work to users through both free and exclusive content, accessible via subscription. Users can purchase subscriptions using the custom token, and creators have the ability to offer perks and rewards to their audience. VidEarn operates on an omnichain structure using LayerZero, making it a multichain platform. The VidEarn project is built using various technologies such as Solidity smart contracts, the LayerZero library for omnichain NFTs, and Lit Protocol for exclusive content. For a Web2-like login experience, we utilize Web3 Auth Kit, and Chainlink CCIP allows users to bridge to different chains based on their preferences.",
        "how_its_made": "The VidEarn project is built using various technologies such as Solidity smart contracts, the LayerZero library for omnichain NFTs, and Lit Protocol for exclusive content. For a Web2-like login experience, we utilize Web3 Auth Kit, and Chainlink CCIP allows users to bridge to different chains based on their preferences.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mjo5j/screenshots/q2tvx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mjo5j/screenshots/2tp33/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mjo5j/screenshots/v3gzq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mjo5j/screenshots/g9733/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/itsshantanu/monitization-contracts",
        "link": "https://ethglobal.com/showcase/videarn-mjo5j"
    },
    {
        "title": "Mint & Crossbreed",
        "brief_description": "Mint & Crossbreed: An innovative NFT project on Galadriel blockchain. Create unique AI-generated NFTs based on your choices. Mint & crossbreed",
        "long_description": "Mint & Crossbreed: An innovative NFT project on Galadriel blockchain. Create unique AI-generated NFTs based on your choices. Low-cost on-chain AI inference meets user-friendly Web3Auth onboarding. Mint, crossbreed, and own truly personalized digital art in a seamless Web3 experience This project uses Galadriel DalleNft contract internally, our contract act as a wrapper and facilitates user inputs and translates to prompt which generate the nft DalleNft calls an oracle and from oracle callback, nft tokenIds get a tokenURI assigned and mints an nft eventually web3 auth helps onboarding new users with social and other login setup",
        "how_its_made": "This project uses Galadriel DalleNft contract internally, our contract act as a wrapper and facilitates user inputs and translates to prompt which generate the nft DalleNft calls an oracle and from oracle callback, nft tokenIds get a tokenURI assigned and mints an nft eventually web3 auth helps onboarding new users with social and other login setup",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/r6bqa/screenshots/uv3i4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6bqa/screenshots/wr9u4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6bqa/screenshots/xjh39/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6bqa/screenshots/zh923/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6bqa/screenshots/iska6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6bqa/screenshots/adi2k/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sharathkrml/crossbreed-nft",
        "link": "https://ethglobal.com/showcase/mint-and-crossbreed-r6bqa"
    },
    {
        "title": "Mint & Crossbreed",
        "brief_description": "Mint & Crossbreed: An innovative NFT project on Galadriel blockchain. Create unique AI-generated NFTs based on your choices. Mint & crossbreed",
        "long_description": "Mint & Crossbreed: An innovative NFT project on Galadriel blockchain. Create unique AI-generated NFTs based on your choices. Low-cost on-chain AI inference meets user-friendly Web3Auth onboarding. Mint, crossbreed, and own truly personalized digital art in a seamless Web3 experience This project uses Galadriel DalleNft contract internally, our contract act as a wrapper and facilitates user inputs and translates to prompt which generate the nft DalleNft calls an oracle and from oracle callback, nft tokenIds get a tokenURI assigned and mints an nft eventually web3 auth helps onboarding new users with social and other login setup",
        "how_its_made": "This project uses Galadriel DalleNft contract internally, our contract act as a wrapper and facilitates user inputs and translates to prompt which generate the nft DalleNft calls an oracle and from oracle callback, nft tokenIds get a tokenURI assigned and mints an nft eventually web3 auth helps onboarding new users with social and other login setup",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/r6bqa/screenshots/uv3i4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6bqa/screenshots/wr9u4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6bqa/screenshots/xjh39/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6bqa/screenshots/zh923/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6bqa/screenshots/iska6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r6bqa/screenshots/adi2k/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sharathkrml/crossbreed-nft",
        "link": "https://ethglobal.com/showcase/mint-and-crossbreed-r6bqa"
    },
    {
        "title": "BlockGovern",
        "brief_description": "BlockGovern is a groundbreaking decentralized application (DApp) revolutionizing small organizations' governance systems.",
        "long_description": "Simple Registration: Organizations can easily register on the platform by providing basic details, such as their name and other necessary information.\nPersonalized Pages: Upon registration, each organization receives a dedicated and customizable URL, leading to their own governance page.\nVoting Mechanism: Each post includes a voting section with options 'yes' and 'no,' allowing members to participate in decision-making processes.\nCost for Voting: To ensure responsible contributions, posting comes with a nominal cost set during account creation, which incentivizes thoughtful participation.\nTransparent Governance: BlockGovern utilizes blockchain technology to ensure transparency and immutability in all voting processes and post interactions.\nCommunity Engagement: The platform fosters active community engagement by encouraging members to share their opinions and participate in the decision-making process.\nData Privacy: Member data and voting preferences are securely stored on the blockchain, ensuring privacy and protection from unauthorized access. BlockGovern addresses the critical issue faced by small organizations in establishing effective governance systems without the complexities of launching their own tokens. Traditionally, token creation requires significant resources, technical knowledge, and regulatory compliance, making it a barrier for smaller entities. By offering a tokenless solution, BlockGovern simplifies the process, allowing organizations to focus on their core mission. With personalized pages, organizations gain a dedicated space to interact with their members, fostering transparent decision-making. The platform's voting mechanism empowers members to actively participate in crucial matters, contributing to a sense of community and inclusivity. By attaching a nominal cost to voting, BlockGovern ensures that posts are thoughtful and constructive, while generating revenue that directly benefits the organization. As a blockchain-based DApp, BlockGovern ensures the integrity of voting processes and data privacy, safeguarding sensitive information. It creates an environment where global participation is facilitated in a decentralized manner, promoting diverse perspectives and collective decision-making. Overall, BlockGovern's innovative approach transforms governance for small organizations, empowering them to thrive and grow without the burden of token creation.",
        "how_its_made": "BlockGovern addresses the critical issue faced by small organizations in establishing effective governance systems without the complexities of launching their own tokens. Traditionally, token creation requires significant resources, technical knowledge, and regulatory compliance, making it a barrier for smaller entities. By offering a tokenless solution, BlockGovern simplifies the process, allowing organizations to focus on their core mission. With personalized pages, organizations gain a dedicated space to interact with their members, fostering transparent decision-making. The platform's voting mechanism empowers members to actively participate in crucial matters, contributing to a sense of community and inclusivity. By attaching a nominal cost to voting, BlockGovern ensures that posts are thoughtful and constructive, while generating revenue that directly benefits the organization. As a blockchain-based DApp, BlockGovern ensures the integrity of voting processes and data privacy, safeguarding sensitive information. It creates an environment where global participation is facilitated in a decentralized manner, promoting diverse perspectives and collective decision-making. Overall, BlockGovern's innovative approach transforms governance for small organizations, empowering them to thrive and grow without the burden of token creation.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3mx6a/screenshots/8v5a9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3mx6a/screenshots/b3kbu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3mx6a/screenshots/p091z/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sumithprabhu/ETHOnline-2024",
        "link": "https://ethglobal.com/showcase/blockgovern-3mx6a"
    },
    {
        "title": "SignGPT",
        "brief_description": "SignGPT is a highly trained assistant that provides in-depth insights about the Sign Protocol and its ecosystem products. It answers queries with precision, making complex Sign topics accessible to newcomers, researchers, enthusiasts, and developers.",
        "long_description": "SignGPT assists developers in building dapps using the Sign Protocol, and the Community to understand and get benefits from the Sign Products through a conversational UI, powered by OpenAI Assistants, GPT-4o model, and the latest tech-stack. It helps developers code, fix, and test their smart contracts to build web3 applications on Sign. Simply enter a prompt in the UI to get accurate answers. Specially designed for the Sign community of developers and ecosystem products, SignGPT is developed by Asharib Ali as a submission for the \"Sign Protocol Hackathon on EthOnline 2024\". SignGPT offers many great features to help developers & community to build, ship, and earn quickly on Sign Protocol. Problem Statement with Solution: Developers want to build on Sign but lack an interactive way to quickly and easily create full-stack web3 applications, and community want to understand the diverse products of Sign. They might use ChatGPT, but it's trained on outdated data and doesn't know about the latest developments. Plus, GPT Plus costs $20 per month. That's why we need a platform/chatbot to address this issue: \"Help developers write, fix, and test their smart contracts & Community to understand and get benefits from the Sign Products for the Sign Protocol\" in a conversational way. I have trained it on a good amount of Sign Ecosystem products data via custom Google Search APIS, and have prompt-engineered it to achieve the best results. Features:\n\u27a1\ufe0f One time Name & Email require to access the Application.\n\ud83c\udfaf Personalized answers for community & developers.\n\ud83d\udd52 Real-time updates from Internet.\n\ud83d\udc68\u200d\ud83d\udcbb Chat via CUI (Conversational User Interface).\n\ud83c\udfa4 Voice functionality for easy interaction.\n\ud83d\udc4d Provide Feedback.\n\u2611\ufe0f12 Limit Messages per 24 hours. Benefits:\n\ud83c\udf1f Enhances developer experience.\n\ud83d\udcf0 Keeps the Sign community informed.\n\ud83c\udf10 Makes Sign more accessible.\n\ud83d\udcc8 Assist greater engagement and project development. Potential Integration:\nI have built two versions of the SignGPT, both have the same functionalities but one chatbot fixes in the full viewport of the screen and the other one is the pop-up version, both have the same functionality and are built with the same APIs, these chatbots can-be integrated into anywhere either on the complete subdomain of official website or the docs website but with the popup version. OpenAI Assistant APIs: Powers the natural language processing abilities to deliver accurate responses and maintain a conversational style with (function calling, code interpreter, and file search).\nFlowiseAI: Customized LLM orchestration flow tool.\nNext.js, TypeScript, TailwindCSS: Provides a seamless, dynamic user interface with a consistent design.\nOpenAI GPT-4o and Moderation APIs: Handles advanced chatbot responses and content moderation.\nGoogle Custom Search API: Allows the chatbot to fetch relevant information online to provide up-to-date answers.\nCustom Training Data with Prompt Engineering: Ensures precise responses through well-crafted prompts and curated data.\nOpenAI Whisper API for Speech-to-Text: Supports speech recognition to deliver a multi-modal experience.\nLangSmith API for Chatbot Analysis: Analyzes chatbot interactions for optimization and refinement.",
        "how_its_made": "OpenAI Assistant APIs: Powers the natural language processing abilities to deliver accurate responses and maintain a conversational style with (function calling, code interpreter, and file search).\nFlowiseAI: Customized LLM orchestration flow tool.\nNext.js, TypeScript, TailwindCSS: Provides a seamless, dynamic user interface with a consistent design.\nOpenAI GPT-4o and Moderation APIs: Handles advanced chatbot responses and content moderation.\nGoogle Custom Search API: Allows the chatbot to fetch relevant information online to provide up-to-date answers.\nCustom Training Data with Prompt Engineering: Ensures precise responses through well-crafted prompts and curated data.\nOpenAI Whisper API for Speech-to-Text: Supports speech recognition to deliver a multi-modal experience.\nLangSmith API for Chatbot Analysis: Analyzes chatbot interactions for optimization and refinement.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/d39e9/screenshots/rwzub/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d39e9/screenshots/jauso/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d39e9/screenshots/u3mni/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d39e9/screenshots/ctmpu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d39e9/screenshots/bqt9o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d39e9/screenshots/fuhq3/default.jpg"
        ],
        "live_demo": "https://signgpt.vercel.app/",
        "source_code": "https://github.com/AsharibAli/SignGPT",
        "link": "https://ethglobal.com/showcase/signgpt-d39e9"
    },
    {
        "title": "EthBus",
        "brief_description": "Our platform bridges tokens from Layer 2 to Layer 1 using CCIP, cutting gas fees by 90%. With our ETH bus mechanism, you share costs with others, paying just 1/10th of the typical bridge price. Enjoy affordable, efficient cross-chain transfers!",
        "long_description": "Our platform offers a cost-efficient solution for bridging tokens between Layer 2 and Layer 1 using Chainlink's Cross-Chain Interoperability Protocol (CCIP). Traditional token bridges can be expensive, often requiring users to pay the full gas fees associated with the transfer. Our unique approach, dubbed the \"ETH bus mechanism,\" drastically reduces these fees by distributing the cost across multiple participants. Here\u2019s how it works: users \"reserve a seat\" on the ETH bus, each committing to bridge their tokens. Once all 10 seats are filled, the bus is ready for departure. At this point, anyone can execute the transaction, and the executor earns a small fee for initiating the bridge process. This setup ensures that the high gas costs associated with Layer 1 transfers are shared among participants, lowering the individual burden to just 1/10th of the normal price. By pooling resources, we aim to make cross-chain transfers more affordable and accessible for everyone, reducing the friction typically associated with Layer 1 bridging. Our platform is built using Chainlink\u2019s Cross-Chain Interoperability Protocol (CCIP) to bridge tokens between Layer 1 and Layer 2. CCIP is critical for handling the complex cross-chain messaging that ensures secure and efficient token transfers, allowing us to focus on building a seamless user experience while benefiting from Chainlink\u2019s robust infrastructure. On the smart contract side, we utilized Foundry for testing and deployment. Foundry allowed us to thoroughly test the contract logic, especially around our \"ETH bus\" mechanism, ensuring that the fee-sharing model worked flawlessly. It provided us with the flexibility to quickly iterate and improve the contract\u2019s performance. For the frontend, we developed the interface using Next.js, which gives us a solid framework for building a scalable and performant web application. With Wagmi, we handle all the blockchain interactions on the frontend, enabling users to connect their wallets, interact with the contract, check balances, and initiate token bridges\u2014all in a smooth, user-friendly way. Together, these technologies helped us create an efficient platform that significantly reduces the cost of bridging tokens to Layer 1 while offering an intuitive and reliable user experience.",
        "how_its_made": "Our platform is built using Chainlink\u2019s Cross-Chain Interoperability Protocol (CCIP) to bridge tokens between Layer 1 and Layer 2. CCIP is critical for handling the complex cross-chain messaging that ensures secure and efficient token transfers, allowing us to focus on building a seamless user experience while benefiting from Chainlink\u2019s robust infrastructure. On the smart contract side, we utilized Foundry for testing and deployment. Foundry allowed us to thoroughly test the contract logic, especially around our \"ETH bus\" mechanism, ensuring that the fee-sharing model worked flawlessly. It provided us with the flexibility to quickly iterate and improve the contract\u2019s performance. For the frontend, we developed the interface using Next.js, which gives us a solid framework for building a scalable and performant web application. With Wagmi, we handle all the blockchain interactions on the frontend, enabling users to connect their wallets, interact with the contract, check balances, and initiate token bridges\u2014all in a smooth, user-friendly way. Together, these technologies helped us create an efficient platform that significantly reduces the cost of bridging tokens to Layer 1 while offering an intuitive and reliable user experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/39iua/screenshots/htwyg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/39iua/screenshots/9idcf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/39iua/screenshots/6adss/default.jpg",
            "https://ethglobal.b-cdn.net/projects/39iua/screenshots/6617j/default.jpg"
        ],
        "live_demo": "https://eth-bus.vercel.app/",
        "source_code": "https://github.com/0xale/EthBus",
        "link": "https://ethglobal.com/showcase/ethbus-39iua"
    },
    {
        "title": "KARO",
        "brief_description": "This is a privacy focused, multiplayer UNO card game played on chain.",
        "long_description": "We have developed a decentralized UNO card game leveraging Kakarot (a zkevm built usiing cairo). By utilizing Kakarot for its robust blockchain capabilities and a privacy layer we have built a secure and transparent card gaming environment that adheres to the principles of Web3. Problem:\nTraditional online card games suffer from trust issues where players doubt the fairness of the game. Centralized platforms often have control over the game mechanics, leading to potential manipulation or lack of transparency. Additionally, the visibility of players\u2019 hands and decks can compromise the integrity of the game, as some players might gain an unfair advantage. Solution:\nOur UNO card game, built on the Kakarot blockchain with a privacy layer addresses these concerns by ensuring that all game mechanics are decentralized and transparent, while the privacy layer guarantees that players' hands and the deck remain hidden. This ensures that no player can gain an unfair advantage, and the integrity of the game is preserved. The integration of a commit-and-reveal mechanism further ensures that all moves are verifiable without compromising privacy. Detailed Project Description\nThe project consists of several key components that ensure a secure, transparent, and fair gaming experience: Game Logic: Decentralized Gameplay: The core game logic, including card shuffling, dealing, and turn management, is implemented on chain using Solidity smart contracts. This ensures that all game actions are transparent, verifiable, and tamper-proof. Game State Management and Updates: The state of the game (e.g., current turn, remaining cards, and played cards) is managed on-chain, ensuring that it is consistent, tamper-proof, and available to all players in real-time. State updates occur with every action taken by players, such as drawing a card or playing a card. The states are synced across clients using socket.io Action Validation and Application: Each player\u2019s action is validated on-chain to ensure it adheres to the game rules. Invalid actions are rejected, and the game state is updated only when valid actions are applied. State Reconstruction and Verification: To maintain fairness and transparency, the game state can be reconstructed and verified by any participant or observer using the transaction history recorded on the blockchain. This ensures that all players can audit the game at any time. Privacy Layer: Confidential Hands and Decks: The hands of each player and the remaining deck are encrypted and stored in the client the other aspects are hashed and stored on chain leveraging its privacy-preserving capabilities. This ensures that no player, except the one holding the cards, can view the contents of any hand\n.\nCryptographic Operations: Cryptographic primitives such as hashing and encryption/decryption are employed to ensure the security and privacy of game data. For example, the deck is shuffled and encrypted and only the relevant cards are decrypted for each player. Deck Shuffling and Initial State Generation: The deck is shuffled in a cryptographically secure manner ensuring that the order of cards is random and unknown to all players. The initial game state is generated with encrypted decks and distributed in a manner that ensures no information leakage. Commit-and-Reveal Mechanism: Ensuring Fairness: A commit-and-reveal scheme is used to prevent cheating. Players first commit to their actions (e.g., the card they intend to play) by submitting a hash. After all commitments are made, they reveal their actions. This prevents any player from changing their action based on others' actions. The decentralized UNO card game is technically built with a combination of Kakarot blockchain and a privacy layer, utilizing several key technologies to ensure fairness, privacy, and transparency. Smart Contracts: The game logic (card dealing, turn management, action validation) is written in Solidity smart contracts on the Kakarot blockchain. This ensures all actions are publicly verifiable, immutable, and tamper-proof. Game State Management: Each player's turn, remaining cards, and game state transitions are stored and managed on-chain. Updates to the game state occur after every validated player action. Action Validation and Commit-Reveal: Each action, such as playing a card, is committed via a hash, and revealed after all players commit, ensuring no player can manipulate their actions based on others' moves. Privacy Layer: The privacy-preserving implementation manage the sensitive aspects of the game, like players\u2019 hands and the deck. These elements are encrypted to ensure that no one, except the player, can see their hand. Deck Shuffling and Cryptographic Operations: Decks are shuffled and encrypted using secure cryptographic algorithms. When a player draws a card, only the specific card is decrypted and revealed to them. State Reconstruction and Verification: While the private elements are hidden, the state of the game remains verifiable by all players through cryptographic commitments, ensuring fairness without exposing sensitive information. Frontend in React & Tailwind CSS: Integration with Smart Contracts: The frontend communicates with the smart contracts via wallet integrations, allowing players to seamlessly interact with both blockchain and privacy layers during gameplay. Syncing states across clients: It utilizes Socket.io to synchronize game states in real-time between clients. This ensures that players experience seamless updates, such as turns, card plays, and game progress, without needing to rely solely on the blockchain for frequent state updates. Socket.io manages the real-time communication between players' frontends, ensuring the user interface reflects the current state of the game instantly. This architecture ensures that the game's fairness is guaranteed through decentralization, while players' privacy is preserved through our privacy layer and encrypted state management.",
        "how_its_made": "The decentralized UNO card game is technically built with a combination of Kakarot blockchain and a privacy layer, utilizing several key technologies to ensure fairness, privacy, and transparency. Smart Contracts: The game logic (card dealing, turn management, action validation) is written in Solidity smart contracts on the Kakarot blockchain. This ensures all actions are publicly verifiable, immutable, and tamper-proof. Game State Management: Each player's turn, remaining cards, and game state transitions are stored and managed on-chain. Updates to the game state occur after every validated player action. Action Validation and Commit-Reveal: Each action, such as playing a card, is committed via a hash, and revealed after all players commit, ensuring no player can manipulate their actions based on others' moves. Privacy Layer: The privacy-preserving implementation manage the sensitive aspects of the game, like players\u2019 hands and the deck. These elements are encrypted to ensure that no one, except the player, can see their hand. Deck Shuffling and Cryptographic Operations: Decks are shuffled and encrypted using secure cryptographic algorithms. When a player draws a card, only the specific card is decrypted and revealed to them. State Reconstruction and Verification: While the private elements are hidden, the state of the game remains verifiable by all players through cryptographic commitments, ensuring fairness without exposing sensitive information. Frontend in React & Tailwind CSS: Integration with Smart Contracts: The frontend communicates with the smart contracts via wallet integrations, allowing players to seamlessly interact with both blockchain and privacy layers during gameplay. Syncing states across clients: It utilizes Socket.io to synchronize game states in real-time between clients. This ensures that players experience seamless updates, such as turns, card plays, and game progress, without needing to rely solely on the blockchain for frequent state updates. Socket.io manages the real-time communication between players' frontends, ensuring the user interface reflects the current state of the game instantly. This architecture ensures that the game's fairness is guaranteed through decentralization, while players' privacy is preserved through our privacy layer and encrypted state management.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/c8rhs/screenshots/fr8g8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c8rhs/screenshots/bc0np/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c8rhs/screenshots/mrtw8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c8rhs/screenshots/huf1c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/c8rhs/screenshots/cwn1q/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ronykris/gameofuno",
        "link": "https://ethglobal.com/showcase/karo-c8rhs"
    },
    {
        "title": "Blockless-wizard",
        "brief_description": "Automate Blockless CLI tasks like project initialization, deployment, and management seamlessly within VS Code.",
        "long_description": "This project is a VS Code extension that automates tasks related to the Blockless Network Command Line Interface (CLI). It aims to streamline and simplify the development and deployment process for developers building on the Blockless Network, a platform for decentralized, serverless applications. By integrating common CLI commands and workflows directly into VS Code, this extension allows users to execute complex tasks with minimal effort and directly from their editor, reducing the need to switch between the terminal and development environment. Key Capabilities: This project was built as a VS Code extension with the goal of streamlining the development workflow for the Blockless Network. Below are the technical details and steps involved in building it:",
        "how_its_made": "This project was built as a VS Code extension with the goal of streamlining the development workflow for the Blockless Network. Below are the technical details and steps involved in building it:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/36vmh/screenshots/qoxwz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/36vmh/screenshots/97n80/default.jpg",
            "https://ethglobal.b-cdn.net/projects/36vmh/screenshots/596rn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/36vmh/screenshots/s1eef/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/PrabalParihar/blockless-wizard",
        "link": "https://ethglobal.com/showcase/blockless-wizard-36vmh"
    },
    {
        "title": "OurFunds",
        "brief_description": "\"OurFunds\" enhances DAO governance by providing a secure platform for transparent fund management, democratic voting, and efficient dispute resolution, all while ensuring regulatory compliance and security with Kinto\u2019s KYC protocols.",
        "long_description": "OurFunds addresses critical operational and governance challenges within decentralized organizations by providing a comprehensive and secure platform for fund management and dispute resolution. Accountability: It actively involves stakeholders in governance through a democratic process of proposals and voting, ensuring that every member has a say in how funds are managed. Efficient Dispute Resolution: \"Our Funds\" incorporates built-in dispute resolution mechanisms that allow for efficient and fair handling of conflicts, including options for stake slashing in cases of fund misuse. Regulatory Compliance & Security: Leveraging Kinto\u2019s Kyc and Safety Protocols We can Make sure the application is safe and Bot Free OurFunds not only streamlines the operational aspects of DAO management but also fosters a culture of transparency and accountability. By empowering members through democratic governance and protecting their interests with secure and fair dispute resolution, the platform not only enhances internal trust but also boosts the DAO\u2019s credibility externally. The integration of regulatory compliance further positions the DAO to operate seamlessly across borders, making it a truly global entity. Kinto Chain's KYC and Compliance Tools: Leveraging Kinto\u2019s infrastructure, \"Our Funds\" incorporates user verification and compliance checks to meet regulatory requirements and enhance security. Kinto\u2019s protocols help ensure that all participants are verified, reducing the risk of fraud.\nSign Protocol: Verifiable Signing to Enable Democratic Decision Making",
        "how_its_made": "Kinto Chain's KYC and Compliance Tools: Leveraging Kinto\u2019s infrastructure, \"Our Funds\" incorporates user verification and compliance checks to meet regulatory requirements and enhance security. Kinto\u2019s protocols help ensure that all participants are verified, reducing the risk of fraud.\nSign Protocol: Verifiable Signing to Enable Democratic Decision Making",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/cnvf1/screenshots/6407b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cnvf1/screenshots/9pxnr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cnvf1/screenshots/jhrdm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cnvf1/screenshots/04f9j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cnvf1/screenshots/85r4c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cnvf1/screenshots/gbn39/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/RomarioKavin1/ourFunds",
        "link": "https://ethglobal.com/showcase/ourfunds-cnvf1"
    },
    {
        "title": "Expressions",
        "brief_description": "Social dapp to conglomerate activities and reactions from different sport clubs",
        "long_description": "This project aims to collect all club activities in a single dapp where every interaction is onchain/offchain and signed with member private keys. The idea is to have a clear record of who said/decided/voted what in order to bring transparency.\nWe'd like to track all following activities via attestations to the project: We decided to create a webapp demo in order to present the skeleton of our product. For this webapp we are using Wagmi for the frontend given all React hooks it provides, then we use Sign protocol as core project to create all schemas and corresponding attestations, in detail we are using Sign Protocol SDK to facilitate interaction with SP smart contracts allowing users to create attestations.",
        "how_its_made": "We decided to create a webapp demo in order to present the skeleton of our product. For this webapp we are using Wagmi for the frontend given all React hooks it provides, then we use Sign protocol as core project to create all schemas and corresponding attestations, in detail we are using Sign Protocol SDK to facilitate interaction with SP smart contracts allowing users to create attestations.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/403j1/screenshots/a74ij/default.jpg",
            "https://ethglobal.b-cdn.net/projects/403j1/screenshots/r3ext/default.jpg",
            "https://ethglobal.b-cdn.net/projects/403j1/screenshots/tez53/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/hackethglobal/Expressions",
        "link": "https://ethglobal.com/showcase/expressions-403j1"
    },
    {
        "title": "Remove-bg",
        "brief_description": "a tiny portrait background removal model, locally in the browser using Transformers.js, WebGPU-acceleration, and Basin to store and retrieve processed images on-chain.",
        "long_description": "A simple React + Vite application designed for running MODNet, a lightweight portrait background removal model, entirely in the browser. This solution leverages Transformers.js for seamless integration of machine learning models, while utilizing WebGPU acceleration to ensure smooth performance. Additionally, Basin is integrated to securely store and retrieve processed images on-chain, providing a decentralized solution for managing image data. This combination allows for a highly efficient, privacy-focused, and scalable application, fully powered by modern web technologies. Follow the steps below to set up and run the application (both frontend and backend). Ensure that you have Basin properly set up by following this guide. Once Basin is running, verify that ADM commands can be executed on your machine. Clone the repository from GitHub: Change your working directory to the basin-remove-bg folder: Install the necessary dependencies for the frontend using npm: We need a backend to handle file uploads and interact with ADM. rename the  template.env file in the project root to store your environment variables (Network and Private Key for ADM): In your .env file, add the following: Replace your_private_key_here with your actual private key for ADM transactions. Navigate to the backend directory and install the necessary backend dependencies: Start the backend server, which will handle file uploads and interactions with ADM: The backend server will be running on http://localhost:5555. Now that the backend is running, return to the main project directory (frontend) and start the development server: The application should now be running locally. Open your browser and go to http://localhost:3511 to see it in action.",
        "how_its_made": "Follow the steps below to set up and run the application (both frontend and backend). Ensure that you have Basin properly set up by following this guide. Once Basin is running, verify that ADM commands can be executed on your machine. Clone the repository from GitHub: Change your working directory to the basin-remove-bg folder: Install the necessary dependencies for the frontend using npm: We need a backend to handle file uploads and interact with ADM. rename the  template.env file in the project root to store your environment variables (Network and Private Key for ADM): In your .env file, add the following: Replace your_private_key_here with your actual private key for ADM transactions. Navigate to the backend directory and install the necessary backend dependencies: Start the backend server, which will handle file uploads and interactions with ADM: The backend server will be running on http://localhost:5555. Now that the backend is running, return to the main project directory (frontend) and start the development server: The application should now be running locally. Open your browser and go to http://localhost:3511 to see it in action.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mahme/screenshots/4agbw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mahme/screenshots/i4j7c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mahme/screenshots/g8f6v/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xgoldenlion/basin-remove-bg",
        "link": "https://ethglobal.com/showcase/remove-bg-mahme"
    },
    {
        "title": "RD",
        "brief_description": "RD is a Remotely opratable Decentralized Door",
        "long_description": "A Remotely Operable Decentralized Door (RD) integrates blockchain technology with smart contracts to control access to physical doors from anywhere. By leveraging decentralized networks, RD systems allow secure and verifiable remote management of door operations. Users interact with the system through a frontend application (like one built with React) to grant or restrict access, while the backend (e.g., Django) handles user authentication and interface logic, ensuring a seamless and secure experience. Hardhat and Solidity for smart contract development, React for the frontend, and Django for the backend. This setup allows you to build a full-stack decentralized application with a user-friendly interface, robust backend, and smart contracts managing blockchain interactions.",
        "how_its_made": "Hardhat and Solidity for smart contract development, React for the frontend, and Django for the backend. This setup allows you to build a full-stack decentralized application with a user-friendly interface, robust backend, and smart contracts managing blockchain interactions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xoxuz/screenshots/jkhy1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xoxuz/screenshots/wh84t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xoxuz/screenshots/qh5ir/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/VedantTarale/RD",
        "link": "https://ethglobal.com/showcase/rd-xoxuz"
    },
    {
        "title": "paintwfrens",
        "brief_description": "Become da Vinci himself in this multiplayer drawing game! Mint your collective work as NFTs.",
        "long_description": "This is a multiplayer drawing which currently has 3 modes Currently adding: 1v1 mode with AI generated topic and judging (Galadriel). AI generated topics will be added to other modes as well",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/av2d7/screenshots/m5jn8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/av2d7/screenshots/0mdmz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/av2d7/screenshots/yaudv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/awesamarth/paintwfrens/",
        "link": "https://ethglobal.com/showcase/paintwfrens-av2d7"
    },
    {
        "title": "Uniswap Position",
        "brief_description": "Tracking Uniswap Position: token amount, position value.. so we can analysis about impermanent lost",
        "long_description": "This project provide a tool for tracking uniswap position (currently on mainnet only, but it will expand soon). Defi users always scare of impermanent loss, so this tool will provide an overview about our position in a long time, hence we can improve Defi strategy. This project currently provide UniV3 position info on mainnet with information about: amount of token (both tokens), price of token. There will be a front end for it, but it still ongoing task. Users will have ability to configure which pool they need to track, on which chain and can query all the information to view on charts. This project use some functions on Uniswap SDK to get position info, and Coingecko API for token pricing. After gathering all information, they will be put in SQlite DB.  There will be interval for getting information to ensure every information not be missed or duplicated. The project also provide HTTP API for querying data from DB in JSON format using express.",
        "how_its_made": "This project use some functions on Uniswap SDK to get position info, and Coingecko API for token pricing. After gathering all information, they will be put in SQlite DB.  There will be interval for getting information to ensure every information not be missed or duplicated. The project also provide HTTP API for querying data from DB in JSON format using express.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/7wn9d/screenshots/s5i30/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7wn9d/screenshots/b7a7v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7wn9d/screenshots/fvcf2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/tnm0113/uniswap-position",
        "link": "https://ethglobal.com/showcase/uniswap-position-7wn9d"
    },
    {
        "title": "SuperVoteChain",
        "brief_description": "Our blockchain voting app uses the OP Stack for scalability, Conduit for rollup deployment, BlockScout for transparency, Pyth Network for random numbers, and Tenderly for Web3 infrastructure. Wallet Connect ensures secure user authentication for a reliable voting experience.",
        "long_description": "Our blockchain-based voting application is designed to revolutionize the voting process by incorporating state-of-the-art technologies to enhance security, transparency, and efficiency. The project is built on the OP Stack, which provides a robust Layer 2 solution for scalability and seamless integration with Ethereum. Conduit simplifies the deployment of rollups, allowing us to rapidly deploy and manage our voting solution without extensive coding. BlockScout offers detailed insights into blockchain transactions, ensuring that all voting activities are transparent and verifiable.\nThe Pyth Network is utilized for its reliable random number generation and price feeds, which are crucial for creating tamper-proof voting mechanisms and ensuring the integrity of random selection processes. Tenderly provides a full-stack Web3 infrastructure, supporting our application with comprehensive tools for development, testing, and live monitoring.\nAdditionally, the integration of Wallet Connect streamlines user authentication, making it easier for voters to participate securely. Our platform is designed to handle high volumes of transactions and adapt to various voting scenarios, from small organizational votes to large-scale elections. With a focus on user-friendly interfaces and robust security features, our voting application aims to provide a reliable and accessible voting experience that upholds democratic values and ensures fair outcomes. OP Stack: Purpose: The OP Stack was chosen for its scalable Layer 2 solution capabilities. It provides a foundation for creating and managing Ethereum-compatible Layer 2 chains, enhancing transaction throughput and reducing costs.\nIntegration: We deployed our smart contracts on the OP Superchain using scaffold-eth, benefiting from its high performance and low latency. The modular nature of the OP Stack also facilitated the integration of additional layers and modules tailored to our needs. Conduit:\nPurpose: Conduit simplifies the deployment process for rollups, allowing us to focus on the application rather than the underlying infrastructure.\nIntegration: We used Conduit to deploy our rollups with minimal code, streamlining the process and reducing deployment time. This integration provided us with a ready-made infrastructure for scaling our application.\nBlockScout:\nPurpose: BlockScout offers an open-source, transparent blockchain explorer, which is essential for monitoring and validating transactions.\nIntegration: We integrated BlockScout to provide users with a comprehensive view of all voting activities, ensuring transparency and traceability. Its support for various chains allowed us to monitor our rollups effectively.\nPyth Network:\nPurpose: Pyth Network provides reliable random number generation and price feeds, crucial for ensuring the integrity and fairness of the voting process.\nIntegration: We utilized Pyth\u2019s Entropy service for generating random numbers used in vote tallying and other processes requiring unpredictability. The price feeds were used to manage and verify the value of staking tokens or rewards. Tenderly:\nPurpose: Tenderly offers a complete Web3 infrastructure with tools for development, testing, and monitoring.\nIntegration: We leveraged Tenderly\u2019s node RPC for interacting with the blockchain, virtual testnets for pre-deployment testing, and live state synchronization to ensure our application remained up-to-date with the latest network changes. Tenderly\u2019s admin RPC capabilities also helped us manipulate network states during testing.\n2. Integration and Workflow: Smart Contracts: Developed using Solidity, our smart contracts were deployed on the OP Superchain. These contracts handle all voting logic, including vote casting, tallying, and result verification.\nIntegration with Conduit allowed us to deploy these contracts efficiently on the rollup, ensuring scalability and reduced costs.\nFrontend Development:\nBuilt using NextJS, our frontend interface allows users to interact with the voting system. It includes features for voting, tracking results, and viewing transaction histories.\nIntegrated with Tenderly Wallet Connect to handle user authentication securely and to facilitate interactions with the blockchain.\nBackend Infrastructure:\nNode.js was used for the backend services, which handle interactions between the frontend and the blockchain. This includes processing votes, managing user sessions, and interfacing with Pyth Network for random number generation.\n3. Notable Implementations: Hacky Solutions:\nCustom Middleware: We developed custom middleware to handle communication between our React frontend and the blockchain. This middleware optimizes transaction processing and integrates with Tenderly\u2019s debugging tools to ensure smooth interactions.\nOptimized Random Number Generation: While Pyth Network\u2019s Entropy service is robust, we implemented additional checks and fallback mechanisms to ensure random number integrity and mitigate any potential issues.\n4. Benefits of Partner Technologies: OP Stack and Conduit: Enabled scalable and efficient rollup deployments, reducing overhead and simplifying management.\nBlockScout: Provided transparency and detailed blockchain insights, which are crucial for verifying vote accuracy and integrity.\nPyth Network: Ensured fairness and security in voting processes through reliable random number generation and accurate data feeds.\nTenderly: Streamlined development and testing processes, ensuring our application could handle real-world conditions and scale effectively.",
        "how_its_made": "OP Stack: Purpose: The OP Stack was chosen for its scalable Layer 2 solution capabilities. It provides a foundation for creating and managing Ethereum-compatible Layer 2 chains, enhancing transaction throughput and reducing costs.\nIntegration: We deployed our smart contracts on the OP Superchain using scaffold-eth, benefiting from its high performance and low latency. The modular nature of the OP Stack also facilitated the integration of additional layers and modules tailored to our needs. Conduit:\nPurpose: Conduit simplifies the deployment process for rollups, allowing us to focus on the application rather than the underlying infrastructure.\nIntegration: We used Conduit to deploy our rollups with minimal code, streamlining the process and reducing deployment time. This integration provided us with a ready-made infrastructure for scaling our application.\nBlockScout:\nPurpose: BlockScout offers an open-source, transparent blockchain explorer, which is essential for monitoring and validating transactions.\nIntegration: We integrated BlockScout to provide users with a comprehensive view of all voting activities, ensuring transparency and traceability. Its support for various chains allowed us to monitor our rollups effectively.\nPyth Network:\nPurpose: Pyth Network provides reliable random number generation and price feeds, crucial for ensuring the integrity and fairness of the voting process.\nIntegration: We utilized Pyth\u2019s Entropy service for generating random numbers used in vote tallying and other processes requiring unpredictability. The price feeds were used to manage and verify the value of staking tokens or rewards. Tenderly:\nPurpose: Tenderly offers a complete Web3 infrastructure with tools for development, testing, and monitoring.\nIntegration: We leveraged Tenderly\u2019s node RPC for interacting with the blockchain, virtual testnets for pre-deployment testing, and live state synchronization to ensure our application remained up-to-date with the latest network changes. Tenderly\u2019s admin RPC capabilities also helped us manipulate network states during testing.\n2. Integration and Workflow: Smart Contracts: Developed using Solidity, our smart contracts were deployed on the OP Superchain. These contracts handle all voting logic, including vote casting, tallying, and result verification.\nIntegration with Conduit allowed us to deploy these contracts efficiently on the rollup, ensuring scalability and reduced costs.\nFrontend Development:\nBuilt using NextJS, our frontend interface allows users to interact with the voting system. It includes features for voting, tracking results, and viewing transaction histories.\nIntegrated with Tenderly Wallet Connect to handle user authentication securely and to facilitate interactions with the blockchain.\nBackend Infrastructure:\nNode.js was used for the backend services, which handle interactions between the frontend and the blockchain. This includes processing votes, managing user sessions, and interfacing with Pyth Network for random number generation.\n3. Notable Implementations: Hacky Solutions:\nCustom Middleware: We developed custom middleware to handle communication between our React frontend and the blockchain. This middleware optimizes transaction processing and integrates with Tenderly\u2019s debugging tools to ensure smooth interactions.\nOptimized Random Number Generation: While Pyth Network\u2019s Entropy service is robust, we implemented additional checks and fallback mechanisms to ensure random number integrity and mitigate any potential issues.\n4. Benefits of Partner Technologies: OP Stack and Conduit: Enabled scalable and efficient rollup deployments, reducing overhead and simplifying management.\nBlockScout: Provided transparency and detailed blockchain insights, which are crucial for verifying vote accuracy and integrity.\nPyth Network: Ensured fairness and security in voting processes through reliable random number generation and accurate data feeds.\nTenderly: Streamlined development and testing processes, ensuring our application could handle real-world conditions and scale effectively.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vwi6c/screenshots/w9foz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vwi6c/screenshots/z4vyr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vwi6c/screenshots/poxn4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vwi6c/screenshots/tkvbr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vwi6c/screenshots/0gcsw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vwi6c/screenshots/akp75/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/anj20/VoteChain",
        "link": "https://ethglobal.com/showcase/supervotechain-vwi6c"
    },
    {
        "title": "ElectroChain",
        "brief_description": "ElectroChain: A secure, transparent voting system for Africa. Uses ZK tech & MACI for voter anonymity. Prevents vote discovery, eliminates social pressure risks. Decentralized solution for fair elections.",
        "long_description": "ElectroChain is an innovative blockchain-based voting system designed to address electoral challenges in Nigeria and other African countries. It leverages Zero-Knowledge technology and Minimal Anti-Collusion Infrastructure (MACI) to ensure voter anonymity and prevent vote manipulation. Key features include: ElectroChain aims to increase voter participation, enhance security, and automate result verification through smart contracts. Its business model includes government contracts, corporate voting services, and a commitment to improving democratic processes globally. ElectroChain leverages MACI (Minimal Anti-Collusion Infrastructure) to ensure voter anonymity and security. At its core, we integrate Alchemy's Account Abstraction for seamless onboarding, enabling embedded accounts, gasless transactions, and biometric signing. This makes it easy for voters to sign and send transactions securely. Understanding the challenges of limited internet access in Nigeria, we've also integrated USSD functionality via Africa's Talking, allowing voters with basic phones or no internet to cast their votes safely and efficiently. This solution ensures accessibility for all, maintaining transparency and security in elections.",
        "how_its_made": "ElectroChain leverages MACI (Minimal Anti-Collusion Infrastructure) to ensure voter anonymity and security. At its core, we integrate Alchemy's Account Abstraction for seamless onboarding, enabling embedded accounts, gasless transactions, and biometric signing. This makes it easy for voters to sign and send transactions securely. Understanding the challenges of limited internet access in Nigeria, we've also integrated USSD functionality via Africa's Talking, allowing voters with basic phones or no internet to cast their votes safely and efficiently. This solution ensures accessibility for all, maintaining transparency and security in elections.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gnutn/screenshots/h3eec/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gnutn/screenshots/bmsgt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gnutn/screenshots/yowgc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gnutn/screenshots/zc7t9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Ayodeji63/ElectroChain",
        "link": "https://ethglobal.com/showcase/electrochain-gnutn"
    },
    {
        "title": "DIMO Analytics Hub",
        "brief_description": "SDK/API that will provide high-level information from the DIMO protocol API to developers and D-insurance app.",
        "long_description": "The Undiscovered Potential of DIMO API Data\nDIMO data has huge undiscovered potential to improve the lives of drivers and businesses. To make the technology popular, it should provide an easy-to-integrate high-level API that allows developers to build their own applications in 3 days, such as As part of the hackathon, it was decided to create an SDK that uses DIMO data and calculates the driving discipline score, both for trips and for the vehicle, based on the following parameters As well as DEMO application. Backend technologies:\nDIMO-node-js SDK: Used to retrieve vehicle data. This suggests the project involves collecting and processing information from vehicles.\nNode.js: Employed for the DIMO Analytics HUB API.\nD-insurance backend: Backend for the Demo mobile app, we've used node.js as well . Mobile app development:\nKotlin Compose Multiplatform: Used for developing both iOS and Android mobile apps. This is a modern toolkit for building native UI for iOS and Android from a single codebase, which significantly streamlines the mobile development process.",
        "how_its_made": "Backend technologies:\nDIMO-node-js SDK: Used to retrieve vehicle data. This suggests the project involves collecting and processing information from vehicles.\nNode.js: Employed for the DIMO Analytics HUB API.\nD-insurance backend: Backend for the Demo mobile app, we've used node.js as well . Mobile app development:\nKotlin Compose Multiplatform: Used for developing both iOS and Android mobile apps. This is a modern toolkit for building native UI for iOS and Android from a single codebase, which significantly streamlines the mobile development process.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/znut4/screenshots/oqii2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/znut4/screenshots/nffxs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/znut4/screenshots/3pxzs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/znut4/screenshots/yg7f6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/znut4/screenshots/p9uvt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/znut4/screenshots/hnhj1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/DIMO-analytics-hub-aiwe/dimo-analytics-hub",
        "link": "https://ethglobal.com/showcase/dimo-analytics-hub-znut4"
    },
    {
        "title": "Feedback Dapp",
        "brief_description": "Want to share your feedback of a DApp? Now you can, with Feedback Dapp!",
        "long_description": "This is a single page application with a form which has three fields, it has Dapp Name, Comments and Rating, the first two fields are strings and the rating is between 0-5. Now say you want to rate Uniswap, a 5 star and share your experience, you can do so by submitting the form and attesting your opinion. This project uses Rainbow Kit Wallet for wallet provision and signer. We use NextJs and Chakra UI for Frontend and UI/Ux, we use React-hook-form for Form, We use Sign protocol for Attestation of Feedback.\nWe use Sign Protocol SDK for attesting the attestations to the schema we created. And use GraphQL to fetch the details",
        "how_its_made": "This project uses Rainbow Kit Wallet for wallet provision and signer. We use NextJs and Chakra UI for Frontend and UI/Ux, we use React-hook-form for Form, We use Sign protocol for Attestation of Feedback.\nWe use Sign Protocol SDK for attesting the attestations to the schema we created. And use GraphQL to fetch the details",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ijtc1/screenshots/csqd6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ijtc1/screenshots/n4ifv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ijtc1/screenshots/qz1jb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Rashmi-278/Feedback-DApp",
        "link": "https://ethglobal.com/showcase/feedback-dapp-ijtc1"
    },
    {
        "title": "w3b_Agent",
        "brief_description": "AI-powered Web3 image generator agent bot. It captures the fusion of AI, blockchain, and real-time digital art creation.",
        "long_description": "Ethereum enabled writing smart contracts to build dApps. Similarly, Galadriel enables developers to build AI apps & agents like smart contracts \u2014 decentralized and on-chain. We support a range of AI usage: from simple LLM features in existing dApps to highly capable AI agents like on-chain AI hedge funds, in-game AI NPCs and AI-generated NFTs. Galadriel is built on a parallel-execution EVM stack which enables high throughput and low latency while providing a familiar experience to Solidity developers. It brings AI inference on-chain in a low-cost, low-latency manner through teeML (Trusted Execution Environment Machine Learning) which allows querying open and closed-source LLM models in a verifiable way. The core of how Galadriel enables on-chain AI is the oracle. The oracle enables contracts to make external API calls (including LLMs). It offers an interface for Solidity contracts on the Galadriel chain to call out LLMs or other models, use tools, and retrieve data. The oracle is implemented as a contract that is called asynchronously and has an off-chain component. This is similar in architecture to ChainLink. However, because tool calls (e.g. web searches) and LLM calls do not produce deterministic results nor cannot be averaged, consensus on those requests is not possible. To solve this, we execute the oracle in a trusted execution environment \u2014 see the TEE section. To make your own on-chain AI, you need to build your Solidity contract in a specific way to interact with the oracle. Making a call to most contracts on EVM chains is synchronous: the call is made, and the result is returned immediately. However, the oracle is asynchronous: the call is made, and the result is returned later, when the oracle has finished processing the request off-chain. The async nature of the oracle is because on-chain programs cannot typically execute long-running tasks (block time is the ceiling on execution time). Due to the above, to make a call to an LLM, generative image model, external tool, or anything else via the oracle you need to use a callback function. This function is called by the oracle when the result is ready. The oracle sits atop a parallel, EVM-compatible Layer 1, based on Cosmos SDK & Sei v2.",
        "how_its_made": "The core of how Galadriel enables on-chain AI is the oracle. The oracle enables contracts to make external API calls (including LLMs). It offers an interface for Solidity contracts on the Galadriel chain to call out LLMs or other models, use tools, and retrieve data. The oracle is implemented as a contract that is called asynchronously and has an off-chain component. This is similar in architecture to ChainLink. However, because tool calls (e.g. web searches) and LLM calls do not produce deterministic results nor cannot be averaged, consensus on those requests is not possible. To solve this, we execute the oracle in a trusted execution environment \u2014 see the TEE section. To make your own on-chain AI, you need to build your Solidity contract in a specific way to interact with the oracle. Making a call to most contracts on EVM chains is synchronous: the call is made, and the result is returned immediately. However, the oracle is asynchronous: the call is made, and the result is returned later, when the oracle has finished processing the request off-chain. The async nature of the oracle is because on-chain programs cannot typically execute long-running tasks (block time is the ceiling on execution time). Due to the above, to make a call to an LLM, generative image model, external tool, or anything else via the oracle you need to use a callback function. This function is called by the oracle when the result is ready. The oracle sits atop a parallel, EVM-compatible Layer 1, based on Cosmos SDK & Sei v2.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/oovnd/screenshots/1scy3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oovnd/screenshots/r9ygt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oovnd/screenshots/th0yr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oovnd/screenshots/dipps/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Bild96/w3b3_agent",
        "link": "https://ethglobal.com/showcase/w3b-agent-oovnd"
    },
    {
        "title": "AuthWallet 2.5",
        "brief_description": "Simplifying Wallet Management with OAuth2.0, OpenID Connect, JWT, and RSA Verification and Account Abstraction",
        "long_description": "AuthWallet 2.5 revolutionizes the way users interact with Ethereum wallets by integrating OAuth2.0, OpenID Connect, JWT, and RSA verification. This user-friendly solution eliminates the need for complex private key management, making secure wallet interactions accessible to all users. With AuthWallet, users can send ETH by email, manage attestations, and execute cross-chain transactions with ease.  Usually, KMS servers act as intermediaries for social sign-ins, but AuthWallet 2.5 directly verifies the ID Token from the Identity Provider (IdP) within the smart contract, removing the need for an intermediary.  The application leverages Chainlink Functions and Chainlink Automation to securely fetch Google\u2019s JSON Web Key Set (JWKS). These keys are used to verify JWTs signed by Google. The JWKS data is regularly updated to ensure the authenticity and integrity of the keys used in RSA signature verification for OAuth2.0 tokens. Users authenticate via OAuth2.0 and OpenID Connect flows. Upon successful authentication, the user receives an ID Token containing key information, including an account abstraction user operation hash. This hash represents a cryptographic fingerprint of the user's intended transaction on the blockchain. The ID Token generated during sign-in contains a JWT. A dedicated smart contract verifies the JWT using RSA signature verification against the modulus fetched from the JWKS oracle. This ensures that the JWT is authentic and has been signed by Google. The contract interacts with the Chainlink-powered JWKS oracle to retrieve and validate the appropriate RSA keys used for signature verification. The AuthWallet 2.5 is fully compatible with EIP-1193: Ethereum Provider JavaScript API. It also supports modern Ethereum libraries like viem and wagmi, making it easy to integrate with decentralized applications (dApps). In this demo, we utilize RainbowKit to simplify the connection of AuthWallet 2.5 to the Ethereum network. With AuthWallet 2.5, users do not need to have an existing wallet address to get started. This eliminates the barrier of requiring a wallet setup before onboarding, making it easier for new users to engage with the Ethereum ecosystem. This implementation is heavily inspired by the referenced article and has been adapted to align with ERC4337 account abstraction principles. https://forum.openzeppelin.com/t/sign-in-with-google-to-your-identity-contract-for-fun-and-profit/1631",
        "how_its_made": " Usually, KMS servers act as intermediaries for social sign-ins, but AuthWallet 2.5 directly verifies the ID Token from the Identity Provider (IdP) within the smart contract, removing the need for an intermediary.  The application leverages Chainlink Functions and Chainlink Automation to securely fetch Google\u2019s JSON Web Key Set (JWKS). These keys are used to verify JWTs signed by Google. The JWKS data is regularly updated to ensure the authenticity and integrity of the keys used in RSA signature verification for OAuth2.0 tokens. Users authenticate via OAuth2.0 and OpenID Connect flows. Upon successful authentication, the user receives an ID Token containing key information, including an account abstraction user operation hash. This hash represents a cryptographic fingerprint of the user's intended transaction on the blockchain. The ID Token generated during sign-in contains a JWT. A dedicated smart contract verifies the JWT using RSA signature verification against the modulus fetched from the JWKS oracle. This ensures that the JWT is authentic and has been signed by Google. The contract interacts with the Chainlink-powered JWKS oracle to retrieve and validate the appropriate RSA keys used for signature verification. The AuthWallet 2.5 is fully compatible with EIP-1193: Ethereum Provider JavaScript API. It also supports modern Ethereum libraries like viem and wagmi, making it easy to integrate with decentralized applications (dApps). In this demo, we utilize RainbowKit to simplify the connection of AuthWallet 2.5 to the Ethereum network. With AuthWallet 2.5, users do not need to have an existing wallet address to get started. This eliminates the barrier of requiring a wallet setup before onboarding, making it easier for new users to engage with the Ethereum ecosystem. This implementation is heavily inspired by the referenced article and has been adapted to align with ERC4337 account abstraction principles. https://forum.openzeppelin.com/t/sign-in-with-google-to-your-identity-contract-for-fun-and-profit/1631",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1i9gq/screenshots/zomf3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1i9gq/screenshots/46rju/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1i9gq/screenshots/bvz40/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1i9gq/screenshots/10i8w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1i9gq/screenshots/66t6k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1i9gq/screenshots/n5qdk/default.jpg"
        ],
        "live_demo": "https://auth-wallet.vercel.app/",
        "source_code": "https://github.com/taijusanagi/auth-wallet",
        "link": "https://ethglobal.com/showcase/authwallet-2-5-1i9gq"
    },
    {
        "title": "Payroll Protocol",
        "brief_description": "We make transactions both confidential and incredibly easy, ensuring that your sensitive financial data stays secure while providing a seamless, user-friendly experience.",
        "long_description": "Payroll Protocol is a confidential money distribution platform built on top of BNB , designed to provide confidentiality during the distribution of funds on-chain. By leveraging FHE cryptography and smart contracts, Payroll Protocol ensures the confidentiality, security, and efficiency of money distribution. Payroll Protocol integrates BICONOMY AA SDK, BNB and INCO FHEVM to enhance user experience while confidentially distributing money. INCO FHEVM provides hidden states to store encrypted addresses that hold encrypted amounts on the INCO network, ensuring that all transactions are secure and confidential. This integration guarantees that money distribution details and recipient information remain confidential. It uses modified Hyperlane infrastructure to bridge these state values from BNB to INCO and vice versa. Key Features\nEncrypted USDC Distributions: Protects sensitive information with robust encryption methods.\nUser-Friendly Interface: Simplifies the payroll process with one click, thanks to BICONOMY SDK.\nStealth Hold: Users can hold stablecoins for an indefinite amount of time without revealing the amount.\nUnderline Distribution: Users can completely hide their withdrawals by distributing the encrypted amount to different encrypted addresses on their behalf, providing an experience similar to Tornado Cash. TFHE functions examples:\nmapping(eaddress => euint32) private ownerToBalance; Acknowledgements\nBiconomy\nBNB\nINCO FHEVM How We Built Payroll Protocol (With a Dash of Fun)\nSo, building Payroll Protocol was kind of like assembling IKEA furniture\u2014only with way more encryption and fewer leftover screws (hopefully). Here\u2019s a peek at the ingredients we used to whip this thing up:",
        "how_its_made": "How We Built Payroll Protocol (With a Dash of Fun)\nSo, building Payroll Protocol was kind of like assembling IKEA furniture\u2014only with way more encryption and fewer leftover screws (hopefully). Here\u2019s a peek at the ingredients we used to whip this thing up:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/kjkoz/screenshots/b4zhq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kjkoz/screenshots/udmgx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kjkoz/screenshots/fqc96/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kjkoz/screenshots/0ttbb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kjkoz/screenshots/do1wp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kjkoz/screenshots/g0ifg/default.jpg"
        ],
        "live_demo": "https://payroll-bnb.vercel.app/",
        "source_code": "https://github.com/vwakesahu/eth-online-2024",
        "link": "https://ethglobal.com/showcase/payroll-protocol-kjkoz"
    },
    {
        "title": "Bet-a-Meme",
        "brief_description": "Bet-A-Meme:  The Ultimate Viral Meme Betting  platform where memes meet blockchain. Bet on viral meme templates, compete to make them go viral, and earn rewards. Powered by Sign Protocol, it's the ultimate fusion of social media trends and decentralized finance.",
        "long_description": "Bet-a-Meme  is a  platform where users can bet on meme templates they believe will go viral, combining the thrill of meme culture with the excitement of decentralized betting. Users compete to make their chosen meme the most popular by creating, sharing, and posting it with a unique hashtag. The meme template that gets the most posts wins, and users who bet on it earn their stake back with a bonus. This project is designed to harness the viral nature of memes, creating a community-driven, competitive environment where creativity meets blockchain technology. To ensure transparency, security, and fairness in the betting process, Bet-a-Meme integrates Sign Protocol in innovative ways through Schema Hooks and Attestations. Functionalities of Bet-a-Meme: When a user places a bet on a meme template, Sign Protocol is used to create an attestation on the blockchain. This attestation records the details of the bet, including the user\u2019s wallet address, the amount staked, and the specific meme template they\u2019ve bet on.\nThe Schema Hooks in this process ensure that custom logic is triggered when a bet is made. For example, the hooks update user profiles in real-time, keeping track of the total number of battles the user has participated in, the amount staked, and their overall betting history.\nThis integration allows the platform to maintain a fully verifiable record of every bet, ensuring transparency and preventing any tampering or disputes in the future. Once a meme battle concludes, users who bet on the winning meme template can claim their rewards. During this process, Schema Hooks verify the eligibility of each user before allowing them to claim their winnings.\nThe Schema Hooks check the blockchain attestations to confirm whether a user placed a valid bet on the winning meme. Only users with valid attestations can claim their rewards, ensuring that no one can fraudulently claim prizes.\nThe claim function triggers another attestation revocation, marking the reward as \u201cclaimed\u201d and preventing duplicate claims. The use of Sign Protocol ensures that the reward distribution process is decentralized, transparent, and verifiable. Since every bet and reward claim is recorded as an attestation on the blockchain, the platform provides a trustless system where users can independently verify the outcome.\nThe reward distribution logic, triggered by Schema Hooks, guarantees fairness by automatically distributing the rewards based on the virality of the memes, ensuring that the system is free from human interference or bias. The integration of Sign Protocol opens up opportunities for expanding Bet-a-Meme\u2019s functionality. In future versions, the platform could introduce more advanced betting strategies, such as multi-tiered betting or side bets, all governed by Sign Protocol\u2019s attestations and Schema Hooks. The platform could also implement community-driven governance features, where users can vote on new meme battles or rules, with Schema Hooks used to validate votes and actions on-chain. Why Sign Protocol is Critical to Bet-a-Meme\u2019s Success? By leveraging Sign Protocol, Bet-a-Meme enhances its core functionalities, ensuring that the platform is truly decentralized, secure, and transparent. The use of Schema Hooks allows for real-time custom logic during bet creation and reward claims, automating processes that would otherwise require manual oversight. This not only improves the user experience but also provides a robust framework for scaling the platform in the future. Furthermore, the integration of Sign Protocol transforms Bet-a-Meme from a simple betting platform into a trustless, verifiable ecosystem. Every bet and reward claim is transparent and provable, building confidence among users and fostering a fair, engaging, and competitive environment for meme creators and trend-predictors alike. Real-World Problem Solving: Viral Culture Monetization: Memes are a vital part of modern internet culture, but monetizing them has always been a challenge. Bet-a-Meme allows users to actively participate in meme virality, not just as content creators but as investors and participants. By betting on viral trends, users can earn real rewards, adding a new layer of value to digital content sharing. Decentralized Betting with Transparency: Traditional betting platforms often lack transparency, with users unsure if the outcomes are fair or tampered with. By using blockchain technology and Sign Protocol's attestations, Bet-a-Meme provides a provable, transparent betting process where outcomes are verifiable and trusted by all participants. Empowering Community Engagement: Bet-a-Meme fosters a highly engaging community where users can not only bet but collaborate on making memes viral. This platform provides a space where online culture can be influenced directly by its participants in a fun, competitive, and rewarding way. How it's Made : Server-side rendering for fast load times and improved SEO.\nEasy navigation through file-based routing.\nBuilt-in API routes for seamless backend functionality.\nComponents like AttestationTable, MemeChatroom, and BattleDetails handle specific tasks, making the app modular and efficient. Styling: Tailwind CSS powers the design for quick, consistent UI development. Its utility-first approach keeps the interface clean and responsive. State Management: React hooks (useState and useEffect) handle state locally, ensuring efficient management of dynamic data, especially in components like AttestationTable. Backend & Database: Firebase provides: Real-time database\nAuthentication\nCloud functions\nIt powers features like chat and battle management, ensuring instant updates and real-time engagement. Wallet connections\nSmart contract interactions for creating and managing on-chain battles\nThis adds decentralization and transparency to the betting process. Transparent record-keeping of user actions\nSecure transactions\nPotential for advanced features like dynamic betting based on user scores\nAPI Integration: Using RapidAPI, the app fetches Instagram post counts to track meme virality, creating a direct link between social media and blockchain betting outcomes. Particularly Notable/Hacky Implementations: Schema Hooks: The use of Sign Protocol's Schema Hooks for bet creation and reward claims is a standout feature. This allows for custom logic to be executed on-chain when attestations are created , adding an extra layer of security and functionality to the betting process. For example: What we did in MemeChatRoom.tsx file when User is Betting on a Meme... and AttestationTable.tsx file when User is claiming his/her rewards. Social Media Integration: The use of RapidAPI to fetch Instagram post counts as a measure of meme virality is an innovative approach to determining battle winners. This creates a unique bridge between blockchain technology and real-world social media trends. Real-time Chat in Blockchain Context: Combining real-time chat functionality (powered by Firebase) with blockchain-based betting in the same interface is a unique feature that enhances user engagement. This integration allows users to discuss and strategize about their bets in real-time, adding a social layer to the blockchain betting experience. Dynamic Battle Management: The ability to create battles, add memes, and declare winners dynamically, all while integrating with blockchain technology, showcases a complex system working seamlessly. This is particularly evident in the AddMemeBattle component: By leveraging these technologies and integrations, Bet-A-Meme  creates a unique platform that bridges the gap between viral internet culture and blockchain technology. The combination of Next.js for the frontend, Firebase for real-time functionality, Ethereum for blockchain integration, and Sign Protocol for secure attestations results in a robust, engaging, and potentially rewarding experience in the world of memes and blockchain betting.",
        "how_its_made": "How it's Made : Server-side rendering for fast load times and improved SEO.\nEasy navigation through file-based routing.\nBuilt-in API routes for seamless backend functionality.\nComponents like AttestationTable, MemeChatroom, and BattleDetails handle specific tasks, making the app modular and efficient. Styling: Tailwind CSS powers the design for quick, consistent UI development. Its utility-first approach keeps the interface clean and responsive. State Management: React hooks (useState and useEffect) handle state locally, ensuring efficient management of dynamic data, especially in components like AttestationTable. Backend & Database: Firebase provides: Real-time database\nAuthentication\nCloud functions\nIt powers features like chat and battle management, ensuring instant updates and real-time engagement. Wallet connections\nSmart contract interactions for creating and managing on-chain battles\nThis adds decentralization and transparency to the betting process. Transparent record-keeping of user actions\nSecure transactions\nPotential for advanced features like dynamic betting based on user scores\nAPI Integration: Using RapidAPI, the app fetches Instagram post counts to track meme virality, creating a direct link between social media and blockchain betting outcomes. Particularly Notable/Hacky Implementations: Schema Hooks: The use of Sign Protocol's Schema Hooks for bet creation and reward claims is a standout feature. This allows for custom logic to be executed on-chain when attestations are created , adding an extra layer of security and functionality to the betting process. For example: What we did in MemeChatRoom.tsx file when User is Betting on a Meme... and AttestationTable.tsx file when User is claiming his/her rewards. Social Media Integration: The use of RapidAPI to fetch Instagram post counts as a measure of meme virality is an innovative approach to determining battle winners. This creates a unique bridge between blockchain technology and real-world social media trends. Real-time Chat in Blockchain Context: Combining real-time chat functionality (powered by Firebase) with blockchain-based betting in the same interface is a unique feature that enhances user engagement. This integration allows users to discuss and strategize about their bets in real-time, adding a social layer to the blockchain betting experience. Dynamic Battle Management: The ability to create battles, add memes, and declare winners dynamically, all while integrating with blockchain technology, showcases a complex system working seamlessly. This is particularly evident in the AddMemeBattle component: By leveraging these technologies and integrations, Bet-A-Meme  creates a unique platform that bridges the gap between viral internet culture and blockchain technology. The combination of Next.js for the frontend, Firebase for real-time functionality, Ethereum for blockchain integration, and Sign Protocol for secure attestations results in a robust, engaging, and potentially rewarding experience in the world of memes and blockchain betting.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ctp5f/screenshots/gssva/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ctp5f/screenshots/qz48v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ctp5f/screenshots/zehg3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ctp5f/screenshots/qisxn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ctp5f/screenshots/z12er/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ctp5f/screenshots/m55pp/default.jpg"
        ],
        "live_demo": "https://betameme.vercel.app/",
        "source_code": "https://github.com/Madhav-Gupta-28/Ethonline-2024/",
        "link": "https://ethglobal.com/showcase/bet-a-meme-ctp5f"
    },
    {
        "title": "Buy The Quake",
        "brief_description": "Buy The Quake leverages Lit Protocol's MPC to create tamper-proof, decentralized earthquake reports. It transforms seismic data into verifiable proofs, enhancing disaster response and insurance claim processes with blockchain-backed reliability.",
        "long_description": "Buy The Quake is an platform that bridges seismic monitoring and blockchain technology, opening up new possibilities for DeFi (Decentralized Finance) and disaster response. By leveraging Lit Protocol's Multi-Party Computation (MPC) capabilities, our project creates immutable and verifiable proofs of earthquake occurrences and triggers DeFi action to hedge the risk of natural disasters. Buy the Quake is built on a focused stack of cutting-edge technologies, carefully integrated to create an innovative and efficient system: Lit Protocol: At the core of our project is Lit Protocol's Multi-Party Computation (MPC) system. We leverage Lit's decentralized network to generate cryptographic proofs of earthquake events. This ensures that our seismic data is verifiable and tamper-proof, as no single party has complete control over the proof generation process. Taiwan Earthquake API: We integrate directly with the Taiwan earthquake API to fetch real-time seismic data. This reliable source of earthquake information serves as the crucial input for our proof generation process, allowing us to create DeFi products based on actual seismic events in Taiwan. Base Onchain Kit: We utilized the Base onchain kit for both our frontend and backend development. This comprehensive toolkit provided us with a robust template to build our decentralized application, ensuring compatibility with the Base ecosystem and streamlining our development process. Frontend: The Base onchain kit's frontend template allowed us to quickly set up a responsive and user-friendly interface for our DeFi products.\nBackend: Using the backend template from the Base onchain kit, we established a solid foundation for handling blockchain interactions and processing seismic data. Smart Contract Integration: Building on the Base onchain kit, we've developed smart contracts that interact with our Lit Protocol-generated proofs. These contracts form the backbone of our DeFi products, such as earthquake prediction markets or parametric insurance policies.",
        "how_its_made": "Buy the Quake is built on a focused stack of cutting-edge technologies, carefully integrated to create an innovative and efficient system: Lit Protocol: At the core of our project is Lit Protocol's Multi-Party Computation (MPC) system. We leverage Lit's decentralized network to generate cryptographic proofs of earthquake events. This ensures that our seismic data is verifiable and tamper-proof, as no single party has complete control over the proof generation process. Taiwan Earthquake API: We integrate directly with the Taiwan earthquake API to fetch real-time seismic data. This reliable source of earthquake information serves as the crucial input for our proof generation process, allowing us to create DeFi products based on actual seismic events in Taiwan. Base Onchain Kit: We utilized the Base onchain kit for both our frontend and backend development. This comprehensive toolkit provided us with a robust template to build our decentralized application, ensuring compatibility with the Base ecosystem and streamlining our development process. Frontend: The Base onchain kit's frontend template allowed us to quickly set up a responsive and user-friendly interface for our DeFi products.\nBackend: Using the backend template from the Base onchain kit, we established a solid foundation for handling blockchain interactions and processing seismic data. Smart Contract Integration: Building on the Base onchain kit, we've developed smart contracts that interact with our Lit Protocol-generated proofs. These contracts form the backbone of our DeFi products, such as earthquake prediction markets or parametric insurance policies.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/x89gz/screenshots/f0mkj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x89gz/screenshots/tvj9t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x89gz/screenshots/552g3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ryanycw/buy-the-quake",
        "link": "https://ethglobal.com/showcase/buy-the-quake-x89gz"
    },
    {
        "title": "Nothing",
        "brief_description": "Training AI models on data that has been encrypted through FHE. The project tries to secure the privacy of user's data by encrypting it through FHE and yet ensuring that operations can be performed by any AI model on it.",
        "long_description": "The project focuses on training AI models on data encrypted through Fully Homomorphic Encryption (FHE), a cutting-edge approach aimed at safeguarding user privacy while enabling secure data processing. FHE is a form of encryption that allows computations to be performed directly on encrypted data without needing to decrypt it first. This means that AI models can process data, perform predictions, or extract insights without ever exposing the raw, sensitive information. By leveraging FHE, the project seeks to address critical privacy concerns associated with the increasing use of AI in sensitive domains like healthcare, finance, and personal data analytics. Traditional methods of encrypting data require decryption before processing, which exposes the data to potential breaches and compromises privacy. However, FHE allows data to remain encrypted throughout the entire AI training and inference process. This approach ensures that user data remains confidential, as it is never revealed to the model, the infrastructure, or even the developers managing the AI system. This level of privacy protection is particularly crucial in today\u2019s landscape, where data privacy regulations like GDPR and CCPA demand stringent measures to protect personal information. The challenge of integrating FHE with AI training lies in the computational overhead and complexity of working with encrypted data. Encrypted data is often significantly larger and more complex to manipulate than plaintext data, making the training process computationally intensive and slower. However, advancements in both FHE schemes and AI model optimization are gradually mitigating these hurdles, making the combination more feasible. This project aims to push the boundaries of AI and cryptography, developing systems where privacy does not come at the expense of performance or accuracy. By enabling AI models to operate on encrypted data, it envisions a future where user privacy is not just an afterthought but a foundational aspect of AI-driven solutions. This project aims to push the boundaries of AI and cryptography, developing systems where privacy does not come at the expense of performance or accuracy. By enabling AI models to operate on encrypted data, it envisions a future where user privacy is not just an afterthought but a foundational aspect of AI-driven solutions.",
        "how_its_made": "This project aims to push the boundaries of AI and cryptography, developing systems where privacy does not come at the expense of performance or accuracy. By enabling AI models to operate on encrypted data, it envisions a future where user privacy is not just an afterthought but a foundational aspect of AI-driven solutions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jshh2/screenshots/vkydt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jshh2/screenshots/ggef1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jshh2/screenshots/awkaa/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/surfer05/BlackBox",
        "link": "https://ethglobal.com/showcase/nothing-jshh2"
    },
    {
        "title": "StreamNil",
        "brief_description": "This project is a Streamlit web application that demonstrates the use of Nillion's secret computation capabilities for basic mathematical operations",
        "long_description": "The app performs two simple math operations: addition and subtraction.\nIt utilizes Nillion's secure computation framework to perform these operations on secret data.\n3. The user interface is built with Streamlit, providing a simple way to input numbers and view results.\nFor each operation (addition and subtraction):\nThe app stores a Nillion program (NADA binary) in the network.\nIt creates and stores secret values based on user input.\nIt sets up permissions and bindings for secure computation.\nIt performs the computation on the Nillion network.\nFinally, it retrieves and displays the result. This project is a Streamlit-based web application that demonstrates Nillion's secret computation capabilities for basic math operations. It uses async functions to handle addition and subtraction, storing NADA programs, creating secret values, and executing computations on the Nillion network.",
        "how_its_made": "This project is a Streamlit-based web application that demonstrates Nillion's secret computation capabilities for basic math operations. It uses async functions to handle addition and subtraction, storing NADA programs, creating secret values, and executing computations on the Nillion network.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/nkww8/screenshots/j2wsc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nkww8/screenshots/8nvo7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nkww8/screenshots/tyg4a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nkww8/screenshots/9ih4h/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/miscsamchris/StreamNil",
        "link": "https://ethglobal.com/showcase/streamnil-nkww8"
    },
    {
        "title": "HyperFungible",
        "brief_description": "Move any token to any chain, even if its not supported natively on the destination chain",
        "long_description": "I've made some tweaks to the ERC20 implementation, while still keeping it compliant with the spec. It is easy to implement for other defi projects, so say you are on optimism, but want to support a specific memecoin from base for your defi protocol, now you can! I informally call these tokens HFTs, Hyper Fungible Tokens, because only one erc20 contract will reflect multiple different tokens on multiple different chains. The tokens are separated through some added mappings https://github.com/jacksmithinsulander/HyperFungible/blob/bea6e2238d94689b4c2c41b689741ca2de056c69/src/HyperFungible.sol#L29 which gets updated on each transaction and mint Unfortunatly I've had a really busy week so didn't have much time for hacking, So it is very much unfinnished, but I wanted to apply anyway The bridging is made with ccip, and the Idea was to deploy some chiliz fan tokens to showcase a hyperfying them to multiple chains, but I didnt get this far. I had a lot of ideas to also make it work with l0 in order to support more networks. For particuarly hacky fun stuff i think the mappings https://github.com/jacksmithinsulander/HyperFungible/blob/bea6e2238d94689b4c2c41b689741ca2de056c69/src/HyperFungible.sol#L29 and the decoding navigation https://github.com/jacksmithinsulander/HyperFungible/blob/bea6e2238d94689b4c2c41b689741ca2de056c69/src/HyperFungible.sol#L102is pretty fun",
        "how_its_made": "The bridging is made with ccip, and the Idea was to deploy some chiliz fan tokens to showcase a hyperfying them to multiple chains, but I didnt get this far. I had a lot of ideas to also make it work with l0 in order to support more networks. For particuarly hacky fun stuff i think the mappings https://github.com/jacksmithinsulander/HyperFungible/blob/bea6e2238d94689b4c2c41b689741ca2de056c69/src/HyperFungible.sol#L29 and the decoding navigation https://github.com/jacksmithinsulander/HyperFungible/blob/bea6e2238d94689b4c2c41b689741ca2de056c69/src/HyperFungible.sol#L102is pretty fun",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mxj0i/screenshots/r1chm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mxj0i/screenshots/k0pc4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mxj0i/screenshots/2n4r0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jacksmithinsulander/HyperFungible",
        "link": "https://ethglobal.com/showcase/hyperfungible-mxj0i"
    },
    {
        "title": "Token-marketplace",
        "brief_description": "Token marketplace to issue,transfer,delete (retire)tokens using HFT",
        "long_description": "This project uses HFT Fungible token to create, issue, transfer, redeem tokens between accounts and for an account. First module contains create account functionality, second module contains creating token, issuing them and retiring them for an account and between accounts.This project leverages Hedera HTS Fungible Tokens to perform a variety of token operations, including the creation, issuance, transfer, and redemption of tokens both for individual accounts and between multiple accounts. The project is divided into two key modules: Account Creation Module: This module is responsible for setting up new accounts on the Hedera network. It generates public and private keys for the account, which are then used in subsequent transactions such as token transfers and associations. This foundational step is essential for interacting with tokens and other network features. Token Management Module: In this module, fungible tokens are created and issued to accounts. The module handles token transfers between accounts, allowing users to send tokens from one account to another securely and efficiently. It also includes functionality to associate tokens with specific accounts, ensuring they can hold and manage those tokens. Finally, the module supports the retirement (or deletion) of tokens once they are no longer needed, ensuring proper lifecycle management of digital assets. This project is built using hedera token sdk-js and tutorials from the hedera.Javascript is used as a main language for creating, issuing,transferring,deleting tokens.Using node.js we can run each of the module i.e creating account which will give us public key and private key . we use that to get the account id by getting some testnet funds from faucet.",
        "how_its_made": "This project is built using hedera token sdk-js and tutorials from the hedera.Javascript is used as a main language for creating, issuing,transferring,deleting tokens.Using node.js we can run each of the module i.e creating account which will give us public key and private key . we use that to get the account id by getting some testnet funds from faucet.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/coxmw/screenshots/t6kcn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/coxmw/screenshots/vfyrs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/coxmw/screenshots/8h7xz/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/NiteeshPutla/hedera-shop",
        "link": "https://ethglobal.com/showcase/token-marketplace-coxmw"
    },
    {
        "title": "Deworld",
        "brief_description": "\ud83c\udfd7 Deworld - A decentralised marketplace for engaging in escrowed transactions",
        "long_description": "Project description\nProblem Statement\nOnline marketplaces often struggle to establish trust between buyers and sellers, leading to a lack of confidence, disputes, abandoned transactions.and a decrease in overall transaction volume. Solution Statement\nDuniverse is a blockchain-based platform for secure and transparent transactions by leveraging escrow and decentralized arbitration Value Proposition\nEnhanced Security:\nEscrow Protection: Funds are held in escrow until the transaction conditions are met, protecting buyers from fraud and ensuring sellers receive payment only after fulfilling their obligations.\nImmutable Records: All transaction and dispute resolution data is recorded on the blockchain, providing an unchangeable history that enhances trust and transparency. Fair and Efficient Dispute Resolution\nDecentralized Arbitration: Independent arbitrators create and manage customizable marketplaces (planets) and resolve disputes based on clear, predefined rules.\nIncentivized Arbitrators: Arbitrators earn a fee from transactions, motivating them to provide fair and effective dispute resolution and maintain high standards in their marketplaces. Transparency and Trust:\nBlockchain Transparency: Every transaction and dispute resolution is recorded on the blockchain, ensuring transparency and accountability throughout the entire process.\nReputation System: Users can build trust through a reputation system based on their transaction history and dispute resolution outcomes. The DeWorld project integrates several technologies, including Next.js, Hardhat (for smart contract development), and RainbowKit (for wallet integration). The smart contracts, written in Solidity, are deployed on both the Rootstock and Hedera networks. It uses TypeScript and Wagmi for seamless Web3 interactions, with contract hot-reloading for efficient front-end updates. Additionally, the project incorporates Ora AI, allowing users to interact with the blockchain via text prompts, enhancing accessibility and functionality in a unique way.",
        "how_its_made": "The DeWorld project integrates several technologies, including Next.js, Hardhat (for smart contract development), and RainbowKit (for wallet integration). The smart contracts, written in Solidity, are deployed on both the Rootstock and Hedera networks. It uses TypeScript and Wagmi for seamless Web3 interactions, with contract hot-reloading for efficient front-end updates. Additionally, the project incorporates Ora AI, allowing users to interact with the blockchain via text prompts, enhancing accessibility and functionality in a unique way.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tz3x6/screenshots/ho08s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tz3x6/screenshots/qn95h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tz3x6/screenshots/x2ve9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jovells",
        "link": "https://ethglobal.com/showcase/deworld-tz3x6"
    },
    {
        "title": "Indie Play",
        "brief_description": "Indie Play is a decentralized platform for indie creators to upload content as NFTs, ensuring fair compensation via smart contracts. With dynamic pricing and Pay-as-You-Watch, it promotes underrepresented genres, offering fractional NFT ownership to engage the community.",
        "long_description": "Indie Play: Empowering Independent Creators Through Decentralization Overview\nIndie Play is a decentralized web application built to support independent directors and small content creators, especially those who work in less mainstream genres. The platform enables creators to upload their content as NFTs (non-fungible tokens), ensuring transparent compensation and ownership, all while leveraging the power of blockchain technology. With Indie Play, creators can take control of their work, pricing, and engagement with their audience. Key Features NFT Content Uploads\nIndie Play allows creators to upload their work as NFTs. This ensures that content is tokenized, granting creators full ownership and control over how their work is distributed and monetized. Through smart contracts, every transaction is secure, decentralized, and recorded on the blockchain, eliminating the need for intermediaries. Automated Price Maker\nAt the heart of Indie Play is the Automated Price Maker algorithm, which dynamically adjusts the pricing of content based on demand and other market factors. This ensures that creators can set fair prices while allowing flexibility for their audience. The algorithm creates a sustainable revenue model, especially for indie creators who may lack traditional distribution support. Pay-as-You-Watch Model\nIndie Play introduces a unique Pay-as-You-Watch model. Viewers pay only for the amount of content they watch, typically on a per-minute basis. This makes content more accessible to audiences, removing financial barriers and offering a more flexible way to engage with creative works. Support for Niche and Unexplored Genres\nIndie Play encourages viewers to explore lesser-known genres and discover independent creators who often go unnoticed in mainstream media. This focus on niche content allows underdog creators to find a dedicated audience and gain exposure without the traditional constraints of major platforms. NFT Ownership Options\nIn addition to watching content, viewers can purchase fractional or complete ownership of the content NFTs. This means viewers can actively participate in the promotion and marketing of the content, fostering a deeper sense of community and engagement. Owners also have a vested interest in the success of the content they support. Conclusion\nIndie Play empowers creators by providing a decentralized platform where they can monetize their work, explore innovative pricing models, and connect with a supportive community. By blending blockchain technology with unique monetization strategies, Indie Play is reshaping how content is created, consumed, and appreciated in the digital age. Technology Stack\nIndie Play is built using modern web development technologies to ensure a seamless user experience: Smart Contracts: Developed with Solidity and deployed on the blockchain.\nFrontend: The user interface is crafted with React and Redux Toolkit for state management, while Tailwind CSS is used for efficient styling.\nBuild Tool: Vite is employed to ensure a fast and optimized development process.\nDeployment: The platform is hosted on Vercel for easy scalability and high performance.",
        "how_its_made": "Technology Stack\nIndie Play is built using modern web development technologies to ensure a seamless user experience: Smart Contracts: Developed with Solidity and deployed on the blockchain.\nFrontend: The user interface is crafted with React and Redux Toolkit for state management, while Tailwind CSS is used for efficient styling.\nBuild Tool: Vite is employed to ensure a fast and optimized development process.\nDeployment: The platform is hosted on Vercel for easy scalability and high performance.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/uj3pr/screenshots/me9bw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uj3pr/screenshots/a56f1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uj3pr/screenshots/c5rkw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uj3pr/screenshots/3np46/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uj3pr/screenshots/woi43/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uj3pr/screenshots/w9chs/default.jpg"
        ],
        "live_demo": "https://defy24-8gpn.vercel.app/",
        "source_code": "https://github.com/DivyankR16/ETH_Online_2024_Team_4bsrw",
        "link": "https://ethglobal.com/showcase/indie-play-uj3pr"
    },
    {
        "title": "FlickArena",
        "brief_description": "A fully on-chain dart 301 game where players compete in thrilling matches, throwing virtual darts to reach zero points. Experience the excitement of darts with blockchain technology, ensuring fairness and transparency in every throw.",
        "long_description": "FlickArena is an innovative, fully on-chain implementation of the classic dart 301 game that bridges the physical and digital worlds. This blockchain-based version connects real dart boards to the Ethereum network through a custom iOS application, creating a unique gaming experience that combines traditional darts with cutting-edge technology. Key features of FlickArena include: Players can join matches by placing a bet, which contributes to the game's prize pool. As they throw darts on a physical board, the iOS app captures the scores in real-time via Bluetooth and transmits them to the blockchain. The game's smart contract handles all aspects of gameplay, from initiating matches to determining winners and distributing prizes, providing a trustless and immersive gaming experience that combines the best of physical and digital worlds. FlickArena is built using a sophisticated blend of hardware integration, mobile development, and blockchain technologies to create a seamless, decentralized gaming experience. Here's a breakdown of the key components and technologies used: Smart Contracts: The core game logic is implemented using Solidity smart contracts deployed on the Ethereum blockchain. These contracts handle game state, player actions, scoring, betting, and prize distribution. iOS Application: We developed a custom iOS app using Swift and SwiftUI. This app serves as the bridge between the physical dart board and the blockchain, handling Bluetooth communication, score tracking, and interaction with Ethereum smart contracts. Bluetooth Integration: The iOS app uses Core Bluetooth framework to communicate with the physical dart board, capturing throw results in real-time. Web3.swift: We integrated Web3.swift library to enable the iOS app to interact with the Ethereum blockchain, allowing players to connect their wallets, place bets, and submit scores directly from their mobile devices. One particularly innovative aspect of our implementation is the seamless integration of physical dart throws with blockchain transactions. We developed a custom protocol that efficiently encodes dart throw results into compact data structures, minimizing gas costs when submitting scores to the blockchain. Another notable feature is our use of a state channel-inspired approach for handling rapid score submissions. This allows for quick, gas-free score updates during a game, with only the final game result being settled on-chain, significantly reducing transaction costs for players. The betting and prize pool system presented unique challenges in terms of ensuring fair play and timely payouts. We implemented a clever escrow mechanism in our smart contracts that locks bets at the start of each game and automatically distributes winnings based on the final scores, all without requiring trust in a central authority. By leveraging the Chiliz Chain and its ecosystem, we've created a truly unique gaming experience that bridges the physical and digital worlds while tapping into the passion of sports fans. FlickArena showcases the potential of blockchain technology, specifically the Chiliz Chain, to transform traditional games, adding new layers of excitement, fairness, and financial incentives to the classic game of darts. Furthermore, our integration with the Chiliz ecosystem opens up exciting possibilities for partnerships with sports teams and organizations. For instance, we could create special tournaments or events tied to specific Fan Tokens, allowing fans to engage with their favorite teams in a whole new way through our dart game.",
        "how_its_made": "FlickArena is built using a sophisticated blend of hardware integration, mobile development, and blockchain technologies to create a seamless, decentralized gaming experience. Here's a breakdown of the key components and technologies used: Smart Contracts: The core game logic is implemented using Solidity smart contracts deployed on the Ethereum blockchain. These contracts handle game state, player actions, scoring, betting, and prize distribution. iOS Application: We developed a custom iOS app using Swift and SwiftUI. This app serves as the bridge between the physical dart board and the blockchain, handling Bluetooth communication, score tracking, and interaction with Ethereum smart contracts. Bluetooth Integration: The iOS app uses Core Bluetooth framework to communicate with the physical dart board, capturing throw results in real-time. Web3.swift: We integrated Web3.swift library to enable the iOS app to interact with the Ethereum blockchain, allowing players to connect their wallets, place bets, and submit scores directly from their mobile devices. One particularly innovative aspect of our implementation is the seamless integration of physical dart throws with blockchain transactions. We developed a custom protocol that efficiently encodes dart throw results into compact data structures, minimizing gas costs when submitting scores to the blockchain. Another notable feature is our use of a state channel-inspired approach for handling rapid score submissions. This allows for quick, gas-free score updates during a game, with only the final game result being settled on-chain, significantly reducing transaction costs for players. The betting and prize pool system presented unique challenges in terms of ensuring fair play and timely payouts. We implemented a clever escrow mechanism in our smart contracts that locks bets at the start of each game and automatically distributes winnings based on the final scores, all without requiring trust in a central authority. By leveraging the Chiliz Chain and its ecosystem, we've created a truly unique gaming experience that bridges the physical and digital worlds while tapping into the passion of sports fans. FlickArena showcases the potential of blockchain technology, specifically the Chiliz Chain, to transform traditional games, adding new layers of excitement, fairness, and financial incentives to the classic game of darts. Furthermore, our integration with the Chiliz ecosystem opens up exciting possibilities for partnerships with sports teams and organizations. For instance, we could create special tournaments or events tied to specific Fan Tokens, allowing fans to engage with their favorite teams in a whole new way through our dart game.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/if2sr/screenshots/xx8fo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/if2sr/screenshots/qtqzh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/if2sr/screenshots/obk19/default.jpg",
            "https://ethglobal.b-cdn.net/projects/if2sr/screenshots/iou2s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/if2sr/screenshots/u7r31/default.jpg",
            "https://ethglobal.b-cdn.net/projects/if2sr/screenshots/a5b0y/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/yuhsuan19/FlickArena",
        "link": "https://ethglobal.com/showcase/flickarena-if2sr"
    },
    {
        "title": "Smart Home Agent",
        "brief_description": "Smart Home Agent is a fully on-chain smart agent IOT application deployed on the Galadriel chain. Users can control devices in their home with a simple chat interface through the website and Converse App powered by XMTP Message Kit.",
        "long_description": "Smart Home Agent is a fully on-chain IoT application deployed on the Galadriel chain, allowing users to control devices in their homes through a simple chat interface available on the website and the Converse App, powered by XMTP Message Kit. Devices are registered on a SmartHomeRegistry smart contract on the Galadriel chain, which is responsible for managing device states and generating system database prompts. When a user submits a prompt, the smart contract prepends a system prompt that provides ChatGPT with the current state of the devices. The oracle then submits the response back to the smart contract. If the response starts with \"TGLOON,\" the light will be turned on; if it starts with \"TGLOFF,\" the light will be turned off for the specified room. Turning the light on and off involves emitting event on the smart contract, and a relayer will forward these emitted events to the XMTP address associated with each IoT device, which then reacts to turn the light on or off physically. Users can also interact with the system via Converse by sending prompts to our XMTP relayer address, which submits the prompt to the contract on Galadriel. This project, Smart Home Agent, leverages several cutting-edge technologies to create a fully on-chain IoT system for home automation. The following are the technical details that make up its architecture: Technologies Used:\nGaladriel Chain: The backbone of the system, Galadriel chain is a decentralized blockchain platform used to deploy smart contracts. All device interactions and control commands are handled via smart contracts deployed on this chain. Smart Contracts: We created a SmartHomeRegistry smart contract responsible for storing the states of registered devices and generating relevant prompts for system interaction. This contract acts as the core controller of the home automation logic, managing all device data and interactions. XMTP Protocol: XMTP (Extensible Message Transport Protocol) is integrated for messaging between users and IoT devices. The messaging interface is accessible through the Converse App, allowing seamless communication between the user\u2019s prompts and the IoT devices via the on-chain system. XMTP Message Kit: The message kit is employed to bridge communications between the user interface (chat-based) and the smart contract. It provides a chat-like experience for users to control devices, which abstracts away the underlying blockchain complexity. Oracles: An oracle is used to bridge off-chain data (prompts and responses) with the on-chain smart contract. When a user submits a control prompt, the oracle fetches the latest device states from the smart contract, prepends this to the user\u2019s prompt, and then forwards it to ChatGPT. The oracle also processes the returned response and triggers actions on the smart contract, such as emitting events for device control. Relayer: A relayer service is employed to forward emitted events from the smart contract to the respective XMTP addresses linked to IoT devices. This ensures that when a response from ChatGPT starts with \"TGLOON\" or \"TGLOFF,\" the appropriate IoT device (in this case, a light) is turned on or off physically in the user's home. Project Benefits:\nPartnering with XMTP provided an essential messaging layer that allowed us to bypass complex UI and focus on chat-based interactions. This also offered seamless integration into the Converse App, allowing users to access home automation features without navigating traditional IoT interfaces.\nGaladriel Chain was chosen for its decentralized and efficient contract deployment, ensuring the entire system remains transparent and tamper-proof.\nHacky Details:\nOne of the key innovations in this project was using the ChatGPT response system to control device states. The SmartHomeRegistry contract dynamically prepends the current state of devices to each prompt, ensuring that ChatGPT makes contextually aware decisions based on real-time information. This allowed us to build a smart system without requiring extensive AI training.\nWe also introduced a simple event-driven architecture where device control is dictated purely through text-based commands (\"TGLOON\" and \"TGLOFF\"). While this seems basic, it allowed us to streamline the communication process between smart contracts and IoT devices via the XMTP protocol.\nBy blending blockchain, messaging, and IoT, Smart Home Agent represents a novel approach to home automation that stays fully on-chain while offering users an intuitive chat interface",
        "how_its_made": "This project, Smart Home Agent, leverages several cutting-edge technologies to create a fully on-chain IoT system for home automation. The following are the technical details that make up its architecture: Technologies Used:\nGaladriel Chain: The backbone of the system, Galadriel chain is a decentralized blockchain platform used to deploy smart contracts. All device interactions and control commands are handled via smart contracts deployed on this chain. Smart Contracts: We created a SmartHomeRegistry smart contract responsible for storing the states of registered devices and generating relevant prompts for system interaction. This contract acts as the core controller of the home automation logic, managing all device data and interactions. XMTP Protocol: XMTP (Extensible Message Transport Protocol) is integrated for messaging between users and IoT devices. The messaging interface is accessible through the Converse App, allowing seamless communication between the user\u2019s prompts and the IoT devices via the on-chain system. XMTP Message Kit: The message kit is employed to bridge communications between the user interface (chat-based) and the smart contract. It provides a chat-like experience for users to control devices, which abstracts away the underlying blockchain complexity. Oracles: An oracle is used to bridge off-chain data (prompts and responses) with the on-chain smart contract. When a user submits a control prompt, the oracle fetches the latest device states from the smart contract, prepends this to the user\u2019s prompt, and then forwards it to ChatGPT. The oracle also processes the returned response and triggers actions on the smart contract, such as emitting events for device control. Relayer: A relayer service is employed to forward emitted events from the smart contract to the respective XMTP addresses linked to IoT devices. This ensures that when a response from ChatGPT starts with \"TGLOON\" or \"TGLOFF,\" the appropriate IoT device (in this case, a light) is turned on or off physically in the user's home. Project Benefits:\nPartnering with XMTP provided an essential messaging layer that allowed us to bypass complex UI and focus on chat-based interactions. This also offered seamless integration into the Converse App, allowing users to access home automation features without navigating traditional IoT interfaces.\nGaladriel Chain was chosen for its decentralized and efficient contract deployment, ensuring the entire system remains transparent and tamper-proof.\nHacky Details:\nOne of the key innovations in this project was using the ChatGPT response system to control device states. The SmartHomeRegistry contract dynamically prepends the current state of devices to each prompt, ensuring that ChatGPT makes contextually aware decisions based on real-time information. This allowed us to build a smart system without requiring extensive AI training.\nWe also introduced a simple event-driven architecture where device control is dictated purely through text-based commands (\"TGLOON\" and \"TGLOFF\"). While this seems basic, it allowed us to streamline the communication process between smart contracts and IoT devices via the XMTP protocol.\nBy blending blockchain, messaging, and IoT, Smart Home Agent represents a novel approach to home automation that stays fully on-chain while offering users an intuitive chat interface",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/iz8fx/screenshots/pe49s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/iz8fx/screenshots/ybnrx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/iz8fx/screenshots/vuz6i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/iz8fx/screenshots/jubmd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/iz8fx/screenshots/yicho/default.jpg",
            "https://ethglobal.b-cdn.net/projects/iz8fx/screenshots/mquxa/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/upnodedev/smarthome-ai-agent",
        "link": "https://ethglobal.com/showcase/smart-home-agent-iz8fx"
    },
    {
        "title": "OmniVault",
        "brief_description": "OmniVault is a cross-chain yield optimizer for USDC using Chainlink's CCIP and ERC4626. It automatically finds the best yields across multiple chains and rebalances assets for maximum returns.",
        "long_description": "OmniVault is a revolutionary cross-chain yield optimization platform designed to maximize returns on USDC deposits by leveraging Chainlink\u2019s Cross-Chain Interoperability Protocol (CCIP) and the ERC4626 vault standard. Unlike traditional vaults that operate on a single chain, OmniVault bridges assets across multiple chains, ensuring that users always access the highest available yields and rewards. At its core, OmniVault integrates with Aave lending markets on Base, Arbitrum, Optimism, and Sepolia, continuously scanning for the best yield opportunities across these chains. By utilizing Chainlink\u2019s CCIP, it seamlessly bridges USDC to the chain offering the most competitive interest rates, allowing users to benefit from the dynamic nature of multi-chain liquidity. The vault is built on the ERC4626 standard, making it compatible with existing DeFi infrastructure and providing users with shares that represent their proportional ownership in the vault. Deposits and withdrawals are simple and efficient, with users receiving vault shares in exchange for deposits, while withdrawals convert those shares back to USDC. Future Plans: The platform will expand beyond USDC to offer a range of cross-chain yield strategies for different assets, all powered by CCIP.\nThe goal is to create a comprehensive platform where users can access diverse investment opportunities across multiple chains without the complexity of manual management. Technologies Used: OpenZeppelin: The smart contracts were written in Solidity, leveraging the ERC4626 vault standard to ensure compatibility with existing DeFi infrastructure. Chainlink CCIP: Chainlink's Cross-Chain Interoperability Protocol (CCIP) was crucial for bridging USDC across chains. This allowed us to move assets seamlessly between Base, Arbitrum, Optimism, and Sepolia based on the best yield available on Aave. Aave Protocol: We integrated with Aave on multiple chains to supply USDC and earn yield. Aave provides a reliable and established lending pool with competitive interest rates, making it the perfect choice for yield optimization. Partner Technologies: Chainlink CCIP: This was the backbone of the cross-chain functionality. Without CCIP, moving assets between chains manually would have been inefficient and error-prone. CCIP allowed us to focus on yield optimization rather than the complexities of cross-chain bridging.",
        "how_its_made": "Technologies Used: OpenZeppelin: The smart contracts were written in Solidity, leveraging the ERC4626 vault standard to ensure compatibility with existing DeFi infrastructure. Chainlink CCIP: Chainlink's Cross-Chain Interoperability Protocol (CCIP) was crucial for bridging USDC across chains. This allowed us to move assets seamlessly between Base, Arbitrum, Optimism, and Sepolia based on the best yield available on Aave. Aave Protocol: We integrated with Aave on multiple chains to supply USDC and earn yield. Aave provides a reliable and established lending pool with competitive interest rates, making it the perfect choice for yield optimization. Partner Technologies: Chainlink CCIP: This was the backbone of the cross-chain functionality. Without CCIP, moving assets between chains manually would have been inefficient and error-prone. CCIP allowed us to focus on yield optimization rather than the complexities of cross-chain bridging.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5c5mq/screenshots/iz15w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5c5mq/screenshots/rjd11/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5c5mq/screenshots/fh3ix/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shivu187/CCIP-Vault",
        "link": "https://ethglobal.com/showcase/omnivault-5c5mq"
    },
    {
        "title": "Parametric insurance",
        "brief_description": "Create a decentralized parametric insurance platform using smart contracts and Chainlink oracles. Automate insurance payouts for natural disasters based on real-world data, streamlining claims and improving transparency.",
        "long_description": "The \"Parametric Insurance for Natural Disasters\" project is a decentralized insurance platform designed to simplify and automate the insurance process for natural disasters using blockchain technology and Chainlink oracles. Project Overview\nObjective: Develop a platform that provides insurance coverage for natural disasters, such as hurricanes, earthquakes, and floods. The platform uses smart contracts to manage insurance policies and trigger payouts automatically based on predefined criteria. Key Components\nSmart Contracts:\nPolicy Management: Smart contracts handle the creation and management of insurance policies. These contracts store policy details, such as the policy name, coverage amount, and type of disaster covered.\nPayout Logic: Smart contracts automate the payout process. When a disaster event is detected and meets the predefined criteria, the contract triggers payouts to policyholders.\nChainlink Oracles:\nData Fetching: Chainlink oracles fetch real-world data related to natural disasters, such as hurricane categories or earthquake magnitudes, from trusted sources (e.g., NOAA, USGS).\nData Integration: The fetched data is used by the smart contracts to determine if the conditions for triggering a payout are met.\nUser Interface:\nPolicy Management: Users can view, create, and manage their insurance policies through a web interface. They can see their coverage details and check the status of their claims.\nClaims Processing: When a disaster event meets the policy criteria, the system automatically processes claims and triggers payouts without requiring manual intervention.\nFeatures\nParametric Insurance Policies: Users can create insurance policies with predefined parameters for different types of natural disasters.\nAutomated Claims: Claims are processed automatically based on data from Chainlink oracles, reducing administrative overhead and improving efficiency.\nTransparent Payouts: The use of blockchain ensures transparency and security in the payout process, as all transactions are recorded on the blockchain.\nBenefits\nEfficiency: Automates the claims process, reducing the time and effort required to handle claims manually.\nTransparency: Utilizes blockchain technology to provide a transparent and immutable record of insurance policies and payouts.\nAccuracy: Leverages Chainlink\u2019s reliable data sources to ensure accurate and timely payouts based on real-world events.\nIn summary, this project integrates blockchain and Chainlink technologies to create a streamlined, transparent, and efficient parametric insurance platform for natural disasters. It automates policy management and payouts, ensuring that users receive timely compensation based on verified disaster data. Technology Used: Solidity: The smart contracts are written in Solidity, a high-level programming language designed for Ethereum smart contracts.\nDetails: DisasterInsurance.sol: The core smart contract manages insurance policies and payouts. It includes functions for creating policies, triggering payouts based on predefined criteria, and managing policy details.\nChainlink Integration: The contract integrates with Chainlink oracles to fetch real-time disaster data. This integration ensures that the contract can automatically process claims based on verified external data.\n2. Blockchain Integration Technology Used: Ethereum: The smart contracts are deployed on the Ethereum blockchain. This provides a decentralized and immutable ledger for managing insurance policies and payouts.\nDetails: Deployment: The contract is deployed using Truffle, a popular development framework for Ethereum. This involves writing migration scripts to handle the deployment process.\n3. Chainlink Oracles Technology Used: Chainlink: Chainlink oracles are used to fetch and verify real-world data related to natural disasters (e.g., hurricane categories, earthquake magnitudes).\nDetails: Data Sources: Chainlink connects to trusted data sources like NOAA and USGS to retrieve disaster data. This data is then used to trigger payouts in the smart contract based on the predefined parameters of the insurance policies.\n4. User Interface Technology Used: React.js: The frontend is built using React.js, a popular JavaScript library for building user interfaces.\nTailwind CSS: Tailwind CSS is used for styling the application, providing a modern and responsive design.\nDetails: Policy Management: Users can interact with the smart contract via a web interface to create and manage insurance policies. The frontend communicates with the Ethereum blockchain using Web3.js.\nClaims Processing: The interface allows users to view their policies and check the status of claims. Automated claims are reflected in real-time based on the data provided by Chainlink oracles.\n5. Deployment and Interaction Technology Used: Truffle: Truffle is used for smart contract deployment and testing. It provides a development environment, testing framework, and asset pipeline for Ethereum.\nHDWalletProvider: This library is used to manage Ethereum accounts and connect to a blockchain network (e.g., Infura or Alchemy) for deployment and interaction.\nDetails: Scripts: Custom scripts are created to deploy the smart contract and interact with it. These scripts use Web3.js and HDWalletProvider to manage deployments and perform transactions.\n6. Notable Technical Details Hacky Integration: To ensure real-time data fetching and processing, a mock Chainlink price feed was used during initial development and testing. This approach allowed for quicker iteration and debugging before integrating with live data sources.\nTesting and Verification: Comprehensive tests are written using Mocha and Chai to verify the functionality of the smart contract, including policy creation, payout triggers, and access control.\nSummary\nThe project leverages a combination of Solidity for smart contracts, Chainlink for external data integration, and Ethereum for decentralized execution. The frontend uses React.js and Tailwind CSS for a responsive user interface. Truffle and HDWalletProvider facilitate contract deployment and interaction. The integration of Chainlink oracles ensures that insurance payouts are automatically triggered based on real-world data, enhancing the efficiency and transparency of the insurance process.",
        "how_its_made": "Technology Used: Solidity: The smart contracts are written in Solidity, a high-level programming language designed for Ethereum smart contracts.\nDetails: DisasterInsurance.sol: The core smart contract manages insurance policies and payouts. It includes functions for creating policies, triggering payouts based on predefined criteria, and managing policy details.\nChainlink Integration: The contract integrates with Chainlink oracles to fetch real-time disaster data. This integration ensures that the contract can automatically process claims based on verified external data.\n2. Blockchain Integration Technology Used: Ethereum: The smart contracts are deployed on the Ethereum blockchain. This provides a decentralized and immutable ledger for managing insurance policies and payouts.\nDetails: Deployment: The contract is deployed using Truffle, a popular development framework for Ethereum. This involves writing migration scripts to handle the deployment process.\n3. Chainlink Oracles Technology Used: Chainlink: Chainlink oracles are used to fetch and verify real-world data related to natural disasters (e.g., hurricane categories, earthquake magnitudes).\nDetails: Data Sources: Chainlink connects to trusted data sources like NOAA and USGS to retrieve disaster data. This data is then used to trigger payouts in the smart contract based on the predefined parameters of the insurance policies.\n4. User Interface Technology Used: React.js: The frontend is built using React.js, a popular JavaScript library for building user interfaces.\nTailwind CSS: Tailwind CSS is used for styling the application, providing a modern and responsive design.\nDetails: Policy Management: Users can interact with the smart contract via a web interface to create and manage insurance policies. The frontend communicates with the Ethereum blockchain using Web3.js.\nClaims Processing: The interface allows users to view their policies and check the status of claims. Automated claims are reflected in real-time based on the data provided by Chainlink oracles.\n5. Deployment and Interaction Technology Used: Truffle: Truffle is used for smart contract deployment and testing. It provides a development environment, testing framework, and asset pipeline for Ethereum.\nHDWalletProvider: This library is used to manage Ethereum accounts and connect to a blockchain network (e.g., Infura or Alchemy) for deployment and interaction.\nDetails: Scripts: Custom scripts are created to deploy the smart contract and interact with it. These scripts use Web3.js and HDWalletProvider to manage deployments and perform transactions.\n6. Notable Technical Details Hacky Integration: To ensure real-time data fetching and processing, a mock Chainlink price feed was used during initial development and testing. This approach allowed for quicker iteration and debugging before integrating with live data sources.\nTesting and Verification: Comprehensive tests are written using Mocha and Chai to verify the functionality of the smart contract, including policy creation, payout triggers, and access control.\nSummary\nThe project leverages a combination of Solidity for smart contracts, Chainlink for external data integration, and Ethereum for decentralized execution. The frontend uses React.js and Tailwind CSS for a responsive user interface. Truffle and HDWalletProvider facilitate contract deployment and interaction. The integration of Chainlink oracles ensures that insurance payouts are automatically triggered based on real-world data, enhancing the efficiency and transparency of the insurance process.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yucbt/screenshots/q2tg8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yucbt/screenshots/h8qpc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yucbt/screenshots/xn4pi/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Upendra-Jaiswal/parametric_insurance",
        "link": "https://ethglobal.com/showcase/parametric-insurance-yucbt"
    },
    {
        "title": "Whisper Transactions",
        "brief_description": "Token Transfer on public chain using ZKP and privacy-preserving token",
        "long_description": "This project represents an implementation of private transactions on a public blockchain, specifically Hedera Hashgraph, using the Hyperledger Zeto toolkit. Here's a technical description of the project: Architecture\nThe project combines Hedera Hashgraph's public distributed ledger with Hyperledger Zeto's privacy-preserving token toolkit to enable confidential token transfers between Hedera wallets. It leverages several key components: Key Technical Features\nUTXO Model\nUnlike typical ERC-20 tokens on Ethereum-compatible chains, this project adopts a UTXO (Unspent Transaction Output) model similar to Bitcoin. This approach enhances privacy and enables better parallel processing of transactions. Zero Knowledge Proofs\nThe project extensively uses ZKPs to validate transactions without revealing sensitive information. The ZKP circuits support various levels of privacy, including: Commitment Scheme\nEach UTXO is represented on-chain as a commitment hash, combining: Transaction Flow Privacy Levels\nMultiple level of privacy configuration is possible: For this project, we have used Basic anonymity to demonstrate the concept. Integration with Hedera Unique Aspects This project showcases the potential for building sophisticated, privacy-preserving decentralized applications on Hedera Hashgraph, bridging the gap between public blockchain transparency and the privacy requirements of sensitive financial transactions. This project implements private transactions on the Hedera Hashgraph public blockchain using the Hyperledger Zeto toolkit. Here's a breakdown of the key components and technologies: Backend (txn-backend): Frontend (txn-app): Zero-Knowledge Proofs (ZKP): Merkle Trees: Cryptography: Smart Contracts: Testing: Notable technical achievements: The project demonstrates a sophisticated approach to privacy-preserving transactions on a public blockchain, combining advanced cryptographic techniques with the efficiency and security of Hedera Hashgraph. The modular architecture allows for different levels of privacy and compliance, making it suitable for various use cases, from simple anonymous transfers to fully regulated, KYC-compliant transactions.",
        "how_its_made": "This project implements private transactions on the Hedera Hashgraph public blockchain using the Hyperledger Zeto toolkit. Here's a breakdown of the key components and technologies: Backend (txn-backend): Frontend (txn-app): Zero-Knowledge Proofs (ZKP): Merkle Trees: Cryptography: Smart Contracts: Testing: Notable technical achievements: The project demonstrates a sophisticated approach to privacy-preserving transactions on a public blockchain, combining advanced cryptographic techniques with the efficiency and security of Hedera Hashgraph. The modular architecture allows for different levels of privacy and compliance, making it suitable for various use cases, from simple anonymous transfers to fully regulated, KYC-compliant transactions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ui8pq/screenshots/jpm2a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ui8pq/screenshots/qj1yg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ui8pq/screenshots/3cvhq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/nandanito/ethonline2024-whisper-txn",
        "link": "https://ethglobal.com/showcase/whisper-transactions-ui8pq"
    },
    {
        "title": "MuseAgent",
        "brief_description": "AI agent that can research and collect albums from your favorite music artists.",
        "long_description": "This project is an agent that combines AI and music, and can search for information about music artists and collect albums. Even now, LLM-based AI technologies such as OpenAI are developing rapidly, and the traditional way of collecting albums is likely to change.\nOn the chat interface, LLM judges the user's query and matches it with actual music data to generate answers that fit the question. In this case, we implemented an agent that enumerates albums and their characteristics when asked about an artist's name.\nAlso, for each album of an artist, we implemented the function to collect the desired album through the attestation of the sign protocol. In this POC, we implemented the attestation part, and in the future, we can expand it to a dashboard where you can check the collected albums at a glance.\nBy decentralizing existing web2 agents using galadriel and sign protocol, users can clearly record their collection rights without being dependent on the existing LLM. For AI, langchain and openAI LLM were used, and the part responsible for running the agent was connected through galadriel. The attestation for each collection was implemented using the sign protocol. For this purpose, a schema was configured and the attestation works based on the base sepolia. We also implemented an automatic way to switch between galadriel and base sepolia as needed.\nThe frontend app is built with nextjs, typescript, web3, langchain, tailwindcss, etc.",
        "how_its_made": "For AI, langchain and openAI LLM were used, and the part responsible for running the agent was connected through galadriel. The attestation for each collection was implemented using the sign protocol. For this purpose, a schema was configured and the attestation works based on the base sepolia. We also implemented an automatic way to switch between galadriel and base sepolia as needed.\nThe frontend app is built with nextjs, typescript, web3, langchain, tailwindcss, etc.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ydnhe/screenshots/iyc1v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ydnhe/screenshots/u00hh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ydnhe/screenshots/dyk1b/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/elegant651/musc-agent",
        "link": "https://ethglobal.com/showcase/museagent-ydnhe"
    },
    {
        "title": "MuseAgent",
        "brief_description": "AI agent that can research and collect albums from your favorite music artists.",
        "long_description": "This project is an agent that combines AI and music, and can search for information about music artists and collect albums. Even now, LLM-based AI technologies such as OpenAI are developing rapidly, and the traditional way of collecting albums is likely to change.\nOn the chat interface, LLM judges the user's query and matches it with actual music data to generate answers that fit the question. In this case, we implemented an agent that enumerates albums and their characteristics when asked about an artist's name.\nAlso, for each album of an artist, we implemented the function to collect the desired album through the attestation of the sign protocol. In this POC, we implemented the attestation part, and in the future, we can expand it to a dashboard where you can check the collected albums at a glance.\nBy decentralizing existing web2 agents using galadriel and sign protocol, users can clearly record their collection rights without being dependent on the existing LLM. For AI, langchain and openAI LLM were used, and the part responsible for running the agent was connected through galadriel. The attestation for each collection was implemented using the sign protocol. For this purpose, a schema was configured and the attestation works based on the base sepolia. We also implemented an automatic way to switch between galadriel and base sepolia as needed.\nThe frontend app is built with nextjs, typescript, web3, langchain, tailwindcss, etc.",
        "how_its_made": "For AI, langchain and openAI LLM were used, and the part responsible for running the agent was connected through galadriel. The attestation for each collection was implemented using the sign protocol. For this purpose, a schema was configured and the attestation works based on the base sepolia. We also implemented an automatic way to switch between galadriel and base sepolia as needed.\nThe frontend app is built with nextjs, typescript, web3, langchain, tailwindcss, etc.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ydnhe/screenshots/iyc1v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ydnhe/screenshots/u00hh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ydnhe/screenshots/dyk1b/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/elegant651/musc-agent",
        "link": "https://ethglobal.com/showcase/museagent-ydnhe"
    },
    {
        "title": "LoanIntent",
        "brief_description": "LoanIntent, is a DeFi application built on the Rootstock network that facilitates decentralized lending by allowing users to secure loans with NFTs as collateral, offering an everyday solution for borrowing and lending in a decentralized, secure, and transparent way",
        "long_description": "LoanIntent is a decentralized finance (DeFi) application designed to streamline borrowing and lending using intent-based transactions on the blockchain. In this system, users can create two types of intents: borrower and lender intents.A borrow intent represents a user's desire to secure a loan by offering an NFT as collateral. A lender intent, on the other hand, reflects a lender's willingness to provide cryptocurrency. These user-signed intents encapsulate their desired outcomes in a secure, single transaction.A solver mechanism matches borrower and lender intents based on predefined compatibility criteria. Once matched, the NFT provided by the borrower is held as collateral, while the lender supplies the agreed-upon cryptocurrency to the borrower.If the borrower fails to repay the principal amount along with the interest within the specified period, the lender has the right to claim ownership of the collateralized NFT. However, if the borrower completes the repayment within the agreed timeframe, the loan is fulfilled, and both intents are marked as completed. Our interest strategy is limit order and once solution is made we use the lower interest which is by the lender.LoanIntent enhances the flexibility and transparency of lending in the DeFi ecosystem, providing secure mechanisms for both parties in a transaction. Our project is based on EIP ERC 7521, introducing the concept of intents where users can create intents in the mempool, and a solver attempts to satisfy these intents based on predefined compatibility criteria. We deployed our contracts and interacted with our dApp on the Rootstock testnet. For the frontend, built with NextJS, we utilized viem, wagmi, and RainbowKit to interact with the smart contracts. We created ERC20 tokens for lending and borrowing in the application, and ERC721 NFTs are used as collateral by borrowers. On the backend, we built the solver using an ExpressJS server with viem. We used foundry to compile and deploy the smart contracts.",
        "how_its_made": "Our project is based on EIP ERC 7521, introducing the concept of intents where users can create intents in the mempool, and a solver attempts to satisfy these intents based on predefined compatibility criteria. We deployed our contracts and interacted with our dApp on the Rootstock testnet. For the frontend, built with NextJS, we utilized viem, wagmi, and RainbowKit to interact with the smart contracts. We created ERC20 tokens for lending and borrowing in the application, and ERC721 NFTs are used as collateral by borrowers. On the backend, we built the solver using an ExpressJS server with viem. We used foundry to compile and deploy the smart contracts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yg402/screenshots/gi54z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yg402/screenshots/copih/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yg402/screenshots/27ezv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yg402/screenshots/ni45i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yg402/screenshots/dgdpt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yg402/screenshots/pmyc1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/alanphil2k01/LoanIntent",
        "link": "https://ethglobal.com/showcase/loanintent-yg402"
    },
    {
        "title": "Dewls",
        "brief_description": "Dewls, a blockchain-integrated arcade platform allows players to raise stakes by betting on their own performance across multi-chain, with all wagers handled securely on-chain. Through attestation, each win is verified immutably, providing proof of victory.",
        "long_description": "Dewls is a multi chain arcade platform which allows user to battle with each other across various games like Rock-Paper-Scissors, Connect 4 etc. The game data is handled on chain and is stored immutably to ensure transparency amongst the competitors. Once a winner is decided, he is prompted to sign an attestation to mark his victory into the leaderboard and get a chance to win the pool prize which is distributed each weekend. This also enables user to build a Proof-Of-Victory to showcase his skills and some surprises for the upcoming features of the application. This project uses Web3Auth to allow each web2 or web3 user to use our application without the hassle of creating wallets and everything. Our whole game logic uses Sockets to ensure no user can tamper with the game while playing. We have our smart contracts deployed on multiple chains like Morph L2, Hedera, Rootstock. This ensures that we have transparent and immutable game results. We utilize the HCSC and HTS provided by Hedera to have easy dev experience as well. We also use cron jobs to handle pool prize distribution. We also have XMTP subscribe for users to opt in into and get new updates to their XMTP account. We have all these showcased with the help of Next.js frontend and Express based REST API along with Supabase to save our nitty gritty data.",
        "how_its_made": "This project uses Web3Auth to allow each web2 or web3 user to use our application without the hassle of creating wallets and everything. Our whole game logic uses Sockets to ensure no user can tamper with the game while playing. We have our smart contracts deployed on multiple chains like Morph L2, Hedera, Rootstock. This ensures that we have transparent and immutable game results. We utilize the HCSC and HTS provided by Hedera to have easy dev experience as well. We also use cron jobs to handle pool prize distribution. We also have XMTP subscribe for users to opt in into and get new updates to their XMTP account. We have all these showcased with the help of Next.js frontend and Express based REST API along with Supabase to save our nitty gritty data.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/oyj1w/screenshots/7nfsd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oyj1w/screenshots/mhwbq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oyj1w/screenshots/49s8j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oyj1w/screenshots/uxdwt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oyj1w/screenshots/vq984/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oyj1w/screenshots/h2cb0/default.jpg"
        ],
        "live_demo": "https://dewls.vercel.app/",
        "source_code": "https://github.com/SneakySensei/dewls",
        "link": "https://ethglobal.com/showcase/dewls-oyj1w"
    },
    {
        "title": "Zala",
        "brief_description": "A dapp which lets users create goals and invest for those goals",
        "long_description": "A dapp which lets users create goals and invest for those goals. The plan is to let users stake Ether and gain interest with Compound or any other deFi protocol. In future we plan to integrate with Signer protocol for each goal user stakes for. More information will be added soon\nMore information will be added soon\nMore information will be added soon Smart contract in solidity on Base Sepolia. More information will be added soon\nMore information will be added soon\nMore information will be added soon\nMore information will be added soon\nMore information will be added soon\nMore information will be added soon\nMore information will be added soon\nMore information will be added soon",
        "how_its_made": "Smart contract in solidity on Base Sepolia. More information will be added soon\nMore information will be added soon\nMore information will be added soon\nMore information will be added soon\nMore information will be added soon\nMore information will be added soon\nMore information will be added soon\nMore information will be added soon",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zsmkf/screenshots/s963p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsmkf/screenshots/xto7y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsmkf/screenshots/z5tux/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jainkrati/Zala",
        "link": "https://ethglobal.com/showcase/zala-zsmkf"
    },
    {
        "title": "AiTribe",
        "brief_description": "AiTribe is an app that harnesses the power of AI and community engagement to boost marketing efforts for project teams.",
        "long_description": "AI Image Generation: Users can create unique images using ChatGPT's image generation capabilities directly within the app.\nGuided Prompts: The app provides users with project-specific prompts to ensure generated images align with the team's marketing goals.\nOne-Click Posting: Generated images can be instantly shared on the project team's Twitter page with pre-approved text and hashtags.\nGamification: Users automatically earn ERC20 tokens for their posts, encouraging ongoing participation. Galadriel Platform: I utilized Galadriel, the first Layer 1 blockchain designed specifically for AI applications, as the foundation for my project.\nSmart Contract Development: Using Solidity, I created smart contracts on Galadriel's blockchain to handle the NFT minting process as well as ERC20 token rewards.\nText-to-Image AI Integration: I integrated a text-to-image AI model within my smart contract, leveraging Galadriel's ability to bring AI inference on-chain through their teeML (Trusted Execution Environment Machine Learning) system.",
        "how_its_made": "Galadriel Platform: I utilized Galadriel, the first Layer 1 blockchain designed specifically for AI applications, as the foundation for my project.\nSmart Contract Development: Using Solidity, I created smart contracts on Galadriel's blockchain to handle the NFT minting process as well as ERC20 token rewards.\nText-to-Image AI Integration: I integrated a text-to-image AI model within my smart contract, leveraging Galadriel's ability to bring AI inference on-chain through their teeML (Trusted Execution Environment Machine Learning) system.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rhwww/screenshots/rana7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rhwww/screenshots/tdps2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rhwww/screenshots/be4qu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/build509/AiTribe",
        "link": "https://ethglobal.com/showcase/aitribe-rhwww"
    },
    {
        "title": "EncrypMarket",
        "brief_description": "EncrypMarket is a decentralized betting platform powered by Fhenix's Fully Homomorphic Encryption (FHE), ensuring complete privacy. Bet amounts, participants, and choices remain fully encrypted, with FHE tokens enabling secure, anonymous transactions on the blockchain.",
        "long_description": "EncrypMarket \ud83c\udfb2\ud83d\udd10 is an innovative decentralized betting platform that prioritizes user privacy and data security using Fully Homomorphic Encryption (FHE) technology, powered by Fhenix. This platform allows users to place bets while ensuring complete confidentiality, as all bet-related information\u2014such as the bet amounts, identities of participants, and their choices\u2014remains fully encrypted throughout the process. Unlike traditional betting systems that expose sensitive user data, EncrypMarket ensures even the platform itself cannot access this information. \ud83d\udd11 Key Features: EncrypMarket combines the best of both worlds\u2014\ud83d\udd10 privacy through encryption and \ud83c\udf10 transparency via blockchain\u2014to create a secure, decentralized, and trusted environment for anonymous betting. We built EncrypMarket using a combination of cutting-edge technologies to create a secure, decentralized, and privacy-focused betting platform. Here's a breakdown of how we pieced everything together: Fully Homomorphic Encryption (FHE) \ud83d\udd10: Fhenix's FHE libraries ensure that all bet-related data (bet amounts, participant identities, choices) remains encrypted during processing. This guarantees that sensitive information is never exposed, even to the platform. Fhenix.js \ud83d\udcdc: Handles cryptographic functions like generating permits, signing EIP-712 compliant data, and implementing access control. It enables seamless encryption and decryption of data within smart contracts. Solidity & Smart Contracts \ud83e\uddd1\u200d\ud83d\udcbb: Smart contracts manage the core betting functions, storing encrypted data and handling bet placement and winnings distribution. They work with Fhenix to ensure privacy. Ethereum Blockchain \u26d3\ufe0f: Deployed on Ethereum for transparency and decentralization. It ensures all bets and transactions are auditable on-chain without exposing user data. FHE Tokens \ud83d\udcb0: Users bet with FHE tokens, maintaining encrypted and secure transactions. These tokens play a key role in preserving privacy. MetaMask & ethers.js \ud83e\udd8a: MetaMask is used for wallet management, while ethers.js connects the platform to Ethereum and manages encrypted interactions with smart contracts. Project Status \ud83d\udea7\nEncrypMarket is still in progress, and I will continue building it after the hackathon with the goal of making it something big and impactful in the decentralized privacy-preserving betting space.",
        "how_its_made": "We built EncrypMarket using a combination of cutting-edge technologies to create a secure, decentralized, and privacy-focused betting platform. Here's a breakdown of how we pieced everything together: Fully Homomorphic Encryption (FHE) \ud83d\udd10: Fhenix's FHE libraries ensure that all bet-related data (bet amounts, participant identities, choices) remains encrypted during processing. This guarantees that sensitive information is never exposed, even to the platform. Fhenix.js \ud83d\udcdc: Handles cryptographic functions like generating permits, signing EIP-712 compliant data, and implementing access control. It enables seamless encryption and decryption of data within smart contracts. Solidity & Smart Contracts \ud83e\uddd1\u200d\ud83d\udcbb: Smart contracts manage the core betting functions, storing encrypted data and handling bet placement and winnings distribution. They work with Fhenix to ensure privacy. Ethereum Blockchain \u26d3\ufe0f: Deployed on Ethereum for transparency and decentralization. It ensures all bets and transactions are auditable on-chain without exposing user data. FHE Tokens \ud83d\udcb0: Users bet with FHE tokens, maintaining encrypted and secure transactions. These tokens play a key role in preserving privacy. MetaMask & ethers.js \ud83e\udd8a: MetaMask is used for wallet management, while ethers.js connects the platform to Ethereum and manages encrypted interactions with smart contracts. Project Status \ud83d\udea7\nEncrypMarket is still in progress, and I will continue building it after the hackathon with the goal of making it something big and impactful in the decentralized privacy-preserving betting space.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/av61h/screenshots/3kji2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/av61h/screenshots/dph7c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/av61h/screenshots/ypb88/default.jpg",
            "https://ethglobal.b-cdn.net/projects/av61h/screenshots/e7ogw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/av61h/screenshots/zu02s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/av61h/screenshots/6dy0g/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AkankshaAttavar/EncrypMarket",
        "link": "https://ethglobal.com/showcase/encrypmarket-av61h"
    },
    {
        "title": "ZKazino",
        "brief_description": "Zero knowledge based poker developed using zknoid SDK which uses protokit behind the scenes and runs on mina chain.",
        "long_description": "ZKazino is a concept for integrating casino games using the ZKNoid SDK, with poker being the first game on the list. We have created a Zero Knowledge-based poker game that utilizes the ZKNoid SDK in the background. The game is designed to allow two players to connect in real time and play together. It features the capability to create private lobbies for players, enabling them to play with their friends. The game leverages Protokit to build an app chain that facilitates lightning-fast transactions, providing players with a true real-time gaming experience. Utilising ZK ensures a secure platform for players to participate. This technology ensures that players have no knowledge of their opponent's cards. Zero-knowledge proofs are generated and verified at the chain's end for every move. The game is played using in-game currency, similar to a real casino. The winner receives their winnings directly in the form of in-game currency, which can be subsequently converted back to MINA. ZKazino is an innovative approach to integrating blockchain technology into casino games, with poker being the first of its offerings. The game is built using the ZKNoid SDK, a toolkit that simplifies state management and multiplayer interactions. By utilizing the @state() decorators, StateMap, and State classes provided by ZKNoid, ZKazino ensures smooth state transitions and real-time gameplay experiences. The game's core multiplayer functionality is managed through the ZKNoid SDK's MatchMaker class, which enables seamless matchmaking, lobby creation, and game session management. To enhance the gaming experience, ZKazino employs Protokit, allowing it to create its own Layer 2 (L2) blockchain specifically tailored to the game's needs. This app chain enables ultra-fast, low-latency transactions, addressing scalability concerns common in blockchain-based games by reducing congestion and transaction delays. The platform leverages Zero Knowledge (ZK) technology, providing an extra layer of security by ensuring that players' hands remain completely hidden from their opponents, and that every move is verified through zero-knowledge proofs on-chain. In-game currency drives the poker matches, and winnings can be converted back into the MINA token, bringing real-world value to the gaming experience. This system mirrors the dynamics of real-world casinos, where players can enjoy a safe, provably fair, and privacy-preserving environment while competing with friends or other users in private lobbies. With these cutting-edge features, ZKazino aims to create an unparalleled online poker experience that combines the best of blockchain, zero-knowledge proofs, and real-time multiplayer gaming, optimized for speed, privacy, and security.",
        "how_its_made": "ZKazino is an innovative approach to integrating blockchain technology into casino games, with poker being the first of its offerings. The game is built using the ZKNoid SDK, a toolkit that simplifies state management and multiplayer interactions. By utilizing the @state() decorators, StateMap, and State classes provided by ZKNoid, ZKazino ensures smooth state transitions and real-time gameplay experiences. The game's core multiplayer functionality is managed through the ZKNoid SDK's MatchMaker class, which enables seamless matchmaking, lobby creation, and game session management. To enhance the gaming experience, ZKazino employs Protokit, allowing it to create its own Layer 2 (L2) blockchain specifically tailored to the game's needs. This app chain enables ultra-fast, low-latency transactions, addressing scalability concerns common in blockchain-based games by reducing congestion and transaction delays. The platform leverages Zero Knowledge (ZK) technology, providing an extra layer of security by ensuring that players' hands remain completely hidden from their opponents, and that every move is verified through zero-knowledge proofs on-chain. In-game currency drives the poker matches, and winnings can be converted back into the MINA token, bringing real-world value to the gaming experience. This system mirrors the dynamics of real-world casinos, where players can enjoy a safe, provably fair, and privacy-preserving environment while competing with friends or other users in private lobbies. With these cutting-edge features, ZKazino aims to create an unparalleled online poker experience that combines the best of blockchain, zero-knowledge proofs, and real-time multiplayer gaming, optimized for speed, privacy, and security.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8wf0u/screenshots/of6tw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8wf0u/screenshots/h0a6o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8wf0u/screenshots/sri0c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8wf0u/screenshots/nf40g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8wf0u/screenshots/uitow/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kituuu/zkazino-ethonline-2024",
        "link": "https://ethglobal.com/showcase/zkazino-8wf0u"
    },
    {
        "title": "Truworld <> DIMO",
        "brief_description": "Truworld \ud83c\udf0d is a next generation Web3 lifestyle and airdrop platform focusing on real world gamification and location based airdrops for mass adoption and real world advertising utility.",
        "long_description": "Truworld \ud83c\udf0d is a next generation Web3 lifestyle and airdrop platform focusing on real world gamification and location based airdrops for mass adoption and real world advertising utility. Truworld transforms the real world into a giant playground full of onchain rewards and drives users to physical locations for advertising, creating innovative IRL interactions through gamification and social features. For location-based airdrops, issuers create airdrops using our custom smart contract, which leverages Chainlink VRF to ensure onchain randomness. During this hackathon, we integrated DIMO authentication, offering users extra rewards for connecting their DIMO accounts. In the future, users traveling with DIMO vehicles will earn additional bonuses, further enhancing their Truworld experience. Truworld mobile App is built using React Native for the mobile app and a Golang backend. Users interact with the app as they explore the real world, with the app tracking and recording their travel paths. These paths are sent to the Truworld backend for verification and proof-of-location. As users level up, the backend mints tokens based on their achievements and rewards their real-world activities.",
        "how_its_made": "For location-based airdrops, issuers create airdrops using our custom smart contract, which leverages Chainlink VRF to ensure onchain randomness. During this hackathon, we integrated DIMO authentication, offering users extra rewards for connecting their DIMO accounts. In the future, users traveling with DIMO vehicles will earn additional bonuses, further enhancing their Truworld experience. Truworld mobile App is built using React Native for the mobile app and a Golang backend. Users interact with the app as they explore the real world, with the app tracking and recording their travel paths. These paths are sent to the Truworld backend for verification and proof-of-location. As users level up, the backend mints tokens based on their achievements and rewards their real-world activities.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bd0hd/screenshots/etz1w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bd0hd/screenshots/5nkhv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bd0hd/screenshots/fdjib/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bd0hd/screenshots/kf9th/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bd0hd/screenshots/28vox/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/trumen-world/ETH-Online-DIMO",
        "link": "https://ethglobal.com/showcase/truworld-dimo-bd0hd"
    },
    {
        "title": "Beepo",
        "brief_description": "Beepo is a decentralized Social Neobank simplifying access to web3",
        "long_description": "Project Beepo is a decentralized Social Neobank that simplifies access to Web3 technologies by integrating a non-custodial wallet with multiple social media functionalities. It aims to empower users with secure, decentralized communication and financial transactions within a single platform, enhancing both social interaction and financial autonomy. https://beepoapp.net/ Vision:\nTo create a seamless and secure decentralized platform where users can communicate, share, and transact without reliance on external third-party applications, fostering a new era of Web3 social engagement. The Beepo Project integrates cutting-edge Web3 technologies to create a seamless and user-friendly platform for communication, transactions, and business operations. At its core, Beepo leverages Web3Auth's MPC (Multi-Party Computation) wallet and authentication infrastructure, alongside XMTP (Extensible Message Transport Protocol) for communication. This combination provides a robust, decentralized platform that caters to both everyday users and businesses. Key Components and Technologies:\nWeb3Auth (MPC Wallet & Authentication Infrastructure): The Beepo platform utilizes Web3Auth for secure wallet management and authentication. Web3Auth's MPC wallet ensures decentralized key management, enhancing security by splitting the private key across multiple parties, reducing the risk of hacks. By using familiar authentication methods like Google Sign-In, Beepo simplifies user onboarding, making Web3 more accessible to non-crypto-savvy users while maintaining the integrity of decentralized ownership. XMTP Communication Technology: XMTP powers Beepo's real-time, decentralized messaging infrastructure. With end-to-end encryption, users can securely communicate, share status updates via the Moments feature, and send tokens directly within chats. XMTP's decentralized nature ensures that user messages and interactions are private and tamper-resistant, enhancing the overall security of the communication layer. Feature Integration:\nMultichain Wallet: The Beepo wallet supports multichain transactions, enabling users to execute cryptocurrency transfers seamlessly across different blockchain networks. This wallet integrates directly into the chat feature, allowing users to send and receive tokens in-chat while also managing other crypto activities, including cross-chain swaps, without leaving the app. \"Moments\" Feature: Inspired by popular social platforms, Beepo introduces Moments, where users can share status updates or public content with their network. This enhances the social aspect of the platform, allowing users to engage with one another through both messages and visual content, driving interaction. Business Transactions and SME Tools: One of Beepo\u2019s standout features is its tailored support for small and medium enterprises (SMEs). Drawing inspiration from WhatsApp Business, Beepo enables businesses to upload product catalogs directly onto the platform. SMEs can conduct transactions, execute sales, and communicate with customers through in-app messaging, creating a streamlined experience for businesses to manage orders and offer customer support in one place. Partner Technologies & Benefits:\nWeb3Auth & XMTP: These partner technologies were crucial in bringing the platform to life. Web3Auth's authentication simplifies the onboarding process while maintaining robust security. XMTP's decentralized messaging ensures privacy and resilience, both critical for Beepo's vision of secure, on-chain communication.\nNotable Hacks:\nTo ensure scalability and efficiency, we employed several unique approaches, such as integrating Web3Auth's MPC wallet with our multichain transaction capabilities, allowing users to switch between chains and execute transactions without the complexity traditionally associated with multichain wallets. Another noteworthy solution was creating a modular backend that allows businesses to manage catalogs, inventory, and customer communications seamlessly within one interface, giving SMEs the flexibility to operate in a decentralized ecosystem",
        "how_its_made": "The Beepo Project integrates cutting-edge Web3 technologies to create a seamless and user-friendly platform for communication, transactions, and business operations. At its core, Beepo leverages Web3Auth's MPC (Multi-Party Computation) wallet and authentication infrastructure, alongside XMTP (Extensible Message Transport Protocol) for communication. This combination provides a robust, decentralized platform that caters to both everyday users and businesses. Key Components and Technologies:\nWeb3Auth (MPC Wallet & Authentication Infrastructure): The Beepo platform utilizes Web3Auth for secure wallet management and authentication. Web3Auth's MPC wallet ensures decentralized key management, enhancing security by splitting the private key across multiple parties, reducing the risk of hacks. By using familiar authentication methods like Google Sign-In, Beepo simplifies user onboarding, making Web3 more accessible to non-crypto-savvy users while maintaining the integrity of decentralized ownership. XMTP Communication Technology: XMTP powers Beepo's real-time, decentralized messaging infrastructure. With end-to-end encryption, users can securely communicate, share status updates via the Moments feature, and send tokens directly within chats. XMTP's decentralized nature ensures that user messages and interactions are private and tamper-resistant, enhancing the overall security of the communication layer. Feature Integration:\nMultichain Wallet: The Beepo wallet supports multichain transactions, enabling users to execute cryptocurrency transfers seamlessly across different blockchain networks. This wallet integrates directly into the chat feature, allowing users to send and receive tokens in-chat while also managing other crypto activities, including cross-chain swaps, without leaving the app. \"Moments\" Feature: Inspired by popular social platforms, Beepo introduces Moments, where users can share status updates or public content with their network. This enhances the social aspect of the platform, allowing users to engage with one another through both messages and visual content, driving interaction. Business Transactions and SME Tools: One of Beepo\u2019s standout features is its tailored support for small and medium enterprises (SMEs). Drawing inspiration from WhatsApp Business, Beepo enables businesses to upload product catalogs directly onto the platform. SMEs can conduct transactions, execute sales, and communicate with customers through in-app messaging, creating a streamlined experience for businesses to manage orders and offer customer support in one place. Partner Technologies & Benefits:\nWeb3Auth & XMTP: These partner technologies were crucial in bringing the platform to life. Web3Auth's authentication simplifies the onboarding process while maintaining robust security. XMTP's decentralized messaging ensures privacy and resilience, both critical for Beepo's vision of secure, on-chain communication.\nNotable Hacks:\nTo ensure scalability and efficiency, we employed several unique approaches, such as integrating Web3Auth's MPC wallet with our multichain transaction capabilities, allowing users to switch between chains and execute transactions without the complexity traditionally associated with multichain wallets. Another noteworthy solution was creating a modular backend that allows businesses to manage catalogs, inventory, and customer communications seamlessly within one interface, giving SMEs the flexibility to operate in a decentralized ecosystem",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/j6w48/screenshots/tb0t3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j6w48/screenshots/7e7do/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j6w48/screenshots/ubw55/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j6w48/screenshots/jcg5m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j6w48/screenshots/si8u4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j6w48/screenshots/nxjcg/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/beepo-app/BeepoApp-2.0",
        "link": "https://ethglobal.com/showcase/beepo-j6w48"
    },
    {
        "title": "Web3vent",
        "brief_description": "Web3vents is a decentralized event management platform built on the Rootstock (RSK) network, enabling users to create and manage events using smart contracts.",
        "long_description": "We want to use blockchain for what it is known best. Being a distributed ledger. Therefore we want to go back to the roots and start establishing blockchain technology for web2 applications. One of these web2 applications that can be made better using blockchain technology is event scheduling. We use blockchain to create the event and we use blockchain for anyone to sign up for the event. Ultimately (not yet tho) you will also receive a PAOP if you have successfully attended the event We chose to integrate our project with the Rootstock network because of its strong focus on Bitcoin compatibility. Many people have a strong sentiment towards Bitcoin and are more likely to use applications that are built on top of the Bitcoin ecosystem. By leveraging Rootstock, we can tap into this sentiment and attract a wider audience to our platform. Our smart contracts are written in Solidity and deployed on the Rootstock testnet. We have successfully executed at least two on-chain transactions to demonstrate the functionality of our platform. \u2022\u2060  \u2060Envio for indexing the RCP data so we can access it quickly via graphql\n\u2022\u2060  \u2060Deployed smart contract for creating and attending events on Rootstock blockchain\n\u2022\u2060  \u2060Web3auth login in case you are coming from web2 and don't have wallet",
        "how_its_made": "We chose to integrate our project with the Rootstock network because of its strong focus on Bitcoin compatibility. Many people have a strong sentiment towards Bitcoin and are more likely to use applications that are built on top of the Bitcoin ecosystem. By leveraging Rootstock, we can tap into this sentiment and attract a wider audience to our platform. Our smart contracts are written in Solidity and deployed on the Rootstock testnet. We have successfully executed at least two on-chain transactions to demonstrate the functionality of our platform. \u2022\u2060  \u2060Envio for indexing the RCP data so we can access it quickly via graphql\n\u2022\u2060  \u2060Deployed smart contract for creating and attending events on Rootstock blockchain\n\u2022\u2060  \u2060Web3auth login in case you are coming from web2 and don't have wallet",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gu0x4/screenshots/zntkt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gu0x4/screenshots/s6amx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gu0x4/screenshots/347yy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gu0x4/screenshots/kc3gx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gu0x4/screenshots/w56m0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/michaeltomasik/EthGlobalHackaton?tab=readme-ov-file",
        "link": "https://ethglobal.com/showcase/web3vent-gu0x4"
    },
    {
        "title": "RuneTrust",
        "brief_description": "RuneTrust is a decentralized trust score aggregator on Fhenix and Rootstock, using Fully Homomorphic Encryption (FHE) and Ordinals/Runes for privacy-preserving trust score computations, ensuring data confidentiality.",
        "long_description": "RuneTrust: Confidential Trust Score Aggregator\nNew Gen Era: From Traditional Credit Scores to Holistic Trust Scores\nRuneTrust Logo TL;DR:\nRuneTrust is a decentralized trust score aggregator built on the Fhenix and Rootstock blockchains. It is designed to provide privacy-preserving trust score computations, leveraging Fully Homomorphic Encryption (FHE) and Ordinals/Runes to ensure secure computation of trust scores while safeguarding user data confidentiality. This platform is ideal for decentralized lending, reputation systems, and financial services, offering verifiable yet private trust metrics to ensure users' privacy and trustworthiness. RuneTrust is composed of three key components that integrate Fhenix contracts and Rootstock HubRelayer: RuneTrust Logo",
        "how_its_made": "RuneTrust is composed of three key components that integrate Fhenix contracts and Rootstock HubRelayer: RuneTrust Logo",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/e7zi9/screenshots/q0woe/default.jpg",
            "https://ethglobal.b-cdn.net/projects/e7zi9/screenshots/3n5yr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/e7zi9/screenshots/o50ud/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/mrhouzlane/RuneTrust",
        "link": "https://ethglobal.com/showcase/runetrust-e7zi9"
    },
    {
        "title": "SSV-Pulse",
        "brief_description": "Welcome to SSV Pulse, an advanced AI-based analytics platform tailored to provide deep insights into the SSV Network. By leveraging state-of-the-art Large Language Models (LLMs).",
        "long_description": "Features- ETH Stake Analytics - Track Staking Trends: Monitor the amount of ETH staked within the SSV network. Analyze key staking participants and their impact on the network's security and rewards.\nPredictive Insights: Our AI models forecast future staking activities, identifying growth opportunities and potential security implications. Fees Analytics - Fee Distribution Insights: Analyze how fees are distributed among validators, operators, and the network. Understand the profitability of different positions.\nOptimization Suggestions: SSV Pulse uses AI to offer strategies for optimizing fee revenues and minimizing operational costs. Growth Analytics - Network Expansion: Monitor the growth of the SSV network over time, tracking new validators, operators, and significant milestones like network upgrades.\nForecasting Growth: Our AI models forecast future growth trajectories, providing insights into the long-term health and scalability of the network. Holders Analytics - Token Distribution Insights: Explore how SSV tokens are distributed across wallets, tracking major holders and their behaviors.\nAI-Driven Predictions: Identify accumulation and distribution patterns, enabling strategic investment based on holder movements and market trends. Network Graph, Insights & Connections - Visualize Relationships: SSV Pulse offers an interactive network graph that shows connections between validators, operators, and accounts. AI-Driven Insights: Gain a unique perspective into the behaviors of key participants. Our AI suggests opportunities for collaboration, investment, and optimization based on network connections. Architecture - SSV Pulse is built using a robust, modular architecture that ensures seamless integration of data from the SSV network and reliable delivery of insights. The architecture incorporates key layers for data extraction, processing, AI-powered analytics, and user interface delivery. Data Extraction & ETL Process: SSV Pulse extracts real-time data from the SSV network and processes it through the ETL (Extract, Transform, Load) pipeline. AI Analytics Engine: Our LLM models analyze the processed data to provide actionable insights and predictions. Database Storage: All data is securely stored, ensuring availability for real-time analytics. Dashboard Delivery: Insights are delivered to the user through an intuitive, interactive dashboard that covers all the key features, including staking, fees, growth, holders, and network visualizations. **Meeting User Needs ** SSV Pulse is designed to meet the needs of various stakeholders in the SSV ecosystem: For Validators & Operators: Optimize Strategies: Use Fee Analytics and ETH Stake Analytics to optimize staking and fee strategies. Monitor Growth: Keep track of network expansion, identifying opportunities to scale operations. For Investors: Informed Investment Decisions: Use Holders Analytics and Growth Analytics to evaluate the long-term health of the network and make informed investments. Predicted Market Trends: Our AI models predict token movements and offer investment suggestions based on real-time data. For New Users & Enthusiasts: Education & Innovation: SSV Pulse provides insights into the SSV network that guide new users toward better understanding. The Network Graph offers a visual overview, helping new users grasp the complexities of the ecosystem. Drive Innovation: The platform supports innovation by offering data-driven insights that help participants design and deploy better solutions. Conclusion SSV Pulse empowers its users with in-depth analytics and AI-driven insights, providing a clear view of the SSV network's health, trends, and opportunities. From validators and operators to investors and new participants, SSV Pulse delivers the tools needed to thrive in the SSV ecosystem. DATA -https://thegraph.com/explorer/subgraphs/7V45fKPugp9psQjgrGsfif98gWzCyC6ChN7CW98VyQnr?view=Query&chain=arbitrum-one DATA CSV - https://api.ssv.network/documentation/#/",
        "how_its_made": "Architecture - SSV Pulse is built using a robust, modular architecture that ensures seamless integration of data from the SSV network and reliable delivery of insights. The architecture incorporates key layers for data extraction, processing, AI-powered analytics, and user interface delivery. Data Extraction & ETL Process: SSV Pulse extracts real-time data from the SSV network and processes it through the ETL (Extract, Transform, Load) pipeline. AI Analytics Engine: Our LLM models analyze the processed data to provide actionable insights and predictions. Database Storage: All data is securely stored, ensuring availability for real-time analytics. Dashboard Delivery: Insights are delivered to the user through an intuitive, interactive dashboard that covers all the key features, including staking, fees, growth, holders, and network visualizations. **Meeting User Needs ** SSV Pulse is designed to meet the needs of various stakeholders in the SSV ecosystem: For Validators & Operators: Optimize Strategies: Use Fee Analytics and ETH Stake Analytics to optimize staking and fee strategies. Monitor Growth: Keep track of network expansion, identifying opportunities to scale operations. For Investors: Informed Investment Decisions: Use Holders Analytics and Growth Analytics to evaluate the long-term health of the network and make informed investments. Predicted Market Trends: Our AI models predict token movements and offer investment suggestions based on real-time data. For New Users & Enthusiasts: Education & Innovation: SSV Pulse provides insights into the SSV network that guide new users toward better understanding. The Network Graph offers a visual overview, helping new users grasp the complexities of the ecosystem. Drive Innovation: The platform supports innovation by offering data-driven insights that help participants design and deploy better solutions. Conclusion SSV Pulse empowers its users with in-depth analytics and AI-driven insights, providing a clear view of the SSV network's health, trends, and opportunities. From validators and operators to investors and new participants, SSV Pulse delivers the tools needed to thrive in the SSV ecosystem. DATA -https://thegraph.com/explorer/subgraphs/7V45fKPugp9psQjgrGsfif98gWzCyC6ChN7CW98VyQnr?view=Query&chain=arbitrum-one DATA CSV - https://api.ssv.network/documentation/#/",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dh4mn/screenshots/2vbqd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dh4mn/screenshots/zsydt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dh4mn/screenshots/xbrhp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dh4mn/screenshots/xv2kk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dh4mn/screenshots/j9mnr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Manidills/SSV-Pulse",
        "link": "https://ethglobal.com/showcase/ssv-pulse-dh4mn"
    },
    {
        "title": "DeSats",
        "brief_description": "Launch and Crowdfund your satellite today with DeSats #tothemoon",
        "long_description": "DeSats is a modern solution for a futuristic problem. Our project is here to make the launching of satellites easy. We want to revolutionize the space of private aerospace control and public aero space control with the help of Crowdfunding. Users can launch satellites in space and create a campaign with us on DeSats for your satellite.\nOther users can participate in the launch through crowdfunding. Crowdfunding is a great way to finance big expenses.\nDeSats is built for people who want to launch their Satellites. Since that sounds expensive that's why we gave a crowdfunding feature through which other participants of the campaign can fund the launch of the satellite.\nAs of now, this is just a prototype since this is a hackathon but we want to take it to the next level by adding an NFT marketplace. We plan to provide rewards for the participants with Airdrops. These users can then ask for a certain limited access to the satellite itself.\nLet's assume you want to launch the James Webb Space Telescope Satellite into Space. Since some users participated in the crowdfunding campaign they can gain special abilities like the access of imagery of whatever the Satellite is taking. We have used multiple technologies. NextJs is for frontend, express js is for backend, and solidity is for smart contracts.\nWe have a few contracts worth mentioning one is our IMAGE generation smart contract which is deployed on Galadriel Testnet. The crowdfunding smart contract and CAP20  SATFAN token are both deployed on the Chiliz Network.\nWe have used a message kit from XMTP to create our chatbot to help users launch the satellites.\nWe have used Three JS to create the 3d environment.\nOnce the Chat bot has helped the users with launching their satellite we create a campaign through the crowdfunding contract on Chiliz Spicy Testnet.\nOther users can participate in the crowdfunding by contributing SATFAN tokens. Once the goal is reached or the duration of the campaign is over the creator of the crowdfunding campaign can end the campaign to withdraw his/her SATFAN tokens from the contract.\nThere were many challenges faced throughout this Hackathon. https://github.com/optimus789/desats-backend",
        "how_its_made": "We have used multiple technologies. NextJs is for frontend, express js is for backend, and solidity is for smart contracts.\nWe have a few contracts worth mentioning one is our IMAGE generation smart contract which is deployed on Galadriel Testnet. The crowdfunding smart contract and CAP20  SATFAN token are both deployed on the Chiliz Network.\nWe have used a message kit from XMTP to create our chatbot to help users launch the satellites.\nWe have used Three JS to create the 3d environment.\nOnce the Chat bot has helped the users with launching their satellite we create a campaign through the crowdfunding contract on Chiliz Spicy Testnet.\nOther users can participate in the crowdfunding by contributing SATFAN tokens. Once the goal is reached or the duration of the campaign is over the creator of the crowdfunding campaign can end the campaign to withdraw his/her SATFAN tokens from the contract.\nThere were many challenges faced throughout this Hackathon. https://github.com/optimus789/desats-backend",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/scpin/screenshots/ds8uy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/scpin/screenshots/xbrec/default.jpg",
            "https://ethglobal.b-cdn.net/projects/scpin/screenshots/kwc3g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/scpin/screenshots/cat1r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/scpin/screenshots/je844/default.jpg",
            "https://ethglobal.b-cdn.net/projects/scpin/screenshots/icyps/default.jpg"
        ],
        "live_demo": "https://de-sat.vercel.app",
        "source_code": "https://github.com/Rishikeshk9/DeSat",
        "link": "https://ethglobal.com/showcase/desats-scpin"
    },
    {
        "title": "SSV DataLens",
        "brief_description": "SSV DataLens is a powerful platform that provides comprehensive insights into the SSV Network. It offers real-time metrics and historical data analysis to help you understand and optimize your SSV operations.",
        "long_description": "SSV DataLens is a powerful dashboard designed to provide you with a deep understanding of the SSV Network. This innovative tool offers a wealth of insights, allowing you to track key metrics, analyze historical data, and make informed decisions about your SSV operations. Key Analytics: Validator Performance: Monitor validators, operators,  and other key performance indicators. Network Health: Track network health metrics, including transaction volume, block times, and consensus mechanisms. Tokenomics: Analyze token supply, distribution, and price trends. DAO Activity: Monitor DAO governance  and treasury management. Security and Risk: Identify potential security vulnerabilities and track network incidents. Whether you're an investor, developer, or simply interested in the SSV Network, SSV DataLens is the essential tool for gaining valuable insights and making informed decisions. SSV DataLens was built using a combination of Next.js, SSV Network APIs, Subgraph, and Recharts to create a powerful and interactive dashboard for analyzing SSV Network data. Next.js provided the foundation for the web application, while SSV Network APIs and Subgraph were used to fetch real-time and historical data. Recharts, a comprehensive charting library, enabled the creation of various visualizations, and Styled-Components ensured a consistent and visually appealing design. The dashboard's technical implementation involved setting up a Next.js project, integrating with SSV Network APIs and Subgraph, processing data, developing React components, creating visualizations with Recharts, and applying styles using Styled-Components. This combination of technologies resulted in a robust, efficient, and user-friendly dashboard for exploring the SSV Network.",
        "how_its_made": "SSV DataLens was built using a combination of Next.js, SSV Network APIs, Subgraph, and Recharts to create a powerful and interactive dashboard for analyzing SSV Network data. Next.js provided the foundation for the web application, while SSV Network APIs and Subgraph were used to fetch real-time and historical data. Recharts, a comprehensive charting library, enabled the creation of various visualizations, and Styled-Components ensured a consistent and visually appealing design. The dashboard's technical implementation involved setting up a Next.js project, integrating with SSV Network APIs and Subgraph, processing data, developing React components, creating visualizations with Recharts, and applying styles using Styled-Components. This combination of technologies resulted in a robust, efficient, and user-friendly dashboard for exploring the SSV Network.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2krns/screenshots/pc4ce/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2krns/screenshots/vh1qj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2krns/screenshots/20r2b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2krns/screenshots/syecb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2krns/screenshots/y87wx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2krns/screenshots/cnujw/default.jpg"
        ],
        "live_demo": "https://ssv-datalens.vercel.app/",
        "source_code": "https://github.com/ajay7284/ssv-datalens",
        "link": "https://ethglobal.com/showcase/ssv-datalens-2krns"
    },
    {
        "title": "PawNet",
        "brief_description": "PawNet is a digital dog database where each dog gets a unique ID, making it easy to track vaccinations, manage breeder info, and help reunite lost dogs with their owners #Web3 #DogTech",
        "long_description": "PawNet is a database for dogs, where each dog is assigned a unique ID that serves as its digital identity. This system streamlines the tracking of vaccination records(and check vaccine validity), enabling easy access to proof of vaccination for scenarios such as flight clearance(in plans). Additionally, it provides breeders and their customers with detailed information management tools. A key feature of our platform is the ability to track lost dogs and offer rewards to those who help reunite them with their owners. This project use",
        "how_its_made": "This project use",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dd0cv/screenshots/r46fq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dd0cv/screenshots/qpk6v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dd0cv/screenshots/0xtiw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dd0cv/screenshots/04u3c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dd0cv/screenshots/fonh8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/aii23/dog3",
        "link": "https://ethglobal.com/showcase/pawnet-dd0cv"
    },
    {
        "title": "Pokeframes",
        "brief_description": "The first Pok\u00e9mon turn based game engine inside a frame. Pokeframes is compatible with open frames standard and XMTP, this way it can be played anywhere by anyone!",
        "long_description": "Pok\u00e9mon Battle Simulation Game combines the nostalgic excitement of Pok\u00e9mon battles with cutting-edge blockchain technology. Players can mint their own unique Pok\u00e9mon NFTs and engage in battles against others in a secure, transparent, and verifiable environment. With the power of the Open Frames standard and XMTP, players can enjoy the game from anywhere! \u2022 Mint Pok\u00e9mon NFTs: Players can create their own unique Pok\u00e9mon as NFTs. \u2022 Battle Other Players: Engage in thrilling, turn-based battles with opponents. \u2022Secure Moves & Battles: Using Fhenix FHE technology, all player moves are encrypted and secure, preventing any interference or visibility of actions before the game engine processes the next game state. The game is built using the Frog+Hono framework and is fully compatible with the Open Frames standard, allowing seamless integration with XMTP. This enables anyone with a wallet to easily play the game. A Message Kit bot has been implemented to enhance user experience, streamlining battle creation, joining, and notifications. To ensure fairness and prevent cheating, Pokeframes leverages Fhenix FHE technology. This ensures that a player\u2019s moves remain hidden until the game state is updated, preventing opponents from seeing moves in advance. \u2022 Minting Pok\u00e9mon: Players can mint their Pok\u00e9mon NFTs using the Farcaster Frames interface, creating unique and personalized Pok\u00e9mon. \u2022 Initiating a Battle: By leveraging Fhenix FHE, players can challenge each other in turn-based battles, where strategies are securely executed without revealing moves in advance. \u2022 Node.js \u2022 Open Frames (+XMTP) \u2022 Message Kit \u2022 FHE (Fhenix) \u2022 Redis \u2022 SQLite",
        "how_its_made": "The game is built using the Frog+Hono framework and is fully compatible with the Open Frames standard, allowing seamless integration with XMTP. This enables anyone with a wallet to easily play the game. A Message Kit bot has been implemented to enhance user experience, streamlining battle creation, joining, and notifications. To ensure fairness and prevent cheating, Pokeframes leverages Fhenix FHE technology. This ensures that a player\u2019s moves remain hidden until the game state is updated, preventing opponents from seeing moves in advance. \u2022 Minting Pok\u00e9mon: Players can mint their Pok\u00e9mon NFTs using the Farcaster Frames interface, creating unique and personalized Pok\u00e9mon. \u2022 Initiating a Battle: By leveraging Fhenix FHE, players can challenge each other in turn-based battles, where strategies are securely executed without revealing moves in advance. \u2022 Node.js \u2022 Open Frames (+XMTP) \u2022 Message Kit \u2022 FHE (Fhenix) \u2022 Redis \u2022 SQLite",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/svnzv/screenshots/vvhoj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/svnzv/screenshots/4yku9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/svnzv/screenshots/7k6zy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/svnzv/screenshots/eyb9b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/svnzv/screenshots/6tnd1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/DanielYuki/ETHOnline24",
        "link": "https://ethglobal.com/showcase/pokeframes-svnzv"
    },
    {
        "title": "karbon",
        "brief_description": "Contracts for defi protocol and testing the functionality of the project.",
        "long_description": "We created a defi protocol contracts, but we didn't got time to finish the projects. This is our submission. the idea was to create an AI platform for the defi protocols and users can do trading using bots. We created a defi protocol contracts, but we didn't got time to finish the projects. This is our submission. the idea was to create an AI platform for the defi protocols and users can do trading using bots. We created a defi protocol contracts, but we didn't got time to finish the projects.\nWe created a defi protocol contracts, but we didn't got time to finish the projects. This is our submission. the idea was to create an AI platform for the defi protocols and users can do trading using bots. We created a defi protocol contracts, but we didn't got time to finish the projects. This is our submission. the idea was to create an AI platform for the defi protocols and users can do trading using bots.",
        "how_its_made": "We created a defi protocol contracts, but we didn't got time to finish the projects.\nWe created a defi protocol contracts, but we didn't got time to finish the projects. This is our submission. the idea was to create an AI platform for the defi protocols and users can do trading using bots. We created a defi protocol contracts, but we didn't got time to finish the projects. This is our submission. the idea was to create an AI platform for the defi protocols and users can do trading using bots.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wgbbh/screenshots/pe1h3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wgbbh/screenshots/mj4p5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wgbbh/screenshots/ky8zi/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shobhit9070/eth_global",
        "link": "https://ethglobal.com/showcase/karbon-wgbbh"
    },
    {
        "title": "Bot Event Tool",
        "brief_description": "The idea of this bot in telegram is to obtain information based on the events of a contract, process this information and provide it to the user",
        "long_description": "I am a solidity auditor and sometimes to demonstrate a bug or calculate the amount of possible damage I have to read different events from the blockchain. For this I usually have to create a project in node and all this takes a lot of time. Given this approach and with the help of Envio I decided to create a bot in telegram (could be moved to discord, whatsapp, etc) with which a user can get events from a contract in a simple way.\nA clear example is the event that is triggered when changing the implementation of the TransparentUpgradeableProxy contract, here an auditor can look for the change in the code and a normal user can be alarmed.\nThe first option of the bot is to give you the list of events, after that you can subscribe to the event so that the bot will send a message to the user once a new event appears.\nOn the other hand, leave a tool that can read events from the blockchain and save them in a file for later processing, this is really useful for auditors and developers. The technologies I use are node.js, TelegramBot, ethers, @envio-dev/hypersync-client, among others. I think the most hacky thing is that a common user can for example see the new implementations of a contract to be aware of the changes in the code where he invested his money.\nWhile it is still an MVP, using this you can process a lot of events making usability really great, another fascinating example is that you can monitor the events of a liquidity pool of uniswap, and thus calculate the price of the token in any block.",
        "how_its_made": "The technologies I use are node.js, TelegramBot, ethers, @envio-dev/hypersync-client, among others. I think the most hacky thing is that a common user can for example see the new implementations of a contract to be aware of the changes in the code where he invested his money.\nWhile it is still an MVP, using this you can process a lot of events making usability really great, another fascinating example is that you can monitor the events of a liquidity pool of uniswap, and thus calculate the price of the token in any block.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/db8y5/screenshots/d2t71/default.jpg",
            "https://ethglobal.b-cdn.net/projects/db8y5/screenshots/3s92i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/db8y5/screenshots/nyxmh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/db8y5/screenshots/sp6ai/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/rotcivegaf/get-event-logs",
        "link": "https://ethglobal.com/showcase/bot-event-tool-db8y5"
    },
    {
        "title": "Bench Market",
        "brief_description": "Marketplace for game based AI benchmarking. AI is tested by playing Battleship on chain, with the positions of the ships protected by encryption.",
        "long_description": "Benchmarket supports a transparent interactive ecosystem for online gaming versus state of the art AI models. For the purposes of this hackathon I enabled every model available on Groq to be utilized and to have its performance measured in the classic board game Battleship. A player can select one of the models available on the menu and play against it. As the game plays out, the AI model can offer odds to the opponent to make the game more interesting. The result of the matchup is recorded and stands as a testament to the effectiveness of the AI to both play the game and judge its likelihood of winning throughout the game. Benchmarket is built on the cutting edge of blockchain technology. The stack combines Web3Auth with the Fhenix and Galadriel Blockchains, making use of Multi-Party Computation (MPC), Account Abstraction, Fully Homomorphic Encryption (FHE), Artificial Intelligence (AI), and Trusted Execution Environment Machine Learning (TEEML) Web3 auth provides a seamless gaming experience for use of the Fhenix blockchain. The player does not have to confirm every transaction while playing the game, making for a better UX. The Fhenix blockchain protects private data from prying eyes, which in this case means that a player in the Battleship game can only see their own battleships and cannot see their opponents battleships. The concept is familiarly called \"Fog of War\" in gaming. I have written a script that can be used with Node.JS to connect the two blockchains. Upon someone creating a game on Fhenix, the script privately places ships on Fhenix, then once a player makes a move the script makes calls to Galadriel to perform AI actions.",
        "how_its_made": "Benchmarket is built on the cutting edge of blockchain technology. The stack combines Web3Auth with the Fhenix and Galadriel Blockchains, making use of Multi-Party Computation (MPC), Account Abstraction, Fully Homomorphic Encryption (FHE), Artificial Intelligence (AI), and Trusted Execution Environment Machine Learning (TEEML) Web3 auth provides a seamless gaming experience for use of the Fhenix blockchain. The player does not have to confirm every transaction while playing the game, making for a better UX. The Fhenix blockchain protects private data from prying eyes, which in this case means that a player in the Battleship game can only see their own battleships and cannot see their opponents battleships. The concept is familiarly called \"Fog of War\" in gaming. I have written a script that can be used with Node.JS to connect the two blockchains. Upon someone creating a game on Fhenix, the script privately places ships on Fhenix, then once a player makes a move the script makes calls to Galadriel to perform AI actions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2mumy/screenshots/3t9wi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2mumy/screenshots/w8xk0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2mumy/screenshots/859hi/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/madschristensen99/benchMarket",
        "link": "https://ethglobal.com/showcase/bench-market-2mumy"
    },
    {
        "title": "UnboundSign",
        "brief_description": "An application that uses the Sign Protocol for all transactions, including product listings by the store and product purchases by users, enabling multi-chain purchases and cross-chain payments through Chainlink CCIP.",
        "long_description": "The project is a transaction platform that makes all product transactions verifiable. It supports contracts and hooks compatible with Sign Protocol Attestations deployed across multiple chains to handle all necessary transactions, such as listings, purchases, and resales. This creates a world where only transparent, verifiable, and visualized transactions exist for everyone. Naturally, the results of multi-chain transactions are managed on a single screen, avoiding fragmentation. Payment results from each chain are transferred to other chains through cross-chain payments, simplifying complex payment operations and expanding use cases. To accommodate various use cases, the schema is designed flexibly, allowing attestations to be linked. This enables the handling of complex structures, similar to databases, which were previously difficult to represent on-chain. The application primarily utilizes: The demo site represents a multi-chain e-commerce platform. All data structures are expressed using the Sign Protocol\u2019s schema. Each product has its own schema, and the product itself is represented by an Attestation. Purchases also have a dedicated schema, which is likewise represented by an Attestation. These Attestations are linked through a LinkedAttestation relationship, designed to be useful for future queries. In the purchase process, when the specified token is sent to the Payment Contract, it references the product\u2019s Attestation. If it confirms that the paid amount exceeds the required price, the payment is transferred to the destination specified in the Attestation, and a new Attestation proving the ownership of the product is created, indicating the completion of the purchase. Not only does it create an Attestation, but it also uses Hooks to ensure that only transactions audited by addresses on the whitelist (in this case, the Payment Contract) can create Attestations. The transferred tokens are sent to a predetermined chain using ChainLink CCIP, allowing the design to align with the organization\u2019s operations.",
        "how_its_made": "The application primarily utilizes: The demo site represents a multi-chain e-commerce platform. All data structures are expressed using the Sign Protocol\u2019s schema. Each product has its own schema, and the product itself is represented by an Attestation. Purchases also have a dedicated schema, which is likewise represented by an Attestation. These Attestations are linked through a LinkedAttestation relationship, designed to be useful for future queries. In the purchase process, when the specified token is sent to the Payment Contract, it references the product\u2019s Attestation. If it confirms that the paid amount exceeds the required price, the payment is transferred to the destination specified in the Attestation, and a new Attestation proving the ownership of the product is created, indicating the completion of the purchase. Not only does it create an Attestation, but it also uses Hooks to ensure that only transactions audited by addresses on the whitelist (in this case, the Payment Contract) can create Attestations. The transferred tokens are sent to a predetermined chain using ChainLink CCIP, allowing the design to align with the organization\u2019s operations.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rig4c/screenshots/hmreo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rig4c/screenshots/ipckq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rig4c/screenshots/up2nm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rig4c/screenshots/44y6k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rig4c/screenshots/gcvtb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rig4c/screenshots/9ytqo/default.jpg"
        ],
        "live_demo": "https://eth-online-2024.vercel.app/",
        "source_code": "https://github.com/keisukefunatsu/eth-online-2024",
        "link": "https://ethglobal.com/showcase/unboundsign-rig4c"
    },
    {
        "title": "Win-Me",
        "brief_description": "Unleash your inner racer in our NFT Racing Game, offering unique NFT Racing Karts, daily tournaments,  dynamic gameplay, and a smooth web2 onboarding experience using Web3Auth. Race, compete, and earn real cryptocurrencies in this immersive, visually stunning adventure!",
        "long_description": "Mario Kart has captivated millions with its thrilling races and competitive gameplay, yet it leaves gaps that web3 can easily address.\n#1 lack of digital asset ownership: in web2, hard-earned achievements, and unlocked race tracks, despite their value to players, are non-fungible and locked within the game environment. To solve this we are deploying NFTs that represent ownership of in-game assets (like users' cars) and store players' assets on the Morph Blockchain!\n#2 lack of monetary rewards for playing: some gamers are attracted by the potential to earn tokens as a reward for the time they spend in the game but this does not happen in web2 games.\n#3 Obstacles and Challenges: Players must navigate through the tracks while searching for hidden coins. These hidden coins add an extra layer of excitement and strategy to the races, making it more than just a typical racing game.\n#4 Variety of Race Types: Beyond traditional races, the game includes obstacle courses and time trials, offering diverse challenges to keep players engaged and entertained. With Win-Me, we\u2019re working to address Web2\u2019s frustrations and bring one of the biggest childhood games to Web3!! Win-Me is an Open Source Racing Game built within the Unity Gaming Engine, for this build, we utilized 3 main technologies. Unity - Unity is a powerful game engine that we utilized for this built, by using custom assets for the racing karts, networking for multiplayer and so on. This game engine has been utilized for numerous Web3 Games but has a lack of documentation for Web3 integrations. Making this build a little harder than anticipated. Morph - We use Morph L2 to power our consumer-based marketplace and manage NFT collections for Win Me Game. Morph allows us to efficiently handle high transaction volumes, ensuring scalability and smooth user experiences during in-game asset trading and NFT interactions. Its layer 2 solution offers the necessary speed and cost savings to optimize our platform\u2019s performance. Web3Auth - Web3Auth simplifies the onboarding process for users by enabling them to log in using social providers like Google or Twitter. Once logged in, Web3Auth automatically generates a non-custodial wallet with a unique address. This wallet can seamlessly connect to any decentralized application (dApp) through Web3Auth plugins, allowing users to interact with various blockchain features. Additionally, the wallet can be used for sending, receiving, and purchasing tokens or NFTs. Furthermore, Web3Auth supports fiat on-ramp services, enabling users to buy cryptocurrencies using payment methods such as Google Pay, Apple Pay, and MasterCard, making it easy to bridge traditional and decentralized finance.",
        "how_its_made": "Win-Me is an Open Source Racing Game built within the Unity Gaming Engine, for this build, we utilized 3 main technologies. Unity - Unity is a powerful game engine that we utilized for this built, by using custom assets for the racing karts, networking for multiplayer and so on. This game engine has been utilized for numerous Web3 Games but has a lack of documentation for Web3 integrations. Making this build a little harder than anticipated. Morph - We use Morph L2 to power our consumer-based marketplace and manage NFT collections for Win Me Game. Morph allows us to efficiently handle high transaction volumes, ensuring scalability and smooth user experiences during in-game asset trading and NFT interactions. Its layer 2 solution offers the necessary speed and cost savings to optimize our platform\u2019s performance. Web3Auth - Web3Auth simplifies the onboarding process for users by enabling them to log in using social providers like Google or Twitter. Once logged in, Web3Auth automatically generates a non-custodial wallet with a unique address. This wallet can seamlessly connect to any decentralized application (dApp) through Web3Auth plugins, allowing users to interact with various blockchain features. Additionally, the wallet can be used for sending, receiving, and purchasing tokens or NFTs. Furthermore, Web3Auth supports fiat on-ramp services, enabling users to buy cryptocurrencies using payment methods such as Google Pay, Apple Pay, and MasterCard, making it easy to bridge traditional and decentralized finance.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mbkgz/screenshots/e71d0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mbkgz/screenshots/m6agx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mbkgz/screenshots/fjdg7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mbkgz/screenshots/5bk5f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mbkgz/screenshots/0o3ux/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Rainbow1nTheDark/Win-ME",
        "link": "https://ethglobal.com/showcase/win-me-mbkgz"
    },
    {
        "title": "TIL ZK Hunt n Fhenix",
        "brief_description": "what I learned about ZK gaming from forking U ZK Hunt, a 2-year-old zk on chain gaming project, and FHE from Fhenix",
        "long_description": "first I explored ZK hunt which is an onchain game based an old version (1.2) of mud.dev and using old versions of various tools (eg yarn) and it took some effort to get it working and I set up the architecture for new Circom circuits in order to implement modified movement rules for the game and those would generate solidity contracts and which would verify proofs generated in the react and phaser front end of the game UI. from that exercise i understood better the ways zero knowledge proofs, Diffie-Hellman key exchange with pre-registered public keys, and commitments with a challenge response, could be useful in a multiplayer game using only smart contracts to coordinate. then i got Fhenix running locally and explored how it supports private or encrypted transaction data. zk hunt uses an old version of mud, an old version of yarn, and an old version of snarkjs to generate solidity code which itself is postprocessed through a small JavaScript code. the frontend is based on react with phaser for the game itself. the fhenix test uses a docker based local testnet and a hardhat plugin and otherwise the contracts are written in a special variant of solidity to support encrypted values and a JavaScript library for decrypting values from contracts.",
        "how_its_made": "zk hunt uses an old version of mud, an old version of yarn, and an old version of snarkjs to generate solidity code which itself is postprocessed through a small JavaScript code. the frontend is based on react with phaser for the game itself. the fhenix test uses a docker based local testnet and a hardhat plugin and otherwise the contracts are written in a special variant of solidity to support encrypted values and a JavaScript library for decrypting values from contracts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dm1qk/screenshots/25zuw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm1qk/screenshots/aj76f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm1qk/screenshots/z6e00/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/tomosaigon/fhenix-hardhat-vickrey",
        "link": "https://ethglobal.com/showcase/til-zk-hunt-n-fhenix-dm1qk"
    },
    {
        "title": "Betomo",
        "brief_description": "AI-powered sports prediction markets in your pocket. Make micro-bets from $1-$10 on live events, create custom markets, and join a community of smart bettors. Our AI generates relevant events and provides intelligent insights. Small stakes, big thrills!",
        "long_description": "Betomo is a cutting-edge mobile app that's changing the game in sports betting. We're all about making betting more fun, accessible, and engaging for everyone \u2013 from die-hard sports fans to casual viewers looking for a little extra excitement. Here's what makes Betomo special: Live Micro-Betting: Place small bets (just $1 to $10) on live games as they happen. It's low-risk, high-fun, and perfect for those \"I bet he misses this shot\" moments. Custom Markets: Think you know what's going to happen next? Create your own betting markets and invite friends to join in. Smart Insights: Get quick, easy-to-understand stats and tips to help you make informed bets. No PhD in sports analytics required. Community Vibes: Join a lively community of sports lovers. Share your predictions, celebrate wins, and enjoy some friendly competition. Betomo is designed for sports enthusiasts who want more than just watching the game. Whether you're looking to add some spice to your viewing experience, test your sports knowledge, or just have some low-stakes fun with friends, Betomo's got you covered. Our goal? To make sports betting a social, entertaining, and accessible part of your game day experience. No big risks, no complicated systems \u2013 just simple, engaging fun that puts you right in the action. We use Solidity for writing smart contracts that handle the betting logic. The Sign Protocol is implemented for market attestation to ensure fairness. Our web application and API are developed with Next.js, providing a fast and responsive user interface. The AI engine for live sports betting is a custom solution built on top of AllSportsAPI and OpenAI API. For user authentication, we've integrated Web3Auth, and we use Envio for efficient data indexing. This tech stack allows us to create a secure, efficient, and user-friendly sports betting platform.",
        "how_its_made": "We use Solidity for writing smart contracts that handle the betting logic. The Sign Protocol is implemented for market attestation to ensure fairness. Our web application and API are developed with Next.js, providing a fast and responsive user interface. The AI engine for live sports betting is a custom solution built on top of AllSportsAPI and OpenAI API. For user authentication, we've integrated Web3Auth, and we use Envio for efficient data indexing. This tech stack allows us to create a secure, efficient, and user-friendly sports betting platform.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/br5e1/screenshots/xe6yb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/br5e1/screenshots/ob8db/default.jpg",
            "https://ethglobal.b-cdn.net/projects/br5e1/screenshots/3h43o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/br5e1/screenshots/9sjf4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/br5e1/screenshots/kioy4/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ayushjain2205/ethonline-2024/",
        "link": "https://ethglobal.com/showcase/betomo-br5e1"
    },
    {
        "title": "juicyquery",
        "brief_description": "JuicyQuery: Decentralized AI search engine with user-controlled, privacy-protected query data storage. Empowering you with data sovereignty.",
        "long_description": "JuicyQuery is a cutting-edge, decentralized AI search engine designed to revolutionize the way users interact with search technology. Built on the principles of Web3, JuicyQuery places a strong emphasis on user data sovereignty, privacy, and security, while leveraging advanced AI capabilities to deliver a personalized and seamless search experience. Decentralized Storage Advanced AI Capabilities Security and Transparency Community and Governance Future Prospects JuicyQuery leverages Tableland's Basin for decentralized storage of user search queries and results. Tableland is a decentralized database protocol that allows for the creation and management of decentralized tables. Basin, a key component of Tableland, facilitates the storage and retrieval of data in a decentralized manner. JuicyQuery integrates AI models with web search capabilities to build a Retrieval-Augmented Generation (RAG) system. RAG combines the strengths of retrieval-based models and generative models to provide intelligent and interactive search experiences. JuicyQuery represents a paradigm shift in the search engine landscape, combining the power of AI with the principles of decentralization to create a user-centric, secure, and transparent search experience. By prioritizing user data sovereignty and privacy, JuicyQuery empowers users to take control of their information while enjoying a highly personalized and efficient search experience. The technical implementation, leveraging Tableland's Basin for decentralized storage and AI-driven RAG for intelligent interaction, ensures that JuicyQuery delivers on its promise of a next-generation search engine. JuicyQuery combines the power of Tableland Basin's decentralized storage and AI-driven RAG models to deliver a secure, transparent, and personalized search experience. Decentralized Storage and User Data Sovereignty AI-Driven RAG Fusion Search JuicyQuery offers a secure, transparent, and highly personalized search experience by leveraging Tableland Basin's decentralized storage and RAG model's intelligent fusion. Users can fully control their data while enjoying AI-driven intelligent search services.",
        "how_its_made": "JuicyQuery combines the power of Tableland Basin's decentralized storage and AI-driven RAG models to deliver a secure, transparent, and personalized search experience. Decentralized Storage and User Data Sovereignty AI-Driven RAG Fusion Search JuicyQuery offers a secure, transparent, and highly personalized search experience by leveraging Tableland Basin's decentralized storage and RAG model's intelligent fusion. Users can fully control their data while enjoying AI-driven intelligent search services.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t4rjp/screenshots/m8j2i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t4rjp/screenshots/nyr1n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t4rjp/screenshots/8fcse/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/BlockCraftsman/juicyquery",
        "link": "https://ethglobal.com/showcase/juicyquery-t4rjp"
    },
    {
        "title": "OnChain Accounting",
        "brief_description": "Web3 accounting software designed for a community operated co-working / events space",
        "long_description": "This is a web3 onchain accounting app for the regenhub.xyz co-working/events space in downtown boulder colorado.. I made the app so we can keep track of membership balances. Each month members are charged a membership fee. They can pay their fees w/ money or by contributing to the space. We also needed the ability to handle reimbursements. EG someone goes to the store to buy cleaning supplies for $100 then they have to pay $100 less in fees that month. The data from the attestations is combined w/ onchain payment info (members pay fees to a multisig) to create total balances for each member. I made this app in react w/ js. I am using the etherscan API to get transaction information from the regenhub multisig. I am using sign protocol's sdk for the attestations and also querying their rest api using axios then decoding the attestations using abidecoder from ethers.js.",
        "how_its_made": "I made this app in react w/ js. I am using the etherscan API to get transaction information from the regenhub multisig. I am using sign protocol's sdk for the attestations and also querying their rest api using axios then decoding the attestations using abidecoder from ethers.js.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2k40p/screenshots/by9g7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2k40p/screenshots/2a33t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2k40p/screenshots/ravyf/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/michaelgreen06/hackathons",
        "link": "https://ethglobal.com/showcase/onchain-accounting-2k40p"
    },
    {
        "title": "Litit",
        "brief_description": "Lit PKP  Minitng mechanism deployed. It's using a telegram bot to help in OAuth and linking the deployed domain with it. After that any user can mint the PKH.",
        "long_description": "It's using a telegram bot to help in OAuth and linking the deployed domain with it. After that any user can mint the PKP. Any app then can be made using it after this stage, any game but it won't work with metamask, walletConnect or any other wallet. Telegram has recently been having some issue due to the imprisonment of the founder. Due to many personal reasons I was not able to do anything more, But I can say I have learnt something that I can use later. It's made with help of Lit's github repo and me deploying on vercel and making a bot on telegram for testing. I learnt a lot during this hackathon as I tried many of the tracks but at the end I couldn't get to a particular conclusion of what to make, so I am restricting myself till this, Thank You Very Much.",
        "how_its_made": "It's made with help of Lit's github repo and me deploying on vercel and making a bot on telegram for testing. I learnt a lot during this hackathon as I tried many of the tracks but at the end I couldn't get to a particular conclusion of what to make, so I am restricting myself till this, Thank You Very Much.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bq6vh/screenshots/39di3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bq6vh/screenshots/hdpd3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bq6vh/screenshots/gpdrc/default.jpg"
        ],
        "live_demo": "https://lit-test-topaz.vercel.app/",
        "source_code": "https://github.com/Shevxer/LitTest",
        "link": "https://ethglobal.com/showcase/litit-bq6vh"
    },
    {
        "title": "SecureHold",
        "brief_description": "Safeguarding Transactions, One Contract at a Time \u2013 Secure, Transparent, and Trustworthy Escrow Solutions",
        "long_description": "SecureHold is an advanced escrow contract designed to ensure safe and transparent transactions between parties. By holding funds securely until all agreed-upon conditions are met, SecureHold provides a reliable way to manage transactions and protect both buyers and sellers from potential disputes. Suitable for various use cases such as online purchases, freelance agreements, and contract-based transactions, SecureHold delivers trust and security in every interaction. SecureHold securely holds funds in escrow until all conditions specified in the contract are fulfilled. This includes verifying that both parties have met their obligations before funds are released. Built using Solidity for Ethereum-compatible chains, SecureHold features robust security measures to prevent unauthorized access and ensure the integrity of transactions. It includes functionalities for deposit management, fund release, and dispute resolution. SecureHold is designed to be adaptable for various transaction types, from simple purchases to complex service agreements, making it a versatile tool for a wide range of use cases.",
        "how_its_made": "SecureHold securely holds funds in escrow until all conditions specified in the contract are fulfilled. This includes verifying that both parties have met their obligations before funds are released. Built using Solidity for Ethereum-compatible chains, SecureHold features robust security measures to prevent unauthorized access and ensure the integrity of transactions. It includes functionalities for deposit management, fund release, and dispute resolution. SecureHold is designed to be adaptable for various transaction types, from simple purchases to complex service agreements, making it a versatile tool for a wide range of use cases.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/268xo/screenshots/hixnb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/268xo/screenshots/qihhf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/268xo/screenshots/trm61/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/harmit2/SecureHold",
        "link": "https://ethglobal.com/showcase/securehold-268xo"
    },
    {
        "title": "Pulse",
        "brief_description": "Pulse is a cross-chain token launchpad powered by LayerZero's OFT, using a bonding curve to enable seamless, native token launches across multiple chains with ease and efficiency.",
        "long_description": "Pulse is a decentralized, cross-chain token launchpad designed to streamline the process of launching and managing tokens across multiple blockchains. Using a bonding curve mechanism, Pulse ensures dynamic liquidity and fair token distribution, automatically adjusting token prices based on supply and demand. This creates a balanced market for early adopters and stable growth for projects. The platform leverages LayerZero\u2019s Omnichain Fungible Token (OFT) standard to enable native cross-chain compatibility. This eliminates the need for complex bridges or token wrapping, making it easier for projects to launch tokens that can operate seamlessly across various blockchains. LayerZero\u2019s infrastructure ensures secure, fast, and cost-effective transactions, helping projects scale efficiently across multiple networks. Additionally, Pulse utilizes Web3Auth for a seamless, non-custodial social login experience. By integrating the Web3Auth MPC Core Kit SDK, users can log in via social platforms, with Web3 elements abstracted away for simplicity. This functionality works within Web and React Native applications, providing a frictionless user onboarding process. The Web3Auth wallet allows users to store, manage, and transfer their cross-chain tokens without needing advanced Web3 knowledge, making the platform highly accessible to mainstream users. LayerZero\u2019s OFT Contracts:\nIntegrated LayerZero's Omnichain Fungible Token (OFT) standard into a factory contract.\nThe factory contract deploys OFT-compliant tokens that are curve bonded, enabling seamless cross-chain operations.\nThis eliminates the need for bridges or token wrapping, making tokens natively cross-chain compatible. Bonding Curve Mechanism:\nApplied a bonding curve mechanism to adjust token prices dynamically based on supply and demand.\nEnsures liquidity for early adopters and stable token growth over time. Web3Auth for Social Logins:\nImplemented Web3Auth to offer non-custodial social login, simplifying user onboarding.\nAbstracted complex wallet management and private key handling, allowing users to log in via social accounts. Next.js for Frontend OFTFactory Address:\n0xe3dc01C0A47FED16a9F6a3De7EC4dd305B4B003B Supported Chains:\nOp-Sepolia, Base-Sepolia, Eth-Sepolia",
        "how_its_made": "LayerZero\u2019s OFT Contracts:\nIntegrated LayerZero's Omnichain Fungible Token (OFT) standard into a factory contract.\nThe factory contract deploys OFT-compliant tokens that are curve bonded, enabling seamless cross-chain operations.\nThis eliminates the need for bridges or token wrapping, making tokens natively cross-chain compatible. Bonding Curve Mechanism:\nApplied a bonding curve mechanism to adjust token prices dynamically based on supply and demand.\nEnsures liquidity for early adopters and stable token growth over time. Web3Auth for Social Logins:\nImplemented Web3Auth to offer non-custodial social login, simplifying user onboarding.\nAbstracted complex wallet management and private key handling, allowing users to log in via social accounts. Next.js for Frontend OFTFactory Address:\n0xe3dc01C0A47FED16a9F6a3De7EC4dd305B4B003B Supported Chains:\nOp-Sepolia, Base-Sepolia, Eth-Sepolia",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sixju/screenshots/n4xb3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sixju/screenshots/g6axw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sixju/screenshots/au70g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sixju/screenshots/21tne/default.jpg"
        ],
        "live_demo": "https://pulse-fun.vercel.app/",
        "source_code": "https://github.com/Harsh2220/Pulse",
        "link": "https://ethglobal.com/showcase/pulse-sixju"
    },
    {
        "title": "sanicert",
        "brief_description": "A private, permissionless medical data attestation protocol built with sign protocol.",
        "long_description": "Sanicert is a privacy-focused medical data attestation platform that leverages blockchain technology and zero-knowledge proofs. It allows users to securely store their medical information and generate verifiable proofs of specific health attributes without revealing sensitive data. The platform enables users to create attestations about their medical status, such as age verification or vaccination records, which can be verified by third parties while maintaining patient privacy. Built on Next.js and integrating with blockchain networks, Sanicert offers a user-friendly interface for managing medical data, generating proofs, and creating blockchain-based attestations. Sanicert is a nextjs app, it leverages: This tech stack enables Sanicert to provide a secure, privacy-preserving medical data attestation system. It leverages blockchain technology and zero-knowledge proofs to generate proofs of medical data, create blockchain-based attestations, and verify these proofs on-chain, all while maintaining user privacy. The combination of frontend technologies, cryptographic tools, and blockchain integration results in a robust and user-friendly application for managing sensitive medical information.",
        "how_its_made": "Sanicert is a nextjs app, it leverages: This tech stack enables Sanicert to provide a secure, privacy-preserving medical data attestation system. It leverages blockchain technology and zero-knowledge proofs to generate proofs of medical data, create blockchain-based attestations, and verify these proofs on-chain, all while maintaining user privacy. The combination of frontend technologies, cryptographic tools, and blockchain integration results in a robust and user-friendly application for managing sensitive medical information.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zac94/screenshots/k4u5w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zac94/screenshots/hyw1x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zac94/screenshots/c7rea/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zac94/screenshots/1bspu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zac94/screenshots/py5fk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jbrit/sanicert",
        "link": "https://ethglobal.com/showcase/sanicert-zac94"
    },
    {
        "title": "SSV Insight",
        "brief_description": "SSV Insight is a powerful dashboard that tracks key metrics of the SSV Network. It use SSV Network Dashboard  with SSV Network, Sign Protocol, Nillion, Web3Auth",
        "long_description": "SSV Insight is a powerful, state-of-the-art dashboard that provides real-time and historical tracking of key metrics within the SSV (Secret Shared Validators) Network. This innovative platform offers deep insights into validators, operators, and clusters, enabling users to optimize their staking operations in a trust-minimized, decentralized environment. Real-Time Metrics: Track live data on validators, operators, and clusters, including total counts, active status, and staking amounts. Historical Data Analysis: Visualize trends over time for validator uptime and cluster size distribution, allowing for informed decision-making. Secure Authentication: Integrated with Web3Auth, providing a seamless and secure login experience using social logins or passkeys. Verifiable Data Integrity: Utilizes Sign Protocol to create attestations for all metrics, ensuring data trustworthiness and transparency. Privacy-Preserving Comparisons: Leverages Nillion's blind computation for users to compare their validator performance against network averages without revealing sensitive data. Comprehensive Network Health Monitoring: Tracks overall network statistics, including total ETH staked, active nodes, and a decentralization index. User-Centric Design: Intuitive interface catering to both novice users and experienced stakers, with responsive design for various devices. SSV Insight was built to provide a comprehensive, real-time view of the SSV (Secret Shared Validators) network's key metrics. The project combines backend data aggregation with a responsive frontend, enhanced by cutting-edge authentication, data integrity, and privacy-preserving technologies. Backend: Python with Flask Frontend: HTML, CSS, and Vanilla JavaScript Data Source: SSV Network GraphQL API Authentication: Web3Auth Data Integrity: Sign Protocol Privacy-Preserving Computations: Nillion The backend serves as the web server, data aggregator, and integration point for various technologies: API Endpoints: GraphQL Queries: Three main GraphQL queries fetch data about validators, operators, and clusters. Data Aggregation: Raw data is processed to calculate key metrics such as total and active counts, average stakes, and network health indicators. Attestation Creation: Sign Protocol is used to create verifiable attestations for each category of data. Blind Computation: Nillion is integrated to perform privacy-preserving comparisons of validator performance. Error Handling: Robust error handling ensures the frontend receives valid data even if some operations fail. The frontend is a single-page application with enhanced security and user experience: Authentication: Web3Auth is integrated for user-friendly, secure login. Data Fetching: JavaScript's fetch API retrieves data from the backend endpoints. Dynamic Updates: The DOM is updated in real-time as new data is received. Data Visualization: Chart.js creates interactive charts for various metrics. Attestation Verification: Sign Protocol attestations are verified on the client-side. Secure Comparisons: The frontend interacts with Nillion through the backend for blind computations.",
        "how_its_made": "SSV Insight was built to provide a comprehensive, real-time view of the SSV (Secret Shared Validators) network's key metrics. The project combines backend data aggregation with a responsive frontend, enhanced by cutting-edge authentication, data integrity, and privacy-preserving technologies. Backend: Python with Flask Frontend: HTML, CSS, and Vanilla JavaScript Data Source: SSV Network GraphQL API Authentication: Web3Auth Data Integrity: Sign Protocol Privacy-Preserving Computations: Nillion The backend serves as the web server, data aggregator, and integration point for various technologies: API Endpoints: GraphQL Queries: Three main GraphQL queries fetch data about validators, operators, and clusters. Data Aggregation: Raw data is processed to calculate key metrics such as total and active counts, average stakes, and network health indicators. Attestation Creation: Sign Protocol is used to create verifiable attestations for each category of data. Blind Computation: Nillion is integrated to perform privacy-preserving comparisons of validator performance. Error Handling: Robust error handling ensures the frontend receives valid data even if some operations fail. The frontend is a single-page application with enhanced security and user experience: Authentication: Web3Auth is integrated for user-friendly, secure login. Data Fetching: JavaScript's fetch API retrieves data from the backend endpoints. Dynamic Updates: The DOM is updated in real-time as new data is received. Data Visualization: Chart.js creates interactive charts for various metrics. Attestation Verification: Sign Protocol attestations are verified on the client-side. Secure Comparisons: The frontend interacts with Nillion through the backend for blind computations.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gg50s/screenshots/58qjc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gg50s/screenshots/2ccqg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gg50s/screenshots/cjtse/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/InvitedTea/ssvinsight",
        "link": "https://ethglobal.com/showcase/ssv-insight-gg50s"
    },
    {
        "title": "Coolbets",
        "brief_description": "CoolBets: A multi-chain platform for trading opinions. Stake your insights, mint NFT bets, and shape the future across Rootstock, Chilliz, Morph L2, and Base networks. Where predictions meet profit!",
        "long_description": "CoolBets is a revolutionary decentralized opinion trading platform that operates across multiple blockchain networks, including Rootstock, Chilliz, Morph L2, and Base. Our platform empowers users to stake their beliefs on various topics and potentially profit from their insights.\nKey features include: Multi-chain support for seamless operation across different networks.\nNFT-based betting system where each bet is minted as a unique NFT, adding value and collectibility to user interactions.\nTransparent reward distribution powered by smart contracts.\nDecentralized governance allowing community-driven proposals and voting.\nIntegration with Sign Protocol for bet attestations, enhancing trust and verifiability.\nA vision to implement Futarchy for collective decision-making based on user opinions. CoolBets aims to revolutionize prediction markets by creating a decentralized ecosystem where users can challenge conventional wisdom, engage with ideas, and potentially earn rewards for their foresight. Foundry was used for testing, deploying, and interacting with smart contracts.Built with Next.js and TypeScript, providing a responsive and type-safe user interface. Each bet is minted as a unique NFT, adding a layer of value and collectibility to user interactions.Implemented support for Rootstock, Chilliz, Morph L2, and Base networks, allowing for a diverse and robust ecosystem.Integrated Sign Protocol for bet attestations, enhancing the trust and verifiability of each bet.",
        "how_its_made": "Foundry was used for testing, deploying, and interacting with smart contracts.Built with Next.js and TypeScript, providing a responsive and type-safe user interface. Each bet is minted as a unique NFT, adding a layer of value and collectibility to user interactions.Implemented support for Rootstock, Chilliz, Morph L2, and Base networks, allowing for a diverse and robust ecosystem.Integrated Sign Protocol for bet attestations, enhancing the trust and verifiability of each bet.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rqmti/screenshots/1w7xk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rqmti/screenshots/09h0y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rqmti/screenshots/9dkth/default.jpg"
        ],
        "live_demo": "https://coolbets.vercel.app/",
        "source_code": "https://github.com/Open-Sorcerer/coolbets",
        "link": "https://ethglobal.com/showcase/coolbets-rqmti"
    },
    {
        "title": "CipherConnect",
        "brief_description": "Chat app on xmtp supporting creator communities with token gated groups and creator earnings, integrating multiple bots, frames, subscriptions and push notifications from content creators.",
        "long_description": "As currently there is no social media platform in web3 that integrates AI tools and creator earning rewards. Also web3 native social platforms pose friction to the next billion users onboarding to web3, This project is apart of a social place(social media) with content moderation, creator earning rewards, robust governance and other on-chain AI features. This platform has social logins(Google, X, Farcaster, Facebook, etc.)  integrated. This has potential to reduce the onboarding friction for the next billion users to the ethereum. On chain AI will provide multiple features such as regulation of the community by checking illegal, spam and unjust content. It will also include creator earning rewards, which will be calculated by analyzing the content created using ML models using galadriel tee models.\nFurther steps include implementing account abstraction and integrating smart accounts, this project would be integrated into platforms such as farcaster, warpcast, hey. This project uses web3auth for social logins, allowing seamless login/ experience. This project uses xmtp-js and mls client for building p2p and group chats. Integration of group chats posed a problem as the mls client is in alpha version. Group chats are integrated into a frontend where users will be able to add members to the group chat, add ai agents, bots into the chat. User will subscribe and get whitelisted for token gated groups. Subscriptions and push notifications are implemented using xmtp tools. The overall app is built imlementing best practices according to mls specifications.\nAI agents receive data from galadriel oracles, which provide data from on-chain ML models running in galadriel trusted execution environment(tee).\nWe are also using envio's HyperIndex to index blockchain data.",
        "how_its_made": "This project uses web3auth for social logins, allowing seamless login/ experience. This project uses xmtp-js and mls client for building p2p and group chats. Integration of group chats posed a problem as the mls client is in alpha version. Group chats are integrated into a frontend where users will be able to add members to the group chat, add ai agents, bots into the chat. User will subscribe and get whitelisted for token gated groups. Subscriptions and push notifications are implemented using xmtp tools. The overall app is built imlementing best practices according to mls specifications.\nAI agents receive data from galadriel oracles, which provide data from on-chain ML models running in galadriel trusted execution environment(tee).\nWe are also using envio's HyperIndex to index blockchain data.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bt607/screenshots/089dc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bt607/screenshots/6d9ju/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bt607/screenshots/vp1gs/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Vedant-asati/xmtp-chat",
        "link": "https://ethglobal.com/showcase/cipherconnect-bt607"
    },
    {
        "title": "BuildYourOwnedAgent",
        "brief_description": "BYOA is a no-code tool to create on-chain AI agents. From NPC in autonomous world that integrate with your game server, to customer service chatbots powered by LLM.",
        "long_description": "With drag and drop, you're able to customize and deploy your AI agent with prompts, different emotion expressions with generative AI, setup up game play strategy and integrate game servers. You can setup rules for AI to deterministically decide its action, such as selecting from a list of optionns or more complicated state machine. Such behaviours will be added onto the contract template to create a trustless, immutable contract when deployed. You can talk to each agent, powered by XMTP. One example is the NPC will send you a message when he steps on a poop \ud83d\udca9 in the game, and you can see she becomes angry on the on-chain avatar. It is also possible to configure external plugins such as chainlink function to integrate an external game server, to maximize use cases of agents. In the game demo, there is a Pok\u00e9mon-style garden where agents will walk around. Tte game mechanics is very simple that when human step on a stone, she gets angry and when the dog step on a bone, it gets happy.\nAll you need to do is to write on contract to request for movement, which they will decide according behaviour you configured on-chain -- such as always move up. Then the on-chain decision is send back to game server to progress the game and update contract status. This tool helps us to deploy on-chain AI agents with guardrails and trustless mechanisms easily. BYOA supports and deploying agents on mutliple EVM networks, namely we provide templates deployable for The no-code tool UI is created with react flow to enable simple drag & drop, connecting control nodes for agent similar to Retool or ComftyUI. We supports different contract agent teampltes and after configuring on tool the avatar, actions plans etc of agent, parameters will be passed to contract deployment and written on-chain. To create assets for various facial expression for different emotion, stable diffusion and Lora is used to pre-generate. For the game demo, there is a custom game server built with nestjs which will control the game state, e.g. position of characters, decorations and the map. With use of Chainlink functions, we allow on-chain NPCs to invoke our endpoint and create movement. Agent contract is registered as consumer of chainlink function. Thus after chainlink nodes invoke game API, result is written back to the smart contract. In our case, emotion of on-chain AI agent will be updated if our server find the character step on a poop. XMTP is used to communicate between user and agents. With a shadow inbox account, accounts also able to send XMTP message via our server.  An inbox account is created for each agent contract. Once XIP-44 is implemented, messages can be sent to/from contract account of Agent directly. Envio is used to listen to events from the agent contracts and update game state accordingly. To make the agent more autonomous, Lit action can be used so once user granted rights, server can programmably trigger trustless execution of contracts",
        "how_its_made": "BYOA supports and deploying agents on mutliple EVM networks, namely we provide templates deployable for The no-code tool UI is created with react flow to enable simple drag & drop, connecting control nodes for agent similar to Retool or ComftyUI. We supports different contract agent teampltes and after configuring on tool the avatar, actions plans etc of agent, parameters will be passed to contract deployment and written on-chain. To create assets for various facial expression for different emotion, stable diffusion and Lora is used to pre-generate. For the game demo, there is a custom game server built with nestjs which will control the game state, e.g. position of characters, decorations and the map. With use of Chainlink functions, we allow on-chain NPCs to invoke our endpoint and create movement. Agent contract is registered as consumer of chainlink function. Thus after chainlink nodes invoke game API, result is written back to the smart contract. In our case, emotion of on-chain AI agent will be updated if our server find the character step on a poop. XMTP is used to communicate between user and agents. With a shadow inbox account, accounts also able to send XMTP message via our server.  An inbox account is created for each agent contract. Once XIP-44 is implemented, messages can be sent to/from contract account of Agent directly. Envio is used to listen to events from the agent contracts and update game state accordingly. To make the agent more autonomous, Lit action can be used so once user granted rights, server can programmably trigger trustless execution of contracts",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/a4vb5/screenshots/svue7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a4vb5/screenshots/bmsu4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a4vb5/screenshots/pvebn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a4vb5/screenshots/c4nus/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a4vb5/screenshots/ti1of/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a4vb5/screenshots/3cohq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/debuggingfuture/byoa",
        "link": "https://ethglobal.com/showcase/buildyourownedagent-a4vb5"
    },
    {
        "title": "BuildYourOwnedAgent",
        "brief_description": "BYOA is a no-code tool to create on-chain AI agents. From NPC in autonomous world that integrate with your game server, to customer service chatbots powered by LLM.",
        "long_description": "With drag and drop, you're able to customize and deploy your AI agent with prompts, different emotion expressions with generative AI, setup up game play strategy and integrate game servers. You can setup rules for AI to deterministically decide its action, such as selecting from a list of optionns or more complicated state machine. Such behaviours will be added onto the contract template to create a trustless, immutable contract when deployed. You can talk to each agent, powered by XMTP. One example is the NPC will send you a message when he steps on a poop \ud83d\udca9 in the game, and you can see she becomes angry on the on-chain avatar. It is also possible to configure external plugins such as chainlink function to integrate an external game server, to maximize use cases of agents. In the game demo, there is a Pok\u00e9mon-style garden where agents will walk around. Tte game mechanics is very simple that when human step on a stone, she gets angry and when the dog step on a bone, it gets happy.\nAll you need to do is to write on contract to request for movement, which they will decide according behaviour you configured on-chain -- such as always move up. Then the on-chain decision is send back to game server to progress the game and update contract status. This tool helps us to deploy on-chain AI agents with guardrails and trustless mechanisms easily. BYOA supports and deploying agents on mutliple EVM networks, namely we provide templates deployable for The no-code tool UI is created with react flow to enable simple drag & drop, connecting control nodes for agent similar to Retool or ComftyUI. We supports different contract agent teampltes and after configuring on tool the avatar, actions plans etc of agent, parameters will be passed to contract deployment and written on-chain. To create assets for various facial expression for different emotion, stable diffusion and Lora is used to pre-generate. For the game demo, there is a custom game server built with nestjs which will control the game state, e.g. position of characters, decorations and the map. With use of Chainlink functions, we allow on-chain NPCs to invoke our endpoint and create movement. Agent contract is registered as consumer of chainlink function. Thus after chainlink nodes invoke game API, result is written back to the smart contract. In our case, emotion of on-chain AI agent will be updated if our server find the character step on a poop. XMTP is used to communicate between user and agents. With a shadow inbox account, accounts also able to send XMTP message via our server.  An inbox account is created for each agent contract. Once XIP-44 is implemented, messages can be sent to/from contract account of Agent directly. Envio is used to listen to events from the agent contracts and update game state accordingly. To make the agent more autonomous, Lit action can be used so once user granted rights, server can programmably trigger trustless execution of contracts",
        "how_its_made": "BYOA supports and deploying agents on mutliple EVM networks, namely we provide templates deployable for The no-code tool UI is created with react flow to enable simple drag & drop, connecting control nodes for agent similar to Retool or ComftyUI. We supports different contract agent teampltes and after configuring on tool the avatar, actions plans etc of agent, parameters will be passed to contract deployment and written on-chain. To create assets for various facial expression for different emotion, stable diffusion and Lora is used to pre-generate. For the game demo, there is a custom game server built with nestjs which will control the game state, e.g. position of characters, decorations and the map. With use of Chainlink functions, we allow on-chain NPCs to invoke our endpoint and create movement. Agent contract is registered as consumer of chainlink function. Thus after chainlink nodes invoke game API, result is written back to the smart contract. In our case, emotion of on-chain AI agent will be updated if our server find the character step on a poop. XMTP is used to communicate between user and agents. With a shadow inbox account, accounts also able to send XMTP message via our server.  An inbox account is created for each agent contract. Once XIP-44 is implemented, messages can be sent to/from contract account of Agent directly. Envio is used to listen to events from the agent contracts and update game state accordingly. To make the agent more autonomous, Lit action can be used so once user granted rights, server can programmably trigger trustless execution of contracts",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/a4vb5/screenshots/svue7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a4vb5/screenshots/bmsu4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a4vb5/screenshots/pvebn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a4vb5/screenshots/c4nus/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a4vb5/screenshots/ti1of/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a4vb5/screenshots/3cohq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/debuggingfuture/byoa",
        "link": "https://ethglobal.com/showcase/buildyourownedagent-a4vb5"
    },
    {
        "title": "FanPredix",
        "brief_description": "FanPredix is a decentralized, peer-to-peer prediction market platform designed specifically for sports events, leveraging team-specific Fan Tokens on the Chiliz blockchain.",
        "long_description": "FanPredix: Fan Token-Powered P2P Sports Prediction Market\nOverview FanPredix is a decentralized, peer-to-peer prediction market platform designed specifically for sports events, leveraging team-specific Fan Tokens on the Chiliz blockchain. It enables official team managers to create markets for their matches, allowing fans to participate using the team's Fan Tokens. This creates an engaging, team-centric betting experience while providing additional utility for Fan Tokens. Key Features Team-specific markets using Fan Tokens\nPeer-to-peer order matching system\nBack and lay betting options\nRisk-free protocol operation\nAutomated fee collection for platform sustainability Roles and Responsibilities Admin\nDeploy the FanPredix contract\nManage contract configuration (e.g., platform fees, minimum bet amounts)\nAdd official team addresses with TEAM_ROLE Team Manager (TEAM_ROLE)\nCreate official prediction markets for their events\nUpdate team information (name, Fan Token address, active status)\nResolve markets by proposing the final outcome Users (Fans)\nPlace back or lay orders on market outcomes using team-specific Fan Tokens\nCancel their own unmatched orders\nRedeem winnings after market resolution Fan Token Integration\nFan Tokens are at the core of FanPredix's functionality: Team Registration: Each team is associated with its specific Fan Token.\nMarket Creation: Team managers create markets using their team's Fan Token.\nBetting: Users place bets using the specified Fan Token for each market.\nWinnings: Profits are paid out in Fan Tokens.\nFuture Feature: Governance voting for dispute resolution using Fan Tokens. User Flow\nConnect Wallet: Users connect their wallet containing Fan Tokens to the FanPredix dApp.\nBrowse Markets: View available prediction markets created by official team managers.\nPlace Order: Choose an outcome, specify amount and odds, and place a back or lay order using the required Fan Tokens.\nOrder Matching: Orders are matched peer-to-peer based on compatible odds and amounts.\nMonitor: Track the progress of the event and the market.\nRedeem Winnings: If successful, claim winnings after market resolution, minus the platform fee. Team Manager Flow\nTeam Registration: Admin adds the team manager address with TEAM_ROLE.\nUpdate Team Info: Team manager can update team name, Fan Token address, and active status.\nCreate Market:\nSet event details: category, question, description, options\nDefine start and end times\nMonitor Market: Observe user participation.\nResolve Market: After the event concludes, propose the final outcome. Technical Implementation Key Functions\naddTeam: Add a new team with TEAM_ROLE (admin only)\nupdateTeam: Update team information (team manager only)\ncreateMarket: Create a new prediction market (TEAM_ROLE only)\nplaceOrder: Place a back or lay order on a specific outcome\ncancelOrder: Cancel an existing unmatched order\n_tryMatchOrder: Internal function to match compatible orders\nresolveMarket: Propose the final outcome of a market (TEAM_ROLE only)\nredeemWinnings: Claim winnings for successful bets Fund Flow\nOrder Placement: When a user places an order, the required Fan Tokens are transferred to the contract.\nOrder Matching: Upon successful matching, the contract holds the Fan Tokens from both parties.\nMarket Resolution: After the market is resolved by the team manager, winners can claim their winnings.\nPlatform Fee: A configurable percentage of each winning bet is deducted as a platform fee before payout.\nRefunds: Unmatched orders are automatically refunded when the market is resolved.\nPlatform Profitability\nFanPredix ensures sustainable operations through an automated fee collection mechanism: A small, configurable percentage fee is deducted from winning bets.\nFees are collected at the time of winning redemption, ensuring the protocol never holds liability.\nCollected fees are sent to a designated treasury address for platform maintenance and development.\nSecurity Considerations\nRole-based access control (RBAC) for admin and team manager functions\nTime-based checks to prevent actions on expired or invalid markets\nCareful handling of Fan Token transfers and storage\nNo protocol liability, as all bets are peer-to-peer and fees are collected from winnings\nFuture Enhancements\nImplementation of a governance voting system for dispute resolution using Fan Tokens\nIntegration with Chiliz blockchain for real-time sports data feeds\nEnhanced analytics and reporting for users and team managers\nMulti-language support for global accessibility Smart Contract: https://github.com/pratikasr/FanPredix\nFrontend Dapp: https://github.com/pratikasr/fanpredix-frontend\nDeployment on chiliz testnet: https://testnet.chiliscan.com/address/0x239EDd859C51b8b7ac88F55Eed96F380F0bD816d\nFanToken used in project: https://testnet.chiliscan.com/token/0x96808b9fbA6301e31BfD2dc4EA98fF0ed91fA6c5 How it's made\nFanPredix is a decentralized sports prediction platform that leverages blockchain technology to create a transparent and engaging ecosystem for sports fans. Here's a detailed breakdown of how we built this project: Smart Contract (Backend)\nTechnologies Used:\nSolidity 0.8.0+\nOpenZeppelin Contracts\nHardhat development environment\nImplementation Details:\nContract Structure: We developed a single main contract FanPredix that inherits from OpenZeppelin's AccessControl. This allows for role-based access control, crucial for differentiating between admins, team managers, and regular users. Data Models: We implemented complex data structures like Team, Market, Order, and Bet to represent the core entities of our prediction market system. These structures are stored efficiently using mappings to optimize gas costs. Market Creation and Management: Team managers can create markets using the createMarket function. We implemented checks to ensure only authorized team managers can create markets for their teams. Order Matching System: We developed a peer-to-peer order matching system within the placeOrder function. The _tryMatchOrder internal function attempts to match new orders with existing opposite orders, creating bets when matches are found. Token Integration: We integrated ERC20 token functionality to handle Fan Tokens. The contract interacts with these tokens for placing orders and redeeming winnings, ensuring a seamless token economy within the platform. Market Resolution: We implemented a secure market resolution process where only authorized team managers can resolve their markets. The resolveMarket function updates the market status and sets the winning outcome. Winnings Redemption: Users can redeem their winnings using the redeemWinnings function, which calculates the payout based on the resolved market outcome and transfers the appropriate amount of Fan Tokens. Platform Fee Mechanism: We incorporated a platform fee system where a configurable percentage of winnings is sent to a treasury address, ensuring the sustainability of the platform. Notable Challenges:\nImplementing an efficient order matching system while considering gas optimization was particularly challenging. We had to carefully balance between on-chain and off-chain operations to ensure a smooth user experience without excessive gas costs.\nEnsuring the security and integrity of the market resolution process required careful consideration of access controls and timing mechanisms.\nFrontend Application\nTechnologies Used:\nNext.js 13 (React framework)\nTypeScript\nTailwind CSS for styling\nFramer Motion for animations\nethers.js for Ethereum interaction\nReact Icons for UI icons\nImplementation Details:\nResponsive Design: We used Tailwind CSS to create a fully responsive design that works seamlessly across desktop and mobile devices. The use of Tailwind's utility classes allowed for rapid development and consistent styling. Interactive UI: Framer Motion was extensively used to create smooth animations and transitions, enhancing the overall user experience. This is particularly evident in the header component and the team manager page. Wallet Integration: We implemented MetaMask wallet connection functionality in the header component. This allows users to connect their Ethereum wallets and interact with the smart contract seamlessly. Dynamic Routing: Next.js's dynamic routing capabilities were utilized to create team-specific and market-specific pages. This allows for a clean URL structure and efficient navigation. State Management: We used React's built-in hooks (useState, useEffect) for local state management. For more complex state management needs, we implemented custom hooks to encapsulate logic and promote reusability. Data Visualization: We integrated chart.js through react-chartjs-2 to create interactive and visually appealing charts for market performance and fan engagement statistics. Modular Component Structure: The application is built using a modular component structure, with reusable components like the Header, Footer, and various card components. This approach enhances maintainability and allows for easy scaling of the application. Server-Side Rendering: We leveraged Next.js's server-side rendering capabilities to improve initial load times and SEO performance. Notable Challenges:\nImplementing a seamless wallet connection experience while handling different connection states and error scenarios required careful consideration of user flows and error handling.\nCreating an intuitive and engaging UI for complex betting mechanisms, especially for the order placement and market resolution processes, required multiple iterations and user feedback.\nPartner Technologies:\nWe utilized OpenZeppelin's battle-tested smart contract libraries to ensure the security and reliability of our smart contract. This significantly reduced the risk of common vulnerabilities and allowed us to focus on implementing our core business logic.\nThe integration of MetaMask provided a secure and widely adopted solution for wallet management and transaction signing, enhancing the trustworthiness of our platform.\nBy combining these technologies and approaches, we were able to create a robust, user-friendly, and highly interactive decentralized sports prediction platform that offers a unique and engaging experience for sports fans and crypto enthusiasts alike.",
        "how_its_made": "How it's made\nFanPredix is a decentralized sports prediction platform that leverages blockchain technology to create a transparent and engaging ecosystem for sports fans. Here's a detailed breakdown of how we built this project: Smart Contract (Backend)\nTechnologies Used:\nSolidity 0.8.0+\nOpenZeppelin Contracts\nHardhat development environment\nImplementation Details:\nContract Structure: We developed a single main contract FanPredix that inherits from OpenZeppelin's AccessControl. This allows for role-based access control, crucial for differentiating between admins, team managers, and regular users. Data Models: We implemented complex data structures like Team, Market, Order, and Bet to represent the core entities of our prediction market system. These structures are stored efficiently using mappings to optimize gas costs. Market Creation and Management: Team managers can create markets using the createMarket function. We implemented checks to ensure only authorized team managers can create markets for their teams. Order Matching System: We developed a peer-to-peer order matching system within the placeOrder function. The _tryMatchOrder internal function attempts to match new orders with existing opposite orders, creating bets when matches are found. Token Integration: We integrated ERC20 token functionality to handle Fan Tokens. The contract interacts with these tokens for placing orders and redeeming winnings, ensuring a seamless token economy within the platform. Market Resolution: We implemented a secure market resolution process where only authorized team managers can resolve their markets. The resolveMarket function updates the market status and sets the winning outcome. Winnings Redemption: Users can redeem their winnings using the redeemWinnings function, which calculates the payout based on the resolved market outcome and transfers the appropriate amount of Fan Tokens. Platform Fee Mechanism: We incorporated a platform fee system where a configurable percentage of winnings is sent to a treasury address, ensuring the sustainability of the platform. Notable Challenges:\nImplementing an efficient order matching system while considering gas optimization was particularly challenging. We had to carefully balance between on-chain and off-chain operations to ensure a smooth user experience without excessive gas costs.\nEnsuring the security and integrity of the market resolution process required careful consideration of access controls and timing mechanisms.\nFrontend Application\nTechnologies Used:\nNext.js 13 (React framework)\nTypeScript\nTailwind CSS for styling\nFramer Motion for animations\nethers.js for Ethereum interaction\nReact Icons for UI icons\nImplementation Details:\nResponsive Design: We used Tailwind CSS to create a fully responsive design that works seamlessly across desktop and mobile devices. The use of Tailwind's utility classes allowed for rapid development and consistent styling. Interactive UI: Framer Motion was extensively used to create smooth animations and transitions, enhancing the overall user experience. This is particularly evident in the header component and the team manager page. Wallet Integration: We implemented MetaMask wallet connection functionality in the header component. This allows users to connect their Ethereum wallets and interact with the smart contract seamlessly. Dynamic Routing: Next.js's dynamic routing capabilities were utilized to create team-specific and market-specific pages. This allows for a clean URL structure and efficient navigation. State Management: We used React's built-in hooks (useState, useEffect) for local state management. For more complex state management needs, we implemented custom hooks to encapsulate logic and promote reusability. Data Visualization: We integrated chart.js through react-chartjs-2 to create interactive and visually appealing charts for market performance and fan engagement statistics. Modular Component Structure: The application is built using a modular component structure, with reusable components like the Header, Footer, and various card components. This approach enhances maintainability and allows for easy scaling of the application. Server-Side Rendering: We leveraged Next.js's server-side rendering capabilities to improve initial load times and SEO performance. Notable Challenges:\nImplementing a seamless wallet connection experience while handling different connection states and error scenarios required careful consideration of user flows and error handling.\nCreating an intuitive and engaging UI for complex betting mechanisms, especially for the order placement and market resolution processes, required multiple iterations and user feedback.\nPartner Technologies:\nWe utilized OpenZeppelin's battle-tested smart contract libraries to ensure the security and reliability of our smart contract. This significantly reduced the risk of common vulnerabilities and allowed us to focus on implementing our core business logic.\nThe integration of MetaMask provided a secure and widely adopted solution for wallet management and transaction signing, enhancing the trustworthiness of our platform.\nBy combining these technologies and approaches, we were able to create a robust, user-friendly, and highly interactive decentralized sports prediction platform that offers a unique and engaging experience for sports fans and crypto enthusiasts alike.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rhuz3/screenshots/b0eum/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rhuz3/screenshots/vs2br/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rhuz3/screenshots/v0nrr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rhuz3/screenshots/gxd28/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rhuz3/screenshots/k9pb5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rhuz3/screenshots/ki8nj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/pratikasr/fanpredix-frontend",
        "link": "https://ethglobal.com/showcase/fanpredix-rhuz3"
    },
    {
        "title": "Kuma",
        "brief_description": "An All-in-one App that let you abstract all the difficulties of the blockchain",
        "long_description": "Onboarding new users into blockchain applications is a challenge. Current solutions revolves around mnemonics that need to be stored to recover accounts on users wallets, effectively introducing security risks. By using passkeys to control accounts, we abstract away the need for users to store mnemonics and we allow users to use a familiar interface to control their accounts (biometric authentication) in one click UX. Our wallet is meant to be an implementation of the ERC-4337 standard, that allow users to have an account in the form of a smart contract. In this case, we use passkeys to let users control their account thanks to the onchain P256 signature verification developed by Daimo. Passkeys are a new way to authenticate users, that are more secure than passwords, and more user friendly than mnemonics. Our aim is to make blockchain applications more accessible to the general public, and we believe that passkeys are a great way to do so. Our UI strives in making it easy for users to create, retrieve existing accounts and sign transactions via Passkeys. As a user, all notion of passkeys are abstracted and you just need to remember a simple username to access your account. While being built with NextJS for ease of development, our wallet is designed to be easy to use on mobile. Grab your phone, proceed to a biometric authentication, and you can start using your account in a few seconds.  When you create an account, a passkey is generated and stored in your device or your password manager. This passkey is tied to an id. This is worth noting that the passkey is never managed by the wallet itself, the wallet only uses the browser API to interact with it. Basically, the wallet asks for signatures and your device/password manager handles the rest. This is a very important security feature, as it means that the wallet never has access to your passkey, and cannot be compromised to steal it. Once the passkey is generated, the passkeys browser API returns a public key and an id. These public information are stored onchain and used to identify your account. The Smart Account is the contract implementing the ERC-4337 standard. Its address is deterministically computed from the public key of the user. This contract implements all the logic to verify signatures, effectively allowing the user to operate onchain actions thanks to their passkey. The contract is not deployed when the passkey is generated to avoid paying huge gas fees for a contract that might never be used. Instead, it is deployed when the user first interacts with the contract. ",
        "how_its_made": "When you create an account, a passkey is generated and stored in your device or your password manager. This passkey is tied to an id. This is worth noting that the passkey is never managed by the wallet itself, the wallet only uses the browser API to interact with it. Basically, the wallet asks for signatures and your device/password manager handles the rest. This is a very important security feature, as it means that the wallet never has access to your passkey, and cannot be compromised to steal it. Once the passkey is generated, the passkeys browser API returns a public key and an id. These public information are stored onchain and used to identify your account. The Smart Account is the contract implementing the ERC-4337 standard. Its address is deterministically computed from the public key of the user. This contract implements all the logic to verify signatures, effectively allowing the user to operate onchain actions thanks to their passkey. The contract is not deployed when the passkey is generated to avoid paying huge gas fees for a contract that might never be used. Instead, it is deployed when the user first interacts with the contract. ",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/trh21/screenshots/0hozx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/trh21/screenshots/h5zis/default.jpg",
            "https://ethglobal.b-cdn.net/projects/trh21/screenshots/x9mq7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/trh21/screenshots/d79k7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/trh21/screenshots/ye1ks/default.jpg"
        ],
        "live_demo": "https://kuma-hedera.vercel.app/",
        "source_code": "https://github.com/Shimadakunn/Kuma-Hedera",
        "link": "https://ethglobal.com/showcase/kuma-trh21"
    },
    {
        "title": "KittyCombat",
        "brief_description": "KittyCombat is a GameFi based project which involves accumulation of points via the combat battle between cats and viruses",
        "long_description": "KittyCombat is a GameFi based project which involves accumulation of points via the combat between cats and viruses.\nThe user can mint a cat or a virus, which is minted randomly using Chainlink VRF with 80% probability for a Cat and 20% for a virus.\nThe virus can infect cats, in that case the cat has to be bridged to a selected chain on the basis of traits of virus and some random basis where it is locked for sometime to heal from the virus.\nThere is also a role of Angel Cat, where the cats whose 9 lives are finished turns into an angel cat.\nAngel cat protects normal cats from virus.\nAll of these executions generates an ERC20 token to the user which will can be used as bid token or raffle token in pool. Testnet Deployment\nAvalanche Fuji: 0xF1470EF915C5FB9095c5AAdB2d44964ab63c8f96\nArbitrum Sepolia: 0xafB70ecc8EE4b38047ADE26d0212ee4FC440d869 We have used openzeppelin ERC721 token.\nERC721 represents the roles for the NFT, it can be a cat, virus or an angel cat.\nWe have used Chainlink VRF to get a random number to decide various minting factors and traits for the roles.\nWe have used Chainlink CCIP to bridge the cat NFT from one chain to a selected chain where it will be healed.",
        "how_its_made": "We have used openzeppelin ERC721 token.\nERC721 represents the roles for the NFT, it can be a cat, virus or an angel cat.\nWe have used Chainlink VRF to get a random number to decide various minting factors and traits for the roles.\nWe have used Chainlink CCIP to bridge the cat NFT from one chain to a selected chain where it will be healed.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pkk4h/screenshots/5xqte/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pkk4h/screenshots/jwwn5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pkk4h/screenshots/7y3xi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pkk4h/screenshots/hzodk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pkk4h/screenshots/jhem1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pkk4h/screenshots/bown7/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shikhar229169/Kitty-Kombat",
        "link": "https://ethglobal.com/showcase/kittycombat-pkk4h"
    },
    {
        "title": "LemonAds",
        "brief_description": "AdTech platform allowing decentralized ad management for publishers and advertisers. Manage ad parcels, set bids, track conversions, and automate payments with blockchain transparency, all while easily integrating ads into your site.",
        "long_description": "Lemonads is a decentralized advertising platform designed to give both publishers and advertisers full control, transparency, and efficiency in the Web3 space. By leveraging blockchain tech, we\u2019ve created a system where publishers can manage ad spaces\u2014called \u201cad parcels\u201d\u2014on their websites via smart contracts on Ethereum. Core Features: Ad Parcel Management Publishers can set up ad parcels on their websites, each with a unique ID and customizable traits like size, fonts, and placement. This data is stored on IPFS, ensuring decentralization and transparency. They can then rent out these ad parcels to advertisers using automated smart contracts. Advertiser Flexibility Advertisers (a.k.a. renters) can place bids on available ad parcels, competing to outbid others for prime ad spots. Once they\u2019ve placed the highest bid, they can upload their ad content\u2014images, links, descriptions\u2014directly to IPFS, ensuring transparency and security. To maintain content quality, all ad uploads go through moderation to prevent inappropriate images. This decentralized approach makes the entire process auditable and ensures the integrity of the ads displayed. Bidding System The platform features live bidding, where advertisers compete to place ads in prime spots. Payments are locked into smart contracts, ensuring a smooth transaction flow. If an advertiser\u2019s budget runs out, the parcel is automatically released, and the publisher gets notified. Automated Payments & Tracking Leveraging Chainlink and Ethereum smart contracts, the platform automates payments based on ad performance metrics like clicks and interactions. Conversions\u2014actions taken after clicking an ad\u2014are tracked via unique query parameters, and notifications are sent when budgets get low, so advertisers can top up on time. Conversion Tracking Advertisers can track conversions (purchases, signups, etc.) through a unique click ID that\u2019s passed when users interact with ads. This allows for a high level of transparency and measurable results for every ad campaign. Full Transparency Every transaction\u2014from ad creation, bidding, to payments\u2014is handled by Ethereum smart contracts. There\u2019s no middleman, reducing fraud and ensuring both publishers and advertisers know exactly where their funds are going. Easy Website Integration Publishers can quickly embed ad parcels on their site with a simple copy-paste code snippet. This ensures the ad space is live and showing the most up-to-date content seamlessly. Use Cases: For Publishers: Monetize website traffic without the hassle. Publishers can manage their ad parcels, set bids, and adjust parcel details while having full transparency. For Advertisers: Gain full control over where your ads appear, track performance in real-time, and automate payments. If a campaign is successful, the platform automatically handles everything from clicks to conversions, with detailed reporting. This project is built with a mix of Web3 technologies and traditional web development tools.\nThe smart contracts are written in Solidity using Foundry and deployed on Base Sepolia testnet, handling the bidding, ad parcel management, and payouts in a decentralized manner.\nWe used Chainlink Functions for automated off-chain data aggregation, enabling features like click tracking and automated notifications for renters running low on budget. On the front end, it\u2019s a Next.js app with React for the UI, utilizing TypeScript for type safety. Ad content is stored on IPFS using Pinata. Content moderation is powered by AWS Rekognition, automatically flagging and blocking inappropriate images before they\u2019re uploaded. The platform also integrates Firebase for user authentication and storing additional metadata. The UI features a dynamic ad parcel data table with interactive tools for publishers and advertisers, including budget management and embed codes for easy integration into websites. For payments, we use a combination of ETH and smart contract-based budget tracking to ensure transparency between publishers and renters. One notable hack is our use of Chainlink to trigger off-chain email notifications to advertisers when their funds are low, which uses a combination of our main smart contract, Chainlink functions and an API endpoint that uses nodemailer with uuids to 'reduce' the DON calls to one single email sent per notification required.",
        "how_its_made": "This project is built with a mix of Web3 technologies and traditional web development tools.\nThe smart contracts are written in Solidity using Foundry and deployed on Base Sepolia testnet, handling the bidding, ad parcel management, and payouts in a decentralized manner.\nWe used Chainlink Functions for automated off-chain data aggregation, enabling features like click tracking and automated notifications for renters running low on budget. On the front end, it\u2019s a Next.js app with React for the UI, utilizing TypeScript for type safety. Ad content is stored on IPFS using Pinata. Content moderation is powered by AWS Rekognition, automatically flagging and blocking inappropriate images before they\u2019re uploaded. The platform also integrates Firebase for user authentication and storing additional metadata. The UI features a dynamic ad parcel data table with interactive tools for publishers and advertisers, including budget management and embed codes for easy integration into websites. For payments, we use a combination of ETH and smart contract-based budget tracking to ensure transparency between publishers and renters. One notable hack is our use of Chainlink to trigger off-chain email notifications to advertisers when their funds are low, which uses a combination of our main smart contract, Chainlink functions and an API endpoint that uses nodemailer with uuids to 'reduce' the DON calls to one single email sent per notification required.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mo7gg/screenshots/10eng/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mo7gg/screenshots/gjp3t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mo7gg/screenshots/png2n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mo7gg/screenshots/ureog/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mo7gg/screenshots/1gn0w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mo7gg/screenshots/packd/default.jpg"
        ],
        "live_demo": "https://lemonads.vercel.app/",
        "source_code": "https://github.com/ethglobal",
        "link": "https://ethglobal.com/showcase/lemonads-mo7gg"
    },
    {
        "title": "2048 ZKNoid",
        "brief_description": "A 2048 game written in Protokit with the ZKNoid SDK for Mina that is almost ready for merging into the ZKNoid official repo!",
        "long_description": "A 2048 game written in Protokit with the ZKNoid SDK for Mina that is almost ready for merging into the ZKNoid official repo The 2048 game is often my go-to choice when exploring new blockchain gaming technologies because of its simplicity. However, ZKNoid currently lacks a 2048 game, pushing new users to engage with more complex games that might deter them from trying the product altogether. This highlights the IMPORTANCE of including the 2048 game in the platform. I have developed the UI for the single-player mode and a runtime module that supports both single and multiplayer modes for 2048 game on Mina & ZKNoid. The single-player mode follows the standard 2048 game rules. However, in multiplayer mode, I have introduced a new set of rules where the game ends when a player runs out of moves. In this mode, each player is responsible for placing new tiles on the opponent's board, aiming to fill the opponent's board as quickly as possible. I utilized the session key feature of ZKNoid to enhance latency and overall gaming experience, incorporating lazy submission to Protokit in the background. A session key is assigned to the player's public key at the start of the game. For the UI and runtime module development, I forked the ZKNoid repository, which provides various utilities for implementing a multiplayer matchmaking system, Mina token bridging, a session key system, and more. I developed a runtime module for both single-player and multiplayer modes of the 2048 game. For the UI, I focused on the single-player implementation, which includes session key integration. I utilized the session key feature of ZKNoid to enhance latency and improve the overall gaming experience, leveraging lazy submission to Protokit in the background. A session key is assigned to the player's public key at the start of the game, optimizing performance throughout the gameplay. Note that 2048 is not too simple. It involves nested loops and the challenge of a non-constant loop, which isn't directly supported in o1js.",
        "how_its_made": "For the UI and runtime module development, I forked the ZKNoid repository, which provides various utilities for implementing a multiplayer matchmaking system, Mina token bridging, a session key system, and more. I developed a runtime module for both single-player and multiplayer modes of the 2048 game. For the UI, I focused on the single-player implementation, which includes session key integration. I utilized the session key feature of ZKNoid to enhance latency and improve the overall gaming experience, leveraging lazy submission to Protokit in the background. A session key is assigned to the player's public key at the start of the game, optimizing performance throughout the gameplay. Note that 2048 is not too simple. It involves nested loops and the challenge of a non-constant loop, which isn't directly supported in o1js.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/f6sir/screenshots/hw4d6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f6sir/screenshots/o6770/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f6sir/screenshots/3jkgp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/f6sir/screenshots/x1rd7/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Chomtana/2048-zknoid",
        "link": "https://ethglobal.com/showcase/2048-zknoid-f6sir"
    },
    {
        "title": "Yamata/Maroon",
        "brief_description": "The Joy of CEX with the Security of DEX, smooth exchanging of assets like on CEX without scarifying your assets custody.",
        "long_description": "Completely Self Custodial with Decentralised Settlement\nEliminate counterparty risk with complete control of your trading and assets at all times.\nWe combined a few open source technologies and, as a result, created a Hybrid cryptocurrency exchange, which is very pleasant to use for the end user without sacrificing the security of users' assets. Combined 0x protocol on-chain settlement, Safe Core AA wallet abstractions and order book build using sequencers.\nIt can run on any EVM chain, and with combined Wormhole bridging integration, you could also execute cross-blockchain trades.\nPartnered with Coinbase Base, Monad and Dymension.\nGuardians working as validation nodes, proving the order book works as designed.",
        "how_its_made": "Combined 0x protocol on-chain settlement, Safe Core AA wallet abstractions and order book build using sequencers.\nIt can run on any EVM chain, and with combined Wormhole bridging integration, you could also execute cross-blockchain trades.\nPartnered with Coinbase Base, Monad and Dymension.\nGuardians working as validation nodes, proving the order book works as designed.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/m5ti7/screenshots/ctxgz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m5ti7/screenshots/tdcz2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m5ti7/screenshots/bhyjb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MarronLab/exchange-app-backgrop",
        "link": "https://ethglobal.com/showcase/yamata-maroon-m5ti7"
    },
    {
        "title": "MoMint",
        "brief_description": "NFT Marketplace for Influencers to Mint their Social Media Posts into NFTs",
        "long_description": "MoMint is an NFT platform that enables influencers and creators to seamlessly mint their social media posts as NFTs. By integrating with popular platforms like Instagram and Twitter, creators can monetize their moments, turning their photos, videos, and memories into valuable, tradeable digital assets. Fans can purchase these NFTs and, depending on the creator's set use cases, gain access to exclusive content, events, and NFT-gated experiences such as meet-ups, concerts, and special offers. MoMint is built using a combination of React, Thirdweb SDK, Web3Auth, Chainlink, Lit Protocol.\n1.\u2060 \u2060Frontend: Built using React.js and styled with Tailwind CSS for modern, responsive designs. 2.\u2060 \u2060Backend:",
        "how_its_made": "MoMint is built using a combination of React, Thirdweb SDK, Web3Auth, Chainlink, Lit Protocol.\n1.\u2060 \u2060Frontend: Built using React.js and styled with Tailwind CSS for modern, responsive designs. 2.\u2060 \u2060Backend:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1s895/screenshots/hfe0n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1s895/screenshots/jdw51/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1s895/screenshots/og36s/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shashanka2a/momint-hack/",
        "link": "https://ethglobal.com/showcase/momint-1s895"
    },
    {
        "title": "Racinefi",
        "brief_description": "RacineFi is a platform offering various DeFi vaults that maximize returns by managing liquidity across multiple DeFi platforms. It dynamically reallocates assets and reinvests rewards, helping users grow their investments efficiently.",
        "long_description": "RacineFi is a decentralized, automated vault platform that helps users maximize returns by managing liquidity across decentralized exchanges (DEXs) and yield farms. With dynamic asset reallocation and auto-reinvestment of rewards, RacineFi allows users to grow their investments without any platform fees. Deposit & Withdrawal Process Deposits: Users deposit assets like WRBTC, RUSDT, or RIF into the vault and receive shares that represent their portion of the vault\u2019s liquidity and earnings. Withdrawals: Users redeem their shares to withdraw funds. The vault calculates the equivalent amount in the deposited asset and transfers it to the user while burning the redeemed shares. Dynamic Liquidity Rebalancing Rebalancing Cycle: Every 6 hours, the rebalancer triggers the moveticks function to adjust liquidity within the same pool and optimize returns. Automated Positioning: Once triggered, the smart contract automatically identifies and opens the best price range for the main liquidity position. It also creates a single-sided position as a limit order on either the left or right side, based on market conditions, to help manage impermanent loss. Automated Rewards Management Earning Rewards: RacineFi earns rewards from providing liquidity in DEXs and yield farms. Harvest and Reinvestment: During harvest, the vault claims all accrued fees from the current liquidity range and redeposits them into both the main and alternate positions, ensuring continued compounding growth. Ideal For Passive Investors: RacineFi is perfect for users who want to maximize their returns without the need for active management of their liquidity positions. Cost-Conscious Users: With zero platform fees, users keep 100% of their earnings, making RacineFi an attractive option for those looking to avoid additional management costs. Current Yield Overview As of September 2024, the vault supports liquidity pools such as: Contract addresses Technology Stack Future Expansion",
        "how_its_made": "Technology Stack Future Expansion",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h66ht/screenshots/rs30c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h66ht/screenshots/5p8vf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h66ht/screenshots/e4f5w/default.jpg"
        ],
        "live_demo": "https://racinefi.vercel.app/",
        "source_code": "https://github.com/Vaults-DEFI/CLM-Vault",
        "link": "https://ethglobal.com/showcase/racinefi-h66ht"
    },
    {
        "title": "Eth GovOps",
        "brief_description": "Developer tools to track and manage incidents, auctions, documentation, workforce, work orders, and inventory in government departments on Ethereum. The platform leverages CCIP, Sign & Lit Protocol, Avail's P2P & Layer Zero network to ensure secure records & efficient operations",
        "long_description": "The Eth GovOps (Ethereum Government Operations) Project is a robust decentralized application (DApp) that enables seamless tracking and management of various business operations, including incidents, auctions, documentation, workforce management, work orders, and inventory, all on the Ethereum blockchain. This platform is designed to enhance efficiency, transparency, and security by leveraging several cutting-edge blockchain protocols and technologies like RootStock and Nethermind. Key Components Incident Management\nThe platform offers tools to efficiently track, report, and manage incidents, such as workforce issues, vehicle breakdowns, or equipment malfunctions. All incident records are stored immutably on the blockchain, ensuring accuracy and tamper-proof logs. Auction Management\nThe project integrates a decentralized auction system for procuring goods, equipment, or services. Auctions are executed transparently, with all bids and transactions recorded on-chain. The use of blockchain eliminates fraud, ensuring fairness in the bidding process. Document Management\nSecure documentation is a critical aspect of the Ethereum Operations Project. Documents are stored and validated using Sign Protocol, ensuring they are digitally signed, tamper-resistant, and auditable. Lit Protocol enables additional privacy and access control, allowing documents to be encrypted and shared selectively with authorized parties. Workforce and HR Management\nWorkforce management includes tools to handle employee records, payroll, and other HR-related tasks. With decentralized identities and secure document storage, the system ensures that personal data remains private, while maintaining transparent employment contracts and work logs. Work Order Tracking\nWork orders, whether they pertain to routine maintenance, repair tasks, or procurement, are securely generated and tracked. All associated costs, timelines, and worker assignments are recorded, and the system ensures accountability by tracking progress and completion status on-chain. Inventory Management\nThe platform includes inventory tracking, allowing users to manage assets, equipment, and materials efficiently. From the acquisition of items to their deployment or disposal, every transaction is securely logged on the blockchain, providing real-time visibility into inventory status. Security and Efficiency Benefits of Ethereum Operations Project Streamlined Operations: The platform simplifies managing incidents, auctions, work orders, and inventory by providing a single, secure, and efficient interface for tracking and executing tasks. Enhanced Security: Utilizing blockchain ensures that all data and transactions are secure, transparent, and tamper-proof, reducing the risk of fraud and ensuring data integrity. Interoperability: The integration of CCIP and Layer Zero provides cross-chain capabilities, enabling operations to interact across various blockchain ecosystems, improving scalability and versatility. Reduced Costs: By eliminating intermediaries and automating tasks through smart contracts, the platform reduces operational costs, particularly in areas like procurement and document management. Scalability and Flexibility: With the support of Avail\u2019s P2P network and other advanced technologies, the system can easily scale to accommodate growing operational needs, from handling large inventories to managing multiple auctions simultaneously. Advanced Integrations: The Eth GovOps project is a decentralized application (DApp) designed to streamline and secure business and government operations on the Ethereum blockchain. It integrates key technologies like Avail, Sign Protocol, Chainlink\u2019s CCIP, Lit Protocol, and Layer Zero, RootStock and Nethermind enabling secure cross-chain communication, encrypted document management, and decentralized identity verification. It leverages advanced blockchain technologies, such as RootStock and Nethermind (Starknet), to ensure secure, efficient, and transparent handling of incidents, auctions, work orders, and documentation. Implementation Details of Core Blockchain Technologies We have implemented a ZK Attestation Verifier with Schema Hooks using Sign Protocol's Schema Hooks and ZK Work Order Listing Verifier dapp, enabling builders to extend the core attestation protocol. This feature adds custom Work Order based Solidity logic, which is triggered each time an attestation is created or revoked for Contractor, Work Order and Contract Work schema. The Schema Hooks is utilized for whitelisting Work Order attesters, receiving Work Invoice and payments, and executing Work Order Listing Verifier application logic. 3a. Cross-Chain Communication via CCIP\nThe Eth Operations DApp utilizes Chainlink's Cross-Chain Interoperability Protocol (CCIP) to enable seamless communication and data transfer for work orders for 4 personas (contractor, staff, admin and dispatcher) between Ethereum, Optimism, Polygon and key blockchain networks like Avalanche, ensuring that data, assets, and smart contract functions can be securely shared and executed across multiple chains. b. RootStock: Our RootStock integration is a key component of the Work Order Management DApp module, which includes a ZK Attestation Verifier with Schema Hooks using Sign Protocol\u2019s Schema Hooks. This allows builders to extend the core attestation protocol via the RootStock Starter Kit.\nWe are also utilizing Lit Protocol to securely encrypt key identity documents in India, such as Aadhaar (national ID), PAN (taxation card), driving licenses, and passports. The encryption ensures secure document handling during user registration, with decryption occurring after wallet signing using Lit protocol through the RootStock Starter Kit.\nPlease visit demo video with RootStock implementation at https://drive.google.com/drive/u/1/folders/1CLTBAA7UJuLCt5TzDGDY94reiWPCX4an\nAs the leading and oldest Bitcoin Layer 2 blockchain, RootStock is fully EVM-compatible, enabling seamless integration of Ethereum's scalability and programmability. We are integrating Avail\u2019s Light Client features with the zk Work Order wallet that seamlessly works across key Ethereum L2 Blockchains and leverages Zero Knowledge Proofs for Crypto-transactions and Identity proofs. Android version at https://github.com/seetadev/Eth-Operations/tree/main/eth-operations-avail-module/avail-work-order-manager Avail network optimizes the performance of the platform, ensuring that data is easily retrievable and verifiable. We are also developing custom rollapps with Avail DA and tools to enable no code, low code analytics tooling using an open source analytics and visualization tool, namely Avail XLS, which enables tabulation, organization, collaboration, visualization, graphing and charting. Layer Zero Transaction hash: https://testnet.layerzeroscan.com/tx/0xb197ee7bad22ba4eec1c4094e844ec8dc7b177f120cc3afe2a555682f607b9e9 Demo Video (screencasts): https://drive.google.com/drive/u/1/folders/1EB6Fao9D1cc4uFVGXShesSy2rjkgNSvk Benefits: Enable hyperlocal medical service and delivery information.\nEnable QR code based blockchain payments at key sites with support for key Ethereum based blockchain platforms.\nEnhance safety through smart incentivization of incident reporting by employees and logistics providers. Additionally, the Eth Operations DApp uses verified medical incident data to mint NFTs on Voyager, which store an image and related insurance metadata. This process leverages Starknet and Argent Mobile to ensure secure and decentralized storage of medical records in the form of NFTs.",
        "how_its_made": "The Eth GovOps project is a decentralized application (DApp) designed to streamline and secure business and government operations on the Ethereum blockchain. It integrates key technologies like Avail, Sign Protocol, Chainlink\u2019s CCIP, Lit Protocol, and Layer Zero, RootStock and Nethermind enabling secure cross-chain communication, encrypted document management, and decentralized identity verification. It leverages advanced blockchain technologies, such as RootStock and Nethermind (Starknet), to ensure secure, efficient, and transparent handling of incidents, auctions, work orders, and documentation. Implementation Details of Core Blockchain Technologies We have implemented a ZK Attestation Verifier with Schema Hooks using Sign Protocol's Schema Hooks and ZK Work Order Listing Verifier dapp, enabling builders to extend the core attestation protocol. This feature adds custom Work Order based Solidity logic, which is triggered each time an attestation is created or revoked for Contractor, Work Order and Contract Work schema. The Schema Hooks is utilized for whitelisting Work Order attesters, receiving Work Invoice and payments, and executing Work Order Listing Verifier application logic. 3a. Cross-Chain Communication via CCIP\nThe Eth Operations DApp utilizes Chainlink's Cross-Chain Interoperability Protocol (CCIP) to enable seamless communication and data transfer for work orders for 4 personas (contractor, staff, admin and dispatcher) between Ethereum, Optimism, Polygon and key blockchain networks like Avalanche, ensuring that data, assets, and smart contract functions can be securely shared and executed across multiple chains. b. RootStock: Our RootStock integration is a key component of the Work Order Management DApp module, which includes a ZK Attestation Verifier with Schema Hooks using Sign Protocol\u2019s Schema Hooks. This allows builders to extend the core attestation protocol via the RootStock Starter Kit.\nWe are also utilizing Lit Protocol to securely encrypt key identity documents in India, such as Aadhaar (national ID), PAN (taxation card), driving licenses, and passports. The encryption ensures secure document handling during user registration, with decryption occurring after wallet signing using Lit protocol through the RootStock Starter Kit.\nPlease visit demo video with RootStock implementation at https://drive.google.com/drive/u/1/folders/1CLTBAA7UJuLCt5TzDGDY94reiWPCX4an\nAs the leading and oldest Bitcoin Layer 2 blockchain, RootStock is fully EVM-compatible, enabling seamless integration of Ethereum's scalability and programmability. We are integrating Avail\u2019s Light Client features with the zk Work Order wallet that seamlessly works across key Ethereum L2 Blockchains and leverages Zero Knowledge Proofs for Crypto-transactions and Identity proofs. Android version at https://github.com/seetadev/Eth-Operations/tree/main/eth-operations-avail-module/avail-work-order-manager Avail network optimizes the performance of the platform, ensuring that data is easily retrievable and verifiable. We are also developing custom rollapps with Avail DA and tools to enable no code, low code analytics tooling using an open source analytics and visualization tool, namely Avail XLS, which enables tabulation, organization, collaboration, visualization, graphing and charting. Layer Zero Transaction hash: https://testnet.layerzeroscan.com/tx/0xb197ee7bad22ba4eec1c4094e844ec8dc7b177f120cc3afe2a555682f607b9e9 Demo Video (screencasts): https://drive.google.com/drive/u/1/folders/1EB6Fao9D1cc4uFVGXShesSy2rjkgNSvk Benefits: Enable hyperlocal medical service and delivery information.\nEnable QR code based blockchain payments at key sites with support for key Ethereum based blockchain platforms.\nEnhance safety through smart incentivization of incident reporting by employees and logistics providers. Additionally, the Eth Operations DApp uses verified medical incident data to mint NFTs on Voyager, which store an image and related insurance metadata. This process leverages Starknet and Argent Mobile to ensure secure and decentralized storage of medical records in the form of NFTs.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ufrbs/screenshots/mosfn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufrbs/screenshots/1yib1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufrbs/screenshots/fn27m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufrbs/screenshots/jn376/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufrbs/screenshots/gh3hn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufrbs/screenshots/gftt6/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/seetadev/Eth-Operations",
        "link": "https://ethglobal.com/showcase/eth-govops-ufrbs"
    },
    {
        "title": "Bubble Cap",
        "brief_description": "BubbleCap is a Decentralized fan meeting platform for baseball fans.",
        "long_description": "This project provides baseball fans with access to game schedules and chat features with players, as well as opportunities to participate in various exclusive events such as private fan meetings for token holders. Our project integrates blockchain technology into real-life applications. By utilizing blockchain-based cryptocurrency, transactions can be conducted without relying on the diverse payment systems of various countries, allowing fans from different countries to participate in the platform without spatial constraints. Additionally, since blockchain technology requires minimal personal information and does not store sensitive data like activity logs on a central server, fans can engage with the platform without concerns about personal information leakage. Furthermore, the ownership and trading of NFTs among fans can generate new revenue models. This will provide many people with access to blockchain technology, contributing to the popularization of blockchain as well. The BubbleCap platform integrates decentralized blockchain technology to revolutionize fan experiences, specifically targeting baseball fans. It provides a unique solution by leveraging Chiliz Spicy Testnet and hardhat for smart contract deployment while utilizing Next.js and styled-components for the frontend, creating a seamless and interactive user experience. Our platform offers the following key features: Bubble Catch: A gacha-style game that allows users to collect NFTs by paying Chiliz Fan Tokens. Completing a team\u2019s collection can unlock exclusive rewards, including private fan meetings with players, fostering deeper connections between fans and their favorite teams. Bubble Talk: A chat feature where fans can communicate with their favorite players using Chiliz Fan Tokens, further enhancing fan engagement. The integration of NFTs and blockchain not only increases fan participation but also contributes to the growth of the Chiliz ecosystem by introducing new revenue models through the trade and ownership of NFTs. By utilizing blockchain, fans can access the platform with minimal personal information, ensuring a secure and private user experience. Additionally, the platform supports a global fanbase by simplifying transactions through cryptocurrency, eliminating the barriers posed by diverse payment systems. With its focus on user-friendly blockchain applications, BubbleCap aims to popularize blockchain technology among sports fans and enhance Chiliz\u2019s brand awareness in the sports and entertainment sectors.",
        "how_its_made": "The BubbleCap platform integrates decentralized blockchain technology to revolutionize fan experiences, specifically targeting baseball fans. It provides a unique solution by leveraging Chiliz Spicy Testnet and hardhat for smart contract deployment while utilizing Next.js and styled-components for the frontend, creating a seamless and interactive user experience. Our platform offers the following key features: Bubble Catch: A gacha-style game that allows users to collect NFTs by paying Chiliz Fan Tokens. Completing a team\u2019s collection can unlock exclusive rewards, including private fan meetings with players, fostering deeper connections between fans and their favorite teams. Bubble Talk: A chat feature where fans can communicate with their favorite players using Chiliz Fan Tokens, further enhancing fan engagement. The integration of NFTs and blockchain not only increases fan participation but also contributes to the growth of the Chiliz ecosystem by introducing new revenue models through the trade and ownership of NFTs. By utilizing blockchain, fans can access the platform with minimal personal information, ensuring a secure and private user experience. Additionally, the platform supports a global fanbase by simplifying transactions through cryptocurrency, eliminating the barriers posed by diverse payment systems. With its focus on user-friendly blockchain applications, BubbleCap aims to popularize blockchain technology among sports fans and enhance Chiliz\u2019s brand awareness in the sports and entertainment sectors.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/k2mc0/screenshots/z749b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k2mc0/screenshots/00ii0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k2mc0/screenshots/wq0i5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k2mc0/screenshots/5eg3s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k2mc0/screenshots/pzt74/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k2mc0/screenshots/yxs70/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/BVBubbleCap/BubbleCapFront",
        "link": "https://ethglobal.com/showcase/bubble-cap-k2mc0"
    },
    {
        "title": "SocialProfiler",
        "brief_description": "Anonymized Social profiles from blockchain transactions",
        "long_description": "This project aims to create anonymized social profiles from blockchain transactions. This can help address malicious users who partake in activities like: This project uses Etherscan APIs to to gather data for Top blockchain protocols like Curve, Uniswap, OpenSea etc. and then categorise the users based on the apps they interact with, their frequency and the interval with which they interact. We can then reliably build user profiles to characterize users\u2019 financial behaviour from their transactional history and predict if two wallet addresses are controlled by a single user.",
        "how_its_made": "This project uses Etherscan APIs to to gather data for Top blockchain protocols like Curve, Uniswap, OpenSea etc. and then categorise the users based on the apps they interact with, their frequency and the interval with which they interact. We can then reliably build user profiles to characterize users\u2019 financial behaviour from their transactional history and predict if two wallet addresses are controlled by a single user.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9979z/screenshots/itowc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9979z/screenshots/7ugeq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9979z/screenshots/899r7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9979z/screenshots/f2rac/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Dayitva/4-equals-10",
        "link": "https://ethglobal.com/showcase/socialprofiler-9979z"
    },
    {
        "title": "Ferriss",
        "brief_description": "I've got very sick during the hackathon. So, I could not finish the project. I'm submitting it to get my stake back.",
        "long_description": "I've got very sick during the hackathon. So, I could not finish the project. I'm submitting it to get my stake back.\nI've got very sick during the hackathon. So, I could not finish the project. I'm submitting it to get my stake back.\nI've got very sick during the hackathon. So, I could not finish the project. I'm submitting it to get my stake back.\nI've got very sick during the hackathon. So, I could not finish the project. I'm submitting it to get my stake back.\nI've got very sick during the hackathon. So, I could not finish the project. I'm submitting it to get my stake back. I've got very sick during the hackathon. So, I could not finish the project. I'm submitting it to get my stake back.\nI've got very sick during the hackathon. So, I could not finish the project. I'm submitting it to get my stake back.\nI've got very sick during the hackathon. So, I could not finish the project. I'm submitting it to get my stake back.\nI've got very sick during the hackathon. So, I could not finish the project. I'm submitting it to get my stake back.",
        "how_its_made": "I've got very sick during the hackathon. So, I could not finish the project. I'm submitting it to get my stake back.\nI've got very sick during the hackathon. So, I could not finish the project. I'm submitting it to get my stake back.\nI've got very sick during the hackathon. So, I could not finish the project. I'm submitting it to get my stake back.\nI've got very sick during the hackathon. So, I could not finish the project. I'm submitting it to get my stake back.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5sqsr/screenshots/iqta2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5sqsr/screenshots/gj7jw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5sqsr/screenshots/p7ns8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/duplantier/tickt-ETHOnline2024",
        "link": "https://ethglobal.com/showcase/ferriss-5sqsr"
    },
    {
        "title": "Proof of Habit",
        "brief_description": "A platform that combines on-chain financial incentives, social support, and AI verification to help users build lasting habits. Users stake crypto, set goals, and submit daily evidence, with AI verifying progress. Success earns rewards; failure results in penalty.",
        "long_description": "Proof of Habit addresses the universal challenge of habit formation by combining behavioral economics, social psychology, and blockchain technology. By creating a system where users have \"skin in the game\" and can receive support from their community, we increase the likelihood of successful habit adoption. Why Proof of Habit is better than other habit-tracking apps? On-chain transaction: Users create habit pledges on the Ethereum blockchain, the bet amount can start in a very small fraction (like 0.01$) and can earn a reward directly in the user's wallet. Financial Incentives: Participants stake cryptocurrency as a self-imposed penalty for failing to meet their habit goals, creating a powerful motivator for success. Social Sponsorship: Friends and supporters can sponsor a user's habit journey, adding additional rewards and encouragement. AI-Powered Verification: Daily progress is verified using ChatGPT-4o, which analyzes photo evidence submitted by users to confirm habit completion. This enables a scalable and cost-effective verification process. How it works? Sign In with Ethereum:\nConnect your wallet and sign to authenticate. Create Your Habit Challenge: Daily Verification:\nSubmit photo evidence of your habit completion each day\nOur AI-powered system (ChatGPT-4o) verifies your progress Consequences:\nSuccess: Reclaim your stake plus any sponsor rewards\nFailure: Your stake is donated to charity\nPartial Success: Get some portion of your stake back By combining financial incentives, social support, and AI verification, Proof of Habit creates a powerful ecosystem for personal growth and habit formation. After researching habit-tracking apps, we found that bringing financial transactions on-chain and using AI to verify the proof of daily progress is scalable and effective. We decided to use Morph L2 as their positioning in a consumer application (it's who we are) and ETH as a native currency for transactions.\nWe still use our own database for a better user experience (like showing usernames, keeping track of a long list of pledges, etc.). Here are our tech stacks",
        "how_its_made": "After researching habit-tracking apps, we found that bringing financial transactions on-chain and using AI to verify the proof of daily progress is scalable and effective. We decided to use Morph L2 as their positioning in a consumer application (it's who we are) and ETH as a native currency for transactions.\nWe still use our own database for a better user experience (like showing usernames, keeping track of a long list of pledges, etc.). Here are our tech stacks",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/q6k3t/screenshots/jahqw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q6k3t/screenshots/8ixyu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q6k3t/screenshots/d8yz0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Proof-of-Habit-POH/ethonlinehackathon",
        "link": "https://ethglobal.com/showcase/proof-of-habit-q6k3t"
    },
    {
        "title": "SphereVibe",
        "brief_description": "Spherevibe is a decentralized social media platform that empowers users with ownership and control over their content, resists censorship, and fosters a community-driven ecosystem for fair content monetization and governance.",
        "long_description": "Project: Decentralized Social Media Platform\nThis ambitious project aims to create a revolutionary decentralized social media platform that addresses the key challenges faced by users in today's centralized social media landscape. The platform is designed to empower individuals with unprecedented control over their digital presence while fostering a vibrant, censorship-resistant community.\nAt its core, the platform leverages blockchain technology to create a decentralized architecture that forms the foundation of its key features and benefits. This approach ensures that no single entity has complete control over user data or platform governance, marking a significant departure from traditional social media models.\nKey Features and Solutions: Decentralized Architecture:\nThe platform is built on Fhenix blockchain network, enabling decentralized content posting, storage, and interaction. Smart contracts manage user interactions and transactions, ensuring transparency and immutability of records. This architecture is fundamental to achieving the platform's goals of censorship resistance and user empowerment.\nUser Ownership and Control:\nUnlike centralized platforms, users retain full ownership of their content and data. This ownership extends to users' digital identities, which are protected through the FHE encryption.\nFreedom of Expression:\nThe platform is designed to promote free speech while maintaining community standards. The decentralized nature of the system makes it inherently resistant to censorship and government interference, allowing users to express themselves without fear of arbitrary content removal, account suspension or Government tracking.\nSocial Integrity and Reputation System:\nA novel social integrity score is implemented to encourage positive contributions and maintain community trust. This score, influenced by factors such as likes and tips received, affects a user's privileges on the platform, including content deletion rights and participation in governance decisions. The scoring algorithm is transparent, ensuring fairness and community buy-in.\nDirect Monetization for Creators:\nContent creators can monetize their work directly through a tipping system using cryptocurrencies. Smart contracts facilitate seamless transactions, allowing creators to receive compensation without intermediaries. This system aims to provide a fairer and more transparent monetization model compared to traditional platforms.\nPrivacy and Anonymity:\nUser privacy is a top priority. These measures protect users from surveillance and data exploitation while still allowing for meaningful interactions.\nInteroperability:\nThe platform is designed to interact with other decentralized applications (dApps) and services, creating a rich ecosystem.\nCommunity-Driven Governance:\nPlatform policies, feature development, and content moderation are governed by the community through a decentralized decision-making process. This ensures that the platform evolves according to the needs and desires of its users, rather than the interests of a small group of executives. Challenges and Mitigations:\nThe project acknowledges several potential risks and challenges: Regulatory challenges are addressed through the use of decentralized infrastructure and privacy features, making the platform resistant to censorship and shutdown attempts.\nAdoption barriers for non-technical users are mitigated through user-friendly interfaces, educational resources, and community support.\nSecurity concerns are tackled with regular audits, multi-signature wallets, and decentralized backup solutions.\nGovernance issues are addressed through a carefully designed system with checks and balances to prevent gridlock or manipulation.\nScalability concerns are anticipated and planned for using Layer 2 solutions and other advanced technologies.\nThe sustainability of the economic model will be continuously evaluated and adjusted to ensure long-term viability. In conclusion, this decentralized social media platform represents a bold step towards a more open, fair, and user-centric digital social ecosystem. By addressing the fundamental issues of censorship, data ownership, fair monetization, and community governance, the project aims to create a social media experience that truly serves its users' interests and upholds the principles of free expression in the digital age. Core Technologies Blockchain:  Fhenix Layer2 blockchain Smart Contracts: Solidity\nDevelopment Framework: Hardhat Frontend: Framework: React.js with Next.js for server-side rendering\nState Management: Redux\nStyling: Tailwind CSS Decentralized Storage: lighthouse IPFS (InterPlanetary File System) for content storage Identity Management: Key Management: ethers.js and MetaMask integration Notable Hacks and Optimizations Content Caching: To improve load times, frequently accessed content is cached on centralized CDNs while maintaining the option for users to verify content integrity against the IPFS hash.\nLazy Loading: The frontend implements lazy loading of content and components to improve initial load times and reduce bandwidth usage.\nSocial Score Optimization: The social integrity score calculation is optimized using the number of interaction content have.",
        "how_its_made": "Core Technologies Blockchain:  Fhenix Layer2 blockchain Smart Contracts: Solidity\nDevelopment Framework: Hardhat Frontend: Framework: React.js with Next.js for server-side rendering\nState Management: Redux\nStyling: Tailwind CSS Decentralized Storage: lighthouse IPFS (InterPlanetary File System) for content storage Identity Management: Key Management: ethers.js and MetaMask integration Notable Hacks and Optimizations Content Caching: To improve load times, frequently accessed content is cached on centralized CDNs while maintaining the option for users to verify content integrity against the IPFS hash.\nLazy Loading: The frontend implements lazy loading of content and components to improve initial load times and reduce bandwidth usage.\nSocial Score Optimization: The social integrity score calculation is optimized using the number of interaction content have.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/cqdqd/screenshots/t5rg7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cqdqd/screenshots/jak5y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cqdqd/screenshots/ntw7m/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/vicsnet/SphereVibe",
        "link": "https://ethglobal.com/showcase/spherevibe-cqdqd"
    },
    {
        "title": "Ship IT",
        "brief_description": "Deploy Solidity contracts effortlessly across multiple chains without worrying about gas fees or network setups. Just connect, upload, and deploy in one go!",
        "long_description": "This project is a Solidity contract deployment service designed to simplify the process of deploying smart contracts across multiple blockchain networks, including Ethereum, Polygon, and Base. It aims to remove the common pain points developers face when deploying smart contracts, such as managing different network configurations, handling gas fees, and dealing with complex setups. By providing a streamlined, easy-to-use platform, the service allows developers to focus on building functionality rather than navigating the intricacies of blockchain infrastructure. Key Features\nMulti-Chain Deployment: The platform supports deploying smart contracts across multiple blockchain networks simultaneously. Users can select their target networks, such as Ethereum, Polygon, or Base, and deploy their contract to all chosen chains in a single step. This eliminates the need to configure each network separately or repeat the deployment process multiple times. Gas-Free Deployments: One of the major hurdles in deploying contracts is managing and paying for gas fees. Our platform automates this process by handling gas payments on behalf of the user, abstracting away the complexity of managing tokens and gas fees for multiple networks. Developers no longer need to worry about balancing wallets with native tokens for each chain they deploy to. API-Driven Workflow: Users interact with the service primarily through an API key generated after connecting their wallet. This API key ensures secure access to the deployment system and enables the user to deploy contracts without needing to interact with lower-level blockchain details. It streamlines the process for developers who prefer using an API to manage their deployments programmatically. Easy Wallet Integration with Web3Auth: To make onboarding smooth and secure, the platform integrates Web3Auth, allowing users to connect their wallets using popular authentication methods such as Google, Facebook, or existing crypto wallets like MetaMask. This eliminates the need for manual wallet management and private key handling, making the service accessible to users of all technical levels. Upload Contract Artifact: Developers can upload their contract artifact (a JSON file containing the contract\u2019s bytecode and ABI) via the web interface. This artifact is the compiled version of the Solidity contract and contains the necessary information for deploying the contract. The platform then processes this artifact for deployment across the selected blockchains, without requiring re-uploads or separate files for different networks. Seamless Contract Deployment: Once the contract artifact is uploaded and the network(s) selected, the user simply clicks 'Deploy'. The platform takes care of the rest, automatically configuring the contract for the specified blockchains and deploying it without any further input from the user. This one-click deployment abstracts all the complexities, such as network configurations, transaction signing, and contract verification, making the process highly efficient. Automated Network Management: The service automatically manages the necessary configurations and details for each blockchain. It ensures the contract is deployed under the correct conditions and optimizes the deployment process to avoid errors or misconfigurations that could occur if the user had to handle multiple networks manually. Post-Deployment Information: After successful deployment, the platform provides the user with crucial details such as the contract address and transaction hash for each deployed contract. This information is important for verifying that the contract is live and operational on the selected blockchain(s). Use Case and Target Audience\nThis service is particularly valuable for developers who regularly work on decentralized applications (dApps) and require frequent contract deployments. It's ideal for startups, blockchain development agencies, or independent developers looking to build projects on multiple chains but who don\u2019t want to deal with the hassle of managing deployments manually. Key benefits include:\nTime Efficiency: Developers save significant time by eliminating the need to configure each network and manage deployment steps for each blockchain individually. Cost Reduction: With automated gas fee management, developers no longer need to manage or fund gas for each network deployment. Error Reduction: Automated processes for handling configuration and deployment reduce the likelihood of mistakes caused by manual handling of blockchain details. Developer Experience: A seamless, easy-to-use interface and API enable developers to deploy contracts with minimal friction, improving the overall development experience. Vision and Future Enhancements\nOur vision is to create the go-to platform for seamless smart contract deployment across all major blockchains. In the future, we plan to expand the platform with additional features: Support for more blockchains like Binance Smart Chain, Avalanche, and Optimism.\nAutomated contract verification with services like Etherscan and Polygonscan.\nAdvanced developer tools, such as contract versioning, environment-specific deployments (testnet, staging, mainnet), and more.\nAnalytics and reporting, allowing users to track contract performance and interactions across multiple chains. Conclusion\nThis project aims to revolutionize how developers interact with blockchain networks by simplifying the process of deploying Solidity smart contracts. With an easy-to-use interface, Web3Auth wallet integration, and API-driven workflow, this service provides a powerful yet accessible solution to the growing complexity of multi-chain smart contract deployments. Whether you're a solo developer or part of a larger team, this platform is designed to help you deploy smart contracts quickly, efficiently, and without the typical headaches of blockchain management. We have integrated Web3Auth to simplify wallet management for users. With Web3Auth, users can create and use a wallet without handling private keys, which is particularly useful since most development-related private keys don't hold actual currencies. The frontend of the web app is built using Next.js along with the Shadcn UI library, ensuring a responsive and modern interface. On the backend, we utilized Node.js to manage the creation and deployment of user contracts to test networks. This architecture enables seamless interaction between the UI and the smart contract deployment process.",
        "how_its_made": "We have integrated Web3Auth to simplify wallet management for users. With Web3Auth, users can create and use a wallet without handling private keys, which is particularly useful since most development-related private keys don't hold actual currencies. The frontend of the web app is built using Next.js along with the Shadcn UI library, ensuring a responsive and modern interface. On the backend, we utilized Node.js to manage the creation and deployment of user contracts to test networks. This architecture enables seamless interaction between the UI and the smart contract deployment process.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/r8sb2/screenshots/ktpqg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r8sb2/screenshots/irq1g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r8sb2/screenshots/094c2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r8sb2/screenshots/yqxt5/default.jpg"
        ],
        "live_demo": "https://ethonline-2024-vbd3.vercel.app/",
        "source_code": "https://github.com/shreyaspapi/ethonline-2024",
        "link": "https://ethglobal.com/showcase/ship-it-r8sb2"
    },
    {
        "title": "Unbound Science",
        "brief_description": "A creator economy for scientists and inventors, powered by web3. Unlocking secret technologies and preserving/sharing them by using the power of blockchain can revolutionize our world in ways not seen since the industrial revolution.",
        "long_description": "The mission of Unbound Science is to spread technology around the world faster than ever before. We start by onboarding scientists into web3, using familiar logins and abstracting away the wallets. Using ZKP, we keep their identities and research private and anonymous (if they choose to be, for their own safety). Scientists can receive funding to further their research into mass production ready products. Once the product is ready to go, it is registered with Story Protocol, then sent to marketplace partners for it to be licensed and leased all over the world. We will start out supporting funding for four categories: Clean Energy, Air/Water/Soil Tech, Pollution/Waste Management, Quantum Devices. We will be using a number of existing web3 technologies in our stack. The list will continue evolving, but the final version will be written in Rust, launched within containers running on Internet Computer, with storage options for Internet Computer, Arweave, and Bitmaps. Secret Network will provide user privacy, interoperability, and compute. Boba Network will provide compute as well. Fileverse will be integrated for whiteboard collaboration. dWallet is being considered to provide the wallet abstraction. Our goal is to use as many proven existing technologies as possible, rather than try to create our own unnecessarily.",
        "how_its_made": "We will be using a number of existing web3 technologies in our stack. The list will continue evolving, but the final version will be written in Rust, launched within containers running on Internet Computer, with storage options for Internet Computer, Arweave, and Bitmaps. Secret Network will provide user privacy, interoperability, and compute. Boba Network will provide compute as well. Fileverse will be integrated for whiteboard collaboration. dWallet is being considered to provide the wallet abstraction. Our goal is to use as many proven existing technologies as possible, rather than try to create our own unnecessarily.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/j91jy/screenshots/z3omb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j91jy/screenshots/3peps/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j91jy/screenshots/3qpyx/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Unboundscience/ETHGlobal2024",
        "link": "https://ethglobal.com/showcase/unbound-science-j91jy"
    },
    {
        "title": "Block Estate",
        "brief_description": "BlockEstate is a decentralized platform for buying, selling, and leasing real estate using Web3 technology. It features Web3Auth for secure authentication, Hedera for fast transactions, and Sign Protocol for verified document handling, ensuring transparency and efficiency.",
        "long_description": "BlockEstate is a decentralized real estate platform that enables users to buy, sell, and lease properties seamlessly through a blockchain-based system. The platform provides a transparent and secure environment for real estate transactions, ensuring that ownership and lease agreements are recorded on the blockchain, enhancing trust and reducing the potential for fraud. Detailed Description: User Verification:\nThe process begins with user verification, where individuals must verify their identity using official ID documentation. This step is crucial to ensure that all participants in the platform are legitimate and trustworthy. Leasing Property:\nSet Duration of Lease: Users looking to lease a property can set the duration of the lease according to their needs. This flexibility allows both short-term and long-term leasing options.\nSet Tokens Count: The platform uses a token-based system where the property value or lease value is represented in tokens. Users can set the number of tokens required for the lease.\nInitial Payment: Once the lease terms are agreed upon, the lessee proceeds with the initial payment. This payment secures the lease and updates the temporary ownership status on the blockchain.\nTemporary Ownership Updated: After the initial payment, the platform records the temporary transfer of ownership rights or leasehold interests, ensuring that both parties are protected under the agreed terms. Selling Property:\nSet Token & Lease Price: Property owners can list their properties for sale by setting the price in tokens and specifying the lease price if applicable. This step includes verifying the property with land documents, ensuring that the listing is legitimate.\nVerification with Land Document: The platform requires verification of property ownership through land documents, adding a layer of security and authenticity to each listing.\nAdded to Marketplace: Once verified, the property is added to the marketplace, where potential buyers can browse and purchase properties. Buying Property:\nSet Tokens Count: Buyers can decide on the number of tokens they wish to allocate to a specific property, making it easy to handle fractional ownership or full property purchases.\nFull Payment: After selecting the property and setting the token count, the buyer proceeds with the full payment. This transaction finalizes the purchase.\nPermanent Ownership Updated: Upon payment, the blockchain updates the property\u2019s ownership status to reflect the new owner permanently. This ensures a transparent and immutable record of ownership. Flow of BlockEstate project: Frontend: Built with Next.js for fast, SEO-friendly interfaces, and styled using Tailwind CSS for a responsive design.\nAuthentication: Web3Auth handles user sign-in with secure wallet or social logins, ensuring verified, decentralized user identities.\nBlockchain & Smart Contracts: Solidity powers the smart contracts for property transactions, while Hedera offers a scalable, low-cost blockchain infrastructure for secure and efficient operations.\nBackend: MongoDB stores off-chain data like user profiles and property listings, providing flexibility and scalability.\nLegal Documents: Sign Protocol manages digital signing of contracts, ensuring legality and immutability on the blockchain.\nNotable Hacks: Hybrid Transaction Model: Critical data is stored on-chain, while non-essential data is off-chain, optimizing speed and cost.\nFractional Ownership: Custom tokenization logic in Solidity enables fractional property investment.\nPartner Benefits: Hedera ensures high-speed, secure transactions.\nWeb3Auth simplifies onboarding with versatile authentication methods.\nBlockEstate delivers a seamless, secure real estate platform, democratizing access to property investments through innovative tech.",
        "how_its_made": "Flow of BlockEstate project: Frontend: Built with Next.js for fast, SEO-friendly interfaces, and styled using Tailwind CSS for a responsive design.\nAuthentication: Web3Auth handles user sign-in with secure wallet or social logins, ensuring verified, decentralized user identities.\nBlockchain & Smart Contracts: Solidity powers the smart contracts for property transactions, while Hedera offers a scalable, low-cost blockchain infrastructure for secure and efficient operations.\nBackend: MongoDB stores off-chain data like user profiles and property listings, providing flexibility and scalability.\nLegal Documents: Sign Protocol manages digital signing of contracts, ensuring legality and immutability on the blockchain.\nNotable Hacks: Hybrid Transaction Model: Critical data is stored on-chain, while non-essential data is off-chain, optimizing speed and cost.\nFractional Ownership: Custom tokenization logic in Solidity enables fractional property investment.\nPartner Benefits: Hedera ensures high-speed, secure transactions.\nWeb3Auth simplifies onboarding with versatile authentication methods.\nBlockEstate delivers a seamless, secure real estate platform, democratizing access to property investments through innovative tech.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/uqb5r/screenshots/c442x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uqb5r/screenshots/no5kq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uqb5r/screenshots/mb8ke/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uqb5r/screenshots/1xwvz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uqb5r/screenshots/gwa3u/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/KaushikKC/BlockEstate_Frontend",
        "link": "https://ethglobal.com/showcase/block-estate-uqb5r"
    },
    {
        "title": "OmniGas",
        "brief_description": "OmniGas is an Smart Wallet that uses Biometric passkeys as private key. It allows users to select their favorite token to pay blockchain fees.",
        "long_description": "This project aims to address the user experience challenges associated with traditional Web3 wallets by developing a more intuitive and versatile smart wallet solution. The primary goal is to simplify the complexities of blockchain interactions while maintaining robust security and expanding functionality. 1 - ERC-4337 Implementation:\nAdopts the ERC-4337 standard for account abstraction, enhancing wallet flexibility and user experience. 2 - Biometric Authentication:\nUtilizes WebAuthn for biometric signatures, replacing the traditional 12-word seed phrase. Enhances security while simplifying the user authentication process. 3 - Flexible Gas Fee Payment Options:\nSupports multiple payment methods for transaction fees: Native blockchain tokens, ERC-20 tokens on the same blockchain, ERC-20 tokens from different blockchains (cross-chain functionality), Sponsored transactions (gasless for the end-user) 4 - WalletConnect Integration:\nEnables seamless connection to decentralized applications (dApps) using the WalletConnect protocol. 5 - Direct DeFi Interactions:\nBuilt-in integration with popular DeFi platforms like Aave, allowing users to interact directly from the wallet interface. 6 - Cross-Chain Compatibility:\nDesigned to work across multiple blockchain networks, simplifying the management of assets on different chains. 7 - User-Centric Design:\nFocuses on maintaining a simple, intuitive interface while providing access to advanced blockchain features. Project Goals: In summary, this smart wallet project combines cutting-edge blockchain standards (ERC-4337) with user-friendly technologies like biometric authentication and flexible payment options. It aims to unlock the full potential of blockchain technology for users while maintaining a simple, accessible interface. By addressing key pain points in current wallet solutions, this project seeks to accelerate blockchain adoption and improve the overall user experience in the Web3 ecosystem. My project leverages the ERC-4337 implementation from OpenZeppelin, with custom modifications to enable biometric signatures as private keys with WebAuthn. This innovative approach allows for enhanced security and user-friendly authentication across multiple blockchains. Smart Account Deployment Transaction Execution Flexible Gas Payment Options Advanced Paymaster Integration Cross-Chain Gas Payment Biometric Signature Integration Cross-Chain Compatibility Gas Abstraction Smart Contract Interactions",
        "how_its_made": "My project leverages the ERC-4337 implementation from OpenZeppelin, with custom modifications to enable biometric signatures as private keys with WebAuthn. This innovative approach allows for enhanced security and user-friendly authentication across multiple blockchains. Smart Account Deployment Transaction Execution Flexible Gas Payment Options Advanced Paymaster Integration Cross-Chain Gas Payment Biometric Signature Integration Cross-Chain Compatibility Gas Abstraction Smart Contract Interactions",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/cqg1m/screenshots/u5yze/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cqg1m/screenshots/wq466/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cqg1m/screenshots/pyk98/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cqg1m/screenshots/obi52/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cqg1m/screenshots/hban7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cqg1m/screenshots/rrhp2/default.jpg"
        ],
        "live_demo": "https://omnigas.vercel.app/",
        "source_code": "https://github.com/Shimadakunn/OmniGas",
        "link": "https://ethglobal.com/showcase/omnigas-cqg1m"
    },
    {
        "title": "AI Content Cop",
        "brief_description": "Farcaster Content Cop: An AI-powered content moderation tool for Farcaster, built on Galadriel's decentralized AI L1. Analyzes user profiles, detects spam, and assesses ethical concerns. Empowering safer social interactions on Web3.",
        "long_description": "Farcaster Content Cop is an innovative application developed for the EthGlobal 2024 hackathon, designed to enhance content moderation and user safety on the Farcaster social media platform. This project uniquely combines blockchain technology with artificial intelligence, leveraging Galadriel's groundbreaking L1 solution for decentralized AI applications. Key Features and Functionality: Farcaster Profile Analysis:\nRetrieves user data from Farcaster, including follower count, following count, and FarScore.\nFetches the user's recent posts (casts) for analysis. AI-Powered Content Evaluation:\nUtilizes Galadriel's decentralized AI infrastructure to analyze user content.\nProcesses user metrics and recent posts to generate comprehensive assessments. Spam Detection:\nEmploys advanced AI algorithms to identify potential spam content.\nProvides a clear indication of spam likelihood in the user's posts. Ethical Assessment:\nEvaluates content for potential ethical concerns or violations of community standards.\nOffers insights into the nature and severity of any identified issues. Action Recommendations:\nSuggests appropriate actions based on the AI analysis, such as monitoring, warning, or reporting. User-Friendly Interface:\nOffers a clean, intuitive web interface for easy interaction.\nAllows users to input Farcaster usernames for instant analysis. Blockchain Integration:\nIncorporates Web3Modal for seamless wallet connectivity.\nEnsures secure and decentralized user authentication. Transparency and Explainability:\nProvides detailed breakdowns of AI assessments.\nAllows users to view both summary results and in-depth analysis. Technical Implementation: Unique Value Proposition:\nFarcaster Content Cop stands out by offering a decentralized approach to content moderation. By leveraging Galadriel's \"Ethereum for AI\" infrastructure, it ensures that AI decision-making processes are transparent, immutable, and free from centralized control. This approach aligns perfectly with the ethos of Web3 and decentralized social media platforms like Farcaster. Future Potential: Cross-Platform Adaptability:\nThe core technology can be easily adapted for use in other decentralized social media platforms such as Lens Protocol, expanding its impact beyond Farcaster.\nWith minor modifications, the system could analyze content across multiple Web3 social networks, providing a comprehensive view of a user's online presence. Integration with Farcaster Frames & Mini Apps:\nFarcaster Content Cop can be seamlessly integrated into Farcaster Frames, allowing for in-situ content analysis and moderation within the Farcaster ecosystem.\nDevelopers can incorporate this tool into their Farcaster Mini Apps, enhancing user safety and content quality in various decentralized applications. Lens & XMTP Frame Integration:\nThe project can be extended to work within Lens Protocol's frame system, bringing its AI-powered content analysis to the Lens ecosystem.\nIntegration with XMTP (Extensible Message Transport Protocol) frames would allow for real-time content moderation in decentralized messaging applications. Evolving AI Model:\nThe AI model can be continually improved through on-chain governance and decentralized machine learning processes, allowing it to adapt to new types of content and emerging moderation challenges. Community-Driven Moderation System:\nThe project could evolve into a decentralized, community-driven moderation system where stakeholders can vote on moderation policies and contribute to the refinement of the AI model. Customizable Moderation Policies:\nFuture versions could allow communities or individual users to set their own moderation parameters, creating a more flexible and personalized content filtering experience. Cross-Chain Compatibility:\nAs the project grows, it could be adapted to work across multiple blockchain networks, leveraging cross-chain technologies to provide a unified content moderation solution for the entire Web3 space. API and SDK Development:\nThe core functionality could be packaged into APIs and SDKs, allowing developers to easily incorporate content moderation features into their own decentralized applications.\nReputation System Integration:\nThe tool could be expanded to contribute to and interact with decentralized reputation systems, helping to create a more trust-based environment in Web3 social platforms. Privacy-Preserving Analysis:\nFuture iterations could incorporate zero-knowledge proofs or other privacy-preserving technologies to perform content analysis without compromising user data privacy. Impact:\nBy providing an efficient, AI-driven tool for content analysis, Farcaster Content Cop aims to create a safer, more transparent social media environment. It empowers users and moderators with insights that can help maintain the quality of discussions and interactions on the Farcaster platform. This project not only showcases the potential of decentralized AI in social media moderation but also demonstrates the practical applications of Galadriel's innovative L1 solution in real-world scenarios. It represents a significant step towards more ethical, transparent, and decentralized content moderation in the Web3 ecosystem. Core Technologies: React.js: We chose React for its component-based architecture and efficient rendering, which allowed us to create a responsive and interactive user interface. TypeScript: Used throughout the project for type safety and improved developer experience. Galadriel L1: The cornerstone of our project, Galadriel's \"Ethereum for AI\" infrastructure enabled us to build decentralized AI applications using Solidity. This allowed us to create AI models that run on-chain, ensuring transparency and immutability of our content moderation processes. Solidity: Used to write smart contracts for our AI models on Galadriel's L1.\nWeb3Modal & Ethers.js: Integrated for wallet connectivity and blockchain interactions, allowing users to authenticate securely. Airstack API: Utilized for efficient retrieval of Farcaster user data and posts.\nIntegration and Development Process: Frontend Development: *Created a React application using Create React App with TypeScript template.\n*Implemented a clean, intuitive UI using CSS modules for styling.\n*Developed components for user input, result display, and detailed analysis views.\nBlockchain Integration:\n*Integrated Web3Modal for wallet connectivity.\n*Used Ethers.js to interact with Galadriel's L1 blockchain.\n*Implemented functions to call our on-chain AI models. Airstack API Integration: *Created custom hooks to fetch Farcaster user data and recent posts.\n*Implemented error handling and loading states for API calls. AI Model Development: *Developed AI models for content analysis using TensorFlow.js.\n*Converted these models to run on Galadriel's L1 using Solidity.\n*Implemented functions for spam detection, ethical assessment, and action recommendations. On-Chain AI Processing: *Deployed our AI models as smart contracts on Galadriel's L1.\n*Developed Solidity functions to process user data and return analysis results. Data Flow: *User inputs a Farcaster username.\n*Frontend fetches user data and recent posts from Airstack API.\n*Data is sent to our on-chain AI models via Ethers.js.\n*AI models process the data and return results.\n*Results are displayed in the UI, with options for detailed views. Notable Challenges and Solutions: On-Chain AI Optimization:\nWe faced challenges in optimizing our AI models to run efficiently on-chain. We implemented a novel compression technique to reduce the model size while maintaining accuracy. Real-time Analysis:\nTo provide near real-time results, we implemented a caching mechanism that stores recent analyses, reducing redundant on-chain computations. Privacy Considerations:\nWe implemented a basic form of differential privacy in our on-chain models to protect user data while maintaining analysis accuracy. Gas Optimization:\nWe optimized our Solidity contracts to minimize gas costs, implementing batched processing where possible.\nInnovative Aspects: Decentralized AI Governance:\nWe implemented a basic on-chain voting system that allows users to propose and vote on changes to the AI model's parameters, creating a truly decentralized and community-driven content moderation system. Cross-Platform Compatibility:\nAlthough primarily designed for Farcaster, we built our system with modularity in mind, allowing easy adaptation for other platforms like Lens Protocol. Frame-Ready Architecture:\nWe structured our frontend components to be easily embeddable in Farcaster Frames and Mini Apps, anticipating future integration. By leveraging Galadriel's innovative L1 solution, we were able to create a truly decentralized AI-powered content moderation tool. This approach not only aligns with Web3 principles but also opens up new possibilities for transparent and community-driven content governance in social media platforms.",
        "how_its_made": "Core Technologies: React.js: We chose React for its component-based architecture and efficient rendering, which allowed us to create a responsive and interactive user interface. TypeScript: Used throughout the project for type safety and improved developer experience. Galadriel L1: The cornerstone of our project, Galadriel's \"Ethereum for AI\" infrastructure enabled us to build decentralized AI applications using Solidity. This allowed us to create AI models that run on-chain, ensuring transparency and immutability of our content moderation processes. Solidity: Used to write smart contracts for our AI models on Galadriel's L1.\nWeb3Modal & Ethers.js: Integrated for wallet connectivity and blockchain interactions, allowing users to authenticate securely. Airstack API: Utilized for efficient retrieval of Farcaster user data and posts.\nIntegration and Development Process: Frontend Development: *Created a React application using Create React App with TypeScript template.\n*Implemented a clean, intuitive UI using CSS modules for styling.\n*Developed components for user input, result display, and detailed analysis views.\nBlockchain Integration:\n*Integrated Web3Modal for wallet connectivity.\n*Used Ethers.js to interact with Galadriel's L1 blockchain.\n*Implemented functions to call our on-chain AI models. Airstack API Integration: *Created custom hooks to fetch Farcaster user data and recent posts.\n*Implemented error handling and loading states for API calls. AI Model Development: *Developed AI models for content analysis using TensorFlow.js.\n*Converted these models to run on Galadriel's L1 using Solidity.\n*Implemented functions for spam detection, ethical assessment, and action recommendations. On-Chain AI Processing: *Deployed our AI models as smart contracts on Galadriel's L1.\n*Developed Solidity functions to process user data and return analysis results. Data Flow: *User inputs a Farcaster username.\n*Frontend fetches user data and recent posts from Airstack API.\n*Data is sent to our on-chain AI models via Ethers.js.\n*AI models process the data and return results.\n*Results are displayed in the UI, with options for detailed views. Notable Challenges and Solutions: On-Chain AI Optimization:\nWe faced challenges in optimizing our AI models to run efficiently on-chain. We implemented a novel compression technique to reduce the model size while maintaining accuracy. Real-time Analysis:\nTo provide near real-time results, we implemented a caching mechanism that stores recent analyses, reducing redundant on-chain computations. Privacy Considerations:\nWe implemented a basic form of differential privacy in our on-chain models to protect user data while maintaining analysis accuracy. Gas Optimization:\nWe optimized our Solidity contracts to minimize gas costs, implementing batched processing where possible.\nInnovative Aspects: Decentralized AI Governance:\nWe implemented a basic on-chain voting system that allows users to propose and vote on changes to the AI model's parameters, creating a truly decentralized and community-driven content moderation system. Cross-Platform Compatibility:\nAlthough primarily designed for Farcaster, we built our system with modularity in mind, allowing easy adaptation for other platforms like Lens Protocol. Frame-Ready Architecture:\nWe structured our frontend components to be easily embeddable in Farcaster Frames and Mini Apps, anticipating future integration. By leveraging Galadriel's innovative L1 solution, we were able to create a truly decentralized AI-powered content moderation tool. This approach not only aligns with Web3 principles but also opens up new possibilities for transparent and community-driven content governance in social media platforms.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fwqq8/screenshots/dm853/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fwqq8/screenshots/oeh4k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fwqq8/screenshots/ih1yf/default.jpg"
        ],
        "live_demo": "https://frontend-sigma-three-99.vercel.app/",
        "source_code": "https://github.com/ethglobal2024-content/frontend",
        "link": "https://ethglobal.com/showcase/ai-content-cop-fwqq8"
    },
    {
        "title": "Meme Arena",
        "brief_description": "This Web3 game combines Pok\u00e9mon-style battles with the world of memecoins.",
        "long_description": "This Web3 game combines Pok\u00e9mon-style battles with the world of memecoins. Players connect their wallets, and stake memecoins to mint \"Gladiators\", and build teams for battles. Each Gladiator's stats are influenced by the real-time performance of the memecoins they represent, creating a constantly evolving game meta. To add more strategy possibilities, each gladiator has specific types and levels. Types determine strengths and weaknesses in battles, while levels affect overall stats and abilities. The app features PvP battles where winners receive a share of the loser's staked memecoins. We aimed to make the game cross-chain, so we deployed contracts on zkSync using Solidity and built the program on Solana with Rust. Although the cross-chain functionality wasn't feasible within the scope of this hackathon, we plan to implement it in future milestones. The game\u2019s backend is developed with Node.js and integrates a WebSocket component for real-time interaction. The frontend is built using TypeScript with Next.js.",
        "how_its_made": "We aimed to make the game cross-chain, so we deployed contracts on zkSync using Solidity and built the program on Solana with Rust. Although the cross-chain functionality wasn't feasible within the scope of this hackathon, we plan to implement it in future milestones. The game\u2019s backend is developed with Node.js and integrates a WebSocket component for real-time interaction. The frontend is built using TypeScript with Next.js.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dt36x/screenshots/95718/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dt36x/screenshots/it7u8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dt36x/screenshots/krtjt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dt36x/screenshots/ybsnh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/raigal-r/meme-arena",
        "link": "https://ethglobal.com/showcase/meme-arena-dt36x"
    },
    {
        "title": "Aeith",
        "brief_description": "A turn-based murder mystery game powered by Galadriel\u2019s on-chain AI agents. Players, represented by characters like Blue Fish, Orange Crab, Green Turtle, and Red Donkey, investigate a haunted mansion while interacting with a Game Master AI to solve the mystery..",
        "long_description": "This project integrates Galadriel\u2019s on-chain AI system to create a dynamic murder mystery game set in a haunted mansion. The players\u2014Blue Fish, Orange Crab, Green Turtle, and Red Donkey\u2014move around the mansion, collecting clues and interacting with the environment through both movement inputs and chat-based commands. The game\u2019s core AI agents run on Galadriel\u2019s Oracle, which manages the asynchronous interactions between the players and external services. The Game Master, facilitated through the Gemini API for structured outputs, oversees the narrative, controlling the flow of the game, issuing challenges, and guiding players toward solving the mystery. Galadriel\u2019s Oracle handles LLM calls and tool use for specific game actions such as gathering external information or managing player inputs. The game\u2019s difficulty and progression evolve dynamically based on player actions, guided by the Game Master\u2019s decisions. The game\u2019s backend relies on Galadriel\u2019s Oracle, enabling smart contract interactions with off-chain AI models and external tools. Player commands are sent to the Game Master, which processes them using structured schemas from the Gemini API, allowing for detailed interactions between players and the environment. Each player\u2019s movements and chat inputs are processed in real time, allowing for a rich and interactive game environment. The Game Master dynamically responds to player actions, while Galadriel\u2019s Oracle manages communication and execution of commands.",
        "how_its_made": "The game\u2019s backend relies on Galadriel\u2019s Oracle, enabling smart contract interactions with off-chain AI models and external tools. Player commands are sent to the Game Master, which processes them using structured schemas from the Gemini API, allowing for detailed interactions between players and the environment. Each player\u2019s movements and chat inputs are processed in real time, allowing for a rich and interactive game environment. The Game Master dynamically responds to player actions, while Galadriel\u2019s Oracle manages communication and execution of commands.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/znvzm/screenshots/su37t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/znvzm/screenshots/fa2ki/default.jpg",
            "https://ethglobal.b-cdn.net/projects/znvzm/screenshots/fvraw/default.jpg"
        ],
        "live_demo": "https://aeith-etho2024.vercel.app",
        "source_code": "https://github.com/tricodex/aeith-etho2024",
        "link": "https://ethglobal.com/showcase/aeith-znvzm"
    },
    {
        "title": "Grouping",
        "brief_description": "Grouping is a decentralized Web 3.0 social commerce platform that enables safe and transparent group purchases.",
        "long_description": "Current Situation In traditional group buying methods, participants' funds are pooled into a central account, requiring complete trust in the organizer. This centralization poses the risk of funds being mismanaged or misused, potentially compromising the safety of participants' assets. Moreover, on Web2 platforms, users' behavioral data can be analyzed to infer sensitive personal information. For instance, there have been cases where shopping sites analyzed a user's purchasing patterns to deduce highly sensitive information about the customer, even before their own family knew. Such instances highlight the risks of sensitive personal information being exposed, underscoring the importance of privacy protection. Solution The Grouping platform uses Zero-Knowledge Proof (zk) technology and blockchain to protect users' personal information during the group buying process and to prevent the centralization of funds. On Grouping, payments are made directly from each participant's wallet when the group purchase is finalized. Additionally, zk technology is employed to protect buyers' personal information from both the platform and other users. This structure enhances the security of funds and protects personal information, thereby providing greater trust to participants. Service Overview Main Components of the Project\nFrameworks and Libraries Used Frontend: NextJS, React, Zustand\nWeb3auth: Utilized to assign pre-created wallets even when logging in via SNS or Google email, making the service more seamless for users. Contract:\nFhenix: Used as a core technology for data protection.",
        "how_its_made": "Main Components of the Project\nFrameworks and Libraries Used Frontend: NextJS, React, Zustand\nWeb3auth: Utilized to assign pre-created wallets even when logging in via SNS or Google email, making the service more seamless for users. Contract:\nFhenix: Used as a core technology for data protection.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/aa3tv/screenshots/fdiso/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aa3tv/screenshots/wgzbu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aa3tv/screenshots/vzno6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aa3tv/screenshots/p66nf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/aa3tv/screenshots/07j8p/default.jpg"
        ],
        "live_demo": "https://grouping-bv.vercel.app/",
        "source_code": "https://github.com/Team-Grouping/Grouping",
        "link": "https://ethglobal.com/showcase/grouping-aa3tv"
    },
    {
        "title": "MediGuard",
        "brief_description": "MediGuard Protocol revolutionizes healthcare by enabling privacy-preserving AI predictions on encrypted medical data using on-chain computation. Powered by Fhenix\u2019s Fully Homomorphic Encryption (FHE), it ensures data security without revealing sensitive information",
        "long_description": "The MediGuard Protocol is a privacy-preserving AI prediction platform designed to revolutionize how medical data is processed in machine learning models. The goal is to securely handle sensitive medical data while enabling institutions to perform predictions without revealing or compromising patient privacy. Medical institutions rely on machine learning for predictive insights into patient outcomes, but traditionally, running models on large datasets poses a serious privacy risk. Patients' medical records contain highly sensitive data, and disclosing them\u2014especially to cloud-based machine learning systems\u2014introduces the risk of data breaches or misuse. MediGuard Protocol addresses this issue by keeping the data encrypted at every stage of processing and providing AI predictions on-chain via a smart contract. In essence, the protocol allows medical institutions to: Run AI models on encrypted data: The institution's data is encrypted at the source (within the user\u2019s browser), preventing exposure of any raw medical data.\nReceive predictions securely: The prediction itself is also encrypted and returned to the institution, which can decrypt it with its own private key.\nLeverage on-chain computation: Using FHE (Fully Homomorphic Encryption) through Fhenix\u2019s smart contracts, we are able to compute on encrypted data directly without ever needing to decrypt it.\nKey Features: End-to-end encryption: From data input, encryption, on-chain computation, to prediction output, the data remains private.\nAccount abstraction: Simplifies the login process for non-technical medical staff, making it easy for institutions to interact with the platform.\nSmart contract computation: The encrypted data is sent to a smart contract that runs an AI model (for example, a regression model to predict diabetes) and returns the encrypted prediction.\nThe example i developed focuses on predicting diabetes risk using patient inputs like age, BMI, and glucose level. These inputs are encrypted locally using the public address of the medical institution and sent to the Fhenix Helium Testnet network where the prediction happens securely using a regression model deployed as a smart contract. The result is sent back in an encrypted format, and only the medical institution can decrypt it. The MediGuard Protocol is not just limited to diabetes predictions\u2014it can be expanded to accommodate other models and predictions, creating a new paradigm for privacy-preserving healthcare AI. MediGuard Protocol is built using React for the frontend and ethers.js. The main focus is on ensuring the privacy of medical data while performing computations on-chain. The protocol is deployed on the Fhenix Helium Testnet, using the smart contract fhe.sol to enable fully homomorphic encryption (FHE) for secure and privacy-preserving on-chain predictions. In the frontend, React handles the user interface where medical institutions can easily input data. When medical data, such as age, weight, or glucose levels, is entered, it is encrypted locally using the user's private key. This ensures that the data remains secure and is never exposed in plaintext, either during transit or on the blockchain. The encrypted data is then sent to the smart contract, which is responsible for performing the machine learning model computations. For this project, we used a logistic regression model as a sample use case for predicting diabetes risk. The encrypted parameters are passed to the smart contract, which computes the prediction on-chain using FHE and returns the result in encrypted form. The system is designed to work with any machine learning model in the future, allowing flexibility for different types of medical predictions. The Diabetes Prediction use case is just an example, and the protocol will be extended to support more complex models and computations as we continue development. This approach shows how privacy-preserving machine learning computations can be done securely on-chain using homomorphic encryption, solving the problem of sharing sensitive medical data while leveraging blockchain technology.",
        "how_its_made": "MediGuard Protocol is built using React for the frontend and ethers.js. The main focus is on ensuring the privacy of medical data while performing computations on-chain. The protocol is deployed on the Fhenix Helium Testnet, using the smart contract fhe.sol to enable fully homomorphic encryption (FHE) for secure and privacy-preserving on-chain predictions. In the frontend, React handles the user interface where medical institutions can easily input data. When medical data, such as age, weight, or glucose levels, is entered, it is encrypted locally using the user's private key. This ensures that the data remains secure and is never exposed in plaintext, either during transit or on the blockchain. The encrypted data is then sent to the smart contract, which is responsible for performing the machine learning model computations. For this project, we used a logistic regression model as a sample use case for predicting diabetes risk. The encrypted parameters are passed to the smart contract, which computes the prediction on-chain using FHE and returns the result in encrypted form. The system is designed to work with any machine learning model in the future, allowing flexibility for different types of medical predictions. The Diabetes Prediction use case is just an example, and the protocol will be extended to support more complex models and computations as we continue development. This approach shows how privacy-preserving machine learning computations can be done securely on-chain using homomorphic encryption, solving the problem of sharing sensitive medical data while leveraging blockchain technology.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qy2us/screenshots/z9i2j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qy2us/screenshots/wxsum/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qy2us/screenshots/g57hw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Sinanpakkada/MediGuard",
        "link": "https://ethglobal.com/showcase/mediguard-qy2us"
    },
    {
        "title": "Eccount",
        "brief_description": "Smart Account (ERC-4337) that uses FHE to hide the owner of the Account",
        "long_description": "This project implements a privacy-enhanced Smart Account wallet based on ERC-4337, leveraging Fully Homomorphic Encryption (FHE) to validate wallet ownership. The key innovation is the ability to operate a smart account without revealing the owner's identity on-chain. By utilizing FHE, the wallet can perform encrypted ownership checks, allowing for secure transactions and account management while maintaining the privacy of the account holder. This approach combines the programmability and flexibility of smart contract wallets with the confidentiality benefits of homomorphic encryption, potentially opening new avenues for privacy-preserving blockchain applications. How its made:\nERC-4337 (Account Abstraction): This forms the foundation of the smart account functionality, allowing for improved user experience and flexibility in account management.\nFully Homomorphic Encryption (FHE): Utilized to encrypt the owner's address, enabling ownership validation without decrypting the data. This is implemented using the Fhenix protocol's FHE library.\nSolidity: The smart contracts are written in Solidity, with heavy use of the FHE library for encrypted operations.\nHardhat: Used as the development environment, providing tools for compiling, testing, and deploying smart contracts.",
        "how_its_made": "How its made:\nERC-4337 (Account Abstraction): This forms the foundation of the smart account functionality, allowing for improved user experience and flexibility in account management.\nFully Homomorphic Encryption (FHE): Utilized to encrypt the owner's address, enabling ownership validation without decrypting the data. This is implemented using the Fhenix protocol's FHE library.\nSolidity: The smart contracts are written in Solidity, with heavy use of the FHE library for encrypted operations.\nHardhat: Used as the development environment, providing tools for compiling, testing, and deploying smart contracts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zsztw/screenshots/26j0b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsztw/screenshots/dd5t8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsztw/screenshots/bhkhn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/alexandrecarvalheira/EccountAbstraction",
        "link": "https://ethglobal.com/showcase/eccount-zsztw"
    },
    {
        "title": "DELUSION",
        "brief_description": "A text/image-based simulation game where players challenge any reality. From economic models to whimsical scenarios, you create the world and watch it evolve based on your choices. No winners, just an ever-changing experience.",
        "long_description": "DELUSION is a text/image-based simulation game designed to let players explore, challenge, and shape any reality they can imagine. Powered by AI models like Mixtral and DALL\u00b7E, running on the Galadriel blockchain, the game offers a unique experience where players propose scenarios\u2014ranging from lighthearted, whimsical ideas to serious, real-world problems like economic models or global crises. Each player starts by writing a scenario of their choice, and DELUSION generates four options for how the scenario might unfold, plus a custom input option. The player's decisions affect various metrics, which track the evolution of their simulation over time. These metrics can represent anything from social, political, and economic indicators to more abstract measures like creativity or chaos. Unlike traditional games, DELUSION has no clear \"winners\" or \"losers.\" It\u2019s all about the journey and watching how the simulation changes with every interaction. Players can use the platform to test ideas, run hypothetical situations, or just enjoy the unpredictable outcomes of their creations. DELUSION also holds the potential for real-world applications. By simulating complex systems like economics or environmental policies, it allows users to model outcomes based on real-world data. As the project grows, there\u2019s room to incorporate collaborative multiplayer scenarios, real-time data integration, and even expand it into a 2D RPG-style experience for a more interactive, game-like feel. In essence, DELUSION merges entertainment and serious simulation, providing a platform for creative exploration, thoughtful experimentation, and even education. DELUSION was built using Next.js for the frontend. The backend is powered by Galadriel blockchain contracts, which govern the interactions between the player and the AI models, ensuring that each scenario is securely processed. One key innovation is blending the AI models to create a virtual Agent, who acts as the game\u2019s referee and guide. This Agent\u2014powered by Mixtral and DALL\u00b7E\u2014generates possible outcomes and visuals for each player\u2019s scenario, offering unique paths for the simulation to evolve. The Agent is also responsible for managing the game\u2019s internal logic and progression, making each interaction feel dynamic and alive. By utilizing blockchain, the AI\u2019s decisions and generated outcomes are securely logged, ensuring reliability and trust in the game\u2019s flow. One hacky aspect was integrating the AI models and blockchain to give the Agent control over the game\u2019s progression, making DELUSION a complete AI-driven experience.",
        "how_its_made": "DELUSION was built using Next.js for the frontend. The backend is powered by Galadriel blockchain contracts, which govern the interactions between the player and the AI models, ensuring that each scenario is securely processed. One key innovation is blending the AI models to create a virtual Agent, who acts as the game\u2019s referee and guide. This Agent\u2014powered by Mixtral and DALL\u00b7E\u2014generates possible outcomes and visuals for each player\u2019s scenario, offering unique paths for the simulation to evolve. The Agent is also responsible for managing the game\u2019s internal logic and progression, making each interaction feel dynamic and alive. By utilizing blockchain, the AI\u2019s decisions and generated outcomes are securely logged, ensuring reliability and trust in the game\u2019s flow. One hacky aspect was integrating the AI models and blockchain to give the Agent control over the game\u2019s progression, making DELUSION a complete AI-driven experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/im574/screenshots/mmbnn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/im574/screenshots/f5x83/default.jpg",
            "https://ethglobal.b-cdn.net/projects/im574/screenshots/82d9d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/im574/screenshots/nkkf3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/im574/screenshots/fdxoy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/im574/screenshots/n8935/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/mateodaza/delusion-app",
        "link": "https://ethglobal.com/showcase/delusion-im574"
    },
    {
        "title": "Pool",
        "brief_description": "Pool is an app that allows a group of people to share common expenses easily",
        "long_description": "We created Pool as a way to allow anyone to easily share common expenses together in a fun, easy, and simple way. Our idea is to have non-crypto native people utilize the benefits of blockchain without evening knowing they\u2019re using crypto. As respected figured in the community say: \u201cBring blockchain to people, not people to blockchain\u201d.\nTo be honest, we\u2019ve seen many ideas/products with a somewhat similar idea. However, it felt lacking in one way or another. Many apps offer payments or calculations alone, none that offer both. We are trying to solve this with pool in a fun and gamified experience.\nWeb3Auth is used for users to easily login with any web2 method and this will create a wallet for them behind the scenes.\nMoney will first be deposited into the pool by each member and a shared crypto wallet will be generated for the members of this specific pool to have access to. When the USD is deposited from the bank account( using chainlink functions that calls the plaid api), it is converted to USDC in that pool\u2019s wallet. Members can use apple pay to pay for anything the way they would normally pay for stuff when purchasing items. The fact that apple is allowing third party apps to utilize their NFC technology for apple pay is significant. This means that people can use our built in crypto wallet to pay for real life purchases through apple pay, alongside samsung/google pay.  Again, all this is done behind the scenes, which means that the users isn\u2019t dealing with anything crypto-related.\nEach purchase made by any member will be posted in the pool and deducted from the total pooled amount. That way it\u2019s equally deducted from everyone and simplifies the process greatly. If there\u2019s some money remaining in the pool after the trip or whatever the activity, it\u2019ll be equally split by the amount of users and the user can choose to keep their share in the app (their wallet) or withdraw back to their bank account.\nLayerzero is our choice of deployment. It offers us all the security, freedom, and ease we could ask for. We don\u2019t have to fully commit to a single blockchain and can utilize multiple easily. We will also make use of the gas fee estimator from Layerzero to help with calculating the micro fee that\u2019ll be taken from each transaction as well as select the best USEC network to swap into and from at different times to make it as cheap as possible for the user by routing the swap through the network that has the lowest gas fee.\nWe will integrate an in-app economy that incentives members to benefit the rest of the members. Actions like running the errands and making the necessary purchases are examples that can get members rewarded with tokens. These tokens could have many use cases, one of which is using them like in-game money to buy extras or show off trophies. Having the ability to have these tokens on different blockchains will only be beneficial.\nThank you very much and see you at the POOL party! We used next.js as the main framework and incorporated the Aceternity UI to provide the gamified feel. We used chainlink functions to call the plaid API to securely connect a bank account.\nLayerzero was the deployment layer of choice.\nWeb3Auth was used as the main login method and acts as a wallet to hold the user\u2019s money.",
        "how_its_made": "We used next.js as the main framework and incorporated the Aceternity UI to provide the gamified feel. We used chainlink functions to call the plaid API to securely connect a bank account.\nLayerzero was the deployment layer of choice.\nWeb3Auth was used as the main login method and acts as a wallet to hold the user\u2019s money.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/33bxn/screenshots/v5h20/default.jpg",
            "https://ethglobal.b-cdn.net/projects/33bxn/screenshots/3c1a1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/33bxn/screenshots/0o7tc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/HussamX98/Pool",
        "link": "https://ethglobal.com/showcase/pool-33bxn"
    }
]