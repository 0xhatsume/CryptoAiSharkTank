[
    {
        "title": "Versioned Walrus",
        "brief_description": "A lib based on walrus DB that supports the version control. A simple file system demo based on this versioned walrus lib.",
        "long_description": "This project involves the creation of a library built on top of WalrusDB, designed to provide robust version control functionality for document storage. The system utilizes WalrusDB as the underlying storage solution, while metadata is stored on the client side to track different versions of documents. Key Features:\nWalrusDB-Based Storage: The system uses WalrusDB to store contract files, ensuring data immutability and decentralized storage for long-term persistence. Version Control: Supports uploading different versions of the same contract, allowing agents to easily manage updates over time.\nPrevious versions of documents are tracked, allowing for easy navigation and auditability of historical changes.\nVersion control is handled at the metadata level, making it possible to skip uploading files that already exist to avoid redundancy.\nWhen a new version of a document is uploaded, the system automatically creates and links it as a new version, tracking the relationship between versions.\nContract Management: Agents can upload contracts onto WalrusDB, leveraging the version control system to manage multiple versions of a contract for clients.\nThe system allows agents and clients to sign a specific version of a document. Upon signing, a signature file is generated, which logs the action in the format: [addr] has signed [BlobID], providing cryptographic proof that a specific version has been signed by a particular party.\nSigning Workflow: Agents or clients can sign individual versions of documents, with the system automatically generating a signature file. This file contains details such as the signer\u2019s address and the BlobID of the signed document, ensuring traceability and proof of signature.\nUse Cases:\nContract Versioning: An agent can upload multiple versions of the same contract as needed, allowing for smooth management of changes over time. The system tracks all previous versions, ensuring complete transparency and traceability. Document Signing: Both agents and clients can sign specific versions of documents. The system generates signature metadata files that certify the signing event and provide an audit trail.",
        "how_its_made": "Key Features:\nWalrusDB-Based Storage: The system uses WalrusDB to store contract files, ensuring data immutability and decentralized storage for long-term persistence. Version Control: Supports uploading different versions of the same contract, allowing agents to easily manage updates over time.\nPrevious versions of documents are tracked, allowing for easy navigation and auditability of historical changes.\nVersion control is handled at the metadata level, making it possible to skip uploading files that already exist to avoid redundancy.\nWhen a new version of a document is uploaded, the system automatically creates and links it as a new version, tracking the relationship between versions.\nContract Management: Agents can upload contracts onto WalrusDB, leveraging the version control system to manage multiple versions of a contract for clients.\nThe system allows agents and clients to sign a specific version of a document. Upon signing, a signature file is generated, which logs the action in the format: [addr] has signed [BlobID], providing cryptographic proof that a specific version has been signed by a particular party.\nSigning Workflow: Agents or clients can sign individual versions of documents, with the system automatically generating a signature file. This file contains details such as the signer\u2019s address and the BlobID of the signed document, ensuring traceability and proof of signature.\nUse Cases:\nContract Versioning: An agent can upload multiple versions of the same contract as needed, allowing for smooth management of changes over time. The system tracks all previous versions, ensuring complete transparency and traceability. Document Signing: Both agents and clients can sign specific versions of documents. The system generates signature metadata files that certify the signing event and provide an audit trail.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/3btjd/screenshots/gn4tq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3btjd/screenshots/3ygam/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3btjd/screenshots/gjspm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/3btjd/screenshots/q68of/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wenlianglaw/versioned_walrus",
        "link": "https://ethglobal.com/showcase/versioned-walrus-3btjd"
    },
    {
        "title": "influencer swap",
        "brief_description": "Ai oracle swaps the influencer's photo onto brand's content. the influencer gets paid",
        "long_description": "Ai oracle swaps the influencer's photo onto brand's content. the influencer gets paid. \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\" layerzero to create omnichain nft, story's IP for licensing and for the influencer getting paid \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"",
        "how_its_made": "layerzero to create omnichain nft, story's IP for licensing and for the influencer getting paid \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zwff7/screenshots/3j1qp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zwff7/screenshots/8org0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zwff7/screenshots/yu0n1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kirilligum/story-protocol-boilerplate-sf24-sonft",
        "link": "https://ethglobal.com/showcase/influencer-swap-zwff7"
    },
    {
        "title": "Integration",
        "brief_description": "AI powered post-journey guide to serve theraphy clinics. \"Unlocking Lasting Insights, From Treatment to Transformation\"",
        "long_description": "Integration a revolutionary Web3 application designed to support individuals through the critical integration phase following a psychedelic experience. Harnessing the neuroplasticity triggered by psychedelics, this app provides a structured, self-guided journey to maximize personal growth and insight.\nBuilt on the robust MAPS (Multidisciplinary Association for Psychedelic Studies) psychological framework, Intergration ensures users follow scientifically-backed steps for effective integration. The app guides you through three core pillars: Intentional Preparation and Reflection, Holistic Integration into Daily Life, and Community Support and Ethical Practice.\nSecurity and privacy are paramount. Utilizing blockchain technology, all journal entries are encrypted and stored safely ensuring your most intimate reflections remain private and secure. Key features include: Customizable integration plans\nEncrypted journaling tools\nProgress tracking with tokenized rewards\nGuided meditation and mindfulness exercises\nCreative expression prompts\nCommunity support options\nEducational resources on psychedelic integration Whether you're processing insights, working through emotions, or implementing life changes, provides the structure and support you need. It's not just a journal; it's a comprehensive tool for transforming profound experiences into lasting positive change. Our project harnesses the power of cutting-edge AI, intuitive design, and adaptive functionality to create a truly revolutionary psychedelic integration experience: Claude AI: Leveraging advanced language models to provide personalized guidance, intelligent prompts, and adaptive content based on user input and progress. Claude's deep understanding of psychedelic experiences and integration practices ensures relevant, empathetic support throughout your journey.\nFigma-Crafted Interface: A meticulously designed user interface created in Figma, offering an intuitive, visually appealing experience. The design prioritizes ease of use, emotional resonance, and a calming aesthetic to support the integration process.\nDynamic Functionality: An adaptive system that evolves with your needs, offering personalized integration pathways, real-time adjustments to your plan based on your progress and feedback, and interactive elements that respond to your unique journey. This powerful combination creates a fluid, intelligent, and beautifully designed tool that adapts to your individual integration needs, making the process of translating profound insights into lasting change both effective and engaging.",
        "how_its_made": "Our project harnesses the power of cutting-edge AI, intuitive design, and adaptive functionality to create a truly revolutionary psychedelic integration experience: Claude AI: Leveraging advanced language models to provide personalized guidance, intelligent prompts, and adaptive content based on user input and progress. Claude's deep understanding of psychedelic experiences and integration practices ensures relevant, empathetic support throughout your journey.\nFigma-Crafted Interface: A meticulously designed user interface created in Figma, offering an intuitive, visually appealing experience. The design prioritizes ease of use, emotional resonance, and a calming aesthetic to support the integration process.\nDynamic Functionality: An adaptive system that evolves with your needs, offering personalized integration pathways, real-time adjustments to your plan based on your progress and feedback, and interactive elements that respond to your unique journey. This powerful combination creates a fluid, intelligent, and beautifully designed tool that adapts to your individual integration needs, making the process of translating profound insights into lasting change both effective and engaging.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xuj1k/screenshots/j5h08/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xuj1k/screenshots/tcng3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xuj1k/screenshots/0t157/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/matthew1809/integration",
        "link": "https://ethglobal.com/showcase/integration-xuj1k"
    },
    {
        "title": "Probana",
        "brief_description": "User Powered Prediction Market for Real-World Events on Flow Chain",
        "long_description": "Probana is a prediction market on flow that allows users to bet on anything. Users can create markets and set rules for those markets.  We created an order book from scratch that has limit orders, this allows people to queue up prices that they want to buy at, straight in the contract. The project uses Flow EVM as the chain we utilize this due to the extremely low block times and extremely affordable gas fees. In order to index the blockchain data we decided to use Alchemy subgraph feature. As our betting token we decided to use USDC because of its stable nature.",
        "how_its_made": "The project uses Flow EVM as the chain we utilize this due to the extremely low block times and extremely affordable gas fees. In order to index the blockchain data we decided to use Alchemy subgraph feature. As our betting token we decided to use USDC because of its stable nature.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sn7tu/screenshots/ubw3g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sn7tu/screenshots/n2nz3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sn7tu/screenshots/yhd31/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ElliotSlusky/Probana",
        "link": "https://ethglobal.com/showcase/probana-sn7tu"
    },
    {
        "title": "P3-FV",
        "brief_description": "Auto-generating formal verification specs from Plonky3 circuits",
        "long_description": "This project is an experimental devtool for more easily generating formal verification specs from existing Plonky3 circuits. First you extract the symbolic constraints from your Rust circuit and then pass it through a Python transpiler to output a Z3 Python program, which you use to run the Z3 solver. This project uses the Z3 theorem prover and Polygon's Plonky3 ZK framework. The Plonky3 framework has nice abstractions around building AIRs which was very beneficial for extracting the constraints before passing them through the Z3 transpiling pipeline in Python (for which Z3 has a far more ergonomic library than in Rust).",
        "how_its_made": "This project uses the Z3 theorem prover and Polygon's Plonky3 ZK framework. The Plonky3 framework has nice abstractions around building AIRs which was very beneficial for extracting the constraints before passing them through the Z3 transpiling pipeline in Python (for which Z3 has a far more ergonomic library than in Rust).",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/95jy3/screenshots/gzukb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/95jy3/screenshots/1tcwa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/95jy3/screenshots/pn8cu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/rpalakkal/p3-fv",
        "link": "https://ethglobal.com/showcase/p3-fv-95jy3"
    },
    {
        "title": "NBA MOMENTUM",
        "brief_description": "NBA Momentum is a strategy-driven trading card game that transforms NBA Top Shot moments into competitive, stats-based gameplay. Players build decks and compete by using real NBA moments with custom abilities.",
        "long_description": "NBA Momentum leverages NBA Top Shot\u2019s blockchain moments to create a trading card game where each moment becomes a playable card with attributes like offense, defense, and special abilities. Players build decks using various types of cards\u2014Player Moments, Hype, Playbook, Equipment, and Arena cards\u2014and engage in strategic gameplay to reach 21 points, simulating a fast-paced pickup basketball game. The game\u2019s innovation lies in its integration with Flow blockchain, giving players ownership over their moments while adding strategic layers through custom stats and abilities, making it a more immersive experience. NBA Momentum is built using the Flow blockchain and Cadence for smart contracts, enabling us to tokenize and add metadata to existing NBA Top Shot moments. We used Python scripts and the OpenAI API to dynamically generate custom stats for each moment, which is stored as metadata on the Flow network. The frontend uses React for a seamless user experience, allowing players to view their moment collections, build decks, and engage in card battles. Postman was used to interact with the NBA Top Shot API, and the game\u2019s backend utilizes Node.js to manage game logic and deck building.",
        "how_its_made": "NBA Momentum is built using the Flow blockchain and Cadence for smart contracts, enabling us to tokenize and add metadata to existing NBA Top Shot moments. We used Python scripts and the OpenAI API to dynamically generate custom stats for each moment, which is stored as metadata on the Flow network. The frontend uses React for a seamless user experience, allowing players to view their moment collections, build decks, and engage in card battles. Postman was used to interact with the NBA Top Shot API, and the game\u2019s backend utilizes Node.js to manage game logic and deck building.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9shz6/screenshots/bzqm6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9shz6/screenshots/5k7vs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9shz6/screenshots/9oy6z/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/bombfriedrice/nbamomentum",
        "link": "https://ethglobal.com/showcase/nba-momentum-9shz6"
    },
    {
        "title": "Engagemint",
        "brief_description": "Engagemint empowers users to earn, tokenize, and unlock rewards for their attention on their favorite artists and influencers. Mint unique tokens, track engagement, and redeem exclusive perks\u2014all in a Web3 ecosystem.",
        "long_description": "Engagemint is an Web3 platform designed to transform user engagement into a valuable currency. Engagemint enables users to earn, tokenize, and unlock exclusive rewards for their interactions with artists and influencers. Upon logging in, users are greeted with a personalized dashboard that displays metrics reflecting their engagement activity, such as time spent streaming specific artists or influencers. This data is essential for tracking progress and rewards. One of the platform's standout features is the influencer tokens, which users can browse to find various artists. These tokens are approved through a community voting process, ensuring users feel connected to the content they engage with. Community members can also propose new artist tokens, and once an artist receives 150 affirmative votes, a new token is minted through a Solidity smart contract on Skale\u2019s Calypso testnet. This process allows underground and emerging artists to gain visibility while providing users with a wider range of tokens to accumulate. As users engage with their favorite artists, they earn engagement points, which contribute to the minting of new tokens and can lead to exclusive perks. Additionally, users accumulate digital proof of their interactions, displayed as achievement collections, which serve as badges of loyalty and enhance the overall experience. The redemption page allows users to exchange their tokens for exclusive rewards, such as backstage passes and limited-edition merchandise, incentivizing ongoing interaction and loyalty. Engagemint fosters a sense of community by allowing users to participate in the decision-making process regarding which artists receive tokens. This collaborative approach not only enhances user satisfaction but also encourages fans to support their favorite artists, driving more engagement on the platform. Overall, Engagemint is revolutionizing the way fans and creators interact in the digital space, making engagement a rewarding experience and transforming casual listeners into invested community members. Whether you\u2019re a dedicated fan or an emerging artist, Engagemint makes it easy to be recognized and rewarded for your engagement. This project is deployed on the Skale Calypso Testnet and we implemented a voting system to that allow users to vote on new tokens. It also tracks how long people are spending on the applications to mint these tokens using a Solidity smart contract.The entire goal is to let creators get to advertise themselves and let fans of those creators get to promote themself",
        "how_its_made": "This project is deployed on the Skale Calypso Testnet and we implemented a voting system to that allow users to vote on new tokens. It also tracks how long people are spending on the applications to mint these tokens using a Solidity smart contract.The entire goal is to let creators get to advertise themselves and let fans of those creators get to promote themself",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/yffv6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/rpexa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/g2rni/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/9nygn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t6caw/screenshots/tem4n/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ssarahmou/engagemint",
        "link": "https://ethglobal.com/showcase/engagemint-t6caw"
    },
    {
        "title": "BlockLingo",
        "brief_description": "A decentralized protocol enabling direct asset transfers between different blockchains.",
        "long_description": "This image illustrates a cross-chain transfer protocol system, focusing on the user experience and the underlying technical process. At the top, we see a user interface represented by a wallet. The wallet shows the source (ETH) and destination (Layer 0 OTP) for a transfer. This represents the user's intent to move assets from one blockchain (Ethereum) to another (a Layer 0 protocol). The lower section of the image depicts the internal workings of the transfer system. The central component is labeled \"Main AI ORCHESTRATOR,\" which appears to be the core logic coordinating the entire process. Connected to this main orchestrator is a \"Translator\" module. This translator interacts with multiple blockchain networks: ETH (Ethereum), EURC (possibly a fictional or newer blockchain), EURC (another blockchain or network), and Layer 0 OTP (the destination chain from the user's perspective). The translator's role seems to be facilitating communication and transaction formatting between these different blockchain protocols. The flow suggests that when a user initiates a transfer, the main orchestrator processes the request, then utilizes the translator to interact with the necessary blockchains. This likely involves creating and verifying transactions on the source chain (ETH in this case), translating the asset or data into a format compatible with the destination chain, and then finalizing the transfer on the Layer 0 OTP network. The bottom of the image states \"Source reaches final destination,\" indicating the successful completion of the cross-chain transfer. This system appears designed to abstract away the complexity of cross-chain interactions from the user, providing a seamless experience for transferring assets between different blockchain networks, while handling the intricate details of protocol translation and transaction orchestration behind the scenes. The frontend is built in react, Coinbase SDK Wallet connect, Tailwind CSS. The backend is comprised of integrations between Metamask, Layer 0, Morph, and Solidity Smart Contracts. Layer 0 was a great benefit to the project as it helped us use hardhat and contracts to simplify our workflow.",
        "how_its_made": "The frontend is built in react, Coinbase SDK Wallet connect, Tailwind CSS. The backend is comprised of integrations between Metamask, Layer 0, Morph, and Solidity Smart Contracts. Layer 0 was a great benefit to the project as it helped us use hardhat and contracts to simplify our workflow.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9pf20/screenshots/bjezt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9pf20/screenshots/jp470/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9pf20/screenshots/ytduw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/U1tra-Labs/blockLingo",
        "link": "https://ethglobal.com/showcase/blocklingo-9pf20"
    },
    {
        "title": "ToneRight",
        "brief_description": "TuneRight is a web marketplace where artists and production companies trade music licensing as intellectual property. It empowers users to register their music, set licensing terms, manage royalties, and ensures the original artist is always credited and compensated.",
        "long_description": "Our web service acts as a marketplace where artists and production companies come to buy and sell licensing to their Music, which is their Intellectual Property. Our webspace allows users to register their music as Intellectual Property Assets, set personalized Licensing Terms and sell rights to their music without any human intervention or requirement of delegation. It also takes care of flow of royalties and makes sure that the original artist is always credited and compensated according to their own accord. The project leverages Story Protocol to streamline intellectual property management, licensing, and royalty distribution. It also integrates Dynamic to offer users an easy and seamless onboarding experience. Built with Next.js, Solidity, viem, and wagmi, the platform ensures a decentralized and efficient approach to music rights and usage.",
        "how_its_made": "The project leverages Story Protocol to streamline intellectual property management, licensing, and royalty distribution. It also integrates Dynamic to offer users an easy and seamless onboarding experience. Built with Next.js, Solidity, viem, and wagmi, the platform ensures a decentralized and efficient approach to music rights and usage.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xdj7q/screenshots/oouav/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xdj7q/screenshots/1m7qg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xdj7q/screenshots/9g5y7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xdj7q/screenshots/qr8tx/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sreekar9601/tone-right/",
        "link": "https://ethglobal.com/showcase/toneright-xdj7q"
    },
    {
        "title": "Build Villager",
        "brief_description": "An interface to write community benefits into intellectual patent acquisitions",
        "long_description": "Mint projects on Story that allow the use of derivatives access to rights within a community. One use case is if I write a novel and mint intellectual copyright on Story, I can allow some parts of the novel to be editable by the reader and others to be uneditable. I can also add multimedia patents such as music to add to the experience of the novel. Token holders of the parent novel and its derivatives can use those tokens to gain access to community events such as concerts, healthcare, and other benefits. Story's Proof of Creativity Protocol would be the origination and host of the parent intellectual properties. Then write the benefits into the individual copyrights during the minting. The ERC-20 tokens could have unique properties allowing easy access for downstream benefit recognition. The project gives token holders access to a community called Villager.",
        "how_its_made": "Story's Proof of Creativity Protocol would be the origination and host of the parent intellectual properties. Then write the benefits into the individual copyrights during the minting. The ERC-20 tokens could have unique properties allowing easy access for downstream benefit recognition. The project gives token holders access to a community called Villager.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qsadf/screenshots/gr1tk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qsadf/screenshots/4og5m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qsadf/screenshots/e5dvp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/eldarina/villager",
        "link": "https://ethglobal.com/showcase/build-villager-qsadf"
    },
    {
        "title": "APIWink",
        "brief_description": "APIWink at core is an API micro-lending service, ideal to attract more users and reduce costs. It's developed on Skale contracts, invisible custodial experience, Europa testnet and program money.",
        "long_description": "APIs traditionally have a monthly/yearly subscription models, for developers who want to just try out APIs for their application, this model becomes a rather costly option. We've developed a micro-lending service enabling devs to purchase \"number of API calls\" for Skale programmed money. This model not only charges per use, but also splits the money between us (the service providers) and creators (api creators). These people are welcome to join our marketplace, we have specially designed an SDK to attach to our eco-system along with robust documentation. The application is heavily centered around Skale, utilizing it's zero gas fees. It's present in our project in the following ways - Skale contracts, Invisible custodial experience, Europa testnet for DeFI and programmable monday. The backend and SDK are developed using python, frontent uses nextjs.\nWe have deployed the backend on render, docs on gitbook, MongoDb for database",
        "how_its_made": "The application is heavily centered around Skale, utilizing it's zero gas fees. It's present in our project in the following ways - Skale contracts, Invisible custodial experience, Europa testnet for DeFI and programmable monday. The backend and SDK are developed using python, frontent uses nextjs.\nWe have deployed the backend on render, docs on gitbook, MongoDb for database",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2ogub/screenshots/2fwif/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2ogub/screenshots/r2c4z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2ogub/screenshots/4wb7r/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ApiWink",
        "link": "https://ethglobal.com/showcase/apiwink-2ogub"
    },
    {
        "title": "Photo Booth",
        "brief_description": "Photo Booth is a fun tool that lets people take photos and add fun overlays including Nouns glasses and their ENS.",
        "long_description": "Photo Booth is a web application built with Next.js that allows users to take photos, add fun overlays including Nouns glasses and their ENS, and see all images uploaded by users from the same event. When you access this app you connect your wallet, then are able to take an photo with your webcam. We then allow you to add cool overlays like Noun glasses and your ENS. We also leverage walrus aggregator and publisher however it was down during the event. We built the project using Next.js and used libraries like wagmi. We let the user take photos and we created an upload route to upload images to Walrus and a route to get images from the walrus aggregator. We used partners like Walrus (for the images hostings), Nouns (for their IP and incorporating their IP in as overlays), ENS (we let users connect wallet and then add their ENS overlayed on the image). This help increase and promote Nouns and ENS visibility and adoption.",
        "how_its_made": "We built the project using Next.js and used libraries like wagmi. We let the user take photos and we created an upload route to upload images to Walrus and a route to get images from the walrus aggregator. We used partners like Walrus (for the images hostings), Nouns (for their IP and incorporating their IP in as overlays), ENS (we let users connect wallet and then add their ENS overlayed on the image). This help increase and promote Nouns and ENS visibility and adoption.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h1pz9/screenshots/b9t1t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h1pz9/screenshots/qpphk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h1pz9/screenshots/fqukd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h1pz9/screenshots/ikub1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jarrensj/photo-booth",
        "link": "https://ethglobal.com/showcase/photo-booth-h1pz9"
    },
    {
        "title": "zk-checkpoint",
        "brief_description": "ZK proofs for checkpointing on Polygon PoS to save on settlement gas and faster interop",
        "long_description": "Polygon PoS being one of the most used chains has a mechanism where it settles to Ethereum (L1) at regular intervals through checkpoints which is helpful for bridging. As a result, the consensus signatures are sent to L1 contract and signature verification for all validators is done on-chain. This incurs a lot of gas on ethereum and ~86% of total gas used is taken by signature verification for all validators (on mainnet, roughly 105). The costs gas go >250$ in case of high demand. This settlement workflow can be improved using ZK proofs which asserts that majority of validator set (>2/3) voted on a particular checkpoint. This can lead to 2 things: The project is made with the help of SP1, which allows to write the signature verification and validation logic in Rust and generate a proof out of it which can be verified on-chain. While the crux is pretty simple, there were lots of challenges while building this. Moreover, the circuit has certain strict constraints which eliminates the risk of prover generating false/fake proofs.",
        "how_its_made": "The project is made with the help of SP1, which allows to write the signature verification and validation logic in Rust and generate a proof out of it which can be verified on-chain. While the crux is pretty simple, there were lots of challenges while building this. Moreover, the circuit has certain strict constraints which eliminates the risk of prover generating false/fake proofs.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1humr/screenshots/3ciie/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1humr/screenshots/fhhp6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1humr/screenshots/h7ktj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/manav2401/zk-checkpoint",
        "link": "https://ethglobal.com/showcase/zk-checkpoint-1humr"
    },
    {
        "title": "bloq",
        "brief_description": "search on-chain data with a prompt, we enable users to search on-chain data and consume it in layman language",
        "long_description": "Using LlamaIndex with The Graph protocol for indexing and serving on-chain data, and then leveraging that with agentic RAG (Retrieval-Augmented Generation) LLMs is a powerful approach. This setup allows for intelligent, context-aware querying of blockchain data with the added benefit of AI-driven insights. We have used llama-index framework to semantically search on-chain data.Using LlamaIndex (formerly GPT Index) for semantically searching on-chain data is an innovative approach. It allows you to create more intelligent and context-aware searches of blockchain data. his setup allows for intelligent, context-aware querying of blockchain data with the added benefit of AI-driven insights.",
        "how_its_made": "We have used llama-index framework to semantically search on-chain data.Using LlamaIndex (formerly GPT Index) for semantically searching on-chain data is an innovative approach. It allows you to create more intelligent and context-aware searches of blockchain data. his setup allows for intelligent, context-aware querying of blockchain data with the added benefit of AI-driven insights.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9k8fv/screenshots/1qnvy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9k8fv/screenshots/1x1ns/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9k8fv/screenshots/qijwb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/DV0x/bloq",
        "link": "https://ethglobal.com/showcase/bloq-9k8fv"
    },
    {
        "title": "SecurityModuleForAA",
        "brief_description": "The user enabled Safe Guard with 2FA (via email) to protect the Smart Account from the risk of a compromised EOA key.",
        "long_description": "A traditional EOA wallet is vulnerable, as a single exposure of the private key can immediately put all assets at risk. Additionally, when managing a smart account through multi-signature, there is the inconvenience of requiring signatures above the threshold every time a transaction occurs. To address these issues, two accounts can be created to manage a single smart account. One account is attached to the smart account to manage transactions via a module, while the other serves as the owner of the smart account and handles signing responsibilities. This approach distributes responsibilities and enhances the user experience. The process is as follows: First, the user creates a smart wallet using their EOA. Simultaneously, they log into our app (SPOT) using another method or another EOA. In SPOT, they create a module that manages transactions and attach this module to the smart wallet created with the previous EOA. By doing so, the management of the smart account is divided into two (the module and the user's EOA), each managed through different methods. This ensures much stronger security than managing everything with a single private key. Since transactions are automatically handled according to the rules set in the module, the hassle of multiple signatures for every transaction is reduced. Furthermore, by incorporating advanced security measures like encryption oracles such as Lit Protocol, users can manage account security at a more sophisticated level (e.g., based on IP address). As more data accumulates, AI-powered fraud detection systems (FDS) can also be provided through the module, further enhancing security. This project implemented smart accounts and attached the appropriate module using Safe Wallet. To create a management point separate from the EOA, we onboarded users through SPOT by utilizing Dynamic.xyz. Additionally, to reduce gas fee conflicts during user onboarding, we used Alchemy's Account Kit and Paymaster to eliminate gas fees associated with creating modules and changing settings. Moving forward, we plan to provide modules that allow users to encrypt their IP addresses and specific actions using Lit Protocol, enabling privacy-preserving configuration.",
        "how_its_made": "This project implemented smart accounts and attached the appropriate module using Safe Wallet. To create a management point separate from the EOA, we onboarded users through SPOT by utilizing Dynamic.xyz. Additionally, to reduce gas fee conflicts during user onboarding, we used Alchemy's Account Kit and Paymaster to eliminate gas fees associated with creating modules and changing settings. Moving forward, we plan to provide modules that allow users to encrypt their IP addresses and specific actions using Lit Protocol, enabling privacy-preserving configuration.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/n7kyk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/9nycn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/iz60v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/mwcka/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ufcg7/screenshots/o3fpn/default.jpg"
        ],
        "live_demo": "https://ethglobal-24-sf.vercel.app/",
        "source_code": "https://github.com/PermissionLabs/ethglobal-24-sf",
        "link": "https://ethglobal.com/showcase/securitymoduleforaa-ufcg7"
    },
    {
        "title": "BenderBite",
        "brief_description": "AI Employee Bender: get AI advices based on previous winners, vote for other project and get prices and meet friends!",
        "long_description": "BenderBite is an AI-powered assistant designed to enhance the EthGlobal hackathon experience by serving as a virtual employee with multiple interactive features. Here's a detailed breakdown: Tailored Advice from Previous Winners: Users can receive tailored advice based on insights from previous hackathon winners.\nBender uses historical data to offer actionable suggestions on project development, presentation, and strategies for winning.\nProject Bidding and Rewards: Users can add projects to the platform using the XMTP bot and automatically receive an ENS domain through the ENS smart contract, along with a wallet created programmatically using Circle\u2019s wallet service.\nUsers can place bids on other projects during the hackathon.\nAutomated reward distribution is facilitated through the Circle API.\nSocial Networking and Collaboration: Bender helps users find friends and collaborate with others.\nIt enables networking by matching users with potential partners. I have integrated XMTP for seamless messaging capabilities, allowing users to communicate effectively within the platform. To provide tailored guidance, I\u2019ve utilized AI for context learning, drawing insights from previous hackathon winners to offer strategic advice on project development and presentation. For identity management, I\u2019ve implemented smart contracts that facilitate ENS subdomain registration, ensuring that users can establish their unique digital identities on the blockchain. Additionally, I\u2019ve incorporated Circle\u2019s programmable wallets API, enabling the automatic generation of secure wallets for users, as well as Circle\u2019s smart contract platform and used Circle for automated and transparent transaction processing, including bidding and reward distribution.",
        "how_its_made": "I have integrated XMTP for seamless messaging capabilities, allowing users to communicate effectively within the platform. To provide tailored guidance, I\u2019ve utilized AI for context learning, drawing insights from previous hackathon winners to offer strategic advice on project development and presentation. For identity management, I\u2019ve implemented smart contracts that facilitate ENS subdomain registration, ensuring that users can establish their unique digital identities on the blockchain. Additionally, I\u2019ve incorporated Circle\u2019s programmable wallets API, enabling the automatic generation of secure wallets for users, as well as Circle\u2019s smart contract platform and used Circle for automated and transparent transaction processing, including bidding and reward distribution.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/z2f7s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/6h54g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/dxvbh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/x19yj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/331m7/screenshots/s5mdj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wisemik/benderbite",
        "link": "https://ethglobal.com/showcase/benderbite-331m7"
    },
    {
        "title": "EssenSwap",
        "brief_description": "EssenSwap is a limit orderbook-based exchange built on the Essential blockchain.",
        "long_description": "In EssenSwap, the bids and asks are submitted as constraints, as required by Essential's declarative virtual machine. Every time there is a positive spread, an external solver bot is created that matches bids and asks and submits a solution to propose a new state of the system, viz., the updated balances of the bidders and askers. EssenSwap consists of three components: front-end, solver bot, and blockend. First, we deploy smart contracts for standard fungible token contracts currently available on Essential. Then, we deploy a unique smart contract for every bid and ask order, with predicates that impose constraints on the swap price of a trade. After that, we build a rust-based script that performs on-behalf of a solver by sorting, and then matching bids and asks orders. The final solution is then submitted to the Essential blockchain through their API. Once the rust script receives a confirmation receipt, it updates the front-end display.",
        "how_its_made": "EssenSwap consists of three components: front-end, solver bot, and blockend. First, we deploy smart contracts for standard fungible token contracts currently available on Essential. Then, we deploy a unique smart contract for every bid and ask order, with predicates that impose constraints on the swap price of a trade. After that, we build a rust-based script that performs on-behalf of a solver by sorting, and then matching bids and asks orders. The final solution is then submitted to the Essential blockchain through their API. Once the rust script receives a confirmation receipt, it updates the front-end display.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/qy5hd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/6rru4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/cw9at/default.jpg",
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/azcmt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/82ygd/screenshots/06nj9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jeffklinck/EthSF",
        "link": "https://ethglobal.com/showcase/essenswap-82ygd"
    },
    {
        "title": "Wilson:sound intents",
        "brief_description": "Execute, Attest, Validate, and Share Communicated data via agent-assisted contracts.",
        "long_description": "Bringing insights on chain, and generating value for data gatherings. Wilson is a toolset built on the Friend SDK that turns your voice into secure triggers for onchain actions. Simply pair your Omi, or other compatible wearable with your Omi app, add the Wilson extension, and tap the screen to complete the memory block whenever you want to process a command. Upon processing, Wilson will send the parsed statement to a server that will generate a response based on your trigger statement. If this is Friend SDK produces a prompt that is sent to a webhook parsed before being sent to an available DA layer, where the request is staged to produce a response from Dynamic for wallet info, or XMTP for external actions. All Dynamic responses return as Sign attestation, under a schema that allows recipient to authenticate the response if they wish the result to be onchain. Otherwise, the insights from the contributor's personal device are shared with the local network once they submit a 'register' command, then all further insights are contributed to local pool until insight stream is 'plugged'. While streaming your insights via Wilson, you can use your device to capture and cultivate local data, post, share, and challenge others from your personal onchain history, and generate new historic intents. Each change in permissions possible thanks to zk toolset from Polygon, and assignable via ENS retrieval contracts.",
        "how_its_made": "Friend SDK produces a prompt that is sent to a webhook parsed before being sent to an available DA layer, where the request is staged to produce a response from Dynamic for wallet info, or XMTP for external actions. All Dynamic responses return as Sign attestation, under a schema that allows recipient to authenticate the response if they wish the result to be onchain. Otherwise, the insights from the contributor's personal device are shared with the local network once they submit a 'register' command, then all further insights are contributed to local pool until insight stream is 'plugged'. While streaming your insights via Wilson, you can use your device to capture and cultivate local data, post, share, and challenge others from your personal onchain history, and generate new historic intents. Each change in permissions possible thanks to zk toolset from Polygon, and assignable via ENS retrieval contracts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/x147v/screenshots/ict2t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x147v/screenshots/tz4nr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x147v/screenshots/ahn5y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x147v/screenshots/4wqhx/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/paulman5/ETHGlobalSF",
        "link": "https://ethglobal.com/showcase/wilson-sound-intents-x147v"
    },
    {
        "title": "Real Lend",
        "brief_description": "Borrowers pledge real-world assets as collateral. An oracle sets the asset\u2019s value and posts a bond. Lenders provide loans with interest. If borrowers default, lenders sell the asset to the oracle to recover funds. Loans can also be sold early through Dutch auctions.",
        "long_description": "Real Lend bridges real-world assets (RWAs) with decentralized finance, allowing borrowers to unlock liquidity and lenders to earn yields. Borrowers pledge assets like vacation cottages as collateral, with an oracle setting the value and posting it as a bond to guarantee the lender\u2019s recovery. Lenders provide loans (e.g., 100k USDC at 10% interest) based on the asset's value. If the borrower repays, they reclaim the asset; if not, the lender recovers funds by selling the asset to the oracle at the bonded value. Lenders can exit early by selling their loan position through a Dutch auction, which starts at a high price and drops until purchased. Pools on protocols like Morpho improve liquidity, ensuring a smooth, secure, and flexible lending experience for both parties. We built a decentralized protocol for real-world asset lending using Solidity smart contracts and the Foundry toolkit. Our core components include USDC.sol for managing loan payments, Cottage.sol to tokenize real estate collateral like vacation homes, and Protocol.sol to oversee loan issuance, repayments, and defaults. An oracle sets asset values and posts bonds, ensuring lenders are protected by guaranteeing recovery if borrowers default. In such cases, lenders can recover their funds by selling the assets to the oracle at the bonded value. To offer flexibility, we implemented a Dutch auction mechanism in DutchAuction.sol, allowing lenders to exit their loan positions early by dynamically selling them as prices adjust over time. We streamlined deployment using Foundry tools such as forge and automated the process with custom Bash scripts for contract deployment and verification. Anvil was used to fork the Ethereum mainnet locally, creating realistic test environments that simulated live network conditions. This setup allowed us to efficiently identify and resolve issues before deployment. Our automation framework ensured a seamless and repeatable workflow, making the development process smooth and scalable from testing through deployment.",
        "how_its_made": "We built a decentralized protocol for real-world asset lending using Solidity smart contracts and the Foundry toolkit. Our core components include USDC.sol for managing loan payments, Cottage.sol to tokenize real estate collateral like vacation homes, and Protocol.sol to oversee loan issuance, repayments, and defaults. An oracle sets asset values and posts bonds, ensuring lenders are protected by guaranteeing recovery if borrowers default. In such cases, lenders can recover their funds by selling the assets to the oracle at the bonded value. To offer flexibility, we implemented a Dutch auction mechanism in DutchAuction.sol, allowing lenders to exit their loan positions early by dynamically selling them as prices adjust over time. We streamlined deployment using Foundry tools such as forge and automated the process with custom Bash scripts for contract deployment and verification. Anvil was used to fork the Ethereum mainnet locally, creating realistic test environments that simulated live network conditions. This setup allowed us to efficiently identify and resolve issues before deployment. Our automation framework ensured a seamless and repeatable workflow, making the development process smooth and scalable from testing through deployment.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/11w4v/screenshots/74sjp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11w4v/screenshots/tnvd3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11w4v/screenshots/6suru/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/mergd/reallend-ui",
        "link": "https://ethglobal.com/showcase/real-lend-11w4v"
    },
    {
        "title": "Omi FM",
        "brief_description": "Decentralized music player, let smart contracts take care of creating the vibes.",
        "long_description": "AI powered Dapp that plays curated music for you based on the conversations analyzed by Omi. DApp created using Omi SDK for conversation analysis with its AI models. UI/UX is command line, using Python and Solidity to communication with Smart Contracts deployed to Skale, Flow, and Avail. Those contracts contain the logic for creating playlists and getting new songs. DApp created using Omi SDK for conversation analysis with its AI models. UI/UX is command line, using Python and Solidity to communication with Smart Contracts deployed to Skale, Flow, and Avail. Those contracts contain the logic for creating playlists and getting new songs. ZK rollups handle bulk song creation off chain.",
        "how_its_made": "DApp created using Omi SDK for conversation analysis with its AI models. UI/UX is command line, using Python and Solidity to communication with Smart Contracts deployed to Skale, Flow, and Avail. Those contracts contain the logic for creating playlists and getting new songs. ZK rollups handle bulk song creation off chain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/i6xxx/screenshots/jyupj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/i6xxx/screenshots/24xk4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/i6xxx/screenshots/g16q8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Derricks-DApps/Omi-FM",
        "link": "https://ethglobal.com/showcase/omi-fm-i6xxx"
    },
    {
        "title": "Block-Jack 21",
        "brief_description": "I have build a multiplayer Blackjack game on the blockchain with one smart contract using Phoenix Solidity for data encryption and privacy. Web3.js and React with Tailwind CSS will handle the UI for smooth player interaction.",
        "long_description": "I have deployed a multiplayer Blackjack game on the blockchain using a single smart contract that integrates the Phoenix Solidity library for encrypting sensitive data. The smart contract handles the entire game logic, including dealing cards, tracking bets, and determining winners, while ensuring that private information like players\u2019 hands remains secure and hidden. This setup allows players to trust that the game operates fairly and securely on the blockchain. The front-end of the game connects to the blockchain using web3.js or ethers.js, while the interface itself is built using React and styled with Tailwind CSS for a user-friendly and visually appealing experience. Players can join games, place bets, and view results in real-time, with the blockchain managing all interactions in the background. The use of Phoenix encryption guarantees that private data is never exposed on the public ledger, adding an extra layer of security, which is crucial for a blockchain-based game. This project balances the transparency of blockchain with the privacy needed for multiplayer gaming, offering a secure and fair platform for players. I started with creating the smart contracts using solidity, Fhenix (FOH.sol) hardhat, and then deployed on sepolia for testing. Then, created the frontend with reactJS and Tailwind. At the end, used Helium PoW Faucet to get the tokens for Fhenix testnet and deploying the smart contract over there.",
        "how_its_made": "I started with creating the smart contracts using solidity, Fhenix (FOH.sol) hardhat, and then deployed on sepolia for testing. Then, created the frontend with reactJS and Tailwind. At the end, used Helium PoW Faucet to get the tokens for Fhenix testnet and deploying the smart contract over there.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t68nv/screenshots/37dcm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t68nv/screenshots/0ent9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t68nv/screenshots/too3b/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/saniddhyaDubey/BlockJack-21",
        "link": "https://ethglobal.com/showcase/block-jack-21-t68nv"
    },
    {
        "title": "Rhizome",
        "brief_description": "Rhizome Markets is a synthetics protocol built on the Rootstock EVM. Rhizome enhances capital efficiency and risk diversification with multicollateralization, allowing users to engage in hedging, yield farming, and collateralized debt positions directly on Rootstock.",
        "long_description": "A Bitcoin synthetics protocol allows users to create and trade synthetic assets\u2014tokens that represent and track the value of other assets like fiat currencies, commodities, or equities\u2014while using Bitcoin as collateral. With Rhizome, Bitcoin holders can participate on complex financial activities such as hedging, yield farming, and CDPs directly on the Rootstock EVM. Capital Efficiency Through Multicollateralization of rhUSD\nSynthetics, primarily the rhUSD dollar pegged instance deployed as an example of the Rootstock EVM mainnet, offers multicollateral support for collateralizing rhUSD, which offers significant advantages: Capital Efficiency: Utilizing multiple assets (rBTC, RIF, USDRIF, ETHs) as collateral allows for more efficient use of capital, enabling users to leverage a broader asset base.\nRehypothecation: Assets used as collateral can be rehypothecated, meaning they can be used simultaneously in multiple financial operations, enhancing liquidity.\nEcosystem: Promotes interoperability within the Rootstock DeFi ecosystem, increasing the utility of various tokens.\nMulticollateralization of assets with rBTC also allows a singular efficient pool of collateral to mint multiple synthetic assets on top of the pool. Additionally, relying solely on Bitcoin as collateral exposes the system to Bitcoin's price volatility. This can be mitigated with stablecoins or more stable assets in the multicollateral pool for all rh synthetics. Liquidation Risks: Sharp declines in Bitcoin's price can trigger collateral liquidations, destabilizing the system.\nOver-Collateralization: Users may need to provide excessive collateral to safeguard against volatility, reducing capital efficiency.\nRisk Diversification: The volatility of Bitcoin can be offset by the stablecoins, by default decreasing risk compared to a purely BTC collateralized CDP protocol.\nStability: A diversified collateral pool enhances the stability of the synthetic stablecoin and decreasing the risk of liquidation for debt positions, maintaining its peg more effectively.\nStabilizers\nStabilizers are multiple modules in the Rhizome protocol that strengthen the peg price for minted rh synthetic assets. For instance, each synthetic can have it's own Peg Stability Modules (PSM) based on the MakerDAO DAI-USDC PSM with various customizations to the swap fee. In the case of rhUSD, the alternative asset to rhUSD would be rUSDT, the fiat stablecoin with the largest dominance on Rootstock at 34.44%. Additionally, as utilized by MakerDAO and Inverse, the amount of synthetics can be controlled by governance or an administrator address through increasing and decreasing the liquidity of mintable synthetics. In these deployed contracts, only a US-dollar pegged synthetic, rhUSD, has been deployed, but any synthetic can be deployed as long as there is a secure oracle for the asset on Rootstock EVM. In the case for rhUSD, the price is hardcoded at 1. This project was based on the Compound v2 lending markets and heavily modified to support synthetic assets, but the synthetics protocol relies on stabilizers, which are optimized modules to keep the theoretical price of Rhizome synthetic assets. The entirety of the contracts were made used with Solidity, and integrated major Rootstock ecosystem tokens such as rBTC, rUSDT, RIF, and USDRIF in the code. The contract deployments were configured to use Umbrella Network oracles for rBTC/rUSDT prices, and were deployed on Rootstock mainnet as well to support all these assets.",
        "how_its_made": "This project was based on the Compound v2 lending markets and heavily modified to support synthetic assets, but the synthetics protocol relies on stabilizers, which are optimized modules to keep the theoretical price of Rhizome synthetic assets. The entirety of the contracts were made used with Solidity, and integrated major Rootstock ecosystem tokens such as rBTC, rUSDT, RIF, and USDRIF in the code. The contract deployments were configured to use Umbrella Network oracles for rBTC/rUSDT prices, and were deployed on Rootstock mainnet as well to support all these assets.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/1a0t5/screenshots/8hk52/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1a0t5/screenshots/hzv84/default.jpg",
            "https://ethglobal.b-cdn.net/projects/1a0t5/screenshots/sj3xr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/in70/rhizome-protocol/",
        "link": "https://ethglobal.com/showcase/rhizome-1a0t5"
    },
    {
        "title": "Kiss Or Slap 2.0",
        "brief_description": "A gamified mobile social app that people can earn under prisoner's dilemma",
        "long_description": "Kiss or Slap is a gamified dating app where users make strategic decisions in a fun social experience based on game theory's prisoner's dilemma. Players engage with each other by choosing either a \"Kiss\" or a \"Slap.\" The outcomes vary: The app has an onboarding process where users create profiles, upload live photos, and link their social media accounts to earn initial points. Users can browse a feed resembling Tinder, view profiles, and see if others have interacted with them. A hot score and karma system reflect user engagement and behavior, with scores visible on profiles. Tech Stack:\nnextjs + prisma Sponsor used:\n@walrus for all image upload and hosting in the app\n@coinbase-sdk for MPC wallet Payout, User Onramp\n@polygon gas-less rail for onramp with USDC Onramp, In app purchase\n@flow Onramp, In App purchase for user want extra rewards\n@privy for login & user identity management\n@circle USDC for in-app payment/payout",
        "how_its_made": "Tech Stack:\nnextjs + prisma Sponsor used:\n@walrus for all image upload and hosting in the app\n@coinbase-sdk for MPC wallet Payout, User Onramp\n@polygon gas-less rail for onramp with USDC Onramp, In app purchase\n@flow Onramp, In App purchase for user want extra rewards\n@privy for login & user identity management\n@circle USDC for in-app payment/payout",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/hyi4i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/5kqpn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/b4yxa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/o87d7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/h54i0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5yxze/screenshots/2mvu2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/yayashuxue/kissorslap-ethsf2024",
        "link": "https://ethglobal.com/showcase/kiss-or-slap-2-0-5yxze"
    },
    {
        "title": "artist-popup",
        "brief_description": "Short Description: A decentralized platform for artist pop-up events, enabling artists to mint NFTs for their physical artwork and attendees to collect digital assets with exclusive content",
        "long_description": "The Artist Pop-Up NFT Platform is an innovative decentralized application that connects artists, attendees, and event organizers by combining physical pop-up art events with digital NFT technology. This platform allows artists to showcase their artwork and create NFTs that represent their pieces, giving collectors and attendees the opportunity to own unique digital collectibles linked to exclusive content. Using MetaMask, users can securely connect and interact with the platform, including minting new NFTs, transferring ownership, and accessing special content. Revised Replit Instructions for Artist Pop-Up Event with NFT Integration We\u2019re simplifying the process for developing your artist pop-up event application, focusing on security, user experience, and reducing complexity by leveraging MetaMask for all user interactions\u2014including admins, artists, and attendees. Here\u2019s a comprehensive guide to set up and deploy your app on Replit, incorporating what we\u2019ve learned so far. Step 1: Set Up the Replit Project Create a New Replit Project: Install Required Dependencies: Add Environment Variables: Step 2: Hardhat Local Deployment for Smart Contract Write the NFT Smart Contract: Deploy the Contract Using Hardhat: Step 3: Implement MetaMask Wallet Interactions Add MetaMask Login Functionality: Use MetaMask for Admin and User Actions: Step 4: Build a Unified Dashboard Create a Role-Based Dashboard (dashboard.html): Show/Hide Features Based on Role: Step 5: Exclusive Content Using Lit Protocol Set Up Exclusive Content Encryption: Front-End Interaction: Step 6: Testing and Deployment on Replit Test the Interaction Flow: Deploy on Replit: Step 7: No API Required for Sign Protocol Key Security Practices Summary\nThe entire app\u2014including Admin, Artist, and Attendee roles\u2014operates securely using MetaMask for authentication and blockchain transactions. Hosting on Replit is focused on the front-end, while smart contracts are managed securely using Hardhat and MetaMask to ensure a consistent, user-friendly experience without compromising security.",
        "how_its_made": "Revised Replit Instructions for Artist Pop-Up Event with NFT Integration We\u2019re simplifying the process for developing your artist pop-up event application, focusing on security, user experience, and reducing complexity by leveraging MetaMask for all user interactions\u2014including admins, artists, and attendees. Here\u2019s a comprehensive guide to set up and deploy your app on Replit, incorporating what we\u2019ve learned so far. Step 1: Set Up the Replit Project Create a New Replit Project: Install Required Dependencies: Add Environment Variables: Step 2: Hardhat Local Deployment for Smart Contract Write the NFT Smart Contract: Deploy the Contract Using Hardhat: Step 3: Implement MetaMask Wallet Interactions Add MetaMask Login Functionality: Use MetaMask for Admin and User Actions: Step 4: Build a Unified Dashboard Create a Role-Based Dashboard (dashboard.html): Show/Hide Features Based on Role: Step 5: Exclusive Content Using Lit Protocol Set Up Exclusive Content Encryption: Front-End Interaction: Step 6: Testing and Deployment on Replit Test the Interaction Flow: Deploy on Replit: Step 7: No API Required for Sign Protocol Key Security Practices Summary\nThe entire app\u2014including Admin, Artist, and Attendee roles\u2014operates securely using MetaMask for authentication and blockchain transactions. Hosting on Replit is focused on the front-end, while smart contracts are managed securely using Hardhat and MetaMask to ensure a consistent, user-friendly experience without compromising security.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8tqgc/screenshots/fxwf3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8tqgc/screenshots/ynvg0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8tqgc/screenshots/q5hui/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/devsodhirao/ArtConnectNFT",
        "link": "https://ethglobal.com/showcase/artist-popup-8tqgc"
    },
    {
        "title": "EZLaunch",
        "brief_description": "A platform for launching meme tokens with an innovative trading curve that optimizes liquidity and token price discovery. Users can easily mint and trade meme tokens, while the enhanced curve ensures better liquidity dynamics, fostering a smoother trading experience.",
        "long_description": "Our platform revolutionizes the meme token space by introducing an improved trading curve that outperforms traditional bonding curves. This curve ensures better liquidity management, providing users with an efficient and more balanced token trading experience. Meme token creators can easily launch their tokens, while traders benefit from improved price discovery mechanisms that stabilize market activity. The platform is designed to make token minting and trading accessible and intuitive, catering to the ever-growing meme economy and offering tools to ensure market sustainability. This project was built using Solidity for smart contract development, leveraging the Uniswap v4 framework to implement custom hooks and an enhanced custom trading curve.\nThis curve ensures better liquidity management, providing users with an efficient and more balanced token trading experience. Meme token creators can easily launch their tokens, while traders benefit from improved price discovery mechanisms that stabilize market activity. The platform is designed to make token minting and trading accessible and intuitive, catering to the ever-growing meme economy and offering tools to ensure market sustainability.",
        "how_its_made": "This project was built using Solidity for smart contract development, leveraging the Uniswap v4 framework to implement custom hooks and an enhanced custom trading curve.\nThis curve ensures better liquidity management, providing users with an efficient and more balanced token trading experience. Meme token creators can easily launch their tokens, while traders benefit from improved price discovery mechanisms that stabilize market activity. The platform is designed to make token minting and trading accessible and intuitive, catering to the ever-growing meme economy and offering tools to ensure market sustainability.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/p1gfa/screenshots/aj4rb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/p1gfa/screenshots/nxexn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/p1gfa/screenshots/aknx3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/DMomot/EZLaunch",
        "link": "https://ethglobal.com/showcase/ezlaunch-p1gfa"
    },
    {
        "title": "RPFT",
        "brief_description": "RPFT stands for Royalty Points Fungible Token is like transfer Royaltypoints of one brands to another one",
        "long_description": "the basic idea is to get Brand A and Brand B collab with each other and once they collab the user from Band A and Brand B should be able to transfer Points from one Brand to another one. and user/consumer should be able to use that points to redeem the things which he wants to buy. This Project mostly uses the LayerZero's standards contract since we assumed that different brand might have their own chain some day with RoyaltyPoint in the smartcontract. smartcontract are developed for EVM on solidity and Test on HardHat using LayerZero CLI.\nsince I have used LayerZero technology it gave me so easy and smooth transaction of messages from one Layer to another Layer. with their builtin CLI hardhat testing.",
        "how_its_made": "This Project mostly uses the LayerZero's standards contract since we assumed that different brand might have their own chain some day with RoyaltyPoint in the smartcontract. smartcontract are developed for EVM on solidity and Test on HardHat using LayerZero CLI.\nsince I have used LayerZero technology it gave me so easy and smooth transaction of messages from one Layer to another Layer. with their builtin CLI hardhat testing.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jygem/screenshots/5n7yy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jygem/screenshots/hux8s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jygem/screenshots/0vy6n/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Nishchit-Dev/EthGlobal-RPFT.git",
        "link": "https://ethglobal.com/showcase/rpft-jygem"
    },
    {
        "title": "Earnify",
        "brief_description": "An all-in-one platform that helps aspiring influencers earn instantly by completing brand tasks, while enabling companies to boost engagement and advertise effectively through real people.",
        "long_description": "A comprehensive platform that empowers aspiring influencers to earn instantly by completing tasks for brands, while helping companies boost engagement and promote their projects through real people.\nWe utilize dynamic wallet creation, account abstraction, task verification, and secure data handling to deliver a seamless experience. This project utilizes the dynamic wallet for account abstraction and onboarding new users to web3. We also leverage the LIT protocol for encrypting/decrypting and running verification tasks in LIT actions. The sign protocol is used to attest the verified task and store information. Finally, we utilize the Coinbase developer pack to create an instant payment system for quick payouts.",
        "how_its_made": "This project utilizes the dynamic wallet for account abstraction and onboarding new users to web3. We also leverage the LIT protocol for encrypting/decrypting and running verification tasks in LIT actions. The sign protocol is used to attest the verified task and store information. Finally, we utilize the Coinbase developer pack to create an instant payment system for quick payouts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/nbo5u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/57vuu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/t49qv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/mpwvm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4hks7/screenshots/whj5t/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shubhank-saxena/eth-sf-submission",
        "link": "https://ethglobal.com/showcase/earnify-4hks7"
    },
    {
        "title": "Loop",
        "brief_description": "Loop is an onchain platform for reinforcement learning with human feedback (RLHF)",
        "long_description": "Loop is an onchain platform for reinforcement learning with human feedback (RLHF). Developers or corporate teams can upload models from HuggingFace (by submitting a link) and issue cryptocurrency bounties for crowdsourcing output validation. Users can sign in via web3 wallet (or web2 social platforms) and utilize the chat interface for regular functionality (i.e., writing essays), while being prompted to validate outputs. These prompts thereby disseminate the crypto rewards, effectively creating a Validate-to-Earn model. Subsequently, the prompts, outputs, and users' scores are stored off-chain in a dataset, accessible to the devs/teams behind the associated model. On the front-end, we built a responsive interface using React.js, implementing custom hooks for state management and modular components for content display and user interactions. Tailwind CSS provided a utility-first styling approach that dramatically accelerated our development cycle, while thirdweb's SDK facilitated seamless wallet connections and blockchain interactions across multiple networks. We deployed our front-end to Vercel. The back-end infrastructure centers around Foundry-developed smart contracts, meticulously unit tested and deployed for multi-chain usage. We've successfully deployed these contracts across nine different testnet environments: Polygon, Hedera, Neon EVM, Zircuit, Story, AirDAO, Rootstock, Morph, Unichain, and Story testnets. For AI processing, we leveraged HuggingFace's model hub to deploy both Llama 3.1 8B and Mixtral 8x-7B models, fine-tuned on our custom dataset. We leveraged Prime Intellect for decentralized GPU orchestration, allowing us to run LLM inference across distributed compute providers like Akash and RunPod during preliminary testing. Firebase serves as our human-verified dataset repository, chosen for its real-time database capabilities and seamless integration with our scoring system.",
        "how_its_made": "On the front-end, we built a responsive interface using React.js, implementing custom hooks for state management and modular components for content display and user interactions. Tailwind CSS provided a utility-first styling approach that dramatically accelerated our development cycle, while thirdweb's SDK facilitated seamless wallet connections and blockchain interactions across multiple networks. We deployed our front-end to Vercel. The back-end infrastructure centers around Foundry-developed smart contracts, meticulously unit tested and deployed for multi-chain usage. We've successfully deployed these contracts across nine different testnet environments: Polygon, Hedera, Neon EVM, Zircuit, Story, AirDAO, Rootstock, Morph, Unichain, and Story testnets. For AI processing, we leveraged HuggingFace's model hub to deploy both Llama 3.1 8B and Mixtral 8x-7B models, fine-tuned on our custom dataset. We leveraged Prime Intellect for decentralized GPU orchestration, allowing us to run LLM inference across distributed compute providers like Akash and RunPod during preliminary testing. Firebase serves as our human-verified dataset repository, chosen for its real-time database capabilities and seamless integration with our scoring system.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yjppn/screenshots/z946j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yjppn/screenshots/4yhr2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yjppn/screenshots/j67sm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shreybirmiwal/eth-sf",
        "link": "https://ethglobal.com/showcase/loop-yjppn"
    },
    {
        "title": "splitoon",
        "brief_description": "imagine giving ai access to your venmo account (real) (they could never)",
        "long_description": "imagine: you and your friends go out to eat and near the end, the bill comes. your friends all don't want to front the bill and neither do you. why? it's a hassle, you're out 30 bucks until they venmo you back. even worse, you have to keep reminding them to pay you or you might completely forget that you paid for this meal (unwillingly) and pretend they are on top of things and pay you your share right there and then. venmo will take 3-5 biz days to settle in your bank account as you definitely aren\u2019t paying them 3% to get your funds quicker. screw that. so let\u2019s leverage crypto and base to ensure you get your share of funds right as you spend it. ex: get paid by your friends before your uber gets here or split your dinner bill before the waiter takes your card. we want to empower ai with mpc wallets so that you can enable your favorite ai agent to manage your crypto wallet and send/transfer funds as you need.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/s5j5c/screenshots/vjkgk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s5j5c/screenshots/dmsha/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s5j5c/screenshots/ifg2k/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/mrbrianhobo/splitoon",
        "link": "https://ethglobal.com/showcase/splitoon-s5j5c"
    },
    {
        "title": "SuperTweets",
        "brief_description": "Do Crypto Transactions on your Twitter Feed - Now on any chain!",
        "long_description": "Project Description: This project is designed to tackle one of the most significant barriers to Web3 adoption\u2014its poor user experience. Most decentralized applications (DApps) have interfaces that are difficult and intimidating for everyday users, creating a significant gap between potential users and the opportunities that Web3 can offer. Both creators and consumers miss out on the potential of decentralized technologies because they are restricted to unfamiliar, isolated platforms. Our solution bridges this gap by allowing users to conduct crypto transactions, such as minting NFTs, making wagers, selling assets, and collecting tips, directly on the platforms where they already spend most of their time. This approach minimizes friction, creating a seamless experience by integrating crypto functionalities into familiar environments like their Twitter feed. Meeting Users Where They Are:\nOne of the keys to unlocking mainstream Web3 adoption is integrating it into the platforms where users already spend their time. Most users are not willing to switch between multiple apps or platforms, especially if they don\u2019t understand the complex blockchain processes behind the scenes. Social media, in particular, is a huge untapped frontier for crypto and blockchain adoption. By bringing crypto functionality to popular social platforms like Twitter, users can easily interact with blockchain features in a setting they are already comfortable with, removing the learning curve and making the process as intuitive as possible. This \u201cmeet-the-user-where-they-are\u201d approach will help drive both consumer and creator adoption, allowing them to seamlessly participate in Web3 without needing to leave their everyday platforms. As social media continues to evolve, it represents the next major frontier for Web3 growth, where digital ownership, peer-to-peer transactions, and decentralized assets can thrive naturally. Problem: Web3 has poor UX: Despite its potential, Web3 is hindered by complicated interfaces and systems that deter average users.\nMost DApps are intimidating to use: Decentralized apps often have steep learning curves, which limits their adoption by a broader audience.\nMissed opportunity for creators and consumers: Both groups miss out on the potential of Web3 technologies because the platforms they are familiar with do not support seamless integration of crypto functionalities.\nSolution: Meet the user where they are: Rather than forcing users to navigate entirely new platforms, we enable them to interact with blockchain functionalities on the platforms they already use every day\u2014whether that\u2019s social media, e-commerce, or content creation platforms.\nEnable Crypto transactions effortlessly: Users can easily mint NFTs, make wagers, sell digital assets, or even collect tips without leaving the environment they are comfortable with. This creates a smooth, user-friendly gateway to blockchain technology.\nOne more thing: Solana\u2019s Blinks integration was promising, but limited: Solana\u2019s Blinks allowed for some interaction within its ecosystem, but the limitation was that it only supported Solana, and the ecosystem was very closed. Therefore we built this as an add-on that leverages Blinks\u2019 infrastructure, but instead of being confined to one blockchain, it supports all major chains, creating a truly decentralized and interoperable solution. This enables a much wider range of users to participate, across multiple blockchains, without being restricted by ecosystem boundaries. The core of this project revolves around creating a seamless integration between social media content and blockchain transactions. We built a Chrome extension that interacts directly with the user's Twitter feed. The extension uses the Blinks SDK to dynamically replace standard links within tweets with interactive \"SuperTweets\" that allow users to engage in blockchain-based activities like minting NFTs, tipping creators, and more, all without leaving the platform. When a user wants to conduct a transaction, they can easily connect their wallet through the Wallet Context Providers injected by MetaMask. By leveraging MetaMask\u2019s environment, users gain access to all Ethereum Virtual Machine (EVM) compatible chains, meaning they can interact with a wide variety of blockchains, making it a truly decentralized experience. What\u2019s particularly innovative about this setup is the way we handle the interactions. The Blinks SDK gives us the infrastructure to support a high-speed experience, while the MetaMask integration ensures compatibility with every EVM chain. This combination provides a frictionless and familiar experience for users, allowing them to engage in Web3 activities directly on their Twitter page without needing to jump between different platforms or learn new interfaces. THE HARD PART: Was making MetaMask work with all the chains using the browser inject provider also building multiple actions for every chain!",
        "how_its_made": "The core of this project revolves around creating a seamless integration between social media content and blockchain transactions. We built a Chrome extension that interacts directly with the user's Twitter feed. The extension uses the Blinks SDK to dynamically replace standard links within tweets with interactive \"SuperTweets\" that allow users to engage in blockchain-based activities like minting NFTs, tipping creators, and more, all without leaving the platform. When a user wants to conduct a transaction, they can easily connect their wallet through the Wallet Context Providers injected by MetaMask. By leveraging MetaMask\u2019s environment, users gain access to all Ethereum Virtual Machine (EVM) compatible chains, meaning they can interact with a wide variety of blockchains, making it a truly decentralized experience. What\u2019s particularly innovative about this setup is the way we handle the interactions. The Blinks SDK gives us the infrastructure to support a high-speed experience, while the MetaMask integration ensures compatibility with every EVM chain. This combination provides a frictionless and familiar experience for users, allowing them to engage in Web3 activities directly on their Twitter page without needing to jump between different platforms or learn new interfaces. THE HARD PART: Was making MetaMask work with all the chains using the browser inject provider also building multiple actions for every chain!",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/urhdz/screenshots/5vteo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/urhdz/screenshots/vjcrs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/urhdz/screenshots/v7frg/default.jpg"
        ],
        "live_demo": "https://ethactions.vercel.app/",
        "source_code": "https://github.com/Rishabhjava/ethactions",
        "link": "https://ethglobal.com/showcase/supertweets-urhdz"
    },
    {
        "title": "ReadyVU",
        "brief_description": "SaaS platform for Teleradiology, remote reporting tools for medical Imaging for various stake holders",
        "long_description": "A few emerging tools are trying to offer useful and practical solutions for Radiology houses, Hospitals, etc., who are in real need of Solutions where they can outsource radiology writing expertise to remotely skilled doctors.\nCurrent situation have many urging needs from patients\u2019 point of view;\n1- specialized radiologists exist in specific cities, lowering the quality of healthcare given to people living outside capital cities\n2- cost and time involved by travelling doctors, travelling patients and thier famililes\n3- untimely report writing, you may have you exam performed and then wait a day or two, in many place it can easily get longer\nAlso apparently problem does affect hospital businesses, radiologist looking to work conveniently remotely, and more free market, etc. Challenges;\nPatient Privacy\nRegulations compliance, HIPAA, ONC,\nQA processes involved, insurance requirements\nNo \u201cone size fits all\u201d for workflow models in different business sizes, geographical areas, specialty level etc.\ncloud/on prem restrictions etc.\nIT experitise need to mainatin such systems are not generlly available\nIT expertise needed from health care providers themsleves, doctors, nurses etc.\nLegacy systems, sometimes from the 80s\u2019\nVarying requirements for compensating  and managing workforce , remote freelance payment models, etc.\nNeed to negotiate and setup long list of custom tools for various stakeholders involved\nMedical imaging has its own \u201cfile\u201d formats, for different kinds of modality and usages\nMedical imaging has a protocol not based http, cannot work with most of common software backend stacks directly, DICOM, HL7, IHE profiles etc. Solution\nReadyVU aim to be a decentralized, healthcare compliant platform for doctors to be able to view medical images and write radiology reports remotely,\nOnly Radiology center need to know about crypto or have a special setup - little as it is but still;\nOn Boarding new Doctors does not require them installing any special software, be that for crypto or medical imaging special software Hospital user story;\nHospital sets up it own infrastructure or have it through a certified partner\nHospital sponsors fees, sets up regulatory compliant workflows using standard business process modeling tools\nUpon receiving images for radiology modalities, its routed to preselected / newly certified doctors. Doctor user story;\nReceive shared document link\naccepts , goes to google doc\nSee info as per need basis\nopen medical images from within google doc, again no special software\nLogs in to the viewer using his google login, no browser extension wallets,etc.\nWrites findings, add images and annotations etc.\nSignal finishing the report when done Similar user stories for all other parties involved, no special tools, see info as per need basis.\nSystem is not hardcoded to public clouds, user can move to a fully decentralized self governed experience when he needs to Technology components in action; bmpn.io, Business process standard modeling tools to model and enforce business compliance\nConvert business process model and deploy as a Pint contract to essential network\nDICOM router to receive studies from radiology machines, CTs, PET, MRIs etc.\nHigh scalable PACS system to store images, for short periods, or commonly 5 to  7 years\nSecure function to dispatch workflow upon recieving a patient study, run as a LIT protocol action\nDiffernet google documents are shared from same template, set by various requirements, like dr pref, business, exam type etc.\nUser logs in to Flow network, using his google login, through Dynamic wallet social login\nGoogle docs have embedded scripts to talk to TEE LIT Action, to get information assinged to each individual user\nRadiologist opens CornerStone DICOM viewer, from inside google docs, adds annotations, take images, write findings etc.\nRadiologist finishes\nQA approves doc\nReport is sent to patient and referring doctor\nThe above workflow is enforced from Essential network using Pint contract generated from workflow",
        "how_its_made": "Technology components in action; bmpn.io, Business process standard modeling tools to model and enforce business compliance\nConvert business process model and deploy as a Pint contract to essential network\nDICOM router to receive studies from radiology machines, CTs, PET, MRIs etc.\nHigh scalable PACS system to store images, for short periods, or commonly 5 to  7 years\nSecure function to dispatch workflow upon recieving a patient study, run as a LIT protocol action\nDiffernet google documents are shared from same template, set by various requirements, like dr pref, business, exam type etc.\nUser logs in to Flow network, using his google login, through Dynamic wallet social login\nGoogle docs have embedded scripts to talk to TEE LIT Action, to get information assinged to each individual user\nRadiologist opens CornerStone DICOM viewer, from inside google docs, adds annotations, take images, write findings etc.\nRadiologist finishes\nQA approves doc\nReport is sent to patient and referring doctor\nThe above workflow is enforced from Essential network using Pint contract generated from workflow",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/q3p2s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/vx6x5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/957d6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/tdgnf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yc4hu/screenshots/djw30/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/melnaquib/ReadyVU",
        "link": "https://ethglobal.com/showcase/readyvu-yc4hu"
    },
    {
        "title": "GovernEase",
        "brief_description": "GovernEase is a cross-chain DAO tooling platform that simplifies DAO creation. It enables users to configure governance, manage tokens, and select voting methods through a seamless interface, allowing quick and efficient setup across multiple blockchains.",
        "long_description": "GovernEase is an innovative cross-chain DAO tooling platform that simplifies the creation and management of decentralized autonomous organizations (DAOs). Traditionally, setting up a DAO involves a complex process of coding, testing, and deployment. GovernEase streamlines this workflow, allowing users to create a DAO quickly and effortlessly by filling out a user-friendly form. One of the standout features of GovernEase is its support for quadratic voting, a unique governance mechanism that enhances fairness in decision-making by giving members more voting power on issues that matter most to them. This innovative approach fosters more democratic and nuanced governance within the DAO. GovernEase also excels in its cross-chain capabilities, enabling the seamless transfer of DAO data between different blockchains. For example, I successfully managed to send DAO data from the Sepolia testnet to the Polygon Cardano testnet, demonstrating the platform's versatility and interoperability across blockchain ecosystems. In addition to these core features, GovernEase offers various functionalities that enhance user experience and collaboration. DAO members can upload and store files directly within the DAO\u2019s storage, facilitating easy access to important documents and resources. Communication among members is also made simple through an integrated chat feature, promoting engagement and collaboration within the community. Furthermore, GovernEase leverages SKALE's sFuel distribution, allowing for zero gas fee transactions. This ensures that users can interact with the DAO without worrying about transaction costs, making the platform more accessible and user-friendly. Overall, GovernEase stands out not only for its cross-chain capabilities but also for its unique voting mechanism and a comprehensive set of features designed to empower users in managing their DAOs efficiently and effectively. At the heart of GovernEase are two key features: zero gas fee transactions and cross-chain capabilities. By utilizing SKALE, users can engage with the DAO without incurring any gas fees, greatly enhancing both accessibility and user satisfaction. Additionally, I successfully bridged DAO data from the Sepolia testnet to the Polygon Cardano testnet using the Unified Bridge (Agglayer), highlighting the platform\u2019s ability to operate seamlessly across multiple blockchain networks. The project leverages a comprehensive tech stack that ensures smooth functionality and an intuitive user interface: Frontend Development: The user interface for GovernEase is built with Next.js, a powerful React framework that supports server-side rendering and static site generation for optimal performance. To create a sleek and responsive design, I incorporated Chakra UI, a versatile and accessible component library that facilitates rapid UI development. Smart Contract Development: The backbone of GovernEase consists of smart contracts written in Solidity. These contracts are deployed and verified across various testnets, including Sepolia, Polygon Cardano, the EVM Flow testnet, and the SKALE Calypso hub. This multi-network deployment empowers users to interact with the DAO on any of these networks, ensuring flexibility and accessibility. Storage Solutions: For handling images and files uploaded by DAO members, I utilized Lighthouse. This decentralized storage service guarantees that files are stored securely and can be easily accessed by users within the DAO. Blockchain Integration: To seamlessly connect the frontend with the deployed smart contracts, I employed Ether.js and Wagmi. Ether.js offers a robust library for Ethereum blockchain interactions, while Wagmi streamlines the integration of React applications with Ethereum-based smart contracts, simplifying the development process. User Onboarding: To provide a smooth wallet connection experience, I implemented Rainbow Kit. This library makes it easy for users to connect their wallets to the application, which is essential for interacting with the DAO. Enhanced User Features: GovernEase also includes additional functionalities that foster collaboration among DAO members, such as integrated file storage and a chat feature for real-time communication. By combining these technologies and tools, GovernEase presents a powerful, user-friendly platform for creating and managing DAOs. The integration of zero gas fees, cross-chain capabilities, innovative voting mechanisms, and efficient user onboarding solidifies GovernEase as a pioneering solution in the blockchain landscape.",
        "how_its_made": "At the heart of GovernEase are two key features: zero gas fee transactions and cross-chain capabilities. By utilizing SKALE, users can engage with the DAO without incurring any gas fees, greatly enhancing both accessibility and user satisfaction. Additionally, I successfully bridged DAO data from the Sepolia testnet to the Polygon Cardano testnet using the Unified Bridge (Agglayer), highlighting the platform\u2019s ability to operate seamlessly across multiple blockchain networks. The project leverages a comprehensive tech stack that ensures smooth functionality and an intuitive user interface: Frontend Development: The user interface for GovernEase is built with Next.js, a powerful React framework that supports server-side rendering and static site generation for optimal performance. To create a sleek and responsive design, I incorporated Chakra UI, a versatile and accessible component library that facilitates rapid UI development. Smart Contract Development: The backbone of GovernEase consists of smart contracts written in Solidity. These contracts are deployed and verified across various testnets, including Sepolia, Polygon Cardano, the EVM Flow testnet, and the SKALE Calypso hub. This multi-network deployment empowers users to interact with the DAO on any of these networks, ensuring flexibility and accessibility. Storage Solutions: For handling images and files uploaded by DAO members, I utilized Lighthouse. This decentralized storage service guarantees that files are stored securely and can be easily accessed by users within the DAO. Blockchain Integration: To seamlessly connect the frontend with the deployed smart contracts, I employed Ether.js and Wagmi. Ether.js offers a robust library for Ethereum blockchain interactions, while Wagmi streamlines the integration of React applications with Ethereum-based smart contracts, simplifying the development process. User Onboarding: To provide a smooth wallet connection experience, I implemented Rainbow Kit. This library makes it easy for users to connect their wallets to the application, which is essential for interacting with the DAO. Enhanced User Features: GovernEase also includes additional functionalities that foster collaboration among DAO members, such as integrated file storage and a chat feature for real-time communication. By combining these technologies and tools, GovernEase presents a powerful, user-friendly platform for creating and managing DAOs. The integration of zero gas fees, cross-chain capabilities, innovative voting mechanisms, and efficient user onboarding solidifies GovernEase as a pioneering solution in the blockchain landscape.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/k2cc0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/7ofon/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/9cqv0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/zg6td/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/ymyby/default.jpg",
            "https://ethglobal.b-cdn.net/projects/17pde/screenshots/7zxad/default.jpg"
        ],
        "live_demo": "https://ethsf-seven.vercel.app/",
        "source_code": "https://github.com/Sohamkayal4103/ETHSF",
        "link": "https://ethglobal.com/showcase/governease-17pde"
    },
    {
        "title": "FlowBets",
        "brief_description": "A transparent, crowdsourced sports betting platform on Flow's network utilizing smart contracts",
        "long_description": "This project uses a combination of smart contracts and web2 frontend frameworks to design a onchain betting application that allows users to wage predictions on sports games, specifically football (NFL). We deployed smart contracts on Flow's testnet and enabled wallet integration. Users can also see the average price, their shares, and potential returns per bet. Additionally, we integrated a chatting feature where users on the platform can communicate regarding bets. For this project, we used Solidity smart contracts deployed on Flow's testnet through hardhat. For the frontend, we utilized Next.js with shadcn components and rainbowkit for wallet integration. We used wagmi to connect the backend with the frontend. We implemented the odds by using a crowdsourcing model where the probability of an event happening was equivalent to the amount of money bet for this event. People's willingness to bet on an outcome directly correlates to the odds for that event.",
        "how_its_made": "For this project, we used Solidity smart contracts deployed on Flow's testnet through hardhat. For the frontend, we utilized Next.js with shadcn components and rainbowkit for wallet integration. We used wagmi to connect the backend with the frontend. We implemented the odds by using a crowdsourcing model where the probability of an event happening was equivalent to the amount of money bet for this event. People's willingness to bet on an outcome directly correlates to the odds for that event.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/9gfsz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/uft1h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/bqeag/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shrithan1/betflow",
        "link": "https://ethglobal.com/showcase/flowbets-u48sh"
    },
    {
        "title": "FlowBets",
        "brief_description": "A transparent, crowdsourced sports betting platform on Flow's network utilizing smart contracts",
        "long_description": "This project uses a combination of smart contracts and web2 frontend frameworks to design a onchain betting application that allows users to wage predictions on sports games, specifically football (NFL). We deployed smart contracts on Flow's testnet and enabled wallet integration. Users can also see the average price, their shares, and potential returns per bet. Additionally, we integrated a chatting feature where users on the platform can communicate regarding bets. For this project, we used Solidity smart contracts deployed on Flow's testnet through hardhat. For the frontend, we utilized Next.js with shadcn components and rainbowkit for wallet integration. We used wagmi to connect the backend with the frontend. We implemented the odds by using a crowdsourcing model where the probability of an event happening was equivalent to the amount of money bet for this event. People's willingness to bet on an outcome directly correlates to the odds for that event.",
        "how_its_made": "For this project, we used Solidity smart contracts deployed on Flow's testnet through hardhat. For the frontend, we utilized Next.js with shadcn components and rainbowkit for wallet integration. We used wagmi to connect the backend with the frontend. We implemented the odds by using a crowdsourcing model where the probability of an event happening was equivalent to the amount of money bet for this event. People's willingness to bet on an outcome directly correlates to the odds for that event.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/9gfsz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/uft1h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/u48sh/screenshots/bqeag/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shrithan1/betflow",
        "link": "https://ethglobal.com/showcase/flowbets-u48sh"
    },
    {
        "title": "PixelProof",
        "brief_description": "A Web Platform for Image Authenticity Verification Using Zero-Knowledge Proofs",
        "long_description": "In today\u2019s digital world, the ability to create, modify, and distribute visual content has become more accessible than ever. With advancements in artificial intelligence (AI), it\u2019s now possible to manipulate images in ways that are nearly undetectable to the human eye. AI-driven tools like deepfakes, image generators, and sophisticated photo-editing software have made it easy to alter or fabricate images that appear authentic. While these technologies offer creative and practical benefits, they also present serious challenges\u2014especially in terms of trust, authenticity, and misinformation. Also in today\u2019s social media-driven world, digital content spreads faster than ever. Unfortunately, false information and tampered images can go viral just as quickly as the truth. Whether it\u2019s fake news, altered photos of public figures, or images designed to mislead audiences, the potential for misinformation to have real-world consequences is significant. Pixel-Proof is a cutting-edge web platform that leverages zero-knowledge proofs (ZKPs) to allow users to verify the authenticity and integrity of digital images without exposing the actual content of the image. The platform provides a privacy-preserving method for determining whether an image has been modified or tampered with, ensuring users can verify the origin and authenticity of their images securely and efficiently. Using advanced cryptographic techniques, particularly ZKPs, the platform allows users to generate proofs of image integrity, proving whether an image is identical to the original version or has undergone changes\u2014without revealing the image itself. This is particularly useful for industries such as media, law enforcement, content verification, and intellectual property management, where proving image authenticity is crucial. Image Authentication verification\nThe platform allows users to capture the photo, edit the photo at which zkProof will be created which basically attests the photo whether the image was edited or not.\nThe interface has an option to upload the image where users can upload the edited image and verify whether the image was altered or not along with it\u2019s history. Zero-Knowledge Proofs (ZKPs) for Privacy\nBy utilizing ZKPs, the platform proves the integrity of the image without revealing its content to the verifier. This preserves the privacy of sensitive images while enabling secure verification.\nVerifiers can check the proof to validate the authenticity of the image without ever seeing the original image. Seamless Web-Based Interface\nPixelProof offers an intuitive and user-friendly web interface where users can easily upload images, generate proofs, and share the proof for verification. Secure Proof Sharing\nAs proof will be stored on-chain, any user from other chain can do the verification Image Capture\nUsers can capture an image on our platform. This will capture the metadata and allow the user to download that image.\nImage Edit\nUsers can select their captured photo and edit the image accordingly. Currently we have only supported grayscale operation because of the time constraints.\nUsing zero-knowledge proof techniques, proof for that edited image will be generated at the end of edit operation and the cryptographic proof is stored on-chain so anyone can use that proof and verify that image.\nEdited Image Upload\nUsers can upload the edited image to verify whether the image was modified or not. At this moment, proof will be verified against the original image and results will be given to the user. The history for that edited image will also be given to the user.\nAs soon as the proof is validated, the user will be shown the results of the verification and the user can see the series of edits on that original image if it was done on the Pixel-Proof platform. Our project, PixelProof, is a novel application of zero-knowledge proofs to verify various image conversions without revealing the original images. Here's a breakdown of how we built it: Circom: We used Circom, a domain-specific language for building zero-knowledge circuits. Circom allowed us to define the constraints for our grayscale verification process in a clear, declarative manner. snarkjs: This JavaScript library was crucial for generating and verifying zero-knowledge proofs based on our Circom circuits. Node.js: We leveraged Node.js for our backend processing, particularly for generating input data from images. canvas: This Node.js library was essential for image processing, allowing us to extract pixel data from both color and grayscale images. Circom Circuit (no_round.circom`): Input Generator (generate_grayscale_inputs.js): Proof Generation and Verification: Precision Handling: One of the trickiest parts was dealing with floating-point precision in grayscale calculations. We implemented a remainder system in our circuit to account for small discrepancies between calculated and given grayscale values. Scale Matching: We had to carefully manage the scale of our calculations. In the Circom circuit, we work with values scaled up by 100 to avoid floating-point operations, which aren't supported in Circom. Efficient Constraint Writing: Writing efficient constraints in Circom was crucial for keeping the proving time reasonable. We optimized our circuit to minimize the number of constraints while maintaining accuracy. This project demonstrates the powerful combination of zero-knowledge proofs and image processing, opening up new possibilities for privacy-preserving image verification systems.",
        "how_its_made": "Our project, PixelProof, is a novel application of zero-knowledge proofs to verify various image conversions without revealing the original images. Here's a breakdown of how we built it: Circom: We used Circom, a domain-specific language for building zero-knowledge circuits. Circom allowed us to define the constraints for our grayscale verification process in a clear, declarative manner. snarkjs: This JavaScript library was crucial for generating and verifying zero-knowledge proofs based on our Circom circuits. Node.js: We leveraged Node.js for our backend processing, particularly for generating input data from images. canvas: This Node.js library was essential for image processing, allowing us to extract pixel data from both color and grayscale images. Circom Circuit (no_round.circom`): Input Generator (generate_grayscale_inputs.js): Proof Generation and Verification: Precision Handling: One of the trickiest parts was dealing with floating-point precision in grayscale calculations. We implemented a remainder system in our circuit to account for small discrepancies between calculated and given grayscale values. Scale Matching: We had to carefully manage the scale of our calculations. In the Circom circuit, we work with values scaled up by 100 to avoid floating-point operations, which aren't supported in Circom. Efficient Constraint Writing: Writing efficient constraints in Circom was crucial for keeping the proving time reasonable. We optimized our circuit to minimize the number of constraints while maintaining accuracy. This project demonstrates the powerful combination of zero-knowledge proofs and image processing, opening up new possibilities for privacy-preserving image verification systems.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/exdzo/screenshots/vrovk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/exdzo/screenshots/b47u2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/exdzo/screenshots/99sex/default.jpg",
            "https://ethglobal.b-cdn.net/projects/exdzo/screenshots/bnyrs/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shyam-patel-kira/pixelProof",
        "link": "https://ethglobal.com/showcase/pixelproof-exdzo"
    },
    {
        "title": "PintAuction",
        "brief_description": "A Dutch auction platform written in Pint, Essential's DSL for declarative smart contracts, focused on logic rather than execution.",
        "long_description": "A Dutch auction platform written in Pint, Essential's DSL for declarative smart contracts, focused on logic rather than execution. The users can mint new currency, transfer currency via the essential-wallet. The users can create auctions from item_id, owner and initial_cost, since it is a Dutch based auction platform, the right to lower the cost of the auction item depends solely on the owner and owner can use the step-auction using item_id, decrease_amount. Once a bidder places bid higher than the cost of the item, and respective validity constraints meet, the amount is deducted from the bidder, and awarded to the owner and the state changes and new owner of the item becomes the bidder. The auction is also marked as closed and the earliest bidder gets the ownership. The smart contracts are written in Pint, and the CLI is written in rust(taking essential-contributions/token example) as a base. The frontend is written in next.js and there is also a small python server that eases the interaction between the frontend and provides the details of all the items i.e item_id, owner, auction_active status, cost. It is deployed on the test-net \"https://bigbangblock.builders\".",
        "how_its_made": "The smart contracts are written in Pint, and the CLI is written in rust(taking essential-contributions/token example) as a base. The frontend is written in next.js and there is also a small python server that eases the interaction between the frontend and provides the details of all the items i.e item_id, owner, auction_active status, cost. It is deployed on the test-net \"https://bigbangblock.builders\".",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jpwjo/screenshots/acrsa/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jpwjo/screenshots/dfujy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jpwjo/screenshots/p9vjy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jpwjo/screenshots/6m4ur/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/0xn4utilus/PintAuction",
        "link": "https://ethglobal.com/showcase/pintauction-jpwjo"
    },
    {
        "title": "Bet",
        "brief_description": "An accountability app to share goals with your friends. put your money where your mouth is",
        "long_description": "Share your goals with friends and set up a system of accountability. You create a goal and place a financial stake as motivation. If you complete the goal, your friends must attest to your success. If they don\u2019t verify the accomplishment within the set time, you forfeit the stake. This encourages commitment by putting real value on your progress. Whether it's personal or professional, the system ensures you stay motivated, with rewards for follow-through or a financial loss if you don't succeed. This app is developed using Solidity as the primary smart contract language. I had initially planned to integrate Sign Protocol for handling the peer attestations, which would have allowed for decentralized verification of goals and claims. Unfortunately, due to time constraints and the complexity of the integration process, I wasn't able to incorporate it before the deadline. However, adding this feature in the future would greatly enhance the functionality and ensure a more robust and decentralized attestation process.",
        "how_its_made": "This app is developed using Solidity as the primary smart contract language. I had initially planned to integrate Sign Protocol for handling the peer attestations, which would have allowed for decentralized verification of goals and claims. Unfortunately, due to time constraints and the complexity of the integration process, I wasn't able to incorporate it before the deadline. However, adding this feature in the future would greatly enhance the functionality and ensure a more robust and decentralized attestation process.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/nqbcs/screenshots/9wrv2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nqbcs/screenshots/hiu28/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nqbcs/screenshots/zb2gn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/finessevanes/bet",
        "link": "https://ethglobal.com/showcase/bet-nqbcs"
    },
    {
        "title": "Socialfly",
        "brief_description": "A decentralized social app where you store your encrypted data once and then use it across multiple apps",
        "long_description": "This project combines Sign protocol with Lit protocol to create the foundation of a social networking app. Data is encrypted using Lit, and then stored using Sign.  Sign's attestations ensure that a user's data is associated with their account. Sign's schemas and indexing are combined to let us define data in a way that lets us efficiently query for it. The schema is used as the identifier for a certain piece of data that could be used for a social app (example: profile_photo_001, bio_short, location, etc.), and the data can be arbitrary - it can be a photo, some text about a user, or structured data such as a location. Using Lit's access controls, we're able to give specific apps (which are ultimately Lit actions) permission to decrypt our data.  From here the data can be used in creative ways, to demonstrate this I created two basic apps: The first is a centralized messageboard where user's data is just used to gain access to the ability to post on the messageboard, it's fundamentally a centralized service but via reusing a user's profile data it lowers the friction of starting to use the app. The second is a matching app where users can swipe through profiles, and connect with people nearby.  User's encrypted location data is decrypted inside a lit action, and the rest of their profile is only decrypted if they're close enough to the user's location.  The app never has access to user data, it only facilitates making the connections. Lit and Sign are used.  Lit is used for encrypting data, Lit actions are used for decrypting the data, and Sign is used for storing the data.  Sign's schemas are used to represent particular types of data, while Sign's query functionality is used to efficiently access the data that's relevant for a given app. Note that there are actually four repos associated with this project: Repo for creating/managing user account\nhttps://github.com/tms7331/socialfly-account Repo for gating access control based on an IPFS hash\nhttps://github.com/tms7331/socialfly-contracts Repo for example app 1  - public messageboard\nhttps://github.com/tms7331/socialfly-messageboard Repo for example app 2 - privacy preserving networking app\nhttps://github.com/tms7331/socialfly-matching",
        "how_its_made": "Lit and Sign are used.  Lit is used for encrypting data, Lit actions are used for decrypting the data, and Sign is used for storing the data.  Sign's schemas are used to represent particular types of data, while Sign's query functionality is used to efficiently access the data that's relevant for a given app. Note that there are actually four repos associated with this project: Repo for creating/managing user account\nhttps://github.com/tms7331/socialfly-account Repo for gating access control based on an IPFS hash\nhttps://github.com/tms7331/socialfly-contracts Repo for example app 1  - public messageboard\nhttps://github.com/tms7331/socialfly-messageboard Repo for example app 2 - privacy preserving networking app\nhttps://github.com/tms7331/socialfly-matching",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qa3o7/screenshots/a2e8d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qa3o7/screenshots/odyh6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qa3o7/screenshots/cabiq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/tms7331/socialfly-account",
        "link": "https://ethglobal.com/showcase/socialfly-qa3o7"
    },
    {
        "title": "Web3Warfare",
        "brief_description": "An IRL laser tag game with onchain components and fun. Place bounties on adverseries, mint powerup NFTs, and win the space race!",
        "long_description": "Web3Warfare is an immersive, real-life laser tag game that merges physical action with the innovative possibilities of blockchain technology. Players engage in thrilling laser tag battles, equipped with real-world hardware components like laser guns, sensors, and 3D-printed gear. These hardware elements track player performance, hits, and gameplay metrics in real time. What sets Web3Warfare apart is its integration of on-chain components. The game leverages blockchain for player stats, rewards, and progression tracking. Each player's achievements, game results, and in-game assets are stored on-chain, creating a permanent and tamper-proof record of their performance. This also enables players to own unique in-game assets, such as special abilities or gear, represented as NFTs, which can be earned, traded, or sold. The hardware ensures that every shot, hit, and movement in the physical world is accurately reflected in the game's digital ecosystem, combining the excitement of laser tag with the innovation of Web3 technology. How It's Made: Web3Warfare Web3Warfare is built with a blend of blockchain technologies, hardware, and software integration. Here's how it all comes together: Smart Contract Architecture: The game uses a custom-built factory design pattern smart contract, managing duels and payout logic. This contract is deployed across multiple blockchain networks including SKALE, Flow, Zircuit, and Ethereum mainnet. The factory design pattern allows for scalable and efficient deployment of new duels, with automated logic governing payouts and challenge results. Each duel is governed by blockchain rules, ensuring transparency and immutability. Frontend Development: The game's frontend is developed using React, hosted on Vercel for fast deployment and scalability. For user wallet onboarding, Dynamic is used, allowing seamless integration of blockchain wallets directly into the frontend experience. This ensures players can easily manage their on-chain interactions like asset ownership and game data. Hardware Integration: The physical components of Web3Warfare are built around an ESP32 module acting as the brain of each laser blaster. The hardware setup includes a breadboard, infrared LED, and code developed in Arduino IDE to manage the interactions between the laser blasters and the game. Each ESP32 module contains an embedded wallet with the firmware, thanks to Dynamic, which enables direct blockchain interaction from the physical devices. On-Chain Authentication: To guarantee the authenticity of in-game data being written to the blockchain, Web3Warfare uses Sign Protocol's schema hooks. A custom whitelist address contract is implemented, allowing only approved laser blasters to write data. Each laser blaster is whitelisted to ensure only genuine hardware can sign and submit events to the blockchain. Since the ESP32 module serves as a smart wallet, each device is the sole owner of its private key, preventing unauthorized devices from participating. Embedded Wallets & Signing: The ESP32 modules act as both the game\u2019s sensor and its on-chain identity, with embedded wallets stored within the firmware. This design allows each laser blaster to sign blockchain transactions directly, securing game events and ensuring the only valid signing devices are the blasters themselves. By flashing the wallets and private keys onto the hardware, the game eliminates the need for external signing mechanisms. Notable Hacks: One particularly hacky aspect of this project is embedding private key functionality directly into the ESP32 modules, allowing each blaster to function as a fully operational smart wallet. This allows for direct interaction with the blockchain from the physical game world, creating a seamless bridge between the real-world gameplay and on-chain logic.",
        "how_its_made": "How It's Made: Web3Warfare Web3Warfare is built with a blend of blockchain technologies, hardware, and software integration. Here's how it all comes together: Smart Contract Architecture: The game uses a custom-built factory design pattern smart contract, managing duels and payout logic. This contract is deployed across multiple blockchain networks including SKALE, Flow, Zircuit, and Ethereum mainnet. The factory design pattern allows for scalable and efficient deployment of new duels, with automated logic governing payouts and challenge results. Each duel is governed by blockchain rules, ensuring transparency and immutability. Frontend Development: The game's frontend is developed using React, hosted on Vercel for fast deployment and scalability. For user wallet onboarding, Dynamic is used, allowing seamless integration of blockchain wallets directly into the frontend experience. This ensures players can easily manage their on-chain interactions like asset ownership and game data. Hardware Integration: The physical components of Web3Warfare are built around an ESP32 module acting as the brain of each laser blaster. The hardware setup includes a breadboard, infrared LED, and code developed in Arduino IDE to manage the interactions between the laser blasters and the game. Each ESP32 module contains an embedded wallet with the firmware, thanks to Dynamic, which enables direct blockchain interaction from the physical devices. On-Chain Authentication: To guarantee the authenticity of in-game data being written to the blockchain, Web3Warfare uses Sign Protocol's schema hooks. A custom whitelist address contract is implemented, allowing only approved laser blasters to write data. Each laser blaster is whitelisted to ensure only genuine hardware can sign and submit events to the blockchain. Since the ESP32 module serves as a smart wallet, each device is the sole owner of its private key, preventing unauthorized devices from participating. Embedded Wallets & Signing: The ESP32 modules act as both the game\u2019s sensor and its on-chain identity, with embedded wallets stored within the firmware. This design allows each laser blaster to sign blockchain transactions directly, securing game events and ensuring the only valid signing devices are the blasters themselves. By flashing the wallets and private keys onto the hardware, the game eliminates the need for external signing mechanisms. Notable Hacks: One particularly hacky aspect of this project is embedding private key functionality directly into the ESP32 modules, allowing each blaster to function as a fully operational smart wallet. This allows for direct interaction with the blockchain from the physical game world, creating a seamless bridge between the real-world gameplay and on-chain logic.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qq1r9/screenshots/vuzag/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qq1r9/screenshots/5bt1o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qq1r9/screenshots/usg8o/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/pane2004/web3warfare",
        "link": "https://ethglobal.com/showcase/web3warfare-qq1r9"
    },
    {
        "title": "Liquid",
        "brief_description": "A crowd-sourced and incentivised bridging protocol using Layer Zero's OApp interface.",
        "long_description": "Liquid is a crowd-sourced and incentivized bridging protocol using Layer Zero's OApp interface. Users can provide liquidity to the bridge on either side and when their liquidity is used by somebody trying to bridge, they are incentivised for providing liquidity to the protocol. Liquid provides an alternate source of income for yield farming and helps users to de-fragment themselves across chains and get rewarded for the same. It also reduces reliance on institutional run bridges. We made use of Layer Zero's cross-chain messaging protocol (OApp), to send messages across chains. For the MVP we used Morph and Arbitrum Sepolia testnet to deploy our contracts, and one can provide liquidity of USDT on either side and others can use that liquidity to bridge their USDT tokens.",
        "how_its_made": "We made use of Layer Zero's cross-chain messaging protocol (OApp), to send messages across chains. For the MVP we used Morph and Arbitrum Sepolia testnet to deploy our contracts, and one can provide liquidity of USDT on either side and others can use that liquidity to bridge their USDT tokens.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yo7bg/screenshots/7d6n6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yo7bg/screenshots/exy4h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yo7bg/screenshots/c6t27/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/arvindkalra/SmartBridge",
        "link": "https://ethglobal.com/showcase/liquid-yo7bg"
    },
    {
        "title": "AI Fans",
        "brief_description": "An AI x Crypto OnlyFans. Uses Generative AI to create text responses and Images for the AI avatars, and faciiltates onchain transactions done by users and agents.",
        "long_description": "This projects combines the technologies of AI and crypto to create a user experience similar to OnlyFans. The idea of the project is to enable users to create their own AI partners, with each partner having control of their own wallet. This means that users can create their partners, but anyone can chat with them, and they are able to make their own decisions and transact onchain. The project uses XMTP, Walrus, and Phala at its core to power the user interface, storage, and security respectively. XMTP allows users to easily chat with their AI partners, tip them, perform onchain transactions all within one interface. Walrus is used directly in the solidity code, as each AI avatar is given a Soulbound NFT, in which the imageUri is actually a blob on walrus. In addition, the actual walrus site is stored onchain, linking the agent to their respective walrus site. Phala is used on the backend with docker to enable a trustless system where AI agents can be created at runtime. Each agent has their own wallet that is deterministic, enabling these agents to transact onchain. This is also done through a trustless manner, as all backend code is secured by TRS and execution is done within TEEs.",
        "how_its_made": "The project uses XMTP, Walrus, and Phala at its core to power the user interface, storage, and security respectively. XMTP allows users to easily chat with their AI partners, tip them, perform onchain transactions all within one interface. Walrus is used directly in the solidity code, as each AI avatar is given a Soulbound NFT, in which the imageUri is actually a blob on walrus. In addition, the actual walrus site is stored onchain, linking the agent to their respective walrus site. Phala is used on the backend with docker to enable a trustless system where AI agents can be created at runtime. Each agent has their own wallet that is deterministic, enabling these agents to transact onchain. This is also done through a trustless manner, as all backend code is secured by TRS and execution is done within TEEs.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/k8x9r/screenshots/aoezm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k8x9r/screenshots/47dk8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k8x9r/screenshots/d36qb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/k8x9r/screenshots/08g90/default.jpg"
        ],
        "live_demo": "https://ai-fans.vercel.app",
        "source_code": "https://github.com/RevanthGundala/AIFans",
        "link": "https://ethglobal.com/showcase/ai-fans-k8x9r"
    },
    {
        "title": "AutoWebChain",
        "brief_description": "decentralised fine tuning of web agents and rag on chain, using lit and walrus",
        "long_description": "Websites are considered out-of-distribution data for LLMs, meaning they aren't naturally optimized to handle such content efficiently. While LLMs can navigate websites, their performance could greatly improve with specialized fine-tuning. During our work, we managed to integrate support for models like 4o-mini, SLMs (which we later removed for performance reasons), and LLama 3.2 B. Additionally, we explored optimizations for better handling of web data and improving interaction across various web environments. We utilized Walrus to simulate the addition of model weights into a network for efficient storage and retrieval as blobs. This allowed users to download these blobs and run the models directly, enabling them to automate tasks in their browsers. The automation was based on a simplified DOM model inspired by Taxy AI's implementation, making it more user-friendly and streamlined for common web interactions. Throughout this process, we added support for models like 4o-mini, SLMs (which we later phased out for performance reasons), and LLama 3.2 B. Though the latter models were eventually removed, their integration provided valuable insights into handling model storage and execution. Additionally, we enhanced the compatibility between model blobs and browser automations, improving overall flexibility and performance for end users.",
        "how_its_made": "We utilized Walrus to simulate the addition of model weights into a network for efficient storage and retrieval as blobs. This allowed users to download these blobs and run the models directly, enabling them to automate tasks in their browsers. The automation was based on a simplified DOM model inspired by Taxy AI's implementation, making it more user-friendly and streamlined for common web interactions. Throughout this process, we added support for models like 4o-mini, SLMs (which we later phased out for performance reasons), and LLama 3.2 B. Though the latter models were eventually removed, their integration provided valuable insights into handling model storage and execution. Additionally, we enhanced the compatibility between model blobs and browser automations, improving overall flexibility and performance for end users.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/8jbmi/screenshots/v3a9i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jbmi/screenshots/tknn4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/8jbmi/screenshots/juobq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/EladWarshawsky/browser-extension",
        "link": "https://ethglobal.com/showcase/autowebchain-8jbmi"
    },
    {
        "title": "Gains Gladiator",
        "brief_description": "Gains Gladiator is an AI agent tournament simulator. It pits two AI's against each other in a battle to the riches!",
        "long_description": "The project uses LLM AI agents to power the reasoning and decision making behind the trading bots. Additionally, the project has a marketplace where user's can buy, sell, or lend their prompts behind their agents. The project also features a bridge for the Agents to use in their investing that relies upon Lit Network for trust less swap of assets on either chain.  The project also has a prediction market where user's can bet on which gladiator that they believe will win the competition. The project also makes use of Lit protocol for the trust-less execution of cross chain swaps. These work by creating a programmable key pair on each chain that waits until both assets on each chain have been received. When they are received then the lit action can be executed which produces the signed transactions that complete the transfers on both chains. The protocol also makes use of Story Network for the management of the data relevant towards the agents. The prompts that each AI agent has is first registered as an NFT and then onto Story. After the IP is created, then another user is able to mint a license token which they can use to then implement a copy or they can use a derivative to create their own agent. The royalties module was also configured so that the initial creator could receive rewards. A simple lending system was also built on top of this that allowed for a license token holder to lend their license out to any other user.\nThe prediction market was custom made and deployed to Flow Blockchain, where we used the advantage of them being a consumer focused app.",
        "how_its_made": "The project also makes use of Lit protocol for the trust-less execution of cross chain swaps. These work by creating a programmable key pair on each chain that waits until both assets on each chain have been received. When they are received then the lit action can be executed which produces the signed transactions that complete the transfers on both chains. The protocol also makes use of Story Network for the management of the data relevant towards the agents. The prompts that each AI agent has is first registered as an NFT and then onto Story. After the IP is created, then another user is able to mint a license token which they can use to then implement a copy or they can use a derivative to create their own agent. The royalties module was also configured so that the initial creator could receive rewards. A simple lending system was also built on top of this that allowed for a license token holder to lend their license out to any other user.\nThe prediction market was custom made and deployed to Flow Blockchain, where we used the advantage of them being a consumer focused app.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/qxbtc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/r3ugn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/jpmio/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/j386u/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/izksw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qvbnj/screenshots/m5rg8/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Gnome101/GainsGladiatorD",
        "link": "https://ethglobal.com/showcase/gains-gladiator-qvbnj"
    },
    {
        "title": "Fuse",
        "brief_description": "Infinite crafting game using GenAI and awarding NFTs, this game involves combining concepts and exploring what they might create",
        "long_description": "Craft to explore what is possible! Combining concepts with GenAI you'll get NFTs for new pairs that haven't been discovered. In Fuse, you'll combine words to create new ones, like water and fire making steam together. The catch is that these are generated by an LLM, so it is infinite! Compete with others to be the first to discover a new pair, and get an NFT for it! We're storing NFT metadata in Walrus, a decentralized storage service. For signup we're using Dynamic, to lower the barrier for new crypto users. On the web2 side of things, we have a backend using FastAPI that calls OpenAI with our custom agent instructions to generate both a new concept and choose a matching emoji. We have fun optimizations to run background tasks that keep the experience snappier, like uploading to Walrus. We also keep a PostgresDB database to keep track of our Walrus blob ids and some user session data. On the frontend we have Next.js and React, using Dynamic for login and signup",
        "how_its_made": "We're storing NFT metadata in Walrus, a decentralized storage service. For signup we're using Dynamic, to lower the barrier for new crypto users. On the web2 side of things, we have a backend using FastAPI that calls OpenAI with our custom agent instructions to generate both a new concept and choose a matching emoji. We have fun optimizations to run background tasks that keep the experience snappier, like uploading to Walrus. We also keep a PostgresDB database to keep track of our Walrus blob ids and some user session data. On the frontend we have Next.js and React, using Dynamic for login and signup",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5wsiz/screenshots/jjf6z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5wsiz/screenshots/cjuqv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5wsiz/screenshots/mx06c/default.jpg"
        ],
        "live_demo": "https://fuse-flax.vercel.app/",
        "source_code": "https://github.com/DiegoJRR/fuse",
        "link": "https://ethglobal.com/showcase/fuse-5wsiz"
    },
    {
        "title": "Photo-Danksharding",
        "brief_description": "Instagram, but the photos are in EIP-4844 blobs. Ephemeral on-chain social.",
        "long_description": "Social media doesn't need to be permanent! Blobs are a great way to have data available for a known period of time while automatically expiring. Gas fees would be paid by advertisers, who contribute funds to a FIFO queue, and have their logo displayed while they're at the top of the queue. Also, L2's are too cheap, and this helps fix that :) Alchemy Account Kit v4 for user wallet creation. Viem for on-chain interactions. Next.js frontend eployed to Vercel and leveraging Vercel KV for Redis caching of available posts on-chain. Explored using thirdweb engine for the backend wallet to submit the blob transactions, but found that the only efficient way to move forward was a private key in my env vars \ud83e\udd74",
        "how_its_made": "Alchemy Account Kit v4 for user wallet creation. Viem for on-chain interactions. Next.js frontend eployed to Vercel and leveraging Vercel KV for Redis caching of available posts on-chain. Explored using thirdweb engine for the backend wallet to submit the blob transactions, but found that the only efficient way to move forward was a private key in my env vars \ud83e\udd74",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/zurt2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/wsxmy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/jiekz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/ggky4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/q835w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/11yph/screenshots/7rrqa/default.jpg"
        ],
        "live_demo": "https://photo-danksharding.vercel.app/",
        "source_code": "https://github.com/0xPenryn/photo-danksharding",
        "link": "https://ethglobal.com/showcase/photo-danksharding-11yph"
    },
    {
        "title": "MySFGame",
        "brief_description": "A simple, browser-based game where players s navigate through a foggy San Francisco, collecting and trading NFTs",
        "long_description": "This is a simple browser-based game that uniquely blends the elements of San Francisco with blockchain technology. Players navigate a stylized, fog-covered San Francisco cityscape as a customizable pixelated cable car, their goal being to collect valuable, city-themed NFTs such as the Golden Gate Bridge, Painted Ladies, and sourdough bread. The game's core mechanic revolves around using \"Fog Coins,\" the in-game cryptocurrency, to disperse the virtual fog and reveal hidden NFTs. As players accumulate these digital assets, they can engage in peer-to-peer trading using smart contracts on the game's simplified blockchain. The gameplay loop is enriched by San Francisco-themed quests, which not only provide players with additional Fog Coins but are also recorded as transactions on the blockchain. A blockchain-based leaderboard adds a competitive element, ranking players based on their NFT collection's value. This game concept not only serves as an entertaining introduction to blockchain technology and NFTs but also captures the essence of San Francisco's tech-forward culture and iconic landmarks in a playful, accessible format. I've created a basic implementation of the CryptoFog game using HTML, CSS, and JavaScript. This version includes the following features: A 5x5 grid representing the foggy San Francisco map.\nFog Coins that decrease when revealing cells.\nRandom placement of San Francisco-themed NFTs (represented by emojis).\nA counter for collected NFTs. This implementation is a simplified version and doesn't include all the features mentioned in the original concept, such as trading NFTs or a full blockchain integration. However, it demonstrates the core gameplay loop and can serve as a starting point for further development.",
        "how_its_made": "I've created a basic implementation of the CryptoFog game using HTML, CSS, and JavaScript. This version includes the following features: A 5x5 grid representing the foggy San Francisco map.\nFog Coins that decrease when revealing cells.\nRandom placement of San Francisco-themed NFTs (represented by emojis).\nA counter for collected NFTs. This implementation is a simplified version and doesn't include all the features mentioned in the original concept, such as trading NFTs or a full blockchain integration. However, it demonstrates the core gameplay loop and can serve as a starting point for further development.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fsd4k/screenshots/53qcc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fsd4k/screenshots/n1ysq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fsd4k/screenshots/wpuxm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/xinsianna/ethsf",
        "link": "https://ethglobal.com/showcase/mysfgame-fsd4k"
    },
    {
        "title": "Roblox Coin Exchange",
        "brief_description": "Enabling Roblox's 300 million (MAUs) to create, buy, and sell meme coins using bonding curves.",
        "long_description": "This project is designed to enable Roblox's 300 million monthly active users (MAU) to create, buy, and sell meme coins through a system that integrates bonding curves, which determine the price of the coins based on supply and demand. The project introduces several key features, including the creation of a Multi-Party Computation (MPC) wallet for each user. This MPC wallet is essential for securely managing users' cryptocurrency transactions and their interactions with the meme coins they create. We used the Coinbase Developer Platform and Coinbase SDK to manage wallets and facilitate meme coin transactions across Base, Polygon, and Flow blockchains. We built a custom ERC20-based bonding curve smart contract to control token prices based on supply and demand. For the game, we used Roblox Studio to create the user interface and integrate meme coins into the Roblox ecosystem. The backend was developed with NestJS for server logic and MongoDB for handling user data and transaction history. One hacky aspect was integrating real crypto transactions with Roblox gameplay, syncing blockchain and in-game interactions smoothly using Coinbase\u2019s SDK and bonding curve contracts.",
        "how_its_made": "We used the Coinbase Developer Platform and Coinbase SDK to manage wallets and facilitate meme coin transactions across Base, Polygon, and Flow blockchains. We built a custom ERC20-based bonding curve smart contract to control token prices based on supply and demand. For the game, we used Roblox Studio to create the user interface and integrate meme coins into the Roblox ecosystem. The backend was developed with NestJS for server logic and MongoDB for handling user data and transaction history. One hacky aspect was integrating real crypto transactions with Roblox gameplay, syncing blockchain and in-game interactions smoothly using Coinbase\u2019s SDK and bonding curve contracts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/nytuo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/ibrkx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/x0z88/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/rc2vk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/dpewj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/833sq/screenshots/a0f53/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/iganbold/roblox-memecoin",
        "link": "https://ethglobal.com/showcase/roblox-coin-exchange-833sq"
    },
    {
        "title": "Intellijack",
        "brief_description": "AI Oracle on Fhenix enabling inference over private data to go on chain. Demonstrated application of an agent and data economy",
        "long_description": "Intellijack is an AI oracle framework for managing and monetizing AI agents and datasets using blockchain technology. The core of the project is a the oracle service that has been adapted from Galadriel's oracle system. However, rather than relying on a single payee for the AI API calls, Lit Protocol's open and secure platform enables self payment. In addition, since we are deployed on Fhenix we can retrieve private data and inference over it with the output from the call going on chain. This opens up a vast frontier of applications. The purpose of Intellijack GPT's is to enable a decentralized marketplace for AI agents and datasets. It allows creators to: The system also includes mechanisms for: The use of blockchain technology provides transparency, immutability, and decentralized control over these AI assets. The integration with AI services allows for dynamic interaction with the AI agents. This project could be particularly useful in scenarios where AI model ownership, licensing, and fair compensation are important, such as in collaborative AI development or AI-as-a-service marketplaces. The oracle system can work on any chain and could potentially be developed into a massively multichain and super scalable oracle service I first got started with Lit Protocol, and eventually decided on using Lit rather than Blockless. Some guy handed out free AI calls on Redpill which was super clutch. I worked all night on Friday and by noon Saturday I had set up the oracle service on Fhenix. After that, I wasn't totally sure what to do next so I ideated but eventually just settled on trying to do something like OpenAI's GPT's with Story protocol.\nThe coolest most hacky thing about the project to me is that I can store API keys and wallet seed phrase on Lit and run the oracle without exposing that information.",
        "how_its_made": "I first got started with Lit Protocol, and eventually decided on using Lit rather than Blockless. Some guy handed out free AI calls on Redpill which was super clutch. I worked all night on Friday and by noon Saturday I had set up the oracle service on Fhenix. After that, I wasn't totally sure what to do next so I ideated but eventually just settled on trying to do something like OpenAI's GPT's with Story protocol.\nThe coolest most hacky thing about the project to me is that I can store API keys and wallet seed phrase on Lit and run the oracle without exposing that information.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/75p06/screenshots/3okjx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/75p06/screenshots/rd932/default.jpg",
            "https://ethglobal.b-cdn.net/projects/75p06/screenshots/1o67i/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/madschristensen99/intellijack/",
        "link": "https://ethglobal.com/showcase/intellijack-75p06"
    },
    {
        "title": "ChainSplash",
        "brief_description": "ChainSplash revolutionizes charitable giving using blockchain. We ensure transparency, efficiency, and privacy in donations through smart contracts, NFTs, and zero-knowledge proofs. Empower trust in global giving with real-time tracking and reduced overhead costs.",
        "long_description": "ChainSplash is a blockchain-based donation platform that aims to revolutionize the NGO sector. Key features include: Transparency: All transactions are recorded on public blockchains.\nEfficiency: Smart contracts enable instant transactions, reducing overhead costs.\nPrivacy: Donors have the option to remain anonymous through zero-knowledge proofs.\nReal-time tracking: Donors can track their contributions as they flow through the system.\nNFT integration: When projects reach 100% funding, smart contracts generate NFTs for NGOs, which can be exchanged for physical goods. The platform allows donors to contribute to various NGO projects using cryptocurrency, addressing issues of trust and fraud in charitable giving. ChainSplash builds on successes like UNICEF's CryptoFund and the World Food Programme's blockchain initiative, offering a scalable solution for NGOs of all sizes. ChainSplash leverages several technologies: Frontend: Next.js, heavily inspired by NousDAO's community-driven approach.\nBackend: SQLite and Python, deployed on Polygon blockchain.\nSmart contracts: Developed using Solidity.\nPrivacy: Implemented zero-knowledge proofs (ZKP) for donor anonymity.",
        "how_its_made": "ChainSplash leverages several technologies: Frontend: Next.js, heavily inspired by NousDAO's community-driven approach.\nBackend: SQLite and Python, deployed on Polygon blockchain.\nSmart contracts: Developed using Solidity.\nPrivacy: Implemented zero-knowledge proofs (ZKP) for donor anonymity.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/m5db8/screenshots/g8e5j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m5db8/screenshots/i9ru9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/m5db8/screenshots/5kcvq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/twliu-dorian/ethglobal-sf-hackathon.git",
        "link": "https://ethglobal.com/showcase/chainsplash-m5db8"
    },
    {
        "title": "DeForms",
        "brief_description": "Buy, sell and trade datasets as tokens to boost it's credibility, tracking ownership starting with survey data today",
        "long_description": "Problem:\nTrust and Data Ownership: Traditional marketplaces require users to trust a central authority with their data.\nData Quality and Authenticity: Ensuring the quality and provenance of data is challenging.\nPricing and Value Assessment: Data is difficult to price, and its value varies greatly depending on use case.\nInefficient Transactions: Traditional marketplaces involve intermediaries, leading to higher costs and slower processes.\nLimited Access and Control: Users often have limited control over their data and how it's used.\nData Silos: Lack of interoperability between different data sources and platforms.\nSolution:\nDecentralization and Smart Contracts:\nEliminates the need for a central authority, enhancing trust and transparency.\nAutomates transactions and licensing through smart contracts, reducing intermediaries.\nTokenization of Datasets:\nRepresents datasets as unique tokens (NFTs), allowing for clear ownership and provenance tracking.\nEnables fractional ownership, making valuable datasets more accessible. We are deploying this on @rootstock to leverage both BTC and ETH network in-case of staking powers in the future. We are using @privy for account abstraction that enables smooth onboarding for crypto and non-crypto users (facing one obstacle) Integration and Interaction:\nUser Interface: Built with React, providing a dynamic, responsive interface.\nBlockchain Interaction: Ether.js facilitates communication between the frontend and the Ethereum blockchain, enabling seamless smart contract interaction and wallet integration.\nSmart Contracts: Solidity contracts handle core business logic, including minting DataTokens, managing listings, and facilitating transactions.\nDeployment: Contracts are deployed on Rootstock, leveraging Bitcoin network interoperability while utilizing Ethereum's smart contract functionality. Stack used: React, Supabase, Rootstock, Privy SDK",
        "how_its_made": "We are deploying this on @rootstock to leverage both BTC and ETH network in-case of staking powers in the future. We are using @privy for account abstraction that enables smooth onboarding for crypto and non-crypto users (facing one obstacle) Integration and Interaction:\nUser Interface: Built with React, providing a dynamic, responsive interface.\nBlockchain Interaction: Ether.js facilitates communication between the frontend and the Ethereum blockchain, enabling seamless smart contract interaction and wallet integration.\nSmart Contracts: Solidity contracts handle core business logic, including minting DataTokens, managing listings, and facilitating transactions.\nDeployment: Contracts are deployed on Rootstock, leveraging Bitcoin network interoperability while utilizing Ethereum's smart contract functionality. Stack used: React, Supabase, Rootstock, Privy SDK",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/2cheu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/hzdni/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/mw2y4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/z5a6z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/18jw6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/a8jbh/screenshots/72a41/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Kashyab19/deforms-ethglobal-sf-2024",
        "link": "https://ethglobal.com/showcase/deforms-a8jbh"
    },
    {
        "title": "ConversationStation",
        "brief_description": "Novel agent chat interface lets users interact with their autonomous agents",
        "long_description": "We\u2019ve developed an innovative agent chat interface that enables users to interact with and monitor their autonomous agents in real-time. This project leverages Large Language Models (LLM) and XMTP to create a seamless user interface for querying and commanding agents. Users can ask questions like \u201cWhat are you built to do?\u201d and the agent will summarize its skills, or ask \u201cWhat state are you in?\u201d for real-time updates. Users can even prompt actions such as \u201cchange parameter X to Y,\u201d and the agent will modify parameters on the fly. Agents can be customized with distinct personalities and deliver unprompted updates based on specific triggers. A mobile app consolidates all messages and updates from connected agents in one place. By leveraging XMTP, agents can also broadcast updates across multiple social channels, ensuring that critical information reaches users wherever they are. As autonomous agents become more essential for tasks like trading, selling, gathering information, and developing new actions, our project bridges the gap, enabling smooth interaction between humans and agents. This chat interface will be key in the evolving landscape of human-agent collaboration. We built this project using the Autonolas framework, which provided the foundation for our agent-based services. The architecture revolves around a set of core skill\u2014 Chit_chat \u2014 running as individual or multi-agent services that communicate and interact within an agent-economy. The chat skill integrates LLMs and XMTP: this allows us to bring together a decentralised chat interface for interacting with users, and LLMs which provide context-aware responses. Technologies Used:",
        "how_its_made": "We built this project using the Autonolas framework, which provided the foundation for our agent-based services. The architecture revolves around a set of core skill\u2014 Chit_chat \u2014 running as individual or multi-agent services that communicate and interact within an agent-economy. The chat skill integrates LLMs and XMTP: this allows us to bring together a decentralised chat interface for interacting with users, and LLMs which provide context-aware responses. Technologies Used:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mnhr4/screenshots/2z5o5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnhr4/screenshots/k5d1r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnhr4/screenshots/y7wd6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnhr4/screenshots/bkgso/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/xiuxiuxar/conversation_station/",
        "link": "https://ethglobal.com/showcase/conversationstation-mnhr4"
    },
    {
        "title": "Plutus",
        "brief_description": "Plutus is financial assistant that can help you with managing money, boosting credit score and paying off debts with lowest interests.",
        "long_description": "Our financial management app integrates with Plaid to provide users with real-time insights into their financial data, such as credit card history, bank balances, and more. The app analyzes this data to help users make informed financial decisions, like whether they can afford large purchases or how to maintain a strong credit score. If users are short on funds, the app seamlessly connects them to decentralized lending pools, such as Aave, enabling them to access loans and pay off debts or complete transactions. Key Features: Tech Stack: Our app bridges the gap between traditional finance and decentralized finance, empowering users to take control of their financial future. Project Build: We built a financial management app that connects traditional and decentralized finance using the following stack: Frontend (React): Provides a clean and intuitive interface for users to view and manage their financial data, including credit card history and bank balances. We used React hooks to manage state and ensure seamless navigation. Plaid Integration: We used Plaid to securely access real-time financial data, such as credit card transactions and bank balances. This allows users to make informed decisions, like whether they can afford large purchases or need to borrow funds. Web3 Tools: Smart Contract Development: We developed custom smart contracts to interact with Aave, enabling users to borrow funds when needed and track repayments. Contracts also handle decision-making logic, such as suggesting loans when funds are insufficient. Hacky Bits: We implemented an encryption layer using Fhenix, ensuring that all sensitive financial data is encrypted before any analysis or blockchain interaction. This keeps user data private while integrating seamlessly with both traditional and decentralized finance. By bridging traditional finance data (Plaid) and DeFi (Aave), our app allows users to move smoothly between fiat and crypto environments, providing a powerful financial management tool.",
        "how_its_made": "Project Build: We built a financial management app that connects traditional and decentralized finance using the following stack: Frontend (React): Provides a clean and intuitive interface for users to view and manage their financial data, including credit card history and bank balances. We used React hooks to manage state and ensure seamless navigation. Plaid Integration: We used Plaid to securely access real-time financial data, such as credit card transactions and bank balances. This allows users to make informed decisions, like whether they can afford large purchases or need to borrow funds. Web3 Tools: Smart Contract Development: We developed custom smart contracts to interact with Aave, enabling users to borrow funds when needed and track repayments. Contracts also handle decision-making logic, such as suggesting loans when funds are insufficient. Hacky Bits: We implemented an encryption layer using Fhenix, ensuring that all sensitive financial data is encrypted before any analysis or blockchain interaction. This keeps user data private while integrating seamlessly with both traditional and decentralized finance. By bridging traditional finance data (Plaid) and DeFi (Aave), our app allows users to move smoothly between fiat and crypto environments, providing a powerful financial management tool.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/fe70s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/i2zyb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/myuge/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/wbdd1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/0cndn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtwx0/screenshots/r638r/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/bunsamosa/plutus",
        "link": "https://ethglobal.com/showcase/plutus-mtwx0"
    },
    {
        "title": "Lit Data Market",
        "brief_description": "Marketplace for data vendors and inference vendors. Run AI inference on any data vendor with your choice of open source models, without knowing the data.",
        "long_description": "Marketplace for data vendors and inference vendors. Run AI inference on any data vendor with your choice of open source models. Data vendors don't need to give up their data, since it's passed to specific inference models and vendors through secure Lit actions. -data vendors can better monetize their data (users don't get all the data) -data privacy; users can run queries on data without all the data -unlocks data from inference Example is Linkedin. Linkedin doesn't want to give up their entire database. Users don't want to be restricted to Linkedin search. Lit Data Marketplace allows users to run Llama 3.2, etc on Linkedin data without getting Linkedin data.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/v2ms0/screenshots/58fgg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v2ms0/screenshots/7vh74/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v2ms0/screenshots/k5siv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v2ms0/screenshots/x9ftn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/financegeek-org/ethsf2024",
        "link": "https://ethglobal.com/showcase/lit-data-market-v2ms0"
    },
    {
        "title": "FriendlyIntent",
        "brief_description": "Intent bridging, but only your friends can fill them! No more whitelisted market makers. You pick who can fill your intent!",
        "long_description": "For a user that doesn't care about being instantly filled (can take their time) and wants to share the intent with their friends rather than market makers, introducing FriendlyIntent! Why let market makers have all the fun? Only let your friends fill your intents, by first encrypting the intent, then giving your friends the decryption key! I spent a stupid amount of time debugging my Stackr rollup so I apologize for the lack of progress.\nI envisioned allowing the User encrypt using Lit Protocol, then put the encrypted intent on a stackr (using Avail) chain. Then, LayerZero would propagate the intent to other chains (using the initial chain as a hub in a hub and spoke model)\nThe decryption key would be sent to friends via a message group or broadcast.\nThen, any user can decrypt the intent on chain and fulfil it. I only really got to launching the group chat built with message kit and the stackr rollup because I spent waaaay too long on dumb bugs on the stackr rollup.",
        "how_its_made": "I spent a stupid amount of time debugging my Stackr rollup so I apologize for the lack of progress.\nI envisioned allowing the User encrypt using Lit Protocol, then put the encrypted intent on a stackr (using Avail) chain. Then, LayerZero would propagate the intent to other chains (using the initial chain as a hub in a hub and spoke model)\nThe decryption key would be sent to friends via a message group or broadcast.\nThen, any user can decrypt the intent on chain and fulfil it. I only really got to launching the group chat built with message kit and the stackr rollup because I spent waaaay too long on dumb bugs on the stackr rollup.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ipu74/screenshots/g2txt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ipu74/screenshots/zzc6g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ipu74/screenshots/ttsfp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Zeebradoom/testtt",
        "link": "https://ethglobal.com/showcase/friendlyintent-ipu74"
    },
    {
        "title": "VVLDrizzy",
        "brief_description": "Mint, watermark, license, and protect your viral short form videos. Get paid by media outlets on your terms. Powered by Story Protocol, Walrus.",
        "long_description": "VVLDrizzy (Viral Video Licensor) aims to make it easy for both content creators and media outlets to get paid for or pay to license video content, helping bridge the legacy media outlets' Web3 adoption gap. As a content creator: As a media agency: VVLDrizzy was part-inspired by my friend, PK, who was riding the TTC (Toronto's subway - hence Drizzy) when he filmed a section of the train with a broken window, popping his phone out the windowsill to show the danger. His video went semi-viral (127K views) after he uploaded it to TikTok, and was contacted by multiple news outlets to show it on live news. It was stolen and reuploaded a few times without permission too.\nHe didn't make any money from it, but now with VVLDrizzy, he easily could have set his own licensing terms and prevented it from being stolen without attribution and earned some money. Features: Inspiration for the name: https://youtu.be/AF2MqFnPotc?feature=shared Stack: Notable hacks:\nOne notable hack I pulled off was the client-side watermarking. Typically, video processing is done server-side, but by using WASM and FFmpeg, I was able to process videos directly in the user's browser, preventing the user from needing to send their video to a third-party server for processing, reducing server costs and keeping video ownership fully on the client side, creating a decentralized-first approach. Another hacky thing I did was leverage the IPA hash from the Story license to store the blob id of the video on Walrus to be used later when the video is retrieved after licensing, creating a single-source-of-truth to reduce the friction of content licensing. This combination of technologies made VVLDrizzy a seamless and decentralized solution for both content creators and media organizations.",
        "how_its_made": "Stack: Notable hacks:\nOne notable hack I pulled off was the client-side watermarking. Typically, video processing is done server-side, but by using WASM and FFmpeg, I was able to process videos directly in the user's browser, preventing the user from needing to send their video to a third-party server for processing, reducing server costs and keeping video ownership fully on the client side, creating a decentralized-first approach. Another hacky thing I did was leverage the IPA hash from the Story license to store the blob id of the video on Walrus to be used later when the video is retrieved after licensing, creating a single-source-of-truth to reduce the friction of content licensing. This combination of technologies made VVLDrizzy a seamless and decentralized solution for both content creators and media organizations.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/socxw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/1qced/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/eip9h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/yahk2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/a7a8f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/he09i/screenshots/b90qk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/dynamicduho/ETHGlobalSF-VVLDrizzy",
        "link": "https://ethglobal.com/showcase/vvldrizzy-he09i"
    },
    {
        "title": "DMNO - PKP secrets",
        "brief_description": "dmno.dev plugin - encrypted secrets using a PKP gated by Github auth + teams",
        "long_description": "This hackathon project is a web3-related plugin for an existing open source devtool called  DMNO (https://dmno.dev) - of which I am the creator. So first some context: DMNO is a powerful tool for managing configuration and secrets that aims to solve all the common paper-cuts of dealing with config. Aside from validation, coercion, type-safety, composability, and leak prevention, sensitive values can be pulled from various backends using plugins. Currently there are plugins to store secrets in an encrypted file within your repo, 1password, and more (ex: bitwarden, aws, etc) are on the way. The existing encrypted file plugin (https://dmno.dev/docs/plugins/encrypted-vault/) uses a single symmetric key which must be shared with all teammates who need access. This is obviously a naive approach and not ideal... Other sensible approaches would require a centralized manager of the private key, which is also not ideal and comes with serious liability/security risks, and compliance requirements. This hackathon project introduces a new encrypted vault plugin (powered by web3) with a far superior decentralized approach to encryption/decryption. This plugin bridges the gap to web2 by relying on Github for access control, and hiding all web3 interactions after initial setup is complete. Encrypted secrets are still stored in a file within your repository, but encryption uses a PKP (powered by Lit Protocol). Using an on-chain PKP allows all devs to update secret values (encrypting using the public key), but decrypting those secrets can be set using programmable conditions - without ever exposing the private key to anyone. The plugin uses Github personal access tokens to identify users, and membership in Github org \"teams\" for access control at the vault level. Secrets can be segmented into multiple vault instances, and access to each vault can be granted to multiple teams, and changed over time, as the access list is also on-chain. The goal is to make this all as seamless as possible, and take advantage of the benefits of decentralization, without forcing the end users to deal with wallets/keys/etc. While a wallet is needed to set up the vault (and corresponding PKP), after that everything is handled via github auth tokens, so most users may not even realize they are using web3 at all. Even this is not necessary as a centralized service could handle setting things up for end users,  taking fiat payments, and hiding all web3 interactions. Future work will need to be done to move this onto mainnet, deal with payments and delegation, complete access management, etc... I ALSO created a simple package with a few web3-related data types for DMNO. This lets us set config items as being web3 addresses and private keys, and we get some basic validations. In the future, I will add more options to check certain conditions as validations - for example checking a balance, or checking that an address is a certain type of contract, etc... THis is just generally useful and will help stop typos turning into huge catastrophes :) This project relies heavily on Lit Protocol - which manages the PKP and talks to Github using Lit actions to restrict access. The access list is stored using Sign protocol as attestations (on a different chain). These attestations hold an encrypted Github Team ID.  The Lit action fetches those attestations, decrypts them, and compares the users current teams to the list. In an ideal world, the PKP would also be used to manage the attestations, also using Lit actions, so that after the initial setup, users never have to deal with a wallet again. This was initially attempted, but dealing with signing and submitting transactions involving multiple wallets and delegating payments proved to add too much complexity for the hackathon. Honestly had Lit protocol not been here, whatever I would have hacked together myself would have been a naive proof of concept... Using Lit solved my exact problem - and one that I had been pondering how to solve more generally, with or without web3, much before this hackathon. Using Sign Protocol was extremely convenient because of the schema, revokability, built-in indexing service, and helpful UI! In the future we could use sign hooks to trigger notifications when things change - or even to affect keys. A next step is to allow Lit actions to access keys that the user may not have access to - to do things like use a master key to generate dev or deployment specific keys. Also an alternative access control mechanism will need to be developed for server-to-server access, but it would look fairly similar, just using keypairs and signed messages, rather than relying on github.",
        "how_its_made": "This project relies heavily on Lit Protocol - which manages the PKP and talks to Github using Lit actions to restrict access. The access list is stored using Sign protocol as attestations (on a different chain). These attestations hold an encrypted Github Team ID.  The Lit action fetches those attestations, decrypts them, and compares the users current teams to the list. In an ideal world, the PKP would also be used to manage the attestations, also using Lit actions, so that after the initial setup, users never have to deal with a wallet again. This was initially attempted, but dealing with signing and submitting transactions involving multiple wallets and delegating payments proved to add too much complexity for the hackathon. Honestly had Lit protocol not been here, whatever I would have hacked together myself would have been a naive proof of concept... Using Lit solved my exact problem - and one that I had been pondering how to solve more generally, with or without web3, much before this hackathon. Using Sign Protocol was extremely convenient because of the schema, revokability, built-in indexing service, and helpful UI! In the future we could use sign hooks to trigger notifications when things change - or even to affect keys. A next step is to allow Lit actions to access keys that the user may not have access to - to do things like use a master key to generate dev or deployment specific keys. Also an alternative access control mechanism will need to be developed for server-to-server access, but it would look fairly similar, just using keypairs and signed messages, rather than relying on github.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/a4f6a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/u38zd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/dp6ug/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/7jp3i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vaytr/screenshots/qwdc5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/dmno-dev/ethsf-2024",
        "link": "https://ethglobal.com/showcase/dmno-pkp-secrets-vaytr"
    },
    {
        "title": "OmiSwap",
        "brief_description": "OmiSwap is an innovative platform that enables voice-activated on-chain transactions through an AI wearable device, allowing users to seamlessly interact with multiple blockchain networks using natural language commands.",
        "long_description": "OmiSwap is an innovative platform that simplifies blockchain interactions through voice-activated commands using an AI wearable device. The system allows users to initiate transactions by speaking into their Omi device, recognizing trigger phrases like \"start transaction\" and \"end transaction\" to capture user intent. The platform utilizes advanced AI, powered by OpenAI's GPT models, to interpret natural language commands. For example, a user can say \"I want to send five bucks to Rohan on Polygon,\" and the system will translate this into structured transaction data. OmiSwap leverages the Omi AI wearable device, which is part of a larger ecosystem integrating with smartphones and companion apps. This integration allows users to receive notifications, make transactions, and access blockchain functionalities directly from their wearable device. The seamless connection between the wearable and the user's smartphone enhances the overall utility and convenience of the OmiSwap platform. The system supports multiple blockchain networks, including Base, Polygon, Arbitrum, and Ethereum. Users can specify the network in their voice command, enabling seamless cross-chain transactions. OmiSwap creates and manages wallets for users across different blockchain networks using the Coinbase CDP (Crypto Development Platform) SDK. This integration allows for efficient wallet provisioning, sending crypto into and out of wallets, tracking balances, and trading crypto assets. OmiSwap supports two main types of transactions: transfers of cryptocurrencies (ETH or USDC) to other users on the platform, and currency swaps between ETH and USDC on the Base network. Notably, for USDC transfers, OmiSwap leverages Coinbase Wallet's recent update that enables instant, fee-free USDC sends. This feature eliminates the need for gas fees when sending USDC, making transactions more cost-effective for users. In terms of backend processing, the system extracts transaction details from voice transcripts, verifies user identities, and retrieves wallet information from a Supabase database. Transactions are executed using the Coinbase SDK, and all transactions and swaps are logged in the database for record-keeping. OmiSwap aims to provide a seamless, intuitive interface for blockchain interactions, eliminating the need for complex UIs or deep technical knowledge. The system prioritizes security by using server-side processing for sensitive operations and integrating with secure wallet providers. The technology stack includes Next.js with shadcn/ui for the frontend, Node.js with Next.js API routes for serverless backend functions, Supabase for user data and transaction logging, Coinbase SDK for wallet management and transactions, and integration with OpenAI's GPT models for natural language processing. The system also incorporates robust error handling to manage issues such as invalid transactions, network errors, or AI interpretation failures. OmiSwap represents a significant advancement in making blockchain technology more accessible to a broader audience by leveraging voice commands, AI wearables, and innovative features like gasless USDC transfers to simplify complex cryptocurrency operations. How it's made:\nOmiSwap is built using a cutting-edge tech stack that combines AI, blockchain, and wearable technology to create a seamless voice-activated crypto transaction platform.\nVoice Input and AI Processing:\nThe system starts with the Omi wearable device, which captures user voice commands. Voice transcripts are sent to our backend, where we use OpenAI's GPT-4 model (via the Red Pill API) to interpret natural language commands into structured transaction intents. We implemented custom prompt engineering to extract specific transaction details like recipient, amount, currency, and network from user utterances.\nBackend Architecture:\nThe core backend is built using Next.js API routes, providing a serverless architecture that scales efficiently. We use TypeScript for type safety and better code maintainability. We also created API routes for webhooks to stream transcription events from the Omi to our backend.\nBlockchain Integration:\nThe heart of our blockchain interactions is the Coinbase CDP (Crypto Development Platform) SDK. This powerful tool allows us to create and manage wallets across multiple networks (Base, Polygon, Arbitrum, Ethereum), execute transfers and swaps, and check balances and transaction statuses. We've implemented support for gasless USDC transfers, leveraging Coinbase Wallet's recent feature update. Multi-chain support is baked into our system, with special emphasis on Polygon & Coinbase for their scalability and low fees.\nDatabase and User Management:\nSupabase serves as our primary database, storing user information, wallet data, and transaction logs. We stream data from Supabase through our backend to enable real-time  frontend updates with the latest transaction data.\nFrontend:\nThe user interface is built with Next.js and shadcn/ui, providing a responsive and accessible dashboard for users to view their transactions and wallet balances.\nSecurity:\nAll sensitive operations, including wallet management and transaction signing, happen server-side to enhance security. We implement proper error handling and input validation to prevent potential exploits.\nInnovative Features:\nWe've created a unique system for extracting transaction intents from natural language using custom regex patterns and AI processing. The integration with the Omi wearable device allows for a truly hands-free crypto experience, bridging the gap between wearable tech and blockchain.\nChallenges and Hacks:\nOne of our biggest challenges was accurately parsing varied user inputs. We implemented a flexible system using regex and AI to handle different phrasings and potential speech-to-text errors. To optimize performance, we parallelized API calls where possible, using Promise.all for concurrent processing of multiple transactions or swaps.\nPartner Technologies:\nCoinbase CDP SDK: This was crucial for our project, providing a unified interface for multi-chain wallet management and transactions. It significantly reduced the complexity of supporting multiple networks.\nPolygon: We leveraged Polygon's fast and cost-effective infrastructure to provide users with an optimal experience for frequent, small-value transactions.\nOmi Wearable: This innovative device forms the core of our user interface, enabling voice-activated blockchain interactions in a way that's never been done before.\nBy combining these technologies, we've created a unique platform that makes blockchain interactions as simple as speaking a command, truly bringing crypto to the masses through the power of AI and wearable tech.",
        "how_its_made": "How it's made:\nOmiSwap is built using a cutting-edge tech stack that combines AI, blockchain, and wearable technology to create a seamless voice-activated crypto transaction platform.\nVoice Input and AI Processing:\nThe system starts with the Omi wearable device, which captures user voice commands. Voice transcripts are sent to our backend, where we use OpenAI's GPT-4 model (via the Red Pill API) to interpret natural language commands into structured transaction intents. We implemented custom prompt engineering to extract specific transaction details like recipient, amount, currency, and network from user utterances.\nBackend Architecture:\nThe core backend is built using Next.js API routes, providing a serverless architecture that scales efficiently. We use TypeScript for type safety and better code maintainability. We also created API routes for webhooks to stream transcription events from the Omi to our backend.\nBlockchain Integration:\nThe heart of our blockchain interactions is the Coinbase CDP (Crypto Development Platform) SDK. This powerful tool allows us to create and manage wallets across multiple networks (Base, Polygon, Arbitrum, Ethereum), execute transfers and swaps, and check balances and transaction statuses. We've implemented support for gasless USDC transfers, leveraging Coinbase Wallet's recent feature update. Multi-chain support is baked into our system, with special emphasis on Polygon & Coinbase for their scalability and low fees.\nDatabase and User Management:\nSupabase serves as our primary database, storing user information, wallet data, and transaction logs. We stream data from Supabase through our backend to enable real-time  frontend updates with the latest transaction data.\nFrontend:\nThe user interface is built with Next.js and shadcn/ui, providing a responsive and accessible dashboard for users to view their transactions and wallet balances.\nSecurity:\nAll sensitive operations, including wallet management and transaction signing, happen server-side to enhance security. We implement proper error handling and input validation to prevent potential exploits.\nInnovative Features:\nWe've created a unique system for extracting transaction intents from natural language using custom regex patterns and AI processing. The integration with the Omi wearable device allows for a truly hands-free crypto experience, bridging the gap between wearable tech and blockchain.\nChallenges and Hacks:\nOne of our biggest challenges was accurately parsing varied user inputs. We implemented a flexible system using regex and AI to handle different phrasings and potential speech-to-text errors. To optimize performance, we parallelized API calls where possible, using Promise.all for concurrent processing of multiple transactions or swaps.\nPartner Technologies:\nCoinbase CDP SDK: This was crucial for our project, providing a unified interface for multi-chain wallet management and transactions. It significantly reduced the complexity of supporting multiple networks.\nPolygon: We leveraged Polygon's fast and cost-effective infrastructure to provide users with an optimal experience for frequent, small-value transactions.\nOmi Wearable: This innovative device forms the core of our user interface, enabling voice-activated blockchain interactions in a way that's never been done before.\nBy combining these technologies, we've created a unique platform that makes blockchain interactions as simple as speaking a command, truly bringing crypto to the masses through the power of AI and wearable tech.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/b3ma8/screenshots/ehyi9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b3ma8/screenshots/h2b9q/default.jpg",
            "https://ethglobal.b-cdn.net/projects/b3ma8/screenshots/gvemk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/raviriley/omitx",
        "link": "https://ethglobal.com/showcase/omiswap-b3ma8"
    },
    {
        "title": "Earn Your Story AI",
        "brief_description": "Using AI to registering your most personal identity IP, based on your open tabs",
        "long_description": "A quick and easy way to monetize your personal identity IP. Advertisers pay me good money if I can show who I am. Academic researchers yearn to know more about my behavioral patterns. And, I want AI to personalize my online user experience based on who I am. I need a quick and bullet-proof way to define and sell my personal interest IP ! I use the data that defines my most personal self: my browser tabs.\nTo understand (!) and explain who I am - transparent, IP-protected, automated in 1 click, thanks to LLMs. Now I only need a self-sovereign way to protect my personal identity:\nI register my identity as IP NFT on Story Protocol. This way my personal identity becomes IP, clearly attributed, and protected. Finally, I sell My Story to advertisers and researchers who are curious to learn more about my interests. Protected by IP licensing terms - e.g. restricting commercial use, but allowing academic research. https://testnet.storyscan.xyz/tx/0xe73588e2a449dfbb164eff645cf5f49682b7dd05e3a01a5dbcec96a9261f1087 The Chrome extension uses the Chrome API to read information such as open browser tabs. Only an extension has access to this personal data. The data then shows in your Chrome tab. GPT summarizes the titles of open browser tabs. A more private local LLM could be used, too, but doesn't quite work for demo purposes here. Then Story Protocol creates an NFT defining your personal interest.",
        "how_its_made": "The Chrome extension uses the Chrome API to read information such as open browser tabs. Only an extension has access to this personal data. The data then shows in your Chrome tab. GPT summarizes the titles of open browser tabs. A more private local LLM could be used, too, but doesn't quite work for demo purposes here. Then Story Protocol creates an NFT defining your personal interest.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tp1jd/screenshots/9z6tq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tp1jd/screenshots/j8f5r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tp1jd/screenshots/vcty6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tp1jd/screenshots/hj6wc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/p0s/earn-your-story",
        "link": "https://ethglobal.com/showcase/earn-your-story-ai-tp1jd"
    },
    {
        "title": "SmartSign",
        "brief_description": "Transform conversations into contracts instantly with our app, combining advanced language models and blockchain for secure, efficient, and transparent deal closures.",
        "long_description": "Imagine instantly transforming your business conversations into legally binding contracts with just a few clicks. Our app effortlessly captures discussions between parties and extracting crucial details. Leveraging advanced language models, it generates comprehensive written contracts instantly. Once both parties agree on the contract, it is AES encrypted, providing passwords exclusively to the involved parties, and stored on the walrus network. A smart contract referencing the encrypted contract is then created and stored on the Rootstock blockchain, ensuring transparency, security, and immutability. Say goodbye to lengthy negotiations and paperwork \u2013 with our app, closing deals has never been easier or more efficient. Say goodbye to pricey subscription services like Docusign, PandaDoc, and SignNow! And say hello to SmartSign! Example use cases:\nTwo parties negotiating a sale of an item.\nWarranty contracts.\nFreelance agreements and project scopes.\nRental and lease agreements.\nService contracts between businesses and clients.\nNon-disclosure agreements (NDAs).\nEmployment contracts and offer letters.\nPartnership agreements.\nLicensing and royalty agreements.\nLoan agreements and repayment terms The project uses XMTP (Converse) for chatting capability between users.  It uses Openai for legal contract capability.  It uses Walrus to store the encrypted contract data.  It uses Solidity contract for signing, timestamp of the contract.  The solidity contract is deployed on Rootstock chain. App Workflow: Two users engage in a conversation on XMTP. Once they finish discussing business details and exchanging personal information, they trigger the /generate contract bot command. The bot gathers the entire chat history and is fed into OpenAI's gpt-4o LLM, which generates a legal contract in text form. The bot then creates a random encryption key and uses it to AES encrypt the PDF contract. The bot sends the encrypted PDF and the encryption key to both users in the chat, allowing them to review the AI-generated contract. If needed, they can regenerate the contract by issuing the command again. No other people have access to the encryption key as XMTP is an end to end encrypted messenger. Either user can deploy the contract when ready. By invoking the /deploy command, the bot generates a link to a page where users can log into their MetaMask wallet and deploy the smart contract. The AES encrypted contract is first deployed on the Walrus Network. Once deployed, a hash for the blob id is stored on the smart contract when it's deployed. Users can sign the smart contract by using the /sign command which uses their Rootstock wallet to officially sign the contract.",
        "how_its_made": "The project uses XMTP (Converse) for chatting capability between users.  It uses Openai for legal contract capability.  It uses Walrus to store the encrypted contract data.  It uses Solidity contract for signing, timestamp of the contract.  The solidity contract is deployed on Rootstock chain. App Workflow: Two users engage in a conversation on XMTP. Once they finish discussing business details and exchanging personal information, they trigger the /generate contract bot command. The bot gathers the entire chat history and is fed into OpenAI's gpt-4o LLM, which generates a legal contract in text form. The bot then creates a random encryption key and uses it to AES encrypt the PDF contract. The bot sends the encrypted PDF and the encryption key to both users in the chat, allowing them to review the AI-generated contract. If needed, they can regenerate the contract by issuing the command again. No other people have access to the encryption key as XMTP is an end to end encrypted messenger. Either user can deploy the contract when ready. By invoking the /deploy command, the bot generates a link to a page where users can log into their MetaMask wallet and deploy the smart contract. The AES encrypted contract is first deployed on the Walrus Network. Once deployed, a hash for the blob id is stored on the smart contract when it's deployed. Users can sign the smart contract by using the /sign command which uses their Rootstock wallet to officially sign the contract.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/9ss1i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/fx3d7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/9vpur/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/k5nt5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/znbxr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zjyn1/screenshots/kvhqd/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/swswsw/contractbot1",
        "link": "https://ethglobal.com/showcase/smartsign-zjyn1"
    },
    {
        "title": "Dream Green",
        "brief_description": "A blockchain-based payment solution for the cannabis industry. We eliminate cash-related risks and complexities for dispensaries by enabling secure crypto and fiat transactions, all settled in USDC. Simplifying operations, ensuring compliance, and improving customer experience.",
        "long_description": "Core Functionality: Hybrid Payment System: Cultivates flexibility by accepting both cryptocurrency and fiat currency payments.\nIntegrates with Stripe for processing traditional card payments.\nSupports various cryptocurrencies for direct crypto transactions. USDC Settlement: All transactions, regardless of input method, bloom into USD Coin (USDC) settlements.\nUtilizes Circle's infrastructure for stable, regulated cryptocurrency transactions. Blockchain-Based Ledger: Plants a secure record of all transactions on a blockchain, ensuring transparency and immutability.\nGrows easy pathways for auditing and regulatory compliance. User-Friendly Interface: Intuitive mobile app for customers to make purchases as easily as watering a plant.\nRobust dashboard for dispensaries to manage transactions, inventory, and analytics. Key Benefits: For Dispensaries: Prunes away cash handling, minimizing security risks and operational costs.\nFertilizes growth by providing a cryptocurrency-based financial solution.\nCultivates compliance with automatic record-keeping and reporting tools.\nEnables businesses to branch out and scale operations more easily. For Customers: Blossoms multiple convenient payment options (crypto, card, bank transfer).\nGrows a canopy of privacy and security around purchases.\nPollinates the overall purchasing experience with fast, digital transactions. For the Cannabis Industry: Bridges the gap between state-level legalization and federal banking regulations.\nPromotes transparency and legitimacy, helping the industry flourish.\nFacilitates easier tax collection and reporting for authorities.\nPayment Integration with Circle, Stripe, and Crypto Wallets\nThis project integrates Circle payments with Stripe to enable checkout using both traditional payment methods (credit/debit cards) and cryptocurrencies (via wallets like MetaMask and Phantom). It facilitates automatic conversions to USDC and ensures that the correct dispensary (dispo) wallet receives the payment. PoW (Proof of Weed)\nRevolutionizing payments in the marijuana industry using Circle, Stripe, and Flow blockchain. Payment Integration with Circle, Stripe, and Crypto Wallets\nThis project integrates Circle payments with Stripe to enable checkout using both traditional payment methods (credit/debit cards) and cryptocurrencies (via wallets like MetaMask and Phantom). It facilitates automatic conversions to USDC and ensures that the correct dispensary (dispo) wallet receives the payment. Features\nMulti-Method Payments: Users can checkout via Stripe (credit/debit) or using cryptocurrency wallets (e.g., MetaMask, Phantom).\nAutomatic USDC Conversion: Fiat payments are converted to USDC using Circle\u2019s API.\nWallet-Based Payment Routing: Each dispensary has a unique USDC wallet, and payments are automatically routed to the respective wallet.\nReal-Time Notifications: Webhooks from Stripe and Circle are used to notify and handle payments in real-time.\nPrerequisites\nAPI Keys: You will need API keys from Circle and Stripe to interact with their services.\nCrypto Wallets: For crypto payments, wallets such as MetaMask and Phantom should be supported.\nUSDC Support: Ensure that your Stripe account is configured to support cryptocurrency payments (specifically USDC).\nHow It Works\nCreate a Wallet for Each Dispensary: Circle API is used to create and manage wallets for each dispensary.\nEach wallet is identified by a unique ID.\nInitiate a Stripe Checkout Session: The user selects a product and starts a checkout session.\nStripe allows the user to pay via credit card, debit card, or cryptocurrency (USDC).\nThe dispensary\u2019s wallet ID is included in the session metadata to ensure the payment is routed correctly.\nConvert Fiat to USDC (if using traditional payment methods): Once the payment is processed via Stripe, a backend process is triggered to convert the fiat currency to USDC using Circle\u2019s API.\nThe USDC is transferred to the correct dispensary wallet.\nHandle Direct Crypto Payments (e.g., MetaMask or Phantom): For users paying directly in USDC via a crypto wallet, the payment is automatically routed to the respective dispensary\u2019s wallet.\nWebhooks for Real-Time Updates: Stripe webhooks notify the backend when a payment is completed.\nCircle webhooks notify the backend when USDC transfers are successfully completed.\nFile Structure\napp.py: Flask application to handle Stripe and Circle webhooks.\nstripe_checkout.py: Code to create Stripe Checkout Sessions.\ncircle_api.py: Code to handle Circle API interactions (wallet creation, fiat-to-USDC conversion).\nREADME.md: This documentation.\nSetup\nClone this repository:\ngit clone https://github.com/your-repo/payment-integration.git\ncd payment-integration\nComplete Setup for Payment Integration with Circle, Stripe, and Crypto Wallets\nInstall Python: Ensure Python 3.6+ is installed from python.org. (Optional) Create Virtual Environment: python -m venv venv\nsource venv/bin/activate (Windows: venv\\Scripts\\activate)\nInstall Required Packages: pip install requests flask stripe python-dotenv\nCreate .env File in your project directory and add the following environment variables: STRIPE_SECRET_KEY=your_stripe_secret_key\nCIRCLE_API_KEY=your_circle_api_key\nSTRIPE_ENDPOINT_SECRET=your_stripe_webhook_endpoint_secret\nCIRCLE_WEBHOOK_SECRET=your_circle_webhook_secret\nLoad Environment Variables in Your Code: from dotenv import load_dotenv\nimport os load_dotenv()\nstripe.api_key = os.getenv(\"STRIPE_SECRET_KEY\")\ncircle_api_key = os.getenv(\"CIRCLE_API_KEY\")",
        "how_its_made": "PoW (Proof of Weed)\nRevolutionizing payments in the marijuana industry using Circle, Stripe, and Flow blockchain. Payment Integration with Circle, Stripe, and Crypto Wallets\nThis project integrates Circle payments with Stripe to enable checkout using both traditional payment methods (credit/debit cards) and cryptocurrencies (via wallets like MetaMask and Phantom). It facilitates automatic conversions to USDC and ensures that the correct dispensary (dispo) wallet receives the payment. Features\nMulti-Method Payments: Users can checkout via Stripe (credit/debit) or using cryptocurrency wallets (e.g., MetaMask, Phantom).\nAutomatic USDC Conversion: Fiat payments are converted to USDC using Circle\u2019s API.\nWallet-Based Payment Routing: Each dispensary has a unique USDC wallet, and payments are automatically routed to the respective wallet.\nReal-Time Notifications: Webhooks from Stripe and Circle are used to notify and handle payments in real-time.\nPrerequisites\nAPI Keys: You will need API keys from Circle and Stripe to interact with their services.\nCrypto Wallets: For crypto payments, wallets such as MetaMask and Phantom should be supported.\nUSDC Support: Ensure that your Stripe account is configured to support cryptocurrency payments (specifically USDC).\nHow It Works\nCreate a Wallet for Each Dispensary: Circle API is used to create and manage wallets for each dispensary.\nEach wallet is identified by a unique ID.\nInitiate a Stripe Checkout Session: The user selects a product and starts a checkout session.\nStripe allows the user to pay via credit card, debit card, or cryptocurrency (USDC).\nThe dispensary\u2019s wallet ID is included in the session metadata to ensure the payment is routed correctly.\nConvert Fiat to USDC (if using traditional payment methods): Once the payment is processed via Stripe, a backend process is triggered to convert the fiat currency to USDC using Circle\u2019s API.\nThe USDC is transferred to the correct dispensary wallet.\nHandle Direct Crypto Payments (e.g., MetaMask or Phantom): For users paying directly in USDC via a crypto wallet, the payment is automatically routed to the respective dispensary\u2019s wallet.\nWebhooks for Real-Time Updates: Stripe webhooks notify the backend when a payment is completed.\nCircle webhooks notify the backend when USDC transfers are successfully completed.\nFile Structure\napp.py: Flask application to handle Stripe and Circle webhooks.\nstripe_checkout.py: Code to create Stripe Checkout Sessions.\ncircle_api.py: Code to handle Circle API interactions (wallet creation, fiat-to-USDC conversion).\nREADME.md: This documentation.\nSetup\nClone this repository:\ngit clone https://github.com/your-repo/payment-integration.git\ncd payment-integration\nComplete Setup for Payment Integration with Circle, Stripe, and Crypto Wallets\nInstall Python: Ensure Python 3.6+ is installed from python.org. (Optional) Create Virtual Environment: python -m venv venv\nsource venv/bin/activate (Windows: venv\\Scripts\\activate)\nInstall Required Packages: pip install requests flask stripe python-dotenv\nCreate .env File in your project directory and add the following environment variables: STRIPE_SECRET_KEY=your_stripe_secret_key\nCIRCLE_API_KEY=your_circle_api_key\nSTRIPE_ENDPOINT_SECRET=your_stripe_webhook_endpoint_secret\nCIRCLE_WEBHOOK_SECRET=your_circle_webhook_secret\nLoad Environment Variables in Your Code: from dotenv import load_dotenv\nimport os load_dotenv()\nstripe.api_key = os.getenv(\"STRIPE_SECRET_KEY\")\ncircle_api_key = os.getenv(\"CIRCLE_API_KEY\")",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hk30m/screenshots/3eezu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hk30m/screenshots/01gdg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hk30m/screenshots/a8201/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/j-ble/proof_of_green ",
        "link": "https://ethglobal.com/showcase/dream-green-hk30m"
    },
    {
        "title": "DeFi-Calendly",
        "brief_description": "A defi calendly, book appointments onchain with a staked deposit",
        "long_description": "A web3 version of calendly. Service providers can allow their clients to book appointments onchain with a staked deposit. Clients get it back when you are marked as attended by the owner of the appointment. Once the appointments are resolved they will either be returned to the client or transferred to the Service Provider. I built this solo, the idea is to expand and create an easy way for service providers (think hairdressers, lawyers, consultants) to provide a booking platform with deposits paid for each appointment. Smart contract written in Sol.\nIntegrated with Metamask and Coinbase Wallet.\nDeployed on Remix and Vercel.\nQA with Polygon Testnet.",
        "how_its_made": "I built this solo, the idea is to expand and create an easy way for service providers (think hairdressers, lawyers, consultants) to provide a booking platform with deposits paid for each appointment. Smart contract written in Sol.\nIntegrated with Metamask and Coinbase Wallet.\nDeployed on Remix and Vercel.\nQA with Polygon Testnet.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h3cis/screenshots/t66tk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h3cis/screenshots/2houh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h3cis/screenshots/aovpz/default.jpg"
        ],
        "live_demo": "https://ethglobal-sf-24-q2kw15vw6-ram-sharmas-projects-7ad2ce07.vercel.app/",
        "source_code": "https://github.com/ram-sharma/ethglobalSF24",
        "link": "https://ethglobal.com/showcase/defi-calendly-h3cis"
    },
    {
        "title": "PQP",
        "brief_description": "Post-Quantum Digital Signature on Trusted Execution Environment",
        "long_description": "Background\nPost-Quantum Proofs (PQP) aims to build a quantum resistant future. Our mission is to implement cryptographic algorithms that remain secure against the potential threats posed by quantum computers, to create a robust Web3 infrastructure. As quantum computing technology advances, it is anticipated that many Web3 protocols which use cryptographic systems, particularly those based on integer factorization and discrete logarithm problems, will become vulnerable to attacks using algorithms like Shor's algorithm. Therefore, the development of quantum-resistant signature schemes is essential for ensuring long-term blockchain security. Problem\nIn quantum computing, a possible Q-day attack would be a hypothetical cyberattack, similar to zero-day vulnerabilities in the cybersecurity field. If quantum technology matures, blockchain protocols and Web3 transactions will become vulnerable to quantum algorithms. Moreover, many of the underlying cryptographic primitives would become vulnerable to quantum attacks. Idea\nPost-quantum signatures are digital signatures designed to be secure against attacks from quantum computers and can verify the validity of onchain cryptographic encryptions. These signatures rely on mathematical problems that are believed to be difficult even for quantum computers to solve. The objective is to create a signature scheme that allows a signer to produce a signature using a private key while enabling anyone with access to the corresponding public key to verify the authenticity of the signature without revealing the private key. We implemented a post-quantum lattice-based digital signature on a trusted execution environment as a proof of concept of PQ in Web3. In our project, we implemented a state-of-the-art post-quantum Digital Signature Algorithm (DSA) on Trusted Execution Environments (TEEs) using TypeScript. We integrated lattice-based cryptographic techniques, leveraging TEEs from Lit and Phala. We experimented and recorded 16ms latency.",
        "how_its_made": "In our project, we implemented a state-of-the-art post-quantum Digital Signature Algorithm (DSA) on Trusted Execution Environments (TEEs) using TypeScript. We integrated lattice-based cryptographic techniques, leveraging TEEs from Lit and Phala. We experimented and recorded 16ms latency.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/s48yc/screenshots/2rkrh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s48yc/screenshots/8uxc2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s48yc/screenshots/ac882/default.jpg",
            "https://ethglobal.b-cdn.net/projects/s48yc/screenshots/oc1h1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/lipet2k/ethsf",
        "link": "https://ethglobal.com/showcase/pqp-s48yc"
    },
    {
        "title": "Anti Swan",
        "brief_description": "An ERC-4626 tokenized vault designed to protect capital by betting against black swan events (P < 5%). Using market data, Kelly Criterion, and advanced strategies, we generate consistent yield while minimizing risk in prediction markets. Protect, profit, repeat.",
        "long_description": "BlackSwan Shield is a tokenized 4626-compliant vault designed to collectively manage user funds while betting against black swan events (with a probability of less than 5%) in prediction markets like Polymarket. Users deposit funds into the vault and receive shares representing their ownership. The vault then autonomously places bets, with a specific focus on events that are statistically unlikely to occur (black swans). In essence, SwanGuard Vault transforms complex prediction market strategies into an accessible, efficient product that allows users to earn consistent returns by betting against highly improbable events. This \u201canti-black swan\u201d approach, combined with yield optimization, provides users with a robust DeFi product focused on risk-adjusted returns.\nOur main product called SwanGuard Vault, and here's how it works:",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/kxtyk/screenshots/fsbb3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxtyk/screenshots/mb8o3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxtyk/screenshots/dafdh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/anti-black-swan/eth-global-sf-submission",
        "link": "https://ethglobal.com/showcase/anti-swan-kxtyk"
    },
    {
        "title": "OmniMemeFoodFactory",
        "brief_description": "Launch your own AI-powered food meme coin as Omni Fungible Token (OFT) on 70+ chains in ONE click(*), made possible by LayerZero V2",
        "long_description": "Launch your own AI-powered food meme coin as Omni Fungible Token (OFT) on 70+ chains in ONE click(*), made possible by LayerZero V2. Contracts are written, organized, and deployed by Foundry (forge, anvil). See description and README, and submitted feedback on partner section for how LayerZero made our project possible Frontend is based on Chakra, Viem, Wagmi, Rainbow Kit, Typescript + React, with full ESLint and dev environment configured Server is powered by Python Flask, and OpenAI dall-e-3 and GPT-4",
        "how_its_made": "Contracts are written, organized, and deployed by Foundry (forge, anvil). See description and README, and submitted feedback on partner section for how LayerZero made our project possible Frontend is based on Chakra, Viem, Wagmi, Rainbow Kit, Typescript + React, with full ESLint and dev environment configured Server is powered by Python Flask, and OpenAI dall-e-3 and GPT-4",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/yc4xf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/5asep/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/do1gj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/4g12t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/fkwf7/screenshots/5227h/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/polymorpher/omni-meme-food-factory",
        "link": "https://ethglobal.com/showcase/omnimemefoodfactory-fkwf7"
    },
    {
        "title": "Cara IP",
        "brief_description": "Let your imagination flow and your creativity go, with the power of AI and IP",
        "long_description": "In the world of AI, we want to make sure artist feel empowered to be their creative selfs. Cara is ment as a playground, where you can upload your photographs or any image, and with words edit it in any way you want.  At the same time, each piece or art is being tracker by Mentaport off chain and is being registered as an IP to Story protocol. This combination is very powerful because if you find an image in the web2 land,   now you can edit it with Cara and automatically Cara will detect the owner and allow you to create a  new IP but with the incredible add-on of derivatives from Story. The project was broken into three main parts.\nPart 1: Gen AI: Part 2: Story: Part 3: Mentaport Part 4: Dynamic:",
        "how_its_made": "The project was broken into three main parts.\nPart 1: Gen AI: Part 2: Story: Part 3: Mentaport Part 4: Dynamic:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/nfx44/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/uwio1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/k5651/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/uxpk2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/f0icx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/x03th/screenshots/nirxd/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/thinkmariale/cara-ip",
        "link": "https://ethglobal.com/showcase/cara-ip-x03th"
    },
    {
        "title": "Carbon Wheel",
        "brief_description": "CarbonWheel is a platform that incentivizes electric vehicle (EV) users by rewarding them with carbon credits for their contributions to environmental sustainability.",
        "long_description": "EVs inherently track the number of miles driven, and we leverage this data to calculate the environmental impact. Specifically, driving a gasoline car emits approximately 404 grams of carbon per mile, which is avoided by EV users. Through this calculation, EV drivers contribute to saving the planet by reducing around 0.4 metric tons of carbon for every 1,000 miles driven. When users choose to redeem their carbon credits through our dashboard, the saved carbon is added to a pool, which is then auctioned to the highest bidder. The profits from these auctions are automatically redistributed to the credit holders, with a portion retained by the platform as a fee for facilitation. The foundation of CarbonWheel was built using the Scaffold-ETH 2 template to accelerate development. I created the core smart contract using Remix, which facilitates the minting of carbon credit NFTs. This contract was deployed on Flow's testnet to ensure scalability and efficient transaction handling. To manage the minting process, I integrated WAGMI for seamless interaction between the frontend and blockchain, while leveraging ethers.js for asynchronous contract management. Ethers.js allowed me to handle contract operations with a high degree of flexibility and efficiency. Additionally, I developed frontend simulations to model future features and scenarios that are planned but not yet implemented, ensuring the project remains adaptable for future growth. By incorporating these technologies, the project achieves an efficient, scalable structure with clear pathways for further enhancements and real-world application.",
        "how_its_made": "The foundation of CarbonWheel was built using the Scaffold-ETH 2 template to accelerate development. I created the core smart contract using Remix, which facilitates the minting of carbon credit NFTs. This contract was deployed on Flow's testnet to ensure scalability and efficient transaction handling. To manage the minting process, I integrated WAGMI for seamless interaction between the frontend and blockchain, while leveraging ethers.js for asynchronous contract management. Ethers.js allowed me to handle contract operations with a high degree of flexibility and efficiency. Additionally, I developed frontend simulations to model future features and scenarios that are planned but not yet implemented, ensuring the project remains adaptable for future growth. By incorporating these technologies, the project achieves an efficient, scalable structure with clear pathways for further enhancements and real-world application.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/ach4g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/7arh4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/ny24e/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kgobin2000/carbon-wheel-v1",
        "link": "https://ethglobal.com/showcase/carbon-wheel-2x3ta"
    },
    {
        "title": "Carbon Wheel",
        "brief_description": "CarbonWheel is a platform that incentivizes electric vehicle (EV) users by rewarding them with carbon credits for their contributions to environmental sustainability.",
        "long_description": "EVs inherently track the number of miles driven, and we leverage this data to calculate the environmental impact. Specifically, driving a gasoline car emits approximately 404 grams of carbon per mile, which is avoided by EV users. Through this calculation, EV drivers contribute to saving the planet by reducing around 0.4 metric tons of carbon for every 1,000 miles driven. When users choose to redeem their carbon credits through our dashboard, the saved carbon is added to a pool, which is then auctioned to the highest bidder. The profits from these auctions are automatically redistributed to the credit holders, with a portion retained by the platform as a fee for facilitation. The foundation of CarbonWheel was built using the Scaffold-ETH 2 template to accelerate development. I created the core smart contract using Remix, which facilitates the minting of carbon credit NFTs. This contract was deployed on Flow's testnet to ensure scalability and efficient transaction handling. To manage the minting process, I integrated WAGMI for seamless interaction between the frontend and blockchain, while leveraging ethers.js for asynchronous contract management. Ethers.js allowed me to handle contract operations with a high degree of flexibility and efficiency. Additionally, I developed frontend simulations to model future features and scenarios that are planned but not yet implemented, ensuring the project remains adaptable for future growth. By incorporating these technologies, the project achieves an efficient, scalable structure with clear pathways for further enhancements and real-world application.",
        "how_its_made": "The foundation of CarbonWheel was built using the Scaffold-ETH 2 template to accelerate development. I created the core smart contract using Remix, which facilitates the minting of carbon credit NFTs. This contract was deployed on Flow's testnet to ensure scalability and efficient transaction handling. To manage the minting process, I integrated WAGMI for seamless interaction between the frontend and blockchain, while leveraging ethers.js for asynchronous contract management. Ethers.js allowed me to handle contract operations with a high degree of flexibility and efficiency. Additionally, I developed frontend simulations to model future features and scenarios that are planned but not yet implemented, ensuring the project remains adaptable for future growth. By incorporating these technologies, the project achieves an efficient, scalable structure with clear pathways for further enhancements and real-world application.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/ach4g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/7arh4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2x3ta/screenshots/ny24e/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kgobin2000/carbon-wheel-v1",
        "link": "https://ethglobal.com/showcase/carbon-wheel-2x3ta"
    },
    {
        "title": "LensChain",
        "brief_description": "Lens Chain is a user-friendly NFT platform specifically designed for photographers to mint, showcase, and trade their unique prints. (not fully done yet)",
        "long_description": "Lens Chain is a user-friendly NFT platform specifically designed for photographers to mint, showcase, and trade their unique prints NFTs. Users can easily upload their images, provide descriptions, and set prices. They can explore and appreciate a diverse collection of photographic art on the chain created by others, fostering community engagement. With seamless wallet connectivity and integrated custom poem generation to give the prints and their artists an opportunity to add a classical dimension to their appeal. We used Scaffold-ETH2 to build this Ethereum dApp and simplify the interactions with the smart contract - solidity. Therefore Wagmi and Next.js - React - Tailwind CSS on the Frontend/styling. We used IPFS for the  decentralized uploading functionality.\nWe added a fun feature using OpenAI to generate poems for the minted prints.",
        "how_its_made": "We used Scaffold-ETH2 to build this Ethereum dApp and simplify the interactions with the smart contract - solidity. Therefore Wagmi and Next.js - React - Tailwind CSS on the Frontend/styling. We used IPFS for the  decentralized uploading functionality.\nWe added a fun feature using OpenAI to generate poems for the minted prints.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2n6nx/screenshots/2kjky/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2n6nx/screenshots/t3330/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2n6nx/screenshots/1dqh0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AndrewRot/lens-chain",
        "link": "https://ethglobal.com/showcase/lenschain-2n6nx"
    },
    {
        "title": "Decl Prediction Mrkt",
        "brief_description": "A very simply prediction market implementation on using Essential's declarative smart contracts.",
        "long_description": "Essential smart contracts are declarative, meaning that you only define the constraints that state transitions must satisfy rather than the details of how those state transitions are accomplished. This project defines a system with Users, Oracles, and Markets. Each User is controlled by its creator and has a balance and can bet on Markets. An Oracle is controlled by its creator, starts unresolved, and can become resolved as true or false at any time (but stays resolved once resolved). A Market is not controlled by anyone, but is linked to an Oracle upon creation. When the Market is unresolved, then any user can bet on either the true or false outcome of the Market. When the Oracle resolves, then the Market resolves, and the money bet on the Market is distributed only to the winning bettors. All of this happens only within the contracts system, so no actual tokens are being transferred (that would be for future work). I also made a simplifying assumption that only two bettors (one for true and one for false) can bet on a Market. I was able to model the entire system in the Pint smart contract, but I was not able to finish writing all of the Rust interactions for testing it. Please note that I forked the Essential example integrations repository, and my contributions are only in the apps/prediction-market sub-directory. I used the basic setup that Essential recommends -- the contracts are written in Pint, and the interactions are written in Rust using the setup demonstrated in the essential-integration/apps examples. In particular, the Rust implements two things: the library for reflecting interactions with the contract, and a test suite that uses the library to test scripted sequences of interactions.",
        "how_its_made": "Please note that I forked the Essential example integrations repository, and my contributions are only in the apps/prediction-market sub-directory. I used the basic setup that Essential recommends -- the contracts are written in Pint, and the interactions are written in Rust using the setup demonstrated in the essential-integration/apps examples. In particular, the Rust implements two things: the library for reflecting interactions with the contract, and a test suite that uses the library to test scripted sequences of interactions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/nocgs/screenshots/wg80r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nocgs/screenshots/vhojt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/nocgs/screenshots/fwtqt/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/rybla/essential-integration/",
        "link": "https://ethglobal.com/showcase/decl-prediction-mrkt-nocgs"
    },
    {
        "title": "BuildBlocks",
        "brief_description": "With BuildBlocks, we have created drag and drop dynamic smart contract components and a platform that allows *anyone* to develop, compile, and deploy audited smart contracts on Rootstock",
        "long_description": "There is a huge barrier of entry when it comes to entering the web3 space. A minor mistake in your code can cost you thousands of dollars! Firms and companies spend hundreds of thousands of dollars auditing their smart contracts to ensure that there are no exploits in their code, but with BuildBlocks, we have created drag and drop dynamic smart contract components and a platform that allows anyone to develop, compile, and deploy reviewed smart contracts on Rootstock. Using a Retrieval pipeline on audited DeFi contracts from resources such as Uniswap, OpenZeppelin, etc., BuildBlocks allows for users to use easy-to-understand blocks to create extremely intensive smart contracts in the blink of an eye. We built BuildingBlocks using the standard NextJS, Tailwind stack, but on top of that, we used injectable wallets, the Rootstock deployment and test network, the SolC compiler for automated Solidity contract compilation, and SIDAI's RAG pipeline generation service which we created buckets of audited Solidity smart contracts.",
        "how_its_made": "We built BuildingBlocks using the standard NextJS, Tailwind stack, but on top of that, we used injectable wallets, the Rootstock deployment and test network, the SolC compiler for automated Solidity contract compilation, and SIDAI's RAG pipeline generation service which we created buckets of audited Solidity smart contracts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/6s6f2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/x2db3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/awpza/default.jpg",
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/ggjs9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/af74h/screenshots/mri2g/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sanjayamirthraj/blockbuild",
        "link": "https://ethglobal.com/showcase/buildblocks-af74h"
    },
    {
        "title": "Swapped",
        "brief_description": "Monetize your digital persona with ethical deep fakes\u2014upload, create, and earn through secure face-swap videos while preserving your anonymity",
        "long_description": "Swapped is a revolutionary NFT marketplace where your digital persona becomes a monetizable asset. Ideal for creators, influencers, public figures and brands, Swapped lets you upload your photos or AI-generated identities as NFTs, granting you full ownership and control over your digital identity. Swappers can use these NFTs to create safe, secure deep fakes via face-swap videos, allowing your persona to generate income while ensuring anonymity and ethical use. Flow is the trust, payment and NFT marketplace. We created a custom NFT that is used to manage users purchasing and selling likenesses. NFT's can be used to validate content was authorized by it's creator. Walrus for hosting distributed files. We needed defi storage for the NFTs. Dynamic for decentralized identity management and smooth Web3 onboarding. This allows us to onboard users to our platform easily. We use a Python server we built to process videos, images and swap their faces",
        "how_its_made": "Flow is the trust, payment and NFT marketplace. We created a custom NFT that is used to manage users purchasing and selling likenesses. NFT's can be used to validate content was authorized by it's creator. Walrus for hosting distributed files. We needed defi storage for the NFTs. Dynamic for decentralized identity management and smooth Web3 onboarding. This allows us to onboard users to our platform easily. We use a Python server we built to process videos, images and swap their faces",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/xuobm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/4e5tj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/tttrw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/xtrn9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yhddc/screenshots/goasn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/j-sp4/ethglobal-SF-2024",
        "link": "https://ethglobal.com/showcase/swapped-yhddc"
    },
    {
        "title": "Walruspecs",
        "brief_description": "Client-side object detection app deployed as a Walrus site. The app's dependencies are packaged into the project and published as a Walrus blob. The object detection model runs on the client's browser (thanks to transformers.js) without needing a web server for computation.",
        "long_description": "The project demonstrates the feasibility of deploying a packaged AI model to a Walrus blob, which would charge its users based on their usage. e.g. every time someone runs the object detection model, the user will pay the creator a fixed amount of money. The application has no external dependencies, which makes the app safe from other points of failures. This project uses transformers.js to enable an AI model run on the client side. For object detection, it uses detr-resnet-50 model with the confidence threshold of 50% i.e. any predictions with a confidence level below 50% will be omitted in the results. The application has been uploaded with Bootstrap's minified CSS/JS, transformers.js, and detr-resnet-50 ONNX model weights.",
        "how_its_made": "This project uses transformers.js to enable an AI model run on the client side. For object detection, it uses detr-resnet-50 model with the confidence threshold of 50% i.e. any predictions with a confidence level below 50% will be omitted in the results. The application has been uploaded with Bootstrap's minified CSS/JS, transformers.js, and detr-resnet-50 ONNX model weights.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mtyf9/screenshots/bkycn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtyf9/screenshots/djm75/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mtyf9/screenshots/kxyp0/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/walrusblob/object-detection",
        "link": "https://ethglobal.com/showcase/walruspecs-mtyf9"
    },
    {
        "title": "Baldr",
        "brief_description": "Baldr is an open source gaming escrow platform which aims to resolve disputes and provide clear resolution for all users. With trust and transparency using sign protocol upon user attestations.",
        "long_description": "Traditional trading of gaming items often lacks transparency and security, leading to disputes and fraudulent activities. Current escrow services may not adequately address these issues, leaving users vulnerable to scams and conflicts. Baldr aims to solve these problems by providing a decentralized escrow platform that leverages AI and blockchain technology to ensure transparent and secure trading of gaming items. By integrating features like the Sign protocol for trade confirmations, dynamic wallets for multi-chain connectivity, and custom subgraphs for transaction analysis, Baldr seeks to establish trust and prevent fraudulent activities in the gaming ecosystem. Baldr is an open-source gaming escrow platform designed to facilitate trading of gaming items while resolving disputes with transparency. It integrates AI to monitor trades and detect suspicious behavior, using a custom subgraph to analyze historical trade events. Baldr employs the Sign protocol for trade confirmations and uses dynamic wallets to connect buyers and sellers across multiple blockchains. It supports Near and Solana ecosystems for trade monitoring and plans to leverage SKALE for gasless transactions. The platform also incorporates Story protocol to protect intellectual property rights of gaming items.",
        "how_its_made": "Baldr is an open-source gaming escrow platform designed to facilitate trading of gaming items while resolving disputes with transparency. It integrates AI to monitor trades and detect suspicious behavior, using a custom subgraph to analyze historical trade events. Baldr employs the Sign protocol for trade confirmations and uses dynamic wallets to connect buyers and sellers across multiple blockchains. It supports Near and Solana ecosystems for trade monitoring and plans to leverage SKALE for gasless transactions. The platform also incorporates Story protocol to protect intellectual property rights of gaming items.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/2fsug/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/hey0w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/cjt8p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/bibkh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyv9f/screenshots/zfybe/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/SwineCoder101/baldr",
        "link": "https://ethglobal.com/showcase/baldr-wyv9f"
    },
    {
        "title": "PPP",
        "brief_description": "An app that allows users to set up and manage personal pension funds using any ERC-20 token",
        "long_description": "Create your own pension fund linked to any ERC-20 token. This app allows you to deposit, withdraw, invest, and pass on your funds to another person if no proof of life is provided within three years. Features: ERC-20 Compatibility: The contract supports any ERC-20 token (USDC is used in this demo).\nFlexible Withdrawals: The account holder can withdraw funds anytime.\nProof of Life: Regular interactions with the contract ensure continued access and can be manually updated. The project was built using Scaffold-ETH 2 as the foundation for both the frontend and smart contracts. A security layer was added with OpenZeppelin, implementing ReentrancyGuard, Ownable, and Pausable functions. Additionally, a frame was created to interact directly with the  smart contract in Farcaster, along with an XMTP bot to enable chat-based communication. The smart contract is deployed across multiple blockchains, offering users broad interoperability.",
        "how_its_made": "The project was built using Scaffold-ETH 2 as the foundation for both the frontend and smart contracts. A security layer was added with OpenZeppelin, implementing ReentrancyGuard, Ownable, and Pausable functions. Additionally, a frame was created to interact directly with the  smart contract in Farcaster, along with an XMTP bot to enable chat-based communication. The smart contract is deployed across multiple blockchains, offering users broad interoperability.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zzjn9/screenshots/d51yy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zzjn9/screenshots/nmkca/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zzjn9/screenshots/uou6n/default.jpg"
        ],
        "live_demo": "https://secure-retire.vercel.app/",
        "source_code": "https://github.com/fedeloterstein/ethglobal-sf",
        "link": "https://ethglobal.com/showcase/ppp-zzjn9"
    },
    {
        "title": "NeoGraph",
        "brief_description": "NeoGraph is a highly powerful and extensible data visualization tool, that seeks to provide new and interactive ways of deriving meaning of otherwise hard to sift through data.",
        "long_description": "NeoGraph is a powerful and extensible tool for building highly interactive data visualizations. As developers and people in tech, we often rely on text to convey meaning, because it is highly interoperable with other text. Which makes up the majority of our tooling with things like log files and code. However text is not a rich medium for expression, because our brains did not evolve to read text. They evolved to identify patterns in visual data. Think of the difference in trying to understand the raw data of an image file, compared to the image it actually represents! The problem with most solutions to this problems, are that most data visualizations are \"lossy\", that is the output of a visualization is only a picture, and not data itself. This heavily restricts how useful these kinds of programs can be. However this is not true in the case of our tool. So what we built, is a tool that is as extensible and usable as text, but provides a much richer medium for visual expression. And with this tool, we can render data sets that your brain can immediately draw meaningful conclusions from, without needing to parse through text or take someone elses word. All while not sacrificing the contextual power that raw data provides. The way our program achieve this, is by making all visualizations living programs that can be modified and used on the fly. What this means, in a visualization, you can interact with an element in the data set, and use it as the starting point of the next meaningful query. Because all elements in the visualization are just a special view on the underlying data object. The uses for this are widespread. Let's walk through a few. DAO Tooling\nIn the case of DAO tooling, we would use this tool to provide views into, for example, what a proposal will mean for the DAO. Another example would be showing the meaningful impact of previous and historical proposals. All of these examples could then be further composed into a single view, which allows us to compose these to build a better story of the data we are trying to explain. Subgraph Data Exploration\nWith our tool, users can query subgraphs or other data sources, and visualize how all of the nodes are related. Upon selecting a node, or sets of nodes, they can use this specific entity as the starting point for a new query, which won't modify our initial view. We built this project using:\nPharo smalltalk\nThe Streamline programming language\nThe graph (as our primary data source for visualizations) Using pharo gives us a ton of super powerful data visualization tools. And without it the project would have been impossible in this timeframe. Using the graph was also pretty fun. But the file data sources were very frustrating to get functional. Additionally the substreams endpoints kept going down for us as we were building. Not good! Streamline was also great. I don't think we could have iterated as fast as we could have without it. All in all we are pretty happy with what we managed to spit out in just over a day!",
        "how_its_made": "We built this project using:\nPharo smalltalk\nThe Streamline programming language\nThe graph (as our primary data source for visualizations) Using pharo gives us a ton of super powerful data visualization tools. And without it the project would have been impossible in this timeframe. Using the graph was also pretty fun. But the file data sources were very frustrating to get functional. Additionally the substreams endpoints kept going down for us as we were building. Not good! Streamline was also great. I don't think we could have iterated as fast as we could have without it. All in all we are pretty happy with what we managed to spit out in just over a day!",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0ffz5/screenshots/jtwvz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0ffz5/screenshots/xkog1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0ffz5/screenshots/e0kxm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MercuricChloride/streamline-hackathon",
        "link": "https://ethglobal.com/showcase/neograph-0ffz5"
    },
    {
        "title": "Aloria",
        "brief_description": "A decentralized omni-powerful AI personal assistant that can complete all kinds of tasks by operating directly on web browser",
        "long_description": "This project uses AI agents to plan tasks, parse images and execute steps of all kinds of tasks by operating on a web browser. Users need to login with their wallet, pay the node that host the service to ask AI agents to complete tasks like booking tickets, monitoring news or price changes, gathering information from reddit, etc. Users can also publish their task prompts to claim ownership. XMTP sends users asynchronous updates about their tasks. The app is built with next.js and typescript and we use:",
        "how_its_made": "The app is built with next.js and typescript and we use:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gfwo5/screenshots/ntm8f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gfwo5/screenshots/yrr9h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gfwo5/screenshots/8d2d1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gfwo5/screenshots/xde3i/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/tkeith/aloria",
        "link": "https://ethglobal.com/showcase/aloria-gfwo5"
    },
    {
        "title": "HOA Insight",
        "brief_description": "Home Owners Association Board Members want to do right by their communities. HOA Insight Smart Contracts help Board Members evaluate and vote on Proposals, Quotes and Funds Allocation, with transparency to their community.",
        "long_description": "The Home Owners Association Board Members don't always to do right by their community when evaluating proposals and finding high quality contractors to fulfill those proposals. That said, most of them also have full-time jobs, and time is limited. A home owner brought them the idea of setting up a HOAInsight Smart Contract. When a new proposal is brought to the HOA, they enter the Project Requirements and the Budget in HOAInsight. All Board Members receive a notification to vote on it in the mobile app. If the proposal receives unanimous vote (as written in Redwood Greens Bylaws), the funds are made available to the HOA Treasurer. Those funds can now be used to pay contracting company's invoice. We began the project using Miro for brainstorming and gathering essential tools to help us build the prototype. For the UI, we used Figma to design a seamless user experience. To generate demo data, we utilized AI tools like ChatGPT and Perplexity. Our tech stack includes HTML, CSS, JavaScript, with Next.js and React for front-end development, while Node.js powers the backend. We also integrated Hardhat for smart contract development, Remix, and Rainbow Wallet for seamless wallet connectivity.",
        "how_its_made": "We began the project using Miro for brainstorming and gathering essential tools to help us build the prototype. For the UI, we used Figma to design a seamless user experience. To generate demo data, we utilized AI tools like ChatGPT and Perplexity. Our tech stack includes HTML, CSS, JavaScript, with Next.js and React for front-end development, while Node.js powers the backend. We also integrated Hardhat for smart contract development, Remix, and Rainbow Wallet for seamless wallet connectivity.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5bc3h/screenshots/m1wgi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5bc3h/screenshots/p4bg1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5bc3h/screenshots/qgakj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/aldenio/hoa",
        "link": "https://ethglobal.com/showcase/hoa-insight-5bc3h"
    },
    {
        "title": "$deeproot",
        "brief_description": "Build a bitcoin  meme-defi dAPP  on RootStock protocol, implementing Reflection Token Reward Logic",
        "long_description": "We built and deployed a rootstock smart contract implementation from scratch. This project involves developing a  A Bitcoin meme-defi-DAO-governance dAPP  on RootStock , with Reflection Token  Logic  in BitMask web wallet.  We equally built and deployed ERC20, ERC721, IERC20 token standards in Rootstock. The reflection mechanism rewards token holders through automatic reflections or dividends from transactions, encouraging long-term holding. The dApp is deployed within the BitMask Wallet, enabling users to seamlessly interact with the decentralized financial ecosystem built on Bitcoin. The integration with MetaMask allows users to connect their MetaMask wallet to interact with the dApp, facilitated by RainbowKit, a popular library for wallet connection. The deployment of the RootStock smart contract enables secure, scalable, and low-cost financial transactions using Bitcoin's Layer 2. The smart contract will manage reflection rewards and allow users to participate in liquidity pools. $deeproot not only bridges Bitcoin and Ethereum\u2019s DeFi ecosystem but also establishes a solid foundation for future Bitcoin-evm financial applications. Smart Contract Development on RootStock (RSK) we built an ERC-20 token smart contract using Solidity on RootStock with built-in reflection mechanisms. Reflection tokens automatically redistribute a percentage of each transaction to holders based on their holdings, creating passive income.\nThis contract would include methods like transfer, approve, and rewardDistribution. Implement the logic so that each transaction applies a fee that gets distributed among token holders. Integration with BitMask Web Wallet and MetaMask\nWe used RainbowKit to bridge the interaction between MetaMask and BitMask. This will allow users to connect their MetaMask wallet to BitMask's dApp where the contract is deployed. We built a frontend web-based user interface (UI) for the dApp, allowing users to:\nView balances, interact with the contract, such as buying or transferring tokens. We made sure that RootStock is set as a custom network in MetaMask. verifying details such as the RPC URL, chain ID, and network name.",
        "how_its_made": "Smart Contract Development on RootStock (RSK) we built an ERC-20 token smart contract using Solidity on RootStock with built-in reflection mechanisms. Reflection tokens automatically redistribute a percentage of each transaction to holders based on their holdings, creating passive income.\nThis contract would include methods like transfer, approve, and rewardDistribution. Implement the logic so that each transaction applies a fee that gets distributed among token holders. Integration with BitMask Web Wallet and MetaMask\nWe used RainbowKit to bridge the interaction between MetaMask and BitMask. This will allow users to connect their MetaMask wallet to BitMask's dApp where the contract is deployed. We built a frontend web-based user interface (UI) for the dApp, allowing users to:\nView balances, interact with the contract, such as buying or transferring tokens. We made sure that RootStock is set as a custom network in MetaMask. verifying details such as the RPC URL, chain ID, and network name.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/1cuho/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/4zpuw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/6vasc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/7atp2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/bkxg4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dm8yg/screenshots/1iyi6/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/trevor-ofarrell/rootstock-hardhat-starterkit",
        "link": "https://ethglobal.com/showcase/deeproot-dm8yg"
    },
    {
        "title": "EAT Global",
        "brief_description": "EAT stands for \"Epicurean Advice & Travel\" and lets users post reviews about their food and travel experiences, and allows users to collaborate to generate curated food guides.  Share, Eat, and Earn.",
        "long_description": "We looked at the travel and food review industry and the problem of personal recommendations versus generic recommendations, The problem EAT Global solves: It\u2019s a fragmented and time consuming process narrowing down places to eat in a new city Not always possible to find personal recommendations for every city you visit Traditional web 2 food reviewers are not yet able to participate in the IP economy and post valuable content without any future monetization potential EAT Global is a dApp that allows users to: Easily post Reviews of their food experiences with licensing and royalties using Story Protocol Generate curated food guides in collaboration with others Get rewarded for their reviews and an opportunity to sell to media and travel websites who want to feature their reviews and guides in their content Please see our pitch here: https://www.canva.com/design/DAGUEzO98bU/jL1l0FFAm6lqmq-YneFajg/view?utm_content=DAGUEzO98bU&utm_campaign=designshare&utm_medium=link&utm_source=editor Story Protocol and Dynamic.  We focused on implementing the \"Proof of Creativity\" protocol and worked on the royalty and the licensing contracts as well as creating derivative works with linage in our travel guide offering. The visualization of the Story explorer is very informative and helped us with building and testing and exploring the IP assets on the Story network.  Speaking with the Story team was very helpful and guided us towards a successful completion.  We used the Typescript SDK and look forward to also using the React SDK next time. We decided to implement this MVP live at the hackathon by conducting food reviews of the food trucks that were on site. We have focused on the beneifts of using easy sign-on with Dynamic and the benefits of Story, including curating food guides, bring social proof on home page, and ability to generate rewards via NFT badges indicating those who post more.",
        "how_its_made": "Story Protocol and Dynamic.  We focused on implementing the \"Proof of Creativity\" protocol and worked on the royalty and the licensing contracts as well as creating derivative works with linage in our travel guide offering. The visualization of the Story explorer is very informative and helped us with building and testing and exploring the IP assets on the Story network.  Speaking with the Story team was very helpful and guided us towards a successful completion.  We used the Typescript SDK and look forward to also using the React SDK next time. We decided to implement this MVP live at the hackathon by conducting food reviews of the food trucks that were on site. We have focused on the beneifts of using easy sign-on with Dynamic and the benefits of Story, including curating food guides, bring social proof on home page, and ability to generate rewards via NFT badges indicating those who post more.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/izfgq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/tt302/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/at6g5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/9dz1p/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/kz6av/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hdcq6/screenshots/gr01u/default.jpg"
        ],
        "live_demo": "https://eatglobal.vercel.app/ ",
        "source_code": "https://github.com/Dangoz/EthSF",
        "link": "https://ethglobal.com/showcase/eat-global-hdcq6"
    },
    {
        "title": "Neurosaurs",
        "brief_description": "A concentration game powered by the Neurosity Crown! Mint Neurosaur NFTs depending on how focused you are during the game.",
        "long_description": "Unlock the power of your mind with our concentration game powered by the Neurosity Crown! Dive into the classic Chrome Dino game like never before, where your focus determines the outcome. As you play, the Neurosity Crown tracks your concentration levels in real-time, transforming your mental focus into digital rewards. The more you concentrate, the better the rare dino NFT you'll receive as a testament to your skills. It's not just a game; it's a unique fusion of neurotechnology and blockchain that turns your mental prowess into collectible assets. Train your brain, level up your focus, and collect exclusive NFTs to show off your mental game!",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/a8r8k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/jin6g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/v25ra/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/wnvwy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/4ymov/screenshots/vzzj4/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MattWong-ca/neurosaurs",
        "link": "https://ethglobal.com/showcase/neurosaurs-4ymov"
    },
    {
        "title": "MAO One",
        "brief_description": "Chat GPT use twitter posts and onchain data to trustless manage funds via Intell SGX, XMTP and Smart Contract.",
        "long_description": "The service to create machine-controlled Smart Contracts. These organizations are managed autonomously and transparently\u2014without any human interference! At the core of MAO lies the integration of advanced security and cryptographic technologies, granting AI unconditional control over users' funds. To obtain real-world information, MAO One relies on X.com (formerly Twitter)\u2014the most open social platform supporting free speech. Users can submit a tweet from an account (whether personal, organizational, or governmental) to verify real-world events. For example, users could submit an election result tweet from the @POTUS account to confirm the outcome. This enables MAO to respond to real-world events promptly and support community members efficiently. Every government has its laws to guide decisions, and in MAO, these laws are captured in the Manifest\u2014the organization\u2019s core document. The Manifest defines: MAO is built around Intel SGX (Software Guard Extensions) technology. These specialized chips run immutable code in a secure, isolated environment and are capable of generating cryptographic signatures. On October 19, 2024, the first instance\u2014\"MAO One\"\u2014was deployed within an SGX chip. This instance guarantees the secure operation of all MAO systems. The process begins when MAO One listens for anonymous messages via the XMTP protocol. Upon receiving a request, the message is forwarded to the central controller\u2014ChatGPT. Communications between MAO One and ChatGPT servers are encrypted using pre-configured TSL certificates, ensuring that no third party can interfere. If the controller authorizes a transaction, MAO One signs it with its private key and sends the signed transaction back to the user via XMTP. The user can then execute the transaction on a blockchain. MAO One can fetch on-chain data from TheGraph via a secure TSL channel. This enables ChatGPT to access essential blockchain information, such as token balances, prices, holders, and transaction volumes. This data allows MAO to make informed decisions based on current blockchain states. Thanks to Intel SGX technology, the \"MAO One\" code is immutable and cannot be altered. All MAOs built on this platform operate exclusively through ChatGPT.",
        "how_its_made": "MAO is built around Intel SGX (Software Guard Extensions) technology. These specialized chips run immutable code in a secure, isolated environment and are capable of generating cryptographic signatures. On October 19, 2024, the first instance\u2014\"MAO One\"\u2014was deployed within an SGX chip. This instance guarantees the secure operation of all MAO systems. The process begins when MAO One listens for anonymous messages via the XMTP protocol. Upon receiving a request, the message is forwarded to the central controller\u2014ChatGPT. Communications between MAO One and ChatGPT servers are encrypted using pre-configured TSL certificates, ensuring that no third party can interfere. If the controller authorizes a transaction, MAO One signs it with its private key and sends the signed transaction back to the user via XMTP. The user can then execute the transaction on a blockchain. MAO One can fetch on-chain data from TheGraph via a secure TSL channel. This enables ChatGPT to access essential blockchain information, such as token balances, prices, holders, and transaction volumes. This data allows MAO to make informed decisions based on current blockchain states. Thanks to Intel SGX technology, the \"MAO One\" code is immutable and cannot be altered. All MAOs built on this platform operate exclusively through ChatGPT.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/da928/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/c8i2d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/wx2ys/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/r2sf3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/wyviu/screenshots/7zb5n/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/pvolnov/sgx-ai-dao",
        "link": "https://ethglobal.com/showcase/mao-one-wyviu"
    },
    {
        "title": "TrailLink",
        "brief_description": "An open Protocol for Marketing Teams to launch campaigns and events onchain",
        "long_description": "We built an NFT ticketing and event curation platform that allows users to mint an NFT for entrance to an event and then go through guided/curated tasks that can earn them points for attend IRL events. This helps protocols incentivize and reward users who show up no only onchain but in real life as well. All interactions happen through a Telegram App with virtually no wallet or gas interactions making this a user friendly onchain activity for anyone. The two frontends (one for marketers and one for end users) are built with Next JS. With one of the frontends deployed as a web page and the user facing one deployed as a Telegram Mini App. We deployed our smart contracts on Polygon, any marketer can deploy NFT campaigns and create tasks without any code thanks to our factory contract on the Polygon Testnet. And we leverage Dynamic for wallets as well as ZeroDev to help with Account Abstraction for better user experience.",
        "how_its_made": "The two frontends (one for marketers and one for end users) are built with Next JS. With one of the frontends deployed as a web page and the user facing one deployed as a Telegram Mini App. We deployed our smart contracts on Polygon, any marketer can deploy NFT campaigns and create tasks without any code thanks to our factory contract on the Polygon Testnet. And we leverage Dynamic for wallets as well as ZeroDev to help with Account Abstraction for better user experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tfpov/screenshots/yox2z/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tfpov/screenshots/jnyp5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tfpov/screenshots/co3g6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tfpov/screenshots/o27kr/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/kasba96/tg-app",
        "link": "https://ethglobal.com/showcase/traillink-tfpov"
    },
    {
        "title": "Stackr ERC721",
        "brief_description": "Modular implementation of ERC721 in Stackr deployed on AvailDA",
        "long_description": "The general idea was to play with Stackr, a framework to build rollups. For this, I wanted to develop a project that relies on known open standards, namely ERC-721 in this case. The idea was to be able to: However, it turns out that Stackr cannot do async transitions, so the image generation part is not quite possible. I thus ended up just playing with Stackr and implementing ERC-721 in a nice and extensible way instead and to deploy the result with Avail as the DA. It mostly just uses Stackr's SDK and CLI. The ERC-721 implementation is based on Solmate's, and quite some work went into architecture decisions to be able to easily import the base ERC-721 functions and extend the ones necessary for the application. A lot of thought also went into types.",
        "how_its_made": "It mostly just uses Stackr's SDK and CLI. The ERC-721 implementation is based on Solmate's, and quite some work went into architecture decisions to be able to easily import the base ERC-721 functions and extend the ones necessary for the application. A lot of thought also went into types.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/15c7x/screenshots/br4uk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/15c7x/screenshots/7xpq1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/15c7x/screenshots/i2hcf/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/filoozom/mru-nfts",
        "link": "https://ethglobal.com/showcase/stackr-erc721-15c7x"
    },
    {
        "title": "Meta Splash",
        "brief_description": "Beautiful lock screens for MetaMask. We redesigned the lock screen for most used crypto wallet MetaMask.",
        "long_description": "To make Ethereum more inviting, we redesigned the lock screen for most used crypto wallet MetaMask. MetaMask wallet is the entry point to Ethereum user experience. Current wallet lock screen is sterile and overly functional, making the first impression technical and uninviting. Proposed lock screen offers wide range of graphics. Users can chose from simple colors to extravagant patterns. We used Adobe Illustrator for vector graphics and Stable Diffusion for graphic backgrounds. Application of the lock screen redesign would involve partnership with existing wallet projects or creation of a custom wallet or DAP. The other screen asking for a stylistic redesign is the wait screen displayed to users while they wait for smart contract execution.",
        "how_its_made": "We used Adobe Illustrator for vector graphics and Stable Diffusion for graphic backgrounds. Application of the lock screen redesign would involve partnership with existing wallet projects or creation of a custom wallet or DAP. The other screen asking for a stylistic redesign is the wait screen displayed to users while they wait for smart contract execution.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/ijkti/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/me9qx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/rs8zy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/z081n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/fqiet/default.jpg",
            "https://ethglobal.b-cdn.net/projects/suf85/screenshots/xk9yj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/d86us/metasplash",
        "link": "https://ethglobal.com/showcase/meta-splash-suf85"
    },
    {
        "title": "freeTrader",
        "brief_description": "A smart contract that trade according to user defined price and real time price",
        "long_description": "This prj include both smart contract piece and a frontend This prj include both smart contract piece and a frontend\nThe smart contract is written in solidity.\nThe frontend is written using NextJS framework. Key Elements\nUser-defined price: A function that allows the user to set a price.\nOracle integration: Use a Chainlink oracle (or another service like Chronicle) to fetch real-time price data.\nUniswap interaction: Utilize Uniswap\u2019s contract to swap USDC for ETH when a condition is met.",
        "how_its_made": "This prj include both smart contract piece and a frontend\nThe smart contract is written in solidity.\nThe frontend is written using NextJS framework. Key Elements\nUser-defined price: A function that allows the user to set a price.\nOracle integration: Use a Chainlink oracle (or another service like Chronicle) to fetch real-time price data.\nUniswap interaction: Utilize Uniswap\u2019s contract to swap USDC for ETH when a condition is met.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/cjm7o/screenshots/q58wi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cjm7o/screenshots/tjhx8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/cjm7o/screenshots/35pia/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/thinkvic/hacksf2024",
        "link": "https://ethglobal.com/showcase/freetrader-cjm7o"
    },
    {
        "title": "StoryVerse",
        "brief_description": "Authors craft unique universes by defining key elements such as lore, environments, characters, and interactions. Build off another author's world, protect your IP and receive royalties.",
        "long_description": "Alex, a passionate fantasy writer, uses our platform to create an expansive new universe. With advanced IP technology, Alex defines the licensing terms, allowing fans to legally build upon their favorite worlds. Fans contribute by crafting new stories within Alex\u2019s world, earning money for their work, while Alex earns royalties from each derivative. As the platform evolves, Alex's fans will be able to buy or rent stories, using encrypted smart contracts to ensure fair payment and limited-time access to the content, expanding Alex's universe with every contribution. We combine IP technology, and harness the power of fans to expand on artistic universes and explore new frontiers of their favorite worlds. We enable fans to earn money for their contributions while sharing a fair amount with the original creator as well. We plan to support the full E2E marketplace in the future, allowing folks to buy/rent content and we will implement that using an encryption protocol with smart contract conditional permissioning based on an expiration date that gets set on the user when they pay for access and it's incremented every time they pay for more access. We use Story to power our IP, Pi\u00f1ata to store the works themselves, and dynamic for our authentication flow. We integrated with the story-sdk, dynamic's sample application / sdk, and pi\u00f1atas SDK. Story handled generating an IP object that stored an ID corresponding to a Pi\u00f1ata object that contained the summary of the artist's world itself.",
        "how_its_made": "We use Story to power our IP, Pi\u00f1ata to store the works themselves, and dynamic for our authentication flow. We integrated with the story-sdk, dynamic's sample application / sdk, and pi\u00f1atas SDK. Story handled generating an IP object that stored an ID corresponding to a Pi\u00f1ata object that contained the summary of the artist's world itself.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/7to6s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/fonh3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/6raqe/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/q4kbn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/f60oe/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hot66/screenshots/2r7hy/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/parsaattari/storyverse",
        "link": "https://ethglobal.com/showcase/storyverse-hot66"
    },
    {
        "title": "Betsy",
        "brief_description": "A Web3 betting platform on Skale with XMTP-powered messaging for group bets. USDC funds are transparently handled via smart contracts, and AI helps determine outcomes. Bets are finalized and resolved on-chain, ensuring secure, trustless, and engaging group betting experiences.",
        "long_description": "Betsy is a Web3-based group betting platform that allows friends and communities to place bets on sporting events in a decentralized, transparent, and fun way on SKALE blockchain. It uses XMTP's Converse app to leverage its group messaging feature and user wallets to create an immersive experience that allows people to place bets while they message and have fun. When a bet is created, group members can chat, agree or disagree with the predictions, and place their wagers, all within the platform. This makes betting more engaging and interactive, creating a shared experience around sporting events. Once the bet is finalized, smart contracts automatically move the funds, ensuring that everyone\u2019s contributions are handled fairly and securely. Additionally, the platform uses AI to analyze real-time sports data and help determine the outcome of each bet, ensuring accuracy and fairness. Once the game is over, the AI checks whether the prediction was correct, and the smart contracts distribute the winnings or losses accordingly. This combination of blockchain, decentralized messaging, and AI creates a seamless, fully automated betting experience where users can enjoy betting with friends, all while having complete control over their funds and the outcome. This project was built on the SKALE blockchain, taking advantage of its gas-free transactions, making it cost-efficient for users placing bets. We integrated XMTP\u2019s Converse app for decentralized messaging, allowing users to communicate in real-time, propose bets, and vote within group chats securely. The platform uses OpenAI's language models (LLMs) to parse user prompts, interpret natural language queries, and interact with external sports data feeds. This helps verify that games exist and process bet outcomes based on real-time sports data. The LLMs also assist in generating responses, making the interaction more natural and efficient. We implemented agents that monitor for specific triggers in user messages, such as bet prompts, agreements, or disagreements. These agents parse the commands, triggering actions such as fund transfers and game creation on-chain. All bets and outcomes are managed by smart contracts, ensuring that the process is fully trust-less and automated. The integration of ethers.js manages blockchain interactions, particularly for handling USDC approvals and fund transfers to the smart contract.",
        "how_its_made": "This project was built on the SKALE blockchain, taking advantage of its gas-free transactions, making it cost-efficient for users placing bets. We integrated XMTP\u2019s Converse app for decentralized messaging, allowing users to communicate in real-time, propose bets, and vote within group chats securely. The platform uses OpenAI's language models (LLMs) to parse user prompts, interpret natural language queries, and interact with external sports data feeds. This helps verify that games exist and process bet outcomes based on real-time sports data. The LLMs also assist in generating responses, making the interaction more natural and efficient. We implemented agents that monitor for specific triggers in user messages, such as bet prompts, agreements, or disagreements. These agents parse the commands, triggering actions such as fund transfers and game creation on-chain. All bets and outcomes are managed by smart contracts, ensuring that the process is fully trust-less and automated. The integration of ethers.js manages blockchain interactions, particularly for handling USDC approvals and fund transfers to the smart contract.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9qx39/screenshots/0bmw0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9qx39/screenshots/v0m9g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9qx39/screenshots/8u8kx/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ItsAdel/ethglobalsf2024",
        "link": "https://ethglobal.com/showcase/betsy-9qx39"
    },
    {
        "title": "SmolSend",
        "brief_description": "Send tokens to friends via a link, without them needing a wallet upfront",
        "long_description": "I want to send tokens to a friend that has never used crypto before. Traditionally, I would ask them to install metamask, they would proceed to download it and send me their address, and I would then send them the tokens. Wouldn't it be cool if we could send them a link that held crypto such that as soon as they onboarded they could play around with those tokens? Also, if I wanted to send tokens to my favorite Twitter KOL, they would want a way to receive the tokens without doxxing their wallet address to me The key insight here is that embedded wallets plus simple use of a hash function allows users to sign in with google to claim the tokens trustlessly This app is best viewed on a mobile browser! It is built with next pwa and is mobile first. Walrus: The Graph:\nWe use this to make sure users aren't submitting a duplicate password! Dynamic: Supported Chains:",
        "how_its_made": "This app is best viewed on a mobile browser! It is built with next pwa and is mobile first. Walrus: The Graph:\nWe use this to make sure users aren't submitting a duplicate password! Dynamic: Supported Chains:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/0vtv1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/e0ms9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/kp0it/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/c9suv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/m9e9d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/n3gsh/screenshots/wnrao/default.jpg"
        ],
        "live_demo": "https://smolsend.vercel.app/",
        "source_code": "https://github.com/AlbertSu123/linkToLambo",
        "link": "https://ethglobal.com/showcase/smolsend-n3gsh"
    },
    {
        "title": "OmnichainFHEAuction",
        "brief_description": "Using fully-homomorphic encryption on Fhenix to implement second-price sealed bid auctions, and using LayerZero to allow bids from any chain, unifying liquidity: a global secret auction across all chains.",
        "long_description": "Auction creator creates an auction contract on Fhenix: The auction creator sets an auction start / end date, minimum bid, and code to run when the auction is won (e.g. automatically send an NFT). This code can be run cross-chain using LayerZero.\nUser visits our frontend, they want to bid on X Chain\nWe use Fhenix\u2019s FHE frontend library to encrypt their bid.\nEncrypted bid is sent to our bid submission smart contract on X Chain.\nWe also ask the user to approve the bid submission smart contract as a spender for UINT256_MAX\nWe use LayerZero to send the encrypted bid to our auction smart contract on Fhenix.\nThe auction contract stores the encrypted bit and the chain from which the bid originated.\nSince it\u2019s difficult to install on LayerZero on new chains, we\u2019re actually sending via Sepolia (the base cain for the Fhenix L2)\nAt the end of the auction period, the contract uses FHE to compare all bids and determine which bid is the highest\nWe use LayerZero to send a message back to the chain from which the bid originated and transfer the assets from the winning bidder.\nIf the transfer is unsuccessful, LayerZero can send message back and Fhenix contract can move on to next highest bidder Frontend which can grab data from Fhenix to show auction status and can send data to X Chain to submit bids\nFigure out how encrypt data with the Fhenix JS SDK and send it as arbitrary bytes to another smart contract Auction smart contract on Fhenix\nFigure out how to compare different encrypted values on Fhenix\nhttps://github.com/FhenixProtocol/blind-auction-example Bid submission contract on any L1 we want to support\nFigure out how to accept encrypted bytes LayerZero infrastructure to send data to and from other L1s and Fhenix\nFigure out how to send data between chains",
        "how_its_made": "Frontend which can grab data from Fhenix to show auction status and can send data to X Chain to submit bids\nFigure out how encrypt data with the Fhenix JS SDK and send it as arbitrary bytes to another smart contract Auction smart contract on Fhenix\nFigure out how to compare different encrypted values on Fhenix\nhttps://github.com/FhenixProtocol/blind-auction-example Bid submission contract on any L1 we want to support\nFigure out how to accept encrypted bytes LayerZero infrastructure to send data to and from other L1s and Fhenix\nFigure out how to send data between chains",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h4q81/screenshots/052is/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h4q81/screenshots/muu1t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h4q81/screenshots/1apo5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/nathanhleung/ethglobal",
        "link": "https://ethglobal.com/showcase/omnichainfheauction-h4q81"
    },
    {
        "title": "Things2Do",
        "brief_description": "Our Discovery Feed curates relevant news and offers based on user transaction history, driving higher engagement. By promoting actionable content, it boosts user retention, reduces churn, and encourages transactions.",
        "long_description": "Our Discovery Feed leverages the GrowthMate API to analyze user transaction history and rank posts based on individual interests. By interpreting on-chain activity, the API ensures users see content most relevant to them, including actionable news, offers, and suggested dApps. Users can choose the chain they want to explore and input any address to view content curated for that specific transaction history. This approach drives engagement by delivering personalized, interest-aligned recommendations, enhancing user retention and increasing the likelihood of completing transactions. This submission is frontend integration to the GrowthMate General Purpose Ranking API. The webpage was built using a default Vite React stack.",
        "how_its_made": "This submission is frontend integration to the GrowthMate General Purpose Ranking API. The webpage was built using a default Vite React stack.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pugqi/screenshots/9k9t0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pugqi/screenshots/3h7be/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pugqi/screenshots/t1yca/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/lennczar/eth-global-sf-2024",
        "link": "https://ethglobal.com/showcase/things2do-pugqi"
    },
    {
        "title": "ChainSage",
        "brief_description": "ChainSage: AI-powered DeFi strategy optimizer across multiple chains. Leverages Zircuit for high-performance smart contracts, LayerZero for cross-chain messaging, and Phala Network for confidential AI computations. Maximize your DeFi returns with personalized, secure insights.",
        "long_description": "ChainSage is an innovative AI-powered DeFi strategy optimizer that operates across multiple blockchain networks. The project aims to solve the challenge of identifying optimal investment strategies in the rapidly evolving DeFi landscape. It does this by aggregating strategies from various chains, using artificial intelligence to analyze and recommend optimal strategies based on user preferences, and providing a user-friendly interface for strategy comparison and selection.\nThe project leverages a sophisticated technology stack, including React.js for the frontend, Solidity for smart contracts, TensorFlow.js for AI modeling, and is primarily deployed on the Zircuit Testnet. It utilizes LayerZero for cross-chain messaging and Phala Network for confidential computing, ensuring privacy and security in AI computations. The core smart contract, ChainSageOApp, manages strategies across different chains and includes functions for adding strategies, retrieving data, and optimizing strategies cross-chain. With its focus on user experience, cross-chain functionality, and AI-driven insights, ChainSage represents a cutting-edge approach to DeFi strategy optimization, aiming to provide users with secure, efficient, and personalized investment recommendations across the fragmented DeFi ecosystem. This project is built on a foundation of Solidity smart contracts, with the main ChainSageOApp contract inheriting from LayerZero's OApp for cross-chain functionality. This allows ChainSage to manage and optimize DeFi strategies across various blockchain networks.\nThe frontend is developed using React.js, providing a user-friendly interface for interacting with the DeFi strategies. Key components include AIOptimizer for strategy fetching and optimization, StrategyDisplay for rendering strategy items, and WalletConnection for managing user wallet connections. The project integrates TensorFlow.js for AI-driven strategy analysis and recommendations, while Ethers.js facilitates blockchain interactions.\nChainSage incorporates several cutting-edge technologies to enhance its functionality and security. LayerZero's protocol enables cross-chain messaging and strategy optimization across different networks. Phala Network's SDK is integrated to ensure the privacy and security of AI model computations through confidential computing in a Trusted Execution Environment (TEE). The smart contracts are deployed on the Zircuit Testnet, taking advantage of its EVM-compatible environment, while the frontend is hosted on Vercel for reliable and fast access.\nThe development process included addressing challenges such as cross-chain data consistency and simulating AI decision-making for the hackathon demo. The project demonstrates the potential for sophisticated and secure DeFi applications by integrating blockchain technologies with AI, showcasing innovative solutions for DeFi strategy optimization across multiple chains.",
        "how_its_made": "This project is built on a foundation of Solidity smart contracts, with the main ChainSageOApp contract inheriting from LayerZero's OApp for cross-chain functionality. This allows ChainSage to manage and optimize DeFi strategies across various blockchain networks.\nThe frontend is developed using React.js, providing a user-friendly interface for interacting with the DeFi strategies. Key components include AIOptimizer for strategy fetching and optimization, StrategyDisplay for rendering strategy items, and WalletConnection for managing user wallet connections. The project integrates TensorFlow.js for AI-driven strategy analysis and recommendations, while Ethers.js facilitates blockchain interactions.\nChainSage incorporates several cutting-edge technologies to enhance its functionality and security. LayerZero's protocol enables cross-chain messaging and strategy optimization across different networks. Phala Network's SDK is integrated to ensure the privacy and security of AI model computations through confidential computing in a Trusted Execution Environment (TEE). The smart contracts are deployed on the Zircuit Testnet, taking advantage of its EVM-compatible environment, while the frontend is hosted on Vercel for reliable and fast access.\nThe development process included addressing challenges such as cross-chain data consistency and simulating AI decision-making for the hackathon demo. The project demonstrates the potential for sophisticated and secure DeFi applications by integrating blockchain technologies with AI, showcasing innovative solutions for DeFi strategy optimization across multiple chains.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/ucdv8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/n4y5n/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/cce9r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/bbq7s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/1kvvb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/0pwyv/screenshots/pgxb5/default.jpg"
        ],
        "live_demo": "https://chain-sage.vercel.app/",
        "source_code": "https://github.com/ajag408/ChainSage",
        "link": "https://ethglobal.com/showcase/chainsage-0pwyv"
    },
    {
        "title": "tinder for memecoins",
        "brief_description": "tinder for memecoins is a telegram mini app that lets you swipe right to purchase a memecoin",
        "long_description": "swipe right to buy, swipe left to load the next meme coin! no selling allowed. buys are pre-approved amounts. View a coins stats and charts and swipe once to buy the coin! This is all done within telegram's chat UI through a bot as a mini app. Swipe to go to the moon instead of getting rejected on traditional tinder! react project using react-tinder-card library and version 18 + 0x API for swaps & privy for telegram mini app authentication and wallet creation swaps on ethereum sepolia testnet from WETH --> UNI using 0x protocols swaps api very hacky and broken in it's current state but able to auth in, swipe through coins and send a swap through 0x protocol's swaps api & privy wallet",
        "how_its_made": "react project using react-tinder-card library and version 18 + 0x API for swaps & privy for telegram mini app authentication and wallet creation swaps on ethereum sepolia testnet from WETH --> UNI using 0x protocols swaps api very hacky and broken in it's current state but able to auth in, swipe through coins and send a swap through 0x protocol's swaps api & privy wallet",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/q3i3k/screenshots/2102f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q3i3k/screenshots/zeg7g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/q3i3k/screenshots/mn3e1/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MikeDank/ethglobalsf",
        "link": "https://ethglobal.com/showcase/tinder-for-memecoins-q3i3k"
    },
    {
        "title": "racoon-crypto-ai",
        "brief_description": "Imagine being able to interact with your favorite protocols, but this time with a chat interface",
        "long_description": "Imagine seamlessly interacting with your favorite blockchain protocols through a chat interface, where complex transactions and interactions become as simple as sending a message. Whether you\u2019re managing DeFi assets, swapping tokens, or exploring NFTs, you can now do it all through an intuitive conversation, making the experience more accessible and user-friendly. No more navigating complicated UIs or remembering contract addresses\u2014just a natural conversation that helps you perform the actions you want, effortlessly. This is the future of decentralized interaction, where blockchain meets simplicity through chat. I took two projects and combined them together. I plugged in a eth scaffold template alongside an open llm chat and got this. Used Dynamic for account management. The llm actually runs inside of the browser preventing any data leaking. Alongside this, messages and chats are saved locally",
        "how_its_made": "I took two projects and combined them together. I plugged in a eth scaffold template alongside an open llm chat and got this. Used Dynamic for account management. The llm actually runs inside of the browser preventing any data leaking. Alongside this, messages and chats are saved locally",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/r0vyu/screenshots/wu9vd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r0vyu/screenshots/zccip/default.jpg",
            "https://ethglobal.b-cdn.net/projects/r0vyu/screenshots/b3eav/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ben-jamming-reilly/racoon-crypto-ai?tab=readme-ov-file",
        "link": "https://ethglobal.com/showcase/racoon-crypto-ai-r0vyu"
    },
    {
        "title": "Easypeace",
        "brief_description": "There is room for improvement as to how we navigate conflict. Easy peace helps with that.",
        "long_description": "Easy Peace is an AI-driven mediation app designed to help individuals and couples resolve relationship conflicts through thoughtful, diplomatic guidance. Whether you're navigating communication barriers, emotional misunderstandings, or complex relationship dynamics, EasyPeace provides a safe space for reflection, resolution, and growth. A heartfelt thanks goes out to the incredible teams behind the technology that makes this peace mediation tool possible. Most of the magic in untangling conflicts and fostering better communication is driven by the powerful AI agent, thanks to the innovative advancements from OpenAI. Their work has provided us with the tools to create meaningful solutions, offering thoughtful rephrasing and suggestions that allow both parties to find common ground. We also extend our deep appreciation to Privy.io for their invaluable support in safeguarding user privacy and handling sensitive data responsibly. Their expertise in privacy matters ensures that our platform not only facilitates conflict resolution but also maintains the highest standards of data protection and user trust. Their contributions to Frontend Matters have been essential in creating a secure, user-friendly experience for all involved. Thank you to both OpenAI and Privy.io for helping to make this mediation tool a reality, empowering people to resolve conflicts while feeling safe and supported.",
        "how_its_made": "A heartfelt thanks goes out to the incredible teams behind the technology that makes this peace mediation tool possible. Most of the magic in untangling conflicts and fostering better communication is driven by the powerful AI agent, thanks to the innovative advancements from OpenAI. Their work has provided us with the tools to create meaningful solutions, offering thoughtful rephrasing and suggestions that allow both parties to find common ground. We also extend our deep appreciation to Privy.io for their invaluable support in safeguarding user privacy and handling sensitive data responsibly. Their expertise in privacy matters ensures that our platform not only facilitates conflict resolution but also maintains the highest standards of data protection and user trust. Their contributions to Frontend Matters have been essential in creating a secure, user-friendly experience for all involved. Thank you to both OpenAI and Privy.io for helping to make this mediation tool a reality, empowering people to resolve conflicts while feeling safe and supported.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mo3do/screenshots/ro9c7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mo3do/screenshots/vvqox/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mo3do/screenshots/7ckj9/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/PiaVictoria21/easypeace",
        "link": "https://ethglobal.com/showcase/easypeace-mo3do"
    },
    {
        "title": "Omni Castles",
        "brief_description": "In Omni Castles, players conquer castles across blockchains, using Skale\u2019s gasless battles, Fhenix\u2019s hidden armies with Acurast weather, and Rootstock\u2019s Bitcoin-based morale. Control 70% of castles to be crowned Emperor\u2014each requiring a unique strategy!",
        "long_description": "Omni Castles is a game where players must conquer and hold multiple castles across different blockchains. To be crowned Emperor, a player must control at least 70% -  (Math.ceil(0.7 * number_of_castles)) of all castles. Each castle is built on a unique blockchain, utilizing its strengths to offer diverse gameplay experiences, requiring different strategies to conquer. Skale Castle: This castle requires a massive army due to Skale's ability to handle large computations. Battles are complex and leverage Skale's built-in, gasless randomness. Skale\u2019s scalability makes large-scale battles possible without gas costs. Fhenix Castle: Utilizing Fully Homomorphic Encryption (FHE), this castle hides the defending army, forcing attackers to guess its composition based on previous battles. Acurast Oracle integrates real-time weather data, which affects battle outcomes. AirDAO Castle: Built on a scalable blockchain with high transactions per second (TPS), battles are more resource-intensive than on Fhenix, though not as demanding as on Skale. Rootstock Castle: Closely tied to the price of Bitcoin, the defending army's morale is affected by Bitcoin\u2019s market performance, adding an economic twist to battles. Here are the relevant Github repos: This hackathon is just the start, we ran out of time before implementing a unifying leaderboard (using subgraph) and Near protocol for controlling other EVM chains. In Omni Castles, we used a variety of technologies tailored to the strengths of different blockchains: Skale: Leveraged Skale\u2019s gasless techniques and built-in RNG for large-scale battles. This allowed us to run complex computations without incurring gas costs, which was crucial for smooth gameplay in army-heavy scenarios. AirDAO: Integrated Acurast for oracles, bringing in real-time weather data to affect battles, and used decentralized keepers for automatic execution of tasks, ensuring the game ran autonomously without manual intervention. Fhenix: Also utilized Acurast for weather oracles but added the twist of Fully Homomorphic Encryption (FHE) to hide defender states, requiring attackers to deduce defensive positions based on prior battles. We initially planned to unify these castles using Near for cross-chain actions and Subgraph for leaderboard tracking, but ran out of time before completing those integrations. These would have enhanced the multi-chain functionality and tracking of player progress across all castles. One of the more hacky aspects of Omni Castles is that neither AirDAO nor Fhenix had native oracle support before. This project is the first to introduce Acurast Oracles on these blockchains. Acurast\u2019s Trusted Execution Environment (TEE) forwards Web2 API data, like weather conditions, directly to smart contracts with minimal trust overhead, making it a groundbreaking integration for decentralized gaming mechanics.",
        "how_its_made": "In Omni Castles, we used a variety of technologies tailored to the strengths of different blockchains: Skale: Leveraged Skale\u2019s gasless techniques and built-in RNG for large-scale battles. This allowed us to run complex computations without incurring gas costs, which was crucial for smooth gameplay in army-heavy scenarios. AirDAO: Integrated Acurast for oracles, bringing in real-time weather data to affect battles, and used decentralized keepers for automatic execution of tasks, ensuring the game ran autonomously without manual intervention. Fhenix: Also utilized Acurast for weather oracles but added the twist of Fully Homomorphic Encryption (FHE) to hide defender states, requiring attackers to deduce defensive positions based on prior battles. We initially planned to unify these castles using Near for cross-chain actions and Subgraph for leaderboard tracking, but ran out of time before completing those integrations. These would have enhanced the multi-chain functionality and tracking of player progress across all castles. One of the more hacky aspects of Omni Castles is that neither AirDAO nor Fhenix had native oracle support before. This project is the first to introduce Acurast Oracles on these blockchains. Acurast\u2019s Trusted Execution Environment (TEE) forwards Web2 API data, like weather conditions, directly to smart contracts with minimal trust overhead, making it a groundbreaking integration for decentralized gaming mechanics.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/yv5wp/screenshots/bsu1d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yv5wp/screenshots/82u7w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/yv5wp/screenshots/g8eha/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Cloakworks-collective/omnicastle_skale",
        "link": "https://ethglobal.com/showcase/omni-castles-yv5wp"
    },
    {
        "title": "ProgressionXR",
        "brief_description": "ProgressionXR blends AI, XR, and Web3 for the ultimate fitness journey! \ud83e\udde0\ud83d\udd76\ufe0f\ud83c\udf0d Train with AI wellness coaches, sync workouts with Fitbit & VR, and earn rewards through fitness challenges while ensuring your privacy with multichain attestations. \ud83d\ude80\ud83d\udcaa",
        "long_description": "ProgressionXR is an innovative platform that combines Artificial Intelligence (AI), Extended Reality (XR), and Web3 technologies to create a truly immersive fitness experience. Users can connect their fitness devices, such as Fitbit and VR headsets, to engage in personalized, real-time workouts. The platform features AI-driven wellness coaches that guide users on their fitness journey, providing tailored advice to help them achieve their goals. With a focus on privacy, ProgressionXR utilizes the Litt X Sign Protocol for privacy-preserved attestations, allowing users to maintain full control over their data. Additionally, the platform offers competitive fitness challenges, where users can predict outcomes, support their favorite teams, and earn exclusive rewards. ProgressionXR's seamless Dynamic integration allows for easy, multichain logins, enhancing the onboarding experience for users across various blockchain ecosystems. ProgressionXR leverages a sophisticated tech stack, blending AI, XR, and Web3 innovations to provide users with an enhanced fitness experience. Phala AI Models: These decentralized AI models power the wellness coaches, offering real-time, personalized fitness advice based on user data and goals, while ensuring privacy through a decentralized approach. XR Integration: Users can sync their Fitbit and VR headsets, creating an immersive fitness journey that tracks workouts in real-time. This provides a fully interactive and engaging fitness experience. Dynamic for Social Logins: The platform uses Dynamic for seamless, multichain logins, allowing users to sign in across various blockchains without any hassle. Litt X Sign Protocol for Privacy Attestations: ProgressionXR integrates the Litt X Sign Protocol to ensure privacy-preserved attestations, allowing users to maintain control over their fitness data in a decentralized and secure way. Fitness Predictions: An integrated oracle enables decentralized prediction markets where users can forecast the outcomes of fitness challenges and earn rewards based on their predictions.",
        "how_its_made": "ProgressionXR leverages a sophisticated tech stack, blending AI, XR, and Web3 innovations to provide users with an enhanced fitness experience. Phala AI Models: These decentralized AI models power the wellness coaches, offering real-time, personalized fitness advice based on user data and goals, while ensuring privacy through a decentralized approach. XR Integration: Users can sync their Fitbit and VR headsets, creating an immersive fitness journey that tracks workouts in real-time. This provides a fully interactive and engaging fitness experience. Dynamic for Social Logins: The platform uses Dynamic for seamless, multichain logins, allowing users to sign in across various blockchains without any hassle. Litt X Sign Protocol for Privacy Attestations: ProgressionXR integrates the Litt X Sign Protocol to ensure privacy-preserved attestations, allowing users to maintain control over their fitness data in a decentralized and secure way. Fitness Predictions: An integrated oracle enables decentralized prediction markets where users can forecast the outcomes of fitness challenges and earn rewards based on their predictions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/84tjv/screenshots/1b2uz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/84tjv/screenshots/94djj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/84tjv/screenshots/650yp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/84tjv/screenshots/qsgbh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ProgressionXR-eth-sanfrancisco/xr-contracts",
        "link": "https://ethglobal.com/showcase/progressionxr-84tjv"
    },
    {
        "title": "Best Consumer App",
        "brief_description": "We make it easy for anyone - even consumers - to \"cook\" code with an AI-assisted interface.",
        "long_description": "Fund.fun is a decentralized, permissionless platform to fund fun projects. The donor seeds a project by staking a designated of amount of cryptocurrency, selecting a source of yield, and designating a recipient of the yield. Other donors can join the pool. The project receives all yield while the donors always have the option to withdraw their principle. I use cookbook.dev to demonstrate the capabilities of its contract library and AI assistance. Cookbook.dev accelerates protocol growth by onboarding developers faster. Cookbook integrates an AI chatbot, dev playground and contract library into a project\u2019s docs. The result is a unified learning, building, and deployment ecosystem so devs can deploy faster and projects can grow their communities.",
        "how_its_made": "I use cookbook.dev to demonstrate the capabilities of its contract library and AI assistance. Cookbook.dev accelerates protocol growth by onboarding developers faster. Cookbook integrates an AI chatbot, dev playground and contract library into a project\u2019s docs. The result is a unified learning, building, and deployment ecosystem so devs can deploy faster and projects can grow their communities.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tcm75/screenshots/hp91h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tcm75/screenshots/eskw8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tcm75/screenshots/6q4w3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/whatupjeff",
        "link": "https://ethglobal.com/showcase/best-consumer-app-tcm75"
    },
    {
        "title": "My Little Quant",
        "brief_description": "AI agent to read charts and tell you where the orderblock is (so you know if it's a good time to buy)",
        "long_description": "When the user presses the chrome extension's button, chrome extension takes a picture of the chart of the asset, and determines where the orderblock is, so that when the asset goes back down to that price, you know it's a good time to buy the asset (because it'll go up). words words words words words words words words words words words words words words words words  words words words words words words words words  words words words words words words words words It's a basic chrome extension. I used the Claude API, React, JS. What inspired me to make this is trying to trade shitcoins and not really knowing when to enter or exit the coin and needing to consult chatgpt to understand these things. words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words",
        "how_its_made": "It's a basic chrome extension. I used the Claude API, React, JS. What inspired me to make this is trying to trade shitcoins and not really knowing when to enter or exit the coin and needing to consult chatgpt to understand these things. words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words words",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bmjyb/screenshots/v7q88/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bmjyb/screenshots/d4eau/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bmjyb/screenshots/04w10/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/619/orderblock-detector",
        "link": "https://ethglobal.com/showcase/my-little-quant-bmjyb"
    },
    {
        "title": "Cr\u00e8de",
        "brief_description": "Decentralized platform using Zero-Knowledge(K) circuits for secure identity verification.",
        "long_description": "Introducing a decentralized platform powered by Zero-Knowledge (ZK) circuits, designed to revolutionize secure identity verification. This innovative solution provides a no-code tool for credential issuers to effortlessly create ZK circuits, simplifying the process of building advanced cryptographic proofs. Users benefit by generating trustless on-chain identities, enabling seamless interaction with various online services without compromising their privacy. The platform empowers both individuals and organizations with privacy-preserving identity management. Key Features: Privacy-Focused: Protect user data by proving identity without sharing personal details.\nTrustless Proofs: On-chain verification ensures transparency without requiring trust in intermediaries.\nNo-Code Tools: Simple UI for credential issuers to build ZK circuits without technical expertise.\nVersatile Use Cases: Support for multiple online services across Web3 and traditional platforms.\nUser-Friendly Interface: Intuitive workflows for both users and issuers, fostering adoption and ease of use.\nThis platform redefines digital trust, ensuring secure and private identity verification in the era of decentralized technology. here are some transactions created by the app:\nhttps://juicy-low-small-testnet.explorer.testnet.skalenodes.com/address/0xf7f861870aC67B27322E6f23f3442E660103Ce00?tab=txs\nhttps://amoy.polygonscan.com/tx/0xe6bfe9743a2434291256f2ccc36ffe268e3c01e332e87936d38a2a6df2651fdb\nhttps://testnet.layerzeroscan.com/tx/0xb302e3f543145b58e1b2d45c83f75d650d55201ae93c89415a98e88dc9a6a517 Our platform is built on a robust, scalable, and decentralized architecture that ensures privacy, security, and seamless integration with blockchain ecosystems. The core components of our architecture are: Backend \u2013 Zero-Knowledge Proof Generation\nTechnology: Rust & Circom\nFunctionality: The backend is responsible for generating Zero-Knowledge (ZK) proofs, providing cryptographic assurance of identity without exposing personal information. Rust ensures high performance and security, while Circom enables the creation of complex ZK circuits. Blockchain Layer \u2013 Smart Contracts and Proof Storage\nTechnology: Solidity\nNetwork: SKALE Network\nFunctionality: Smart contracts, written in Solidity, store and manage ZK proofs on-chain, enabling secure, trustless identity verification. The SKALE blockchain provides scalability, low-latency transactions, and interoperability to support seamless identity verification. Incentivization Token\nToken Utility: Encourages adoption and usage of the platform through an incentive model.\nBridge Technology: LayerZero protocol.\nToken Transfer: A cross-chain bridge connects SKALE with the Polygon network, ensuring seamless transfer of tokens between chains for users and incentivizing ecosystem participants. Frontend \u2013 User and Issuer Interface\nTechnology: Next.js\nFunctionality: The frontend offers an intuitive and responsive interface for users and credential issuers. With easy-to-navigate workflows, it allows issuers to create ZK circuits without code and users to generate, manage, and carry trustless on-chain identities across services. This modular and decentralized architecture ensures that the platform remains secure, scalable, and user-friendly. Each component integrates seamlessly to deliver a privacy-preserving, trustless identity verification system, leveraging the best technologies across Rust, Circom, Solidity, and modern blockchain protocols.",
        "how_its_made": "Our platform is built on a robust, scalable, and decentralized architecture that ensures privacy, security, and seamless integration with blockchain ecosystems. The core components of our architecture are: Backend \u2013 Zero-Knowledge Proof Generation\nTechnology: Rust & Circom\nFunctionality: The backend is responsible for generating Zero-Knowledge (ZK) proofs, providing cryptographic assurance of identity without exposing personal information. Rust ensures high performance and security, while Circom enables the creation of complex ZK circuits. Blockchain Layer \u2013 Smart Contracts and Proof Storage\nTechnology: Solidity\nNetwork: SKALE Network\nFunctionality: Smart contracts, written in Solidity, store and manage ZK proofs on-chain, enabling secure, trustless identity verification. The SKALE blockchain provides scalability, low-latency transactions, and interoperability to support seamless identity verification. Incentivization Token\nToken Utility: Encourages adoption and usage of the platform through an incentive model.\nBridge Technology: LayerZero protocol.\nToken Transfer: A cross-chain bridge connects SKALE with the Polygon network, ensuring seamless transfer of tokens between chains for users and incentivizing ecosystem participants. Frontend \u2013 User and Issuer Interface\nTechnology: Next.js\nFunctionality: The frontend offers an intuitive and responsive interface for users and credential issuers. With easy-to-navigate workflows, it allows issuers to create ZK circuits without code and users to generate, manage, and carry trustless on-chain identities across services. This modular and decentralized architecture ensures that the platform remains secure, scalable, and user-friendly. Each component integrates seamlessly to deliver a privacy-preserving, trustless identity verification system, leveraging the best technologies across Rust, Circom, Solidity, and modern blockchain protocols.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/64vph/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/2mies/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/i1ciu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/07kpb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/NJCinnamond/crede",
        "link": "https://ethglobal.com/showcase/crede-pucis"
    },
    {
        "title": "Cr\u00e8de",
        "brief_description": "Decentralized platform using Zero-Knowledge(K) circuits for secure identity verification.",
        "long_description": "Introducing a decentralized platform powered by Zero-Knowledge (ZK) circuits, designed to revolutionize secure identity verification. This innovative solution provides a no-code tool for credential issuers to effortlessly create ZK circuits, simplifying the process of building advanced cryptographic proofs. Users benefit by generating trustless on-chain identities, enabling seamless interaction with various online services without compromising their privacy. The platform empowers both individuals and organizations with privacy-preserving identity management. Key Features: Privacy-Focused: Protect user data by proving identity without sharing personal details.\nTrustless Proofs: On-chain verification ensures transparency without requiring trust in intermediaries.\nNo-Code Tools: Simple UI for credential issuers to build ZK circuits without technical expertise.\nVersatile Use Cases: Support for multiple online services across Web3 and traditional platforms.\nUser-Friendly Interface: Intuitive workflows for both users and issuers, fostering adoption and ease of use.\nThis platform redefines digital trust, ensuring secure and private identity verification in the era of decentralized technology. here are some transactions created by the app:\nhttps://juicy-low-small-testnet.explorer.testnet.skalenodes.com/address/0xf7f861870aC67B27322E6f23f3442E660103Ce00?tab=txs\nhttps://amoy.polygonscan.com/tx/0xe6bfe9743a2434291256f2ccc36ffe268e3c01e332e87936d38a2a6df2651fdb\nhttps://testnet.layerzeroscan.com/tx/0xb302e3f543145b58e1b2d45c83f75d650d55201ae93c89415a98e88dc9a6a517 Our platform is built on a robust, scalable, and decentralized architecture that ensures privacy, security, and seamless integration with blockchain ecosystems. The core components of our architecture are: Backend \u2013 Zero-Knowledge Proof Generation\nTechnology: Rust & Circom\nFunctionality: The backend is responsible for generating Zero-Knowledge (ZK) proofs, providing cryptographic assurance of identity without exposing personal information. Rust ensures high performance and security, while Circom enables the creation of complex ZK circuits. Blockchain Layer \u2013 Smart Contracts and Proof Storage\nTechnology: Solidity\nNetwork: SKALE Network\nFunctionality: Smart contracts, written in Solidity, store and manage ZK proofs on-chain, enabling secure, trustless identity verification. The SKALE blockchain provides scalability, low-latency transactions, and interoperability to support seamless identity verification. Incentivization Token\nToken Utility: Encourages adoption and usage of the platform through an incentive model.\nBridge Technology: LayerZero protocol.\nToken Transfer: A cross-chain bridge connects SKALE with the Polygon network, ensuring seamless transfer of tokens between chains for users and incentivizing ecosystem participants. Frontend \u2013 User and Issuer Interface\nTechnology: Next.js\nFunctionality: The frontend offers an intuitive and responsive interface for users and credential issuers. With easy-to-navigate workflows, it allows issuers to create ZK circuits without code and users to generate, manage, and carry trustless on-chain identities across services. This modular and decentralized architecture ensures that the platform remains secure, scalable, and user-friendly. Each component integrates seamlessly to deliver a privacy-preserving, trustless identity verification system, leveraging the best technologies across Rust, Circom, Solidity, and modern blockchain protocols.",
        "how_its_made": "Our platform is built on a robust, scalable, and decentralized architecture that ensures privacy, security, and seamless integration with blockchain ecosystems. The core components of our architecture are: Backend \u2013 Zero-Knowledge Proof Generation\nTechnology: Rust & Circom\nFunctionality: The backend is responsible for generating Zero-Knowledge (ZK) proofs, providing cryptographic assurance of identity without exposing personal information. Rust ensures high performance and security, while Circom enables the creation of complex ZK circuits. Blockchain Layer \u2013 Smart Contracts and Proof Storage\nTechnology: Solidity\nNetwork: SKALE Network\nFunctionality: Smart contracts, written in Solidity, store and manage ZK proofs on-chain, enabling secure, trustless identity verification. The SKALE blockchain provides scalability, low-latency transactions, and interoperability to support seamless identity verification. Incentivization Token\nToken Utility: Encourages adoption and usage of the platform through an incentive model.\nBridge Technology: LayerZero protocol.\nToken Transfer: A cross-chain bridge connects SKALE with the Polygon network, ensuring seamless transfer of tokens between chains for users and incentivizing ecosystem participants. Frontend \u2013 User and Issuer Interface\nTechnology: Next.js\nFunctionality: The frontend offers an intuitive and responsive interface for users and credential issuers. With easy-to-navigate workflows, it allows issuers to create ZK circuits without code and users to generate, manage, and carry trustless on-chain identities across services. This modular and decentralized architecture ensures that the platform remains secure, scalable, and user-friendly. Each component integrates seamlessly to deliver a privacy-preserving, trustless identity verification system, leveraging the best technologies across Rust, Circom, Solidity, and modern blockchain protocols.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/64vph/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/2mies/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/i1ciu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pucis/screenshots/07kpb/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/NJCinnamond/crede",
        "link": "https://ethglobal.com/showcase/crede-pucis"
    },
    {
        "title": "bitGaming",
        "brief_description": "Play-to-earn gaming platform and NFT marketplace powered by AI, Blockchain and Decentralized storage",
        "long_description": "Bitgame-ETH is a blockchain-powered gaming platform that integrates NFTs, decentralized storage, and multiple interactive  play-to-earn (P2E) games, including an AI-driven Dungeons & Dragons (DnD) experience, Chimp Test, and Number Memory. The platform uses: Dynamic.xyz for lightning-fast authentication. Dynamic's widget enables first time users to create new wallet with various accounts including GitHub, emails, e.g. without extra effort. Wallet address is the key for user to enter the world of web3,  claim NFTs, and view leaderboard and galleries. Walrus for decentralized object storage. We store NFTs and D&D narration images in Walrus and serve them on our frontend. The blob id returned from Walrus are also stored as a folder-like file to optimize the storage space in our server, and ensures the security and robustness of the data, utilizing the BFT feature of Walrus. OpenAI APIs LLM for AI gaming experience. We use OpenAI's API to create AI chat bot that generate sceneries and images according to user's selection of actions, providing a immersive and innovative experience for users. Morph Holesky Testnet for the smart contract deployments & interactions. Smart contracts manage NFT creation and ownership, with Morph handling the underlying transaction processes, allowing for secure, transparent, and automated interactions. You may play these games on our platform: Other functionalities: Technologies Backend Technologies Architecture Notable Features",
        "how_its_made": "Technologies Backend Technologies Architecture Notable Features",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/oqjnk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/ffq0i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/b3r62/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/a1jqc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/j2v3q/default.jpg",
            "https://ethglobal.b-cdn.net/projects/2up94/screenshots/zwpvz/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Akezh/bitgaming-eth",
        "link": "https://ethglobal.com/showcase/bitgaming-2up94"
    },
    {
        "title": "Guides",
        "brief_description": "An educational app for learning Web3 protocols with interactive lessons, on-chain actions, and attestations. Users earn XP, complete quizzes, and validate achievements on Polygon while seamlessly engaging with blockchain tech like Coinbase AA and Sign Attestation Protocol.",
        "long_description": "The project is a comprehensive educational mobile platform designed to make learning about Web3 protocols interactive and engaging. Built using React, Next.js, and designed in Figma, the app provides a seamless user experience with a dynamic interface. User access is facilitated through Alchemy Account Kit, which supports flexible login options like email and wallet connections. Course completions are validated through Sign Protocol, which generates attestations stored immutably on the Polygon blockchain, providing verifiable proof of user achievements. The platform also integrates Coinbase's account abstraction (AA) flow in specific lessons to enable users to create smart accounts and experience advanced blockchain features firsthand. Inspired by the Easy A platform, the app combines theoretical learning with practical experience. Users explore blockchain protocols through lessons that detail features, technical background, use cases, and provides information on estimated completion time, developer participation, and XP rewards. Each lesson ends with an on-chain interaction, such as minting an NFT or signing a transaction, allowing users to directly engage with blockchain technologies. The platform emphasizes real-world skills, where completing lessons not only imparts knowledge but also involves blockchain activities that solidify the learning experience. This project aims to enhance blockchain education by merging interactive content, decentralized technologies, and practical applications to create an all-encompassing environment where users can learn, engage, and verify their skills through the entire Web3 ecosystem. The project uses React, Next.js, and Figma for a dynamic and visually consistent frontend. Alchemy Account Kit provides flexible authentication, while Coinbase's AA flow enables smart account creation. Sign Protocol verifies course completions with attestations stored on Polygon. The platform includes on-chain tasks like minting NFTs, and features real-time tracking for XP rewards and a custom onboarding flow for seamless user experience.",
        "how_its_made": "The project uses React, Next.js, and Figma for a dynamic and visually consistent frontend. Alchemy Account Kit provides flexible authentication, while Coinbase's AA flow enables smart account creation. Sign Protocol verifies course completions with attestations stored on Polygon. The platform includes on-chain tasks like minting NFTs, and features real-time tracking for XP rewards and a custom onboarding flow for seamless user experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ac8ng/screenshots/6b4z8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ac8ng/screenshots/assio/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ac8ng/screenshots/dkoyq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/henrikkv/Guides",
        "link": "https://ethglobal.com/showcase/guides-ac8ng"
    },
    {
        "title": "Notarix",
        "brief_description": "Our project is a secure, real-world, ID-verified notarization platform designed to streamline digital notarization while maintaining strong user privacy and security.",
        "long_description": "notarix.vercel.app This project is designed to on-board users not familiar with web3 to a secure, real-world ID-verified digital notarization platform. The website is designed such that the file upload provides a one-click attestation, generating a unique URL that can be sent to a notary of your choice. Dynamic wallet is used for extensive compatibility with wallets, including Ledger Live. The attestation includes an on-chain stored file via the Skale Network and real-world identity verification via Synaps. The notary is then able to verify the identity of the document and provider via a simple interface and provide their own signature via the Sign protocol. The entire project is hosted on Polygon to allow for rapid execution of dApps and low gas fees. All payment uses USDC as currency to further break down the web2 to web3 barrier for uninitiated users. We use Dynamic for wallet authentication to serve as the central identity for document notarization and payment processes. We use Ledger for cryptographic document signing, ensuring private keys remain offline and tamper-proof. Skale Network provides decentralized, zero-cost storage for affidavit voice memos and other files via elastic sidechains. We built a smart contract that handles payment, using Circle\u2019s USDC, ensuring seamless and transparent fee settlements for the non-blockchain enthusiast. The core of the platform is our custom Sign Protocol, which emulates in-person notary workflows using nested schemas. In this process, clients submit signed documents and verified identities through Synaps, a decentralized identity protocol utilizing zero-knowledge proofs for AML/KYC real-world identity verification. Upon verifying document integrity and associated identity, a digital notary attests the signature, with notarization entries indexed on-chain for fast lookups. Our documentation includes setup instructions, architecture diagrams, and a roadmap for future scalability and multi-chain support.",
        "how_its_made": "We use Dynamic for wallet authentication to serve as the central identity for document notarization and payment processes. We use Ledger for cryptographic document signing, ensuring private keys remain offline and tamper-proof. Skale Network provides decentralized, zero-cost storage for affidavit voice memos and other files via elastic sidechains. We built a smart contract that handles payment, using Circle\u2019s USDC, ensuring seamless and transparent fee settlements for the non-blockchain enthusiast. The core of the platform is our custom Sign Protocol, which emulates in-person notary workflows using nested schemas. In this process, clients submit signed documents and verified identities through Synaps, a decentralized identity protocol utilizing zero-knowledge proofs for AML/KYC real-world identity verification. Upon verifying document integrity and associated identity, a digital notary attests the signature, with notarization entries indexed on-chain for fast lookups. Our documentation includes setup instructions, architecture diagrams, and a roadmap for future scalability and multi-chain support.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/h30kb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/n5ihm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/oyo8d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/byc4m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/hkm1f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hyb0a/screenshots/pm9x1/default.jpg"
        ],
        "live_demo": "https://notarix.vercel.app/",
        "source_code": "https://github.com/kevinledev/notarix",
        "link": "https://ethglobal.com/showcase/notarix-hyb0a"
    },
    {
        "title": "TrueCanvas",
        "brief_description": "TrueCanvas empowers digital artists to authenticate their original work using zero-knowledge proofs. By providing command logs and artworks, artists generate proofs published to blockchains. This allows anyone to verify authenticity, enhancing trust in digital creations.",
        "long_description": "Problem Statement/Motivation Digital artists who create original works manually or with traditional digital tools like Adobe Illustrator or Photoshop face significant challenges in proving the authenticity of their creations. The rise of generative AI and sophisticated digital manipulation tools has made it increasingly difficult for viewers and other artists to discern whether a piece of art is genuinely original or partially generated by AI. This skepticism undermines the value and credibility of authentic digital art, making it challenging for artists to showcase their hard work and for viewers to trust the originality of the pieces they admire. Moreover, artists are concerned about privacy issues, as they may not want to disclose the intricate details of their creative process or reveal proprietary techniques that constitute their \"secret sauce\" in art creation. Solution: To tackle the challenge of proving the authenticity of original digital artworks without compromising the artist's privacy, we developed TrueCanvas. This platform allows artists to notarize their creations using zero-knowledge proofs (ZKPs), ensuring that their work is original and unaltered by AI without revealing sensitive details of their creative process. Generating a Proof Workflow Artist Generates Creation Logs The artist creates their digital artwork using tools like Photoshop and exports the command logs (.psd logs) that record each creative action taken during the artwork's development. Uploading Artwork and Requesting Proof The artist uploads their artwork (e.g., a PNG file) along with the associated .psd logs to the TrueCanvas frontend application. They then make a request for proof generation through the application's interface. Proof Request Processing The frontend application sends the proof request to the backend server, which is responsible for handling the proof generation process. Log Verification and Proof Generation The backend server verifies the uploaded logs to ensure they meet specific criteria, such as confirming that less than 10% of the pixels are copy-pasted. If the logs pass verification, they are fed into the zero-knowledge proof generator written in Rust using RISC Zero. Receiving Proof and Verification The generated proof and verification details are returned to the artist. This proof attests to the authenticity and originality of the artwork without disclosing any proprietary information or revealing the artist's creative techniques. Publishing to Blockchains The proof and a reference to the artwork are securely stored using Walrus, a decentralized storage solution. They are then published to various blockchains, such as the Story Protocol, via smart contracts written in Solidity. This ensures that the proof is immutable and publicly accessible for verification by anyone. Verifying Proof Accessing the Proof Anyone interested in verifying the authenticity of the artwork can access the verification link provided by the artist. This link might be shared in an Instagram description, on an online gallery, or through other platforms where the artwork is showcased. Proof Verification The verifier reads the proof directly from the blockchain and can independently verify the authenticity of the artwork on any device. This process does not require specialized software or access to the artist's private creation logs. By verifying the proof, they are assured that the artwork is original and not generated or heavily modified using AI tools. Technology Stack To implement TrueCanvas effectively, we integrated a comprehensive technology stack that ensures security, scalability, and a seamless user experience. Here's how the various technologies work together: At the frontend, we utilized Next.js and React to build a responsive and intuitive application where artists can upload their artwork and request proof generation. This user-friendly interface allows artists to interact with the platform effortlessly. The frontend communicates with a backend server developed in Go, which handles proof requests and orchestrates the interactions between different system components. Go's efficiency and concurrency support make it ideal for managing these operations reliably. For the core logic of zero-knowledge proof generation, we employed Rust in conjunction with RISC Zero, a zero-knowledge virtual machine (zkVM). Rust provides high performance and security, which are crucial for cryptographic computations. RISC Zero enables us to create off-chain zero-knowledge proofs that verify the artist's creation process without revealing sensitive information. This ensures that the proofs are both secure and efficient. To securely store the generated proofs and associated artwork, we used Walrus, a decentralized data availability storage solution. Walrus ensures that the data is tamper-proof and remains accessible, leveraging the benefits of decentralized storage to enhance security and reliability. The proofs and references to the artwork are published to multiple blockchains to guarantee transparency and immutability. We wrote smart contracts in Solidity and deployed them on platforms like Polygon and Story Protocol. Polygon provides a scalable and decentralized blockchain platform, ensuring cost-effective transactions and fast confirmation times. The Story Protocol facilitates the registration of NFTs and offers a provenance system, which is essential for tracking the history and ownership of digital artworks. To enable cross-chain interoperability, we integrated Layer Zero. This technology allows proofs to be published and verified across multiple blockchain networks, enhancing the system's flexibility and reach. It ensures that artists and verifiers can interact with the platform regardless of their preferred blockchain. For secure authentication, we incorporated Dynamic, which provides wallet-based authentication for artists. This enables artists to securely log in and manage their proofs using their digital wallets, adding an extra layer of security and convenience. By combining these technologies, TrueCanvas offers a cohesive system where each component plays a vital role: The frontend provides an accessible platform for artists to interact with.\nThe backend manages proof generation requests and system coordination.\nRISC Zero and Rust handle secure and efficient proof generation.\nWalrus ensures secure and decentralized storage of proofs and artworks.\nSolidity smart contracts on Polygon and Story Protocol handle blockchain interactions, providing transparency and immutability.\nLayer Zero enhances interoperability across different blockchain networks.\nDynamic secures user authentication and session management.\nThis integrated technology stack ensures that TrueCanvas operates smoothly, providing artists with a secure and private way to authenticate their digital artworks, and offering verifiers a reliable method to confirm authenticity. ZK Proofs At the heart of TrueCanvas is the use of advanced cryptographic techniques involving zero-knowledge proofs (ZKPs) to verify the authenticity of digital artworks without revealing any sensitive information about the creation process. Canvas Representation as a Two-Dimensional Merkle Tree with Action Logs The digital canvas is modeled as a two-dimensional Merkle tree, a cryptographic data structure that efficiently represents and verifies large datasets. Each pixel or group of pixels acts as leaves in the tree, and the root hash uniquely represents the current state of the canvas. Any modification to the canvas, such as altering pixels through an action, updates the Merkle root, serving as a secure fingerprint of the artwork at any given time. Artists export detailed action logs from Photoshop, which record every action performed and the specific pixels modified. These logs provide the necessary data to understand how the canvas evolves with each action, forming the foundation for our proofs. Base Proof Generation Using RISC Zero, we generate base proofs that verify the correctness of the canvas's transition from the initial state to the updated state after each action. The function inputs for the proof generation are: Initial Merkle Tree (Before an Action): Represents the state of the canvas before a specific action is applied.\nUpdates from Actions: The set of pixel modifications resulting from the action.\nThis base proof ensures that the action is legitimate and consistent with the canvas's state changes without revealing any details about the action itself. Recursive Proofs and Merkle Root Constraints Each base proof is transformed into a recursive proof, which encapsulates not just a single action but the entire sequence of actions up to that point. Recursive proofs are combined by aligning the Merkle root hashes: The output Merkle root of one proof becomes the input Merkle root of the next.\nThis chaining ensures that all transitions between canvas states are valid and verifiable, effectively proving the integrity of the entire creation process. We employ Scalable Transparent ARguments of Knowledge (STARKs) to construct these recursive proofs. STARKs provide scalability and transparency, making the proofs efficient to generate and verify without requiring trusted setups. Enhancing Proof Succinctness with KZG Commitments While STARKs are powerful, the proofs they generate can be relatively large compared to other proof systems. To further reduce the size of the proofs and enhance verification efficiency, we use Kate-Zaverucha-Goldberg (KZG) polynomial commitments. Zero-Knowledge Proof of Verification:\nWe create a zk-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) of the STARK proof verification using KZG commitments.\nThis process generates a succinct zero-knowledge proof that verifies the correctness of the original STARK proof without revealing any additional information.\nBy making a zk-proof of the verification process, we significantly compress the proof data. The combination of STARKs with KZG commitments results in highly succinct proofs that are practical for real-world applications, offering both transparency and efficiency.",
        "how_its_made": "Technology Stack To implement TrueCanvas effectively, we integrated a comprehensive technology stack that ensures security, scalability, and a seamless user experience. Here's how the various technologies work together: At the frontend, we utilized Next.js and React to build a responsive and intuitive application where artists can upload their artwork and request proof generation. This user-friendly interface allows artists to interact with the platform effortlessly. The frontend communicates with a backend server developed in Go, which handles proof requests and orchestrates the interactions between different system components. Go's efficiency and concurrency support make it ideal for managing these operations reliably. For the core logic of zero-knowledge proof generation, we employed Rust in conjunction with RISC Zero, a zero-knowledge virtual machine (zkVM). Rust provides high performance and security, which are crucial for cryptographic computations. RISC Zero enables us to create off-chain zero-knowledge proofs that verify the artist's creation process without revealing sensitive information. This ensures that the proofs are both secure and efficient. To securely store the generated proofs and associated artwork, we used Walrus, a decentralized data availability storage solution. Walrus ensures that the data is tamper-proof and remains accessible, leveraging the benefits of decentralized storage to enhance security and reliability. The proofs and references to the artwork are published to multiple blockchains to guarantee transparency and immutability. We wrote smart contracts in Solidity and deployed them on platforms like Polygon and Story Protocol. Polygon provides a scalable and decentralized blockchain platform, ensuring cost-effective transactions and fast confirmation times. The Story Protocol facilitates the registration of NFTs and offers a provenance system, which is essential for tracking the history and ownership of digital artworks. To enable cross-chain interoperability, we integrated Layer Zero. This technology allows proofs to be published and verified across multiple blockchain networks, enhancing the system's flexibility and reach. It ensures that artists and verifiers can interact with the platform regardless of their preferred blockchain. For secure authentication, we incorporated Dynamic, which provides wallet-based authentication for artists. This enables artists to securely log in and manage their proofs using their digital wallets, adding an extra layer of security and convenience. By combining these technologies, TrueCanvas offers a cohesive system where each component plays a vital role: The frontend provides an accessible platform for artists to interact with.\nThe backend manages proof generation requests and system coordination.\nRISC Zero and Rust handle secure and efficient proof generation.\nWalrus ensures secure and decentralized storage of proofs and artworks.\nSolidity smart contracts on Polygon and Story Protocol handle blockchain interactions, providing transparency and immutability.\nLayer Zero enhances interoperability across different blockchain networks.\nDynamic secures user authentication and session management.\nThis integrated technology stack ensures that TrueCanvas operates smoothly, providing artists with a secure and private way to authenticate their digital artworks, and offering verifiers a reliable method to confirm authenticity. ZK Proofs At the heart of TrueCanvas is the use of advanced cryptographic techniques involving zero-knowledge proofs (ZKPs) to verify the authenticity of digital artworks without revealing any sensitive information about the creation process. Canvas Representation as a Two-Dimensional Merkle Tree with Action Logs The digital canvas is modeled as a two-dimensional Merkle tree, a cryptographic data structure that efficiently represents and verifies large datasets. Each pixel or group of pixels acts as leaves in the tree, and the root hash uniquely represents the current state of the canvas. Any modification to the canvas, such as altering pixels through an action, updates the Merkle root, serving as a secure fingerprint of the artwork at any given time. Artists export detailed action logs from Photoshop, which record every action performed and the specific pixels modified. These logs provide the necessary data to understand how the canvas evolves with each action, forming the foundation for our proofs. Base Proof Generation Using RISC Zero, we generate base proofs that verify the correctness of the canvas's transition from the initial state to the updated state after each action. The function inputs for the proof generation are: Initial Merkle Tree (Before an Action): Represents the state of the canvas before a specific action is applied.\nUpdates from Actions: The set of pixel modifications resulting from the action.\nThis base proof ensures that the action is legitimate and consistent with the canvas's state changes without revealing any details about the action itself. Recursive Proofs and Merkle Root Constraints Each base proof is transformed into a recursive proof, which encapsulates not just a single action but the entire sequence of actions up to that point. Recursive proofs are combined by aligning the Merkle root hashes: The output Merkle root of one proof becomes the input Merkle root of the next.\nThis chaining ensures that all transitions between canvas states are valid and verifiable, effectively proving the integrity of the entire creation process. We employ Scalable Transparent ARguments of Knowledge (STARKs) to construct these recursive proofs. STARKs provide scalability and transparency, making the proofs efficient to generate and verify without requiring trusted setups. Enhancing Proof Succinctness with KZG Commitments While STARKs are powerful, the proofs they generate can be relatively large compared to other proof systems. To further reduce the size of the proofs and enhance verification efficiency, we use Kate-Zaverucha-Goldberg (KZG) polynomial commitments. Zero-Knowledge Proof of Verification:\nWe create a zk-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) of the STARK proof verification using KZG commitments.\nThis process generates a succinct zero-knowledge proof that verifies the correctness of the original STARK proof without revealing any additional information.\nBy making a zk-proof of the verification process, we significantly compress the proof data. The combination of STARKs with KZG commitments results in highly succinct proofs that are practical for real-world applications, offering both transparency and efficiency.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/h29mf/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/jrdrv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/hyhxb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/7i8y3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/91b2k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/5uwmd/screenshots/cmk2t/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Pistondo/eth-sf-2024",
        "link": "https://ethglobal.com/showcase/truecanvas-5uwmd"
    },
    {
        "title": "The Monk Store",
        "brief_description": "Add feature that will allow user ENS names to be resolved to wallet address for payments",
        "long_description": "This project adds a simple utility that enables users to be able to use Unlimit web payment portal with their ENS. Currently the user cannot simply pay using his ENS name. The address has to be input manually. This feature allows for the input to be parsed and then supplied to the web payment portal Next.js, ethers, and Unlimit integration was used to create this project. I added a new feature for them so their overlay model can accept an ENS address. Unlimit payment portal was fun to use and thei documentation was helpful. I caught couple of bugs in the documentation, and the integration process",
        "how_its_made": "Next.js, ethers, and Unlimit integration was used to create this project. I added a new feature for them so their overlay model can accept an ENS address. Unlimit payment portal was fun to use and thei documentation was helpful. I caught couple of bugs in the documentation, and the integration process",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/qyf6m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/toos3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/thpha/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/oew00/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/orc1v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zsjk1/screenshots/gyxzt/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/way2rach/unlimit-ens-resolver",
        "link": "https://ethglobal.com/showcase/the-monk-store-zsjk1"
    },
    {
        "title": "EthBox",
        "brief_description": "EthBox is a Web3-based Dropbox for artists and listeners. It ensures secure, tamper-proof, and verifiable file sharing through Dynamic login and Weavechain for encrypted storage, and Skale\u2019s Calypso Chain for transaction proofs creating a decentralized solution to protect IPs",
        "long_description": "EthBox is a decentralized, secure music distribution platform, designed to tackle file sharing and piracy issues. The music industry has long struggled with piracy and unauthorized file sharing at the peer-to-peer level and within larger circles. Large music labels and streaming services often control rights and distribution, but peer-to-peer sharing, especially among smaller artists, continues to be a problem. For example, DJs often distribute their work on thumb drives, lacking secure and verifiable methods for managing their intellectual property.  EthBox is a specialized Web3 Dropbox for music, offering an encrypted, semi-decentralized file-sharing platform that maintains privacy and authenticity. It integrates with Dynamic for secure login, using a wallet address to authenticate users, ensuring that only trusted users can share and receive files. Artists can upload their music to Weavechain, an in-house API for storing and transporting encrypted files. Each file is signed and associated with a recipient's wallet address, ensuring that only the intended recipient can access the file.  Additionally, audit logs are generated during each read-and-write operation by the Weave node on the storage database.  These logs are stored on Skale Network, a zero-cost, gas-free blockchain platform that allows for scalable and efficient deployment. By writing audit logs on-chain, EthBox ensures verifiable proof of file immutability and lineage, preventing unauthorized tampering and verifying the sender's authenticity through cryptographic methods. This project is primarily written in javascript, using React for the frontend, using solidity to write the Skale smart contracts.  Python is used to control the development server that hosts the files and the weave node.  We start with Dynamic's login (React) which abstracts Web3 authentication behind a familiar Web2-like interface, which was crucial for onboarding users who might not be familiar with decentralized applications. Each user\u2019s public key is generated through their wallet address, and their actions are signed using cryptographic keys for secure identification.  I used Weavechain's API  (external) to code the backend.  A bit of solidity + java is used to create smart contracts deployed on the Skale network for each operation on the Weave database. Skale\u2019s zero-cost deployment was very helpful in dealing with gas fees, which would have been prohibitively expensive with frequent contract deployments for file tracking and audit logging. Next, looking at the way the public key exchange works, I used the Diffie Hellman pub key exchange.",
        "how_its_made": "This project is primarily written in javascript, using React for the frontend, using solidity to write the Skale smart contracts.  Python is used to control the development server that hosts the files and the weave node.  We start with Dynamic's login (React) which abstracts Web3 authentication behind a familiar Web2-like interface, which was crucial for onboarding users who might not be familiar with decentralized applications. Each user\u2019s public key is generated through their wallet address, and their actions are signed using cryptographic keys for secure identification.  I used Weavechain's API  (external) to code the backend.  A bit of solidity + java is used to create smart contracts deployed on the Skale network for each operation on the Weave database. Skale\u2019s zero-cost deployment was very helpful in dealing with gas fees, which would have been prohibitively expensive with frequent contract deployments for file tracking and audit logging. Next, looking at the way the public key exchange works, I used the Diffie Hellman pub key exchange.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ce3s1/screenshots/1srdk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ce3s1/screenshots/jjon0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ce3s1/screenshots/09bpq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ebchassine/final-ethsf24",
        "link": "https://ethglobal.com/showcase/ethbox-ce3s1"
    },
    {
        "title": "Medily",
        "brief_description": "An on-chain platform for medical image storage, solving interoperability across global healthcare systems.",
        "long_description": "A broken foot led me to the Canadian Emergency services. Unfortunately, the X ray was not shared with me for further consultation. This is a problem on many fronts. This project has 3 major parts:",
        "how_its_made": "This project has 3 major parts:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/66gcm/screenshots/uxv6a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/66gcm/screenshots/a57ik/default.jpg",
            "https://ethglobal.b-cdn.net/projects/66gcm/screenshots/gvctj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/66gcm/screenshots/9eos5/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Garima5/Medily",
        "link": "https://ethglobal.com/showcase/medily-66gcm"
    },
    {
        "title": "CareHippos",
        "brief_description": "Data aggregation app to give a real-time, reputational, and quantitative assessment of the community's health.",
        "long_description": "The CareHippos App is a decentralized application designed to allow users to submit their mood within the context of their communities, helping track the overall mental health and well-being of the community. Whether it\u2019s an office department, a DAO, a hospital floor, or a hackathon sponsor, this app provides a simple and effective way to assess a community's emotional state. By enabling users to vote via \"mood submission\", the app aggregates these votes to give a real-time, reputational, and quantitative assessment of the community's health. It helps community administrators identify potential conflicts, stress levels, and overall mood trends, empowering them to take action where needed. The smart contracts are deployed on Morph Holesky Testnet. We use Morph Holesky Testnet for each of the Mood CareHippo Token, Dynamic for wallet management \u00b4+ account abstraction. Our app is built with NextJS and wagmi, and deployed on Vercel. The users login with their social account, a wallet is generated for them. Users can create a Passkey to manage their keys, and gasless transactions are in the roadmap for seamless user interactions",
        "how_its_made": "We use Morph Holesky Testnet for each of the Mood CareHippo Token, Dynamic for wallet management \u00b4+ account abstraction. Our app is built with NextJS and wagmi, and deployed on Vercel. The users login with their social account, a wallet is generated for them. Users can create a Passkey to manage their keys, and gasless transactions are in the roadmap for seamless user interactions",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sn19u/screenshots/fhm03/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sn19u/screenshots/5thu2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sn19u/screenshots/jkjvb/default.jpg"
        ],
        "live_demo": "https://carehippos.vercel.app",
        "source_code": "https://github.com/a1uaP/carehippos",
        "link": "https://ethglobal.com/showcase/carehippos-sn19u"
    },
    {
        "title": "UniV4Backtester",
        "brief_description": "An institutional grade UniV4 backtester that faithfully replays UniV3 events (Swap, Mint, Burn), and see how a hypothetical position would have performed over a time window.",
        "long_description": "Uniswap v4 introduces the concept of hooks which allows DEX builders to customize behaviors throughout the swap lifecycle, i.e. before/after every swap and liquidity management actions.  A UniV4 pool is usually equipped with the concentrated liquidity curve of UniV3, but the hooks contract can customize how fees accrue to liquidity providers, among many others things, which can have a profound impact on LP profitability. As UniV4 gets ready for production and as more and more hooks are being developed, it is essential to build fast and robust tools that can help analyze how a hooks implementation affects traders and liquidity providers.  In that spirit, we introduce our UniV4 backtester. Our UniV4 backtester fetches liquidity events from a specified UniV3 pool, and then replays these events (Swap, Increase Liquidity, Remove Liquidity) in a hypothetical UniV4 pool which may come with specified hooks. This setup enables institutional grade backtesting analyses on how a UniV4 pool would have performed using the exact liquidity events of a real-world CLMM pool, rather than using aggregated (hourly or daily) historical data which will result in inaccurate and unrealistic results. The backtester is able to set up a hypothetical position, and backtests the position\u2019s performance through a specified time window. We used a variety of technologies to make this backtester: Viem (NodeJS) to fetch UniV3 pool events; Foundry to fork the Sepolia testnet and execute the backtest. --- UniV3 Event Fetching ---\nUniV3 events are fetched from an Ethereum RPC node through eth_getLogs calls on the UniV3 pool contract.  For the demo, we fetched early events of the WBTC-WETH 0.3% pool on Ethereum mainnet.  Since each eth_getLogs call only supports a limited block range, we have to fetch events in batches.  Retry mechanism has been implemented to make event fetching more robust against temporary communication issues with the rpc node. Details of Swap, Mint, Burn are recorded. Collect events are skipped as they do not affect the pool\u2019s liquidity state. --- Backtester Engine ---\nWe use Foundry to create a fork of the Ethereum Sepolia network where UniV4 is deployed.  First, the specified UniV4 pool is created on the fork.  Two dummy token contracts are deployed since production tokens are not available on testnet.  A large amount of tokens are minted to an arbitrary whale address. Liquidity events are replayed: The hypothetical position is set up at startTime, and its state (how much currency0 and currency1 can be collected) at endTime is returned as output at the end of the backtest.",
        "how_its_made": "We used a variety of technologies to make this backtester: Viem (NodeJS) to fetch UniV3 pool events; Foundry to fork the Sepolia testnet and execute the backtest. --- UniV3 Event Fetching ---\nUniV3 events are fetched from an Ethereum RPC node through eth_getLogs calls on the UniV3 pool contract.  For the demo, we fetched early events of the WBTC-WETH 0.3% pool on Ethereum mainnet.  Since each eth_getLogs call only supports a limited block range, we have to fetch events in batches.  Retry mechanism has been implemented to make event fetching more robust against temporary communication issues with the rpc node. Details of Swap, Mint, Burn are recorded. Collect events are skipped as they do not affect the pool\u2019s liquidity state. --- Backtester Engine ---\nWe use Foundry to create a fork of the Ethereum Sepolia network where UniV4 is deployed.  First, the specified UniV4 pool is created on the fork.  Two dummy token contracts are deployed since production tokens are not available on testnet.  A large amount of tokens are minted to an arbitrary whale address. Liquidity events are replayed: The hypothetical position is set up at startTime, and its state (how much currency0 and currency1 can be collected) at endTime is returned as output at the end of the backtest.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/zwhv6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/n01mx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/kodmz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/69i1e/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ht1e6/screenshots/pt8kw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Aperture-Finance/UniV4Backtester_ETHSF2024",
        "link": "https://ethglobal.com/showcase/univ4backtester-ht1e6"
    },
    {
        "title": "CryptoBASO",
        "brief_description": "Splits swaps across multiple transactions to prevent front running",
        "long_description": "Our project involves splitting up swap orders on DEX\u2019s across multiple transactions by taking advantage of SKALE\u2019s zero gas fees. This is so we can minimize losses occurred from frontrunning.\nOn other blockchains, trying to split up transactions results in more and more gas fees. If you want to make a trade of $50 across multiple transactions, it is not easily doable. It doesn\u2019t make sense to do 5 $10 trades if gas fees are $5.\nThe SKALE network\u2019s zero gas features improves the ability to spread out buy and sell orders across multiple transactions because gas costs are no longer a problematic factor.\nOur project can be slightly altered to work with any DEX on the network (given the DEX has good documentation). We used a simple \u201cfake DEX\u201d for demonstration purposes.\nWe hope that, as the SKALE network\u2019s DeFi ecosystem increases, we could help facilitate that growth with our own project and differentiate the SKALE ecosystem by using SKALE\u2019s zero gas features with our unique way of minimizing MEV. The frontend, built with Next.js and styled using Tailwind CSS, serves as the user interface where traders place limit orders, connect wallets, and monitor trades. Ethers.js bridges the frontend with the SKALE blockchain, enabling direct user interaction with the smart contracts. TypeScript enhances code reliability across the application. The smart contracts, written in Solidity, manage the core functionalities on the SKALE network. For the purpose of this project, we have created our own DEX to simulate trading conditions.\nIt manages trading operations such as token swaps, liquidity management, and order execution, with functions for adding/removing liquidity and handling token swaps. Here, the user mentions the limit orders. The orderbook.sol contract manages the lifecycle of limit orders, providing functionalities to place, modify, and cancel orders. It maintains a record of active orders and interacts with the DEX contract to execute trades when market conditions match the user\u2019s specified price. The PriceChecker.sol contract is responsible for validating real-time prices before executing a trade. It interacts with the DEX to fetch current market prices and ensures that each fragmented order meets the user\u2019s criteria for execution. We have a backend \u201cserver\u201d that utilizes ethers.js and the hardhat framework to conduct constant price checks and executions for every order. We utilized hardhat\u2019s local node for testing as well as SKALE\u2019s Europa DeFi testnet. The \"hacky\" part involved creating the dex.sol contract to simulate a realistic DEX environment for testing. There were no testnet DEX\u2019s, and other DEX\u2019s we tried to use had poor documentation on deployment. Our DEX handles fragmented trade execution, breaking large orders into smaller swaps to prevent frontrunning, leveraging SKALE's zero gas fees for efficient, iterative execution without incurring extra costs.",
        "how_its_made": "The frontend, built with Next.js and styled using Tailwind CSS, serves as the user interface where traders place limit orders, connect wallets, and monitor trades. Ethers.js bridges the frontend with the SKALE blockchain, enabling direct user interaction with the smart contracts. TypeScript enhances code reliability across the application. The smart contracts, written in Solidity, manage the core functionalities on the SKALE network. For the purpose of this project, we have created our own DEX to simulate trading conditions.\nIt manages trading operations such as token swaps, liquidity management, and order execution, with functions for adding/removing liquidity and handling token swaps. Here, the user mentions the limit orders. The orderbook.sol contract manages the lifecycle of limit orders, providing functionalities to place, modify, and cancel orders. It maintains a record of active orders and interacts with the DEX contract to execute trades when market conditions match the user\u2019s specified price. The PriceChecker.sol contract is responsible for validating real-time prices before executing a trade. It interacts with the DEX to fetch current market prices and ensures that each fragmented order meets the user\u2019s criteria for execution. We have a backend \u201cserver\u201d that utilizes ethers.js and the hardhat framework to conduct constant price checks and executions for every order. We utilized hardhat\u2019s local node for testing as well as SKALE\u2019s Europa DeFi testnet. The \"hacky\" part involved creating the dex.sol contract to simulate a realistic DEX environment for testing. There were no testnet DEX\u2019s, and other DEX\u2019s we tried to use had poor documentation on deployment. Our DEX handles fragmented trade execution, breaking large orders into smaller swaps to prevent frontrunning, leveraging SKALE's zero gas fees for efficient, iterative execution without incurring extra costs.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/d7xqy/screenshots/t3tbt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d7xqy/screenshots/5bmb2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d7xqy/screenshots/4pmkn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/d7xqy/screenshots/fo6a2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/cryptobaso/cryptobaso_skale",
        "link": "https://ethglobal.com/showcase/cryptobaso-d7xqy"
    },
    {
        "title": "Liquidity",
        "brief_description": "Implementation of an Automated Market Maker (AMM) contract using PINT (Programming Intent Notation). Supports providing liquidity, removing liquidity, token swaps, staking LP tokens, and claiming rewards based on staking duration.",
        "long_description": "This project is an implementation of an Automated Market Maker (AMM) smart contract using PINT (Programming Intent Notation). The contract supports providing liquidity, removing liquidity, token swaps, staking liquidity provider (LP) tokens, and claiming rewards based on staking duration. Contract Features\nProvide Liquidity: Users can provide two tokens, Token A and Token B, to a liquidity pool and receive LP tokens representing their share.\nRemove Liquidity: Users can remove liquidity from the pool by redeeming their LP tokens for Token A and Token B.\nSwap Tokens: Users can swap between Token A and Token B. A fee is charged on swaps, which is distributed to liquidity providers.\nStaking Liquidity: Liquidity providers can stake their LP tokens to earn rewards over time.\nClaiming Rewards: Users who stake their LP tokens can claim rewards based on how long their tokens were staked. The AMM project is built using a robust and scalable architecture. Here's a deep dive into how it was built: Smart Contract Layer: The core of the project is the AMM smart contract, implemented using PINT (Programming Intent Notation). PINT allows for a structured representation of contract logic, which enhances the readability and security of the code. The contract includes functions for providing liquidity, removing liquidity, swapping tokens, staking LP tokens, and claiming rewards. PINT's expressiveness allowed us to simplify complex behaviors through macros such as @auth for authorization checks, and @init_once for state consistency. Backend Infrastructure: The backend, entirely written in Rust, handles off-chain computations and interacts directly with the blockchain. Rust was chosen for its high performance and memory safety, making it ideal for managing critical financial transactions. The backend is responsible for processing requests from users, managing data consistency, and ensuring that all interactions with the blockchain are secure and efficient. Security Measures: Security is a significant concern for any DeFi project. We employed Secp256k1Signature for signed transactions, a cryptographic algorithm known for its use in blockchain systems like Bitcoin. Additionally, PredicateAddress authorization mechanisms were used to ensure flexible, programmable access control, which makes our solution highly secure while allowing composability with other smart contracts. We also implemented nonce-based replay protection to secure transaction integrity. Partner Technologies: To facilitate deployment and continuous integration, we used GitHub Actions for automating testing and deployments. This significantly reduced manual errors and ensured a smooth development workflow. Hacky but Notable Workarounds: One particularly hacky approach worth mentioning is our use of state delta tracking to minimize gas costs during state transitions. Instead of updating the entire state, we track and update only the deltas\u2014what has changed since the last transaction. This optimization led to reduced gas fees and more efficient execution of complex contract operations. By combining PINT, Rust, and efficient deployment practices, we've built a robust, scalable, and efficient AMM that offers flexibility, security, and a solid user experience. Partner technologies like GitHub Actions enriched the platform, ensuring stability and consistent deployments.",
        "how_its_made": "The AMM project is built using a robust and scalable architecture. Here's a deep dive into how it was built: Smart Contract Layer: The core of the project is the AMM smart contract, implemented using PINT (Programming Intent Notation). PINT allows for a structured representation of contract logic, which enhances the readability and security of the code. The contract includes functions for providing liquidity, removing liquidity, swapping tokens, staking LP tokens, and claiming rewards. PINT's expressiveness allowed us to simplify complex behaviors through macros such as @auth for authorization checks, and @init_once for state consistency. Backend Infrastructure: The backend, entirely written in Rust, handles off-chain computations and interacts directly with the blockchain. Rust was chosen for its high performance and memory safety, making it ideal for managing critical financial transactions. The backend is responsible for processing requests from users, managing data consistency, and ensuring that all interactions with the blockchain are secure and efficient. Security Measures: Security is a significant concern for any DeFi project. We employed Secp256k1Signature for signed transactions, a cryptographic algorithm known for its use in blockchain systems like Bitcoin. Additionally, PredicateAddress authorization mechanisms were used to ensure flexible, programmable access control, which makes our solution highly secure while allowing composability with other smart contracts. We also implemented nonce-based replay protection to secure transaction integrity. Partner Technologies: To facilitate deployment and continuous integration, we used GitHub Actions for automating testing and deployments. This significantly reduced manual errors and ensured a smooth development workflow. Hacky but Notable Workarounds: One particularly hacky approach worth mentioning is our use of state delta tracking to minimize gas costs during state transitions. Instead of updating the entire state, we track and update only the deltas\u2014what has changed since the last transaction. This optimization led to reduced gas fees and more efficient execution of complex contract operations. By combining PINT, Rust, and efficient deployment practices, we've built a robust, scalable, and efficient AMM that offers flexibility, security, and a solid user experience. Partner technologies like GitHub Actions enriched the platform, ensuring stability and consistent deployments.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/rn6mp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/oz6a6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/1wggt/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/tydxo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/is3e3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/w7ccf/screenshots/3e4kp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/dkcodes2/amm-pint",
        "link": "https://ethglobal.com/showcase/liquidity-w7ccf"
    },
    {
        "title": "ETHGambit",
        "brief_description": "A superior, decentralized alternative to online chess betting.",
        "long_description": "The act of \"hustling\" is a core part of chess culture. In big cities like New York and Boston, chess hustlers hang out in the park and play strangers, each putting down a small wager on the winner of the game. A single online service, chesshustleonline.com, attempts to capitalize on this tradition. On this website, 10% of each player's bets are taken as a fee. You don't get to decide how much to bet, which chess platform is used, and must wait 5-7 business days for your winnings. However, ETHGambit can completely circumvent all of these downsides. Using blockchain technology, users can take back control of this timeless tradition, tapping into an extremely large market of approximately 110 million users that were previously priced out and sketched out by the status quo. Overall, an intuitive UI combined with a solution alleviating a major pain point in the market will make a big splash in the online chess community, onboarding many enthusiastic users into web3. The blockchain technology used in ETHGambit is a Solidity smart contract originally deployed on Polygon, but switched to Flow. The Polygon Amoy Testnet had about a 50% percent chance of throwing a random \"Internal JSON-RPC Error\" when interacting with the contract, which contributed to much frustration. The Flow Testnet did not have these issues. The contract acts as an escrow with three main functions: An additional part of the back-end is a Python Flask server that grabs the result of the game. To make it more decentralized/trustless, we would use an oracle in the smart contract instead of a central server, which is the next step for this project. The front end was originally planned to be a browser extension, however, we shelved that for the purposes of technical capability demonstration. The UI is built with ReactJS that imports modules like ethers and web3 to pass values to the smart contract.",
        "how_its_made": "The blockchain technology used in ETHGambit is a Solidity smart contract originally deployed on Polygon, but switched to Flow. The Polygon Amoy Testnet had about a 50% percent chance of throwing a random \"Internal JSON-RPC Error\" when interacting with the contract, which contributed to much frustration. The Flow Testnet did not have these issues. The contract acts as an escrow with three main functions: An additional part of the back-end is a Python Flask server that grabs the result of the game. To make it more decentralized/trustless, we would use an oracle in the smart contract instead of a central server, which is the next step for this project. The front end was originally planned to be a browser extension, however, we shelved that for the purposes of technical capability demonstration. The UI is built with ReactJS that imports modules like ethers and web3 to pass values to the smart contract.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/y8v9e/screenshots/snze4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8v9e/screenshots/pzv7y/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8v9e/screenshots/pemmw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/y8v9e/screenshots/2hecg/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wolfiesell/ETHGambit",
        "link": "https://ethglobal.com/showcase/ethgambit-y8v9e"
    },
    {
        "title": "TerraTracker",
        "brief_description": "TerraTracker: Harnessing blockchain and AI for hyper-local disaster predictions. Empower communities with real-time insights, engage users through staking rewards, and support relief efforts with a portion of profits. Predict. Prepare. Protect.",
        "long_description": "TerraTracker is an innovative platform designed to predict natural disasters with precision and engage communities in proactive preparedness. By leveraging blockchain technology, TerraTracker ensures secure, transparent transactions and data integrity. The platform integrates real-time data from diverse sources, such as weather and seismic APIs, using Chainlink oracles for accurate predictions. Key Features: Blockchain Platform: Flow, Polygon for smart contracts, ensuring secure and transparent transactions. Integration and Benefits Notable Hacks",
        "how_its_made": "Blockchain Platform: Flow, Polygon for smart contracts, ensuring secure and transparent transactions. Integration and Benefits Notable Hacks",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/7jne7/screenshots/onvb4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7jne7/screenshots/sb9xp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7jne7/screenshots/cabr2/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jackiesafari/Terratracker3",
        "link": "https://ethglobal.com/showcase/terratracker-7jne7"
    },
    {
        "title": "Fluxus",
        "brief_description": "The project aims to maintain stablecoin price stability within a Uniswap V4 pool by using Chronicle oracles and dynamic fees.",
        "long_description": "The aim of the our project is to create a flexible, dynamic fee system that maintains stablecoin price stability within a Uniswap V4 liquidity pool. By integrating external oracles, dynamic fees, and the ability to toggle price behavior, we seek to maintain the value of a stablecoin near its target, discouraging extreme price volatility through economic incentives (fees). Smart Contract:\nThe smart contract is built via Foundry. It integrates Uniswap V4 to customize swap behavior for stablecoin trades, allowing dynamic fee adjustments based on price deviations from a target. The contract manages stablecoin prices using oracles to track pool prices and applies dynamic buy/sell fees to stabilize the price. A flipping mechanism allows the contract to switch between two pricing models. Fees are capped at 50%, encouraging price stability. Core functions include retrieving stablecoin prices, calculating fees, and modifying Uniswap\u2019s swap behavior. Additionally, a selfKiss method links oracles through the Chronicle ISelfKisser interface. Frontend:\nThis frontend is built with Next.js, React, and other web3 tools. It integrates authentication using Alchemy Account Kit with multiple login options, including email, passkey, social logins (Google, Facebook), and external wallets via WalletConnect. The project also utilizes Sepolia Testnet for blockchain interactions, configured with Alchemy's infrastructure for secure data transport.\nReact Query is used for efficient data fetching, and Wagmi with Viem handles wallet connections and blockchain transactions. TailwindCSS is used for styling, and ESLint ensures code quality. This setup makes the app a responsive and secure platform for interacting with stablecoins and decentralized finance features.",
        "how_its_made": "Smart Contract:\nThe smart contract is built via Foundry. It integrates Uniswap V4 to customize swap behavior for stablecoin trades, allowing dynamic fee adjustments based on price deviations from a target. The contract manages stablecoin prices using oracles to track pool prices and applies dynamic buy/sell fees to stabilize the price. A flipping mechanism allows the contract to switch between two pricing models. Fees are capped at 50%, encouraging price stability. Core functions include retrieving stablecoin prices, calculating fees, and modifying Uniswap\u2019s swap behavior. Additionally, a selfKiss method links oracles through the Chronicle ISelfKisser interface. Frontend:\nThis frontend is built with Next.js, React, and other web3 tools. It integrates authentication using Alchemy Account Kit with multiple login options, including email, passkey, social logins (Google, Facebook), and external wallets via WalletConnect. The project also utilizes Sepolia Testnet for blockchain interactions, configured with Alchemy's infrastructure for secure data transport.\nReact Query is used for efficient data fetching, and Wagmi with Viem handles wallet connections and blockchain transactions. TailwindCSS is used for styling, and ESLint ensures code quality. This setup makes the app a responsive and secure platform for interacting with stablecoins and decentralized finance features.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/zr3xd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/a03vp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/caubd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/oqbr5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ci8sj/screenshots/s5tsy/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Ashy5000/stablecoin_contracts",
        "link": "https://ethglobal.com/showcase/fluxus-ci8sj"
    },
    {
        "title": "StreamChain",
        "brief_description": "We don\u2019t want a centralized organization controlling crucial video evidence of things like police brutality or war crimes, but safety and legality must be paramount. StreamChain combines the trust of decentralized storage with the versatility of multi-modal LLM moderation.",
        "long_description": "While we don\u2019t want a centralized organization controlling crucial video evidence of things like police brutality or war crimes, safety and legality must be paramount. Combining the decentralized and immutable nature of Walrus Blob Storage with the safety and versatility of multi-modal LLM content moderation, we can ensure that videos that need to be published can be seen, while also moderating content that users upload, simultaneously ensuring the legality of the uploaded content. Using the SKALE blockchain, the content moderation model is fully auditable, as every confirmation or rejection is pushed to the chain with a reason provided by the model. Even the weights of the model are published on Walrus, meaning anybody can investigate the nature of the model and object to its behavior. Walrus Blob Storage is leveraged for its decentralized and immutable nature. The frontend procures blobIDs directly from the SKALE blockchain, and fetches the video directly from Walrus. Before any content is pushed to Walrus, the content moderation must make a decision as to its visibility and legality. Using the SKALE blockchain, the content moderation model is fully auditable, as every confirmation or rejection is pushed to the chain with a reason provided by the model. Even the weights of the model are published on Walrus, meaning anybody can investigate the nature of the model and object to its behavior. The video content moderation system uses an advanced filtering technique that can moderate huge amounts of footage with little inference cost. First, the frames are embedded in a multi-modal vector space using OpenAI CLIP. This process runs super fast entirely on device using Mac M2 Metal Performance Shaders. We can run this inexpensive computation in huge volume for free, which makes it perfect for filtering out potential true positives. We can then forward the frame to a smarter model, such as GPT-4o, for a final decision on content moderation. This method of content moderation is completely zero shot and is therefore extremely versatile. It can be further tuned with either fine-tuning or prompt adjustments, which can increase accuracy and usability.",
        "how_its_made": "Walrus Blob Storage is leveraged for its decentralized and immutable nature. The frontend procures blobIDs directly from the SKALE blockchain, and fetches the video directly from Walrus. Before any content is pushed to Walrus, the content moderation must make a decision as to its visibility and legality. Using the SKALE blockchain, the content moderation model is fully auditable, as every confirmation or rejection is pushed to the chain with a reason provided by the model. Even the weights of the model are published on Walrus, meaning anybody can investigate the nature of the model and object to its behavior. The video content moderation system uses an advanced filtering technique that can moderate huge amounts of footage with little inference cost. First, the frames are embedded in a multi-modal vector space using OpenAI CLIP. This process runs super fast entirely on device using Mac M2 Metal Performance Shaders. We can run this inexpensive computation in huge volume for free, which makes it perfect for filtering out potential true positives. We can then forward the frame to a smarter model, such as GPT-4o, for a final decision on content moderation. This method of content moderation is completely zero shot and is therefore extremely versatile. It can be further tuned with either fine-tuning or prompt adjustments, which can increase accuracy and usability.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zj41z/screenshots/85586/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zj41z/screenshots/hd7sx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zj41z/screenshots/prgpj/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/sun-jay/ETHsf24",
        "link": "https://ethglobal.com/showcase/streamchain-zj41z"
    },
    {
        "title": "undegen finance",
        "brief_description": "Undegen simplifies portfolio management by using a risk survey defined strategy to build and rebalance crypto investments automatically. Users can easily sign up, deposit funds, and maintain an optimal mix of assets based on their risk tolerance.",
        "long_description": "Our project tackles the challenge that many users face in building and balancing an optimal portfolio aligned with their risk tolerance, particularly those outside the U.S. who lack access to traditional investment options. Inspired by The Missing Billionaires by James White and Victor Haghani, we address common mistakes investors make when assessing risk, which often leads to poor financial outcomes. Through Undegen, users begin by taking a risk profile survey that helps them allocate assets across risk categories. This allocation is based on Merton portfolio calculations, offering an optimal split between low-risk (USDC with fixed yield) and high-risk (staked ETH and wrapped Bitcoin) assets. Users can then easily sign up with just an email and deposit funds, starting with USDC, to have their portfolio automatically built. Once set up, the platform provides real-time visibility into their holdings via a dashboard. The system continuously monitors risk allocation, and users can update their risk profile at any time, triggering automatic rebalancing of their portfolio to ensure it aligns with their updated investment goals and risk tolerance. Undegen aims to offer a globally accessible, permissionless solution for portfolio optimization, making smart investing easy and adaptable for everyone. We're streamlining the onboarding process by using Dynamic, which allows users to sign up using just their email. In the background, this creates an embedded wallet, offering a seamless experience without the complexity of traditional wallet setup. We're also generating a Safe smart wallet for each user. This wallet enables account abstraction, which lets us send transactions and handle gas fees on behalf of the user, enhancing usability. Our system leverages a Safe module to initiate a transaction on the Safe smart account, calling the UndegenModule's rebalance() function. This function then calls back into the Safe account (where it has authorization as an approved module), performing a delegatecall to the UndegenRebalancer contract. The rebalance action is executed from there, dynamically adjusting the portfolio based on preset risk strategies. One key advantage of this architecture is that the rebalancing occurs without needing explicit approvals, allowing everything to happen within a single transaction. The user still initiates the flow by specifying the desired allocation of risky assets (in USD) for their portfolio, with any excess automatically deposited into a USDC fixed-rate pool on Hyperdrive. To ensure accurate conversions between token prices and USD, our contracts use Chronicle oracles, ensuring smooth and precise portfolio rebalancing. We also used shadcn components for both figma and front-end implementation.",
        "how_its_made": "We're streamlining the onboarding process by using Dynamic, which allows users to sign up using just their email. In the background, this creates an embedded wallet, offering a seamless experience without the complexity of traditional wallet setup. We're also generating a Safe smart wallet for each user. This wallet enables account abstraction, which lets us send transactions and handle gas fees on behalf of the user, enhancing usability. Our system leverages a Safe module to initiate a transaction on the Safe smart account, calling the UndegenModule's rebalance() function. This function then calls back into the Safe account (where it has authorization as an approved module), performing a delegatecall to the UndegenRebalancer contract. The rebalance action is executed from there, dynamically adjusting the portfolio based on preset risk strategies. One key advantage of this architecture is that the rebalancing occurs without needing explicit approvals, allowing everything to happen within a single transaction. The user still initiates the flow by specifying the desired allocation of risky assets (in USD) for their portfolio, with any excess automatically deposited into a USDC fixed-rate pool on Hyperdrive. To ensure accurate conversions between token prices and USD, our contracts use Chronicle oracles, ensuring smooth and precise portfolio rebalancing. We also used shadcn components for both figma and front-end implementation.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/sr3vj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/bxefr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/e99x0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/w916i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/4f9cw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ym8tt/screenshots/dcejp/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/pcarranzav/undegen-contracts",
        "link": "https://ethglobal.com/showcase/undegen-finance-ym8tt"
    },
    {
        "title": "\u00c6xtend",
        "brief_description": "\u00c6xtend is a way to take your life, your specialty, and spread it everywhere.",
        "long_description": "The Project uses a series of AI agents to Mimic your skills, to make the model much better than it was at that skill, which also make it better than leading models at that skill while still being a mid-tier model. We first feed an AI model some documents you might have, it makes conclusions, which show us its thinking process and what its learning. From there you can edit that according to what you need it to be then test it with that takeaway/thought-process, then tweak it, and repeat the cycle till what you have is the perfect one. From there use it on real life projects. Usually Gemini 1.5 < GPT-4o For us, Gemini 1.5+\u00c6xtend > GPT-4o There is also Yddgrasil mode, which is several Gemini 1.5+\u00c6xtend skills put togther, this is >4o, weaker than OpenAI O1, but can reason with many more diverse skills and over much longer sizes (1M tokens), giving it some advantages over even the strongest models This project was made with my favorite fullstack setup, Sveltekit+Firebase, Then I used the Google GenAI api and its Model Gemini 1.5 for the very long very fast AI capabilities. From there I also used the Clip model to measure text similarity, and I used @Coinbase's wallets for all the transactions between my agents. Overall everything connects in the front end, but I had to make a key operation into a backend part and now its really clean+open source jump point for AI agents",
        "how_its_made": "This project was made with my favorite fullstack setup, Sveltekit+Firebase, Then I used the Google GenAI api and its Model Gemini 1.5 for the very long very fast AI capabilities. From there I also used the Clip model to measure text similarity, and I used @Coinbase's wallets for all the transactions between my agents. Overall everything connects in the front end, but I had to make a key operation into a backend part and now its really clean+open source jump point for AI agents",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/mn7xw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/u6p09/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/8hmup/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/k0mbu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/2yrfi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6e2df/screenshots/h3458/default.jpg"
        ],
        "live_demo": "https://extendtheta.vercel.app/",
        "source_code": "https://github.com/VatsaDev/ethglobalhack",
        "link": "https://ethglobal.com/showcase/aextend-6e2df"
    },
    {
        "title": "Swipa.meme",
        "brief_description": "Memecoin collecting with Tinder UI and points. If you like it, swipe right \ud83d\ude80",
        "long_description": "We're bringing memecoins to the masses, using a familiar touch: the swipe \u2714\ufe0f Memecoins are eating the world. In 2024, the memecoin market cap is $44.9B, and it's only going to grow. We want everyone in the world to join in on the fun. Introducing: Swipa.meme How does it work? The project is a PWA that aims to abstract as much of the boring and difficult web3 elements of crypto away from users so that they can focus on the fun of curating and rating memes for points. One point = one swipe = $0.01 Tech stack User Onboarding Swiping Cashing out",
        "how_its_made": "The project is a PWA that aims to abstract as much of the boring and difficult web3 elements of crypto away from users so that they can focus on the fun of curating and rating memes for points. One point = one swipe = $0.01 Tech stack User Onboarding Swiping Cashing out",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/r82ik/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/1mhp3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/adxwg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/1r0i8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/mgrca/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zucyg/screenshots/a2no6/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/thatguyintech/swipa",
        "link": "https://ethglobal.com/showcase/swipa-meme-zucyg"
    },
    {
        "title": "Crypto Carbon Alerts",
        "brief_description": "We built a React app that connects to user authentication via Alchemy\u2019s Accounts UI Widget. We're creating a composite Ethereum token of two crypto carbon credits on Celo using Toucan Protocol. A subgraph listens to wallet events and broadcasts via XMTP to a Telegram bot.",
        "long_description": "The background of this project is deeply rooted in sustainability, especially in the context of upcoming regulations like California's SB 253 and SB 261, which require companies to report on their carbon emissions across Scope 1, 2, and 3. These regulations, along with growing pressures from big tech companies like Amazon and Apple, are pushing corporations to be more transparent about their emissions and take action to reduce them.\nTo achieve net-zero emissions, these companies will need to purchase carbon offsets that compensate for the emissions they can't eliminate. However, there is currently a dearth of high-quality carbon credits, and the process of purchasing and managing them can be cumbersome.\nThe Role of Blockchain:\nBlockchain offers a promising solution by enabling dramatic transparency in carbon credit transactions. It allows companies to seamlessly purchase and retire carbon credits, ensuring that these credits are verifiable and traceable. The application your team built aims to address this need by fractionalizing a variety of carbon credits into a single composite token, reducing friction for companies seeking to offset emissions across various projects related to their operations.\nSingle Token for Multiple Projects:\nCompanies often want to offset their carbon footprint by investing in a variety of projects such as: Our team of three UC Berkeley students built for EthGlobal SF integrates several advanced technologies to create a unique solution for tracking and broadcasting crypto carbon credit movements.\nOverview:\nThe project is a React-based application that leverages Alchemy, Ethereum smart contracts, Toucan Protocol, The Graph, and XMTP for decentralized carbon credit tracking. The purpose of this application is to allow users to authenticate, monitor, and interact with carbon credit transactions on the blockchain, broadcasting real-time updates to a Telegram bot for easy tracking.\nDetailed Components:",
        "how_its_made": "Our team of three UC Berkeley students built for EthGlobal SF integrates several advanced technologies to create a unique solution for tracking and broadcasting crypto carbon credit movements.\nOverview:\nThe project is a React-based application that leverages Alchemy, Ethereum smart contracts, Toucan Protocol, The Graph, and XMTP for decentralized carbon credit tracking. The purpose of this application is to allow users to authenticate, monitor, and interact with carbon credit transactions on the blockchain, broadcasting real-time updates to a Telegram bot for easy tracking.\nDetailed Components:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/gus4z/screenshots/1xe6j/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gus4z/screenshots/kydt4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gus4z/screenshots/y8eve/default.jpg",
            "https://ethglobal.b-cdn.net/projects/gus4z/screenshots/dm8fu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/CarbonSustain/ethglobalsf",
        "link": "https://ethglobal.com/showcase/crypto-carbon-alerts-gus4z"
    },
    {
        "title": "PintSwap",
        "brief_description": "We built the first DEX on Essential Blockchain, powered by a declarative framework. Users can seamlessly add/remove liquidity, swap tokens, and earn LP tokens. Plus, we open-sourced a JS framework to make Essential development accessible to all developers.",
        "long_description": "Our project is the first decentralized exchange (DEX) built on Essential Blockchain, which operates using a declarative programming model. Essential allows state updates driven by constraints and solvers, optimizing outcomes without requiring direct transaction execution.\nWe dedicated significant time to developing and open-sourcing a TypeScript framework for Essential Blockchain, as no such framework existed before. This tool allows other developers to build applications on Essential using JavaScript/TypeScript, significantly lowering the barrier to entry for the ecosystem. In addition, we created a rigorous testing framework that helped us master contract syntax. Due to the limited resources and documentation available, we frequently worked with Essential\u2019s development team in Australia to troubleshoot issues and deepen our understanding of the chain and its capabilities. Our DEX allows users to:\n\u2022\tAdd/remove liquidity using token pairs and receive LP tokens, representing their share of the liquidity pool.\n\u2022\tSwap tokens within the liquidity pools, with prices adjusting automatically based on the AMM model.\n\u2022\tEarn LP tokens for providing liquidity and share in transaction fees as passive income.\nSince no tokens existed on the Essential Blockchain when we started, we wrote contracts to mint, burn, and transfer tokens. We also experimented with building a smart wallet tailored for the Essential Blockchain. On the front-end, we utilized Next.js and React to create a modern, responsive user interface, adhering to best practices observed in other swap protocols. Despite building the DEX in just 36 hours, we see incredible potential for future enhancements. Our next steps include developing a Dollar-Cost Averaging (DCA) tool, which will allow users to automatically purchase assets on a scheduled basis using time-based constraints in Pint contracts. This DEX project is just the beginning of leveraging the power of declarative blockchains to innovate in decentralized finance. Building the first decentralized exchange (DEX) on Essential Blockchain was a deeply technical and challenging process, particularly because Essential is a declarative blockchain, and most tooling traditionally supports imperative blockchains. Since Essential only supported Rust, we had to innovate to make the blockchain more accessible to a broader developer audience. Technologies We Used:\n\u2022\tPint: Essential\u2019s declarative smart contract language. It allowed us to write contracts with constraints that solvers could optimize, making the DEX function without relying on sequential execution.\n\u2022\tJavaScript/TypeScript: To make development easier and more accessible, we built a TypeScript framework that lets other developers write tools in JS/TS for Essential, bypassing the need for fluency in Rust. This framework also integrates with Essential\u2019s backend to allow contracts to be executed declaratively.\n\u2022\tNext.js: We built the DEX\u2019s front-end using Next.js & React to create a modern, responsive user interface, adopting best practices from established DEX protocols like Uniswap. This gave us a solid front-end development framework with server-side rendering for optimal performance.\n\u2022\tCustom Testing Framework: Since no robust testing framework existed for Pint contracts, we built our own to ensure that the constraints and contract logic were functioning properly. This involved writing tests that forced us to learn the nuances of the contract language and ensuring that all contract conditions were met during execution.\n\u2022\tSolvers & Constraints: The DEX relies on solvers to find the optimal token swaps and liquidity pooling conditions based on user-set constraints. This required a deep understanding of how solvers work to ensure that valid state transitions were made. How It Came Together:\n\u2022\tBackend Contracts: We built contracts for minting, burning, and transferring tokens since no tokens existed on the Essential chain when we started. These foundational contracts allowed us to create liquidity pools and issue LP tokens. Using Pint, we expressed constraints rather than step-by-step execution, which solvers would optimize to ensure valid outcomes.\n\u2022\tFrontend Development: With Next.js, we implemented the DEX\u2019s UI, allowing users to interact with the smart contracts seamlessly. We focused on user experience by mimicking the design patterns of successful swap protocols, ensuring users could add liquidity, swap tokens, and remove liquidity with ease. Challenges & Hacky Solutions:\n\u2022\tBuilding a JavaScript Framework: One of the most hacky and notable aspects of our project was building the JavaScript framework from scratch. Essential only supports Rust, so to make development easier for the broader community, we created this JS framework so that developers could write tools and apps for Essential without needing to dive deep into Rust. This was critical for us to overcome the limitations imposed by Rust-only support and enabled us to open-source the framework for future projects.\n\u2022\tCustom Wallet Development: We experimented with creating our own smart wallet to handle specific token interactions on the Essential chain. While this wasn\u2019t fully completed during the hackathon, it allowed us to explore how custom wallets could interact with the new JS framework and Pint contracts.\n\u2022\tConstant Communication with Essential\u2019s Dev Team: Since the documentation and guides for Essential were sparse, we often found ourselves directly reaching out to their dev team in Australia. This became essential for resolving tough bugs, especially when we were trying to wrap our heads around the proper contract syntax in Pint and testing various contract executions.",
        "how_its_made": "Building the first decentralized exchange (DEX) on Essential Blockchain was a deeply technical and challenging process, particularly because Essential is a declarative blockchain, and most tooling traditionally supports imperative blockchains. Since Essential only supported Rust, we had to innovate to make the blockchain more accessible to a broader developer audience. Technologies We Used:\n\u2022\tPint: Essential\u2019s declarative smart contract language. It allowed us to write contracts with constraints that solvers could optimize, making the DEX function without relying on sequential execution.\n\u2022\tJavaScript/TypeScript: To make development easier and more accessible, we built a TypeScript framework that lets other developers write tools in JS/TS for Essential, bypassing the need for fluency in Rust. This framework also integrates with Essential\u2019s backend to allow contracts to be executed declaratively.\n\u2022\tNext.js: We built the DEX\u2019s front-end using Next.js & React to create a modern, responsive user interface, adopting best practices from established DEX protocols like Uniswap. This gave us a solid front-end development framework with server-side rendering for optimal performance.\n\u2022\tCustom Testing Framework: Since no robust testing framework existed for Pint contracts, we built our own to ensure that the constraints and contract logic were functioning properly. This involved writing tests that forced us to learn the nuances of the contract language and ensuring that all contract conditions were met during execution.\n\u2022\tSolvers & Constraints: The DEX relies on solvers to find the optimal token swaps and liquidity pooling conditions based on user-set constraints. This required a deep understanding of how solvers work to ensure that valid state transitions were made. How It Came Together:\n\u2022\tBackend Contracts: We built contracts for minting, burning, and transferring tokens since no tokens existed on the Essential chain when we started. These foundational contracts allowed us to create liquidity pools and issue LP tokens. Using Pint, we expressed constraints rather than step-by-step execution, which solvers would optimize to ensure valid outcomes.\n\u2022\tFrontend Development: With Next.js, we implemented the DEX\u2019s UI, allowing users to interact with the smart contracts seamlessly. We focused on user experience by mimicking the design patterns of successful swap protocols, ensuring users could add liquidity, swap tokens, and remove liquidity with ease. Challenges & Hacky Solutions:\n\u2022\tBuilding a JavaScript Framework: One of the most hacky and notable aspects of our project was building the JavaScript framework from scratch. Essential only supports Rust, so to make development easier for the broader community, we created this JS framework so that developers could write tools and apps for Essential without needing to dive deep into Rust. This was critical for us to overcome the limitations imposed by Rust-only support and enabled us to open-source the framework for future projects.\n\u2022\tCustom Wallet Development: We experimented with creating our own smart wallet to handle specific token interactions on the Essential chain. While this wasn\u2019t fully completed during the hackathon, it allowed us to explore how custom wallets could interact with the new JS framework and Pint contracts.\n\u2022\tConstant Communication with Essential\u2019s Dev Team: Since the documentation and guides for Essential were sparse, we often found ourselves directly reaching out to their dev team in Australia. This became essential for resolving tough bugs, especially when we were trying to wrap our heads around the proper contract syntax in Pint and testing various contract executions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/a229i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/dd8jr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/qminr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/pwkya/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/3z0vd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/70ayj/screenshots/15yug/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/ewitulsk/PintSwap",
        "link": "https://ethglobal.com/showcase/pintswap-70ayj"
    },
    {
        "title": "SuperPass",
        "brief_description": "Super secure password management to prevent database pass code from getting lost or stolen.",
        "long_description": "Passman allows AI powered swipe based authentication to prevent lost or stolen passwords. The application allows database encryption and decryption using AI powered signature recognition preventing the possibility of stolen pass codes and persists on the blockchain to prevent code from becoming lost or forgotten. The server runs on a secure hardware TEE component. This project utilizes SIGN for encryption and decryption, Lit for database management, WALRUS for storage and PHALA for for a secure server. It uses AI image recognition and analysis to verify that the signature belongs to the user and can be used conveniently from either a mobile app or web browser.",
        "how_its_made": "This project utilizes SIGN for encryption and decryption, Lit for database management, WALRUS for storage and PHALA for for a secure server. It uses AI image recognition and analysis to verify that the signature belongs to the user and can be used conveniently from either a mobile app or web browser.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/z2esk/screenshots/8a8jv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z2esk/screenshots/kcg90/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z2esk/screenshots/tfhnr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z2esk/screenshots/0yr0f/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/amirhyoussefi/supersecurepass",
        "link": "https://ethglobal.com/showcase/superpass-z2esk"
    },
    {
        "title": "SmartEthereumWallet",
        "brief_description": "Smart Ethereum Wallet is a secure, user-friendly wallet tracker that monitors your Ethereum wallet activities, sends notifications for incoming/outgoing transactions, and provides a summary of balance changes over time\u2014all in one streamlined dashboard.",
        "long_description": "Smart Ethereum Wallet is a user-friendly tracker that provides real-time insights into Ethereum wallet activities. Built with a React frontend and an Express.js backend, it connects to the Ethereum blockchain using Ethers.js and Infura, ensuring fast and reliable data access. Users can view wallet balances, track transaction history, and receive instant notifications for new transactions through WebSocket integration. A custom caching mechanism on the backend helps reduce redundant API calls, providing a faster and smoother experience. SmartEthereumWallet is built using a React frontend for a seamless user experience, integrated with an Express.js backend to handle API requests and data processing. We used Ethers.js for interacting with the Ethereum blockchain, allowing us to fetch wallet balances and transaction history efficiently. The backend is connected to Infura, which serves as the Ethereum node provider, ensuring quick and reliable access to blockchain data without the need to manage our own nodes.",
        "how_its_made": "SmartEthereumWallet is built using a React frontend for a seamless user experience, integrated with an Express.js backend to handle API requests and data processing. We used Ethers.js for interacting with the Ethereum blockchain, allowing us to fetch wallet balances and transaction history efficiently. The backend is connected to Infura, which serves as the Ethereum node provider, ensuring quick and reliable access to blockchain data without the need to manage our own nodes.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/t692u/screenshots/55mpp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t692u/screenshots/c8ry0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/t692u/screenshots/yua3s/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/michelllee/SmartEthereumWallet",
        "link": "https://ethglobal.com/showcase/smartethereumwallet-t692u"
    },
    {
        "title": "DeHack",
        "brief_description": "A blazing fast cross-chain bridge utilizing account abstraction across all EVM chains",
        "long_description": "A blazing fast cross-chain bridge utilizing account abstraction across all EVM chains offers a seamless and efficient way to transfer assets. By enabling instant transactions and automating processes through smart contract wallets, users can enjoy a streamlined experience without the complexities of traditional cross-chain methods. This bridge optimizes gas fees and enhances security with additional measures like multi-signatures. Ultimately, it promotes improved liquidity and universal compatibility, making it a vital tool for the evolving DeFi ecosystem. A blazing fast cross-chain bridge utilizing account abstraction across all EVM chains offers a seamless and efficient way to transfer assets. By enabling instant transactions and automating processes through smart contract wallets, users can enjoy a streamlined experience without the complexities of traditional cross-chain methods. This bridge optimizes gas fees and enhances security with additional measures like multi-signatures. Ultimately, it promotes improved liquidity and universal compatibility, making it a vital tool for the evolving DeFi ecosystem.",
        "how_its_made": "A blazing fast cross-chain bridge utilizing account abstraction across all EVM chains offers a seamless and efficient way to transfer assets. By enabling instant transactions and automating processes through smart contract wallets, users can enjoy a streamlined experience without the complexities of traditional cross-chain methods. This bridge optimizes gas fees and enhances security with additional measures like multi-signatures. Ultimately, it promotes improved liquidity and universal compatibility, making it a vital tool for the evolving DeFi ecosystem.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vepwo/screenshots/j154x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vepwo/screenshots/m4df9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vepwo/screenshots/02wdm/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Chaitenyag/DeHack",
        "link": "https://ethglobal.com/showcase/dehack-vepwo"
    },
    {
        "title": "PumpRoyale",
        "brief_description": "Improve your fitness goals while also exposing yourself to immense monetary gain.",
        "long_description": "In PumpRoyale users across the globe can stake any amount of USDC across recurring global competitions. At random times during the competition a user is prompted to record themselves completing a basic fitness activity within 10 minutes of being prompted. Those who successfully completed the physical activity within the time frame will have their stake returned while those that fail will lose their stake which will form a losers pool. Upon the completion of every game, there will be a random select few of people that completed the fitness activity and will be awarded a distribution of the losers pool. Not only is the physical challenge relatively simple, but as the user base increases, the potential reward becomes exponentially larger. This project uses smart contracts to hold the stake from the users entering the competition, as well as refunding, and distributing the money from the loser pool amongst some randomly selected winners that completed their physical exercise. We built our frontend in React.js and our backend in Node.js. The reason why deploying this as a web3 application is advantageous is because these type of incentives fitness apps have been built on web2, however with payment processors like Stripe taking a 2.5% fee and receiving so many refund requests, Stripe actually blocked the company. With web3 we can avoid this problem since everything is handled on chain.",
        "how_its_made": "This project uses smart contracts to hold the stake from the users entering the competition, as well as refunding, and distributing the money from the loser pool amongst some randomly selected winners that completed their physical exercise. We built our frontend in React.js and our backend in Node.js. The reason why deploying this as a web3 application is advantageous is because these type of incentives fitness apps have been built on web2, however with payment processors like Stripe taking a 2.5% fee and receiving so many refund requests, Stripe actually blocked the company. With web3 we can avoid this problem since everything is handled on chain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/4zvfv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/sjns9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/y27s7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/xkei8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vdz5o/screenshots/04o0s/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/gkarthi280/hackathon_project/",
        "link": "https://ethglobal.com/showcase/pumproyale-vdz5o"
    },
    {
        "title": "Curvy",
        "brief_description": "Custom Curve Custom Curve Custom Curve Custom Curve Custom Curve",
        "long_description": "Custom Curve Custom Curve Custom Curve Custom Curve Custom Curve\nCustom Curve Custom Curve Custom Curve Custom Curve Custom Curve\nCustom Curve Custom Curve Custom Curve Custom Curve Custom Curve\nCustom Curve Custom Curve Custom Curve Custom Curve Custom Curve\nCustom Curve Custom Curve Custom Curve Custom Curve Custom Curve Solidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math",
        "how_its_made": "Solidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math\nSolidity Desmos prb-math Solidity Desmos prb-math Solidity Desmos prb-math",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/joijc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/odkbq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/ttvfx/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/y4xw5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/06iou/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vjk7e/screenshots/bksfw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MarcusWentz/eth-sf-2024",
        "link": "https://ethglobal.com/showcase/curvy-vjk7e"
    },
    {
        "title": "HelloACAI",
        "brief_description": "HelloACAI is Agent-based Collaborative AI infrastructure running On-Chain",
        "long_description": "Current Generalized AI helps with suggestions but doesn\u2019t actually help save execution time. AI lacks the ability to take the appropriate action based on the request. Enter Collaborative AI Agents. Multiple AI agents specializing in capabilities like:\nResearch, Interacting with websites, APIs, Calendars, Payments, etc. Purpose-built AI Agents all working together to perform complex tasks. When AI is collaborating, how can we ensure good interactions? Human agents do this through pen and paper contracts, HelloACAI does so via Smart Contracts. Interactions with and between AI Agents are bound by these contracts. HelloACAI also provides a registry for AI Agents built via a Smart Contract. Bring your own AI Agent, choose one from the registry, or both. With Collaborative AI, complex tasks are easily broken up into smaller, specific chunks. Building Collaborative AI via Smart Contracts ensures all agents interact well together. ACI Registry: Agent Collaboration Interface Registry: On-Chain Registry of Agents indexed via Subgraph Spindle \u2013 Agent Collaboration Thread: Spindle is a custom thread management system we built leveraging Substreams to rapidly respond to Agent Requested events from the ACS contract and call the corresponding Agent API Chat Interface: Friendly GUI for interacting with ACAI\nLeveraging Dynamic.xyz for easy sign in with email and CDP onramp for rapid onboarding AI Agents: Each Agent can be created independently by anyone\nAgents get contract signing capabilities, and an EOA provisioned via CDP when they are registered on ACAI",
        "how_its_made": "ACI Registry: Agent Collaboration Interface Registry: On-Chain Registry of Agents indexed via Subgraph Spindle \u2013 Agent Collaboration Thread: Spindle is a custom thread management system we built leveraging Substreams to rapidly respond to Agent Requested events from the ACS contract and call the corresponding Agent API Chat Interface: Friendly GUI for interacting with ACAI\nLeveraging Dynamic.xyz for easy sign in with email and CDP onramp for rapid onboarding AI Agents: Each Agent can be created independently by anyone\nAgents get contract signing capabilities, and an EOA provisioned via CDP when they are registered on ACAI",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/hbeet/screenshots/gjixw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hbeet/screenshots/xjuaz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/hbeet/screenshots/5c7ry/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/helloacai/helloacai",
        "link": "https://ethglobal.com/showcase/helloacai-hbeet"
    },
    {
        "title": "SmolKOL",
        "brief_description": "A transparent LLM-powered attention marketplace for Twitter.",
        "long_description": "I would encourage you watch the pitch! SmolKOL is an attention marketplace that connects indie Twitter accounts and companies through performance-based bounties. It allows companies or individuals to create bounties for social media engagement, and shitposters to earn rewards based on how well their content performs. The platform ensures that payments are tied to measurable outcomes such as likes or views, providing transparency and efficiency. Current \"KOL\" marketing models involve paying influencers upfront, often with no clear correlation between the payment and the actual results achieved. This creates inefficiency for brands and limits opportunities for smaller content creators to participate. There is a lack of transparency in how much value brands are getting for the money spent. SmolKOL addresses this by allowing companies/individuals to offer bounties based on specific performance metrics. Poasters submit content that aligns with these criteria, and payments are only made if the content meets the required level of engagement. This ensures that compensation is based on actual performance rather than follower count or reputation. SmolKOL operates as a bounty board where bounties are posted in natural language. Companies or individuals specify the type of engagement they want (e.g., likes, views) and the reward for meeting these targets. Creating a Bounty: A brand wants to increase awareness about a new product. They create a bounty for tweets that receive over 100 likes, offering 0.01 ETH for each tweet that meets this condition. Submitting a Tweet: A user with a relevant story or comment about the product tweets and submits their post to SmolKOL once it hits 100 likes. Verification: SmolKOL uses GPT-4O to verify that the tweet meets the bounty\u2019s criteria, including relevance to the prompt and engagement level. If the tweet is approved, the user receives the reward. Rejection Example: If the tweet does not meet the requirements or is irrelevant, GPT-4O provides natural language feedback explaining why it was rejected. SmolKOL has a few multiple parts: More specifically: And some weirdness in between (docker for postgres) It's practically my first time building frontend, especially with Next. I was way more comfortable in Rust, so I used it where I can, but it's certainly an odd mix of tech. I also didn't expect to be exploring prompt engineering before the hackathon; but realized that the new OpenAI beta feature for structured JSON output could be super useful to adjudicate whether a given tweet was valid or not. As such, I spent some time writing a system prompt which pleased me (https://github.com/stanleyjzheng/smolkol/blob/master/openai.md). By far the most annoying part of it was the Twitter API. There's so many oddities; it just said my auth was wrong. It turns out, for the free tier, Twitter API is WRITE ONLY. I've never remotely heard of that; you can create tweets, but not read? Despite all docs saying that 1500 tweets/month could still be read, it's straight up wrong, and one only finds out via forms. Else, it was $100/mo. Therefore, I decided to scrape twitter using my own account's bearer token, which oddly worked much better. Other oddities were that the callback url can't be localhost (but it allows you to set it as localhost?) so localhost:3000 doesn't work, but 127.0.0.1:3000 works fine. Why???? Truly bizzare. But whatever, some makeshift scraping did the job, so it's hard to complain in the end.",
        "how_its_made": "SmolKOL has a few multiple parts: More specifically: And some weirdness in between (docker for postgres) It's practically my first time building frontend, especially with Next. I was way more comfortable in Rust, so I used it where I can, but it's certainly an odd mix of tech. I also didn't expect to be exploring prompt engineering before the hackathon; but realized that the new OpenAI beta feature for structured JSON output could be super useful to adjudicate whether a given tweet was valid or not. As such, I spent some time writing a system prompt which pleased me (https://github.com/stanleyjzheng/smolkol/blob/master/openai.md). By far the most annoying part of it was the Twitter API. There's so many oddities; it just said my auth was wrong. It turns out, for the free tier, Twitter API is WRITE ONLY. I've never remotely heard of that; you can create tweets, but not read? Despite all docs saying that 1500 tweets/month could still be read, it's straight up wrong, and one only finds out via forms. Else, it was $100/mo. Therefore, I decided to scrape twitter using my own account's bearer token, which oddly worked much better. Other oddities were that the callback url can't be localhost (but it allows you to set it as localhost?) so localhost:3000 doesn't work, but 127.0.0.1:3000 works fine. Why???? Truly bizzare. But whatever, some makeshift scraping did the job, so it's hard to complain in the end.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/v4sy5/screenshots/1q5pv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v4sy5/screenshots/ua6o3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/v4sy5/screenshots/ut8kg/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/stanleyjzheng/smolkol",
        "link": "https://ethglobal.com/showcase/smolkol-v4sy5"
    },
    {
        "title": "Spatio",
        "brief_description": "Spatio is the perfect assistant for new crypto retail traders",
        "long_description": "Spatio is your ultimate consumer app for retail traders which is a chat assistant that has access to real time crypto, crypto news, macro economic news and your portfolio data, not only that but you can also ask it to send others money and trade and swap assets making it the easiest onboarding tool to your ecosystem We are using groq llama 8b as our base llm while using different functions utilising mobula APIs which helps us fetch the MarketData, metadata and price history of any token, portfolio details and historical networth of your wallet whereas crypto panic for news and zero hedge for macroeconomic data and are asking it to generate code to solve the users query, while we are using dynamic\u2019s inbuilt functions for transferring and are using LiFi widget for cross swaps",
        "how_its_made": "We are using groq llama 8b as our base llm while using different functions utilising mobula APIs which helps us fetch the MarketData, metadata and price history of any token, portfolio details and historical networth of your wallet whereas crypto panic for news and zero hedge for macroeconomic data and are asking it to generate code to solve the users query, while we are using dynamic\u2019s inbuilt functions for transferring and are using LiFi widget for cross swaps",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6ikch/screenshots/22gic/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6ikch/screenshots/t513w/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6ikch/screenshots/aym51/default.jpg"
        ],
        "live_demo": "https://spatio-psi.vercel.app/",
        "source_code": "https://github.com/harshalmadnani/spatio",
        "link": "https://ethglobal.com/showcase/spatio-6ikch"
    },
    {
        "title": "BAM Protocol",
        "brief_description": "The BAM Protocol defines a new primitive for incentivizing provable off-chain actions on chain. In addition we have built the BAM portal v0.1, a competitive, scam resistant escrow market for Twitter KOL\u2019s powered by our new primitive.",
        "long_description": "Our Project consists of two main components, the BAM protocol, and the BAM portal. The BAM Protocol is a novel primitive which allows for any off chain action, that can be proven to have happened. The Current Implementation of the BAM protocol is built to be able to incentivise ANY action. To leverage it, you simply need to connect a prover service, an off-chain source of truth (SOT), or an oracle. If the action can be proven, it can be incentivized through the BAM Protocol. To harness the power of the BAM protocol we also created the BAM Portal, which acts as scam-resistant, competitive, escrow market for twitter  KOLs. Incentive providers can create bespoke orders for their needs, filtering by follower count, sentiment, and many other variables, and pair their desired action with an incentive, which is then temporarily stored in the contract. Action providers can negotiate on both the action and the incentives. Once they fill the order, they would create the tweet and provide the tweet ID to our front end. This is then passed to the TEE running on LIT Protocol, which uses the Twitter API to reach consensus on the result of the action. Once consensus is reached the attestation is posted to both Flow network and Fhenix. At this point the incentive is taken out of the order and is sent to the action provider.\\ However our current BAM portal is just the tip of the iceberg. The BAM primitive is far more powerful  and flexible than just verifying twitter KOL\u2019s. Here are some of the extensions that are possible TODAY with BAM.\nIncentivised KOL\u2019s on any platform\nSupply Chain proofs, allowing for real work goods to be exchanged\nWhite hat hacking and auditing\nConsumer / Market Data\nDigital Labor (Logo Creation, Video Creation etc) Our project is designed to facilitate the incentivization of off-chain actions, while still supporting on-chain actions through traditional mechanisms. We achieved this by implementing a fork of the Royco protocol, which provides a solid foundation for managing incentives and verification processes. The core component of the system is the order book, which serves as a marketplace for defining and negotiating the terms of verification scripts. These scripts, which are critical for off-chain action validation, are stored on IPFS and executed by LIT Protocol nodes using Trusted Execution Environments (TEEs). Within the marketplace, order negotiation allows both incentive providers and action providers to adjust the parameters that will feed into these verification scripts. For example, in the case of Twitter actions, these parameters might include follower counts or retweet activity over a specified period. This flexible negotiation process ensures that both parties agree on clear, quantifiable metrics. Once an order is fulfilled on-chain, the off-chain action provider has a set timeframe\u2014defined by the incentive provider\u2014to complete the required action. At that point, the LIT Protocol nodes run the verification scripts to confirm whether the action occurred as agreed. The result is a signed message or hash, which is then verified by the on-chain contract. Upon successful verification, the action provider is paid out atomically, ensuring a secure, trustless transaction. By integrating multiple technologies such as IPFS for decentralized storage, LIT Protocol for off-chain verification, and smart contracts for secure payouts, we\u2019ve built a robust, flexible platform that enables seamless incentivization of both on-chain and off-chain actions.",
        "how_its_made": "Our project is designed to facilitate the incentivization of off-chain actions, while still supporting on-chain actions through traditional mechanisms. We achieved this by implementing a fork of the Royco protocol, which provides a solid foundation for managing incentives and verification processes. The core component of the system is the order book, which serves as a marketplace for defining and negotiating the terms of verification scripts. These scripts, which are critical for off-chain action validation, are stored on IPFS and executed by LIT Protocol nodes using Trusted Execution Environments (TEEs). Within the marketplace, order negotiation allows both incentive providers and action providers to adjust the parameters that will feed into these verification scripts. For example, in the case of Twitter actions, these parameters might include follower counts or retweet activity over a specified period. This flexible negotiation process ensures that both parties agree on clear, quantifiable metrics. Once an order is fulfilled on-chain, the off-chain action provider has a set timeframe\u2014defined by the incentive provider\u2014to complete the required action. At that point, the LIT Protocol nodes run the verification scripts to confirm whether the action occurred as agreed. The result is a signed message or hash, which is then verified by the on-chain contract. Upon successful verification, the action provider is paid out atomically, ensuring a secure, trustless transaction. By integrating multiple technologies such as IPFS for decentralized storage, LIT Protocol for off-chain verification, and smart contracts for secure payouts, we\u2019ve built a robust, flexible platform that enables seamless incentivization of both on-chain and off-chain actions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/2to0b/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/xscf4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/q98j0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/swo4a/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/8xzhk/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mg10y/screenshots/xi59a/default.jpg"
        ],
        "live_demo": "https://bam-portal.vercel.app/",
        "source_code": "https://github.com/githubotoro/BAM",
        "link": "https://ethglobal.com/showcase/bam-protocol-mg10y"
    },
    {
        "title": "Archivault",
        "brief_description": "Museums collection management tool with blockchain-based storage",
        "long_description": "Users can instantly create new record entries by simply taking a photo of an object. This feature eliminates the need for manual data entry, making it incredibly easy to start building a comprehensive digital catalog. Entries can be started and saved for later, with folders to organize pending entries, all entries, and then sorting by exhibits that those artifacts have been a part of. As students new to web3 development, we chose React as our frontend framework. This allowed us to break down our complex UI into manageable pieces for photo capture, AI analysis, and collection management. We focused on creating a minimum viable product where a user could create an entry based on an uploaded photo and then enter information into predefined fields. We used tailwind in order to make the front end prettier. One of us was entirely new to web development and the other was still mostly new. We tried to use Dynamic.xyz for authentication and to create a wallet that was abstracted for the user that is not familiar with blockchain. However, we ran into a lot of issues with TypeScript dependencies and were  not able to implement it.",
        "how_its_made": "As students new to web3 development, we chose React as our frontend framework. This allowed us to break down our complex UI into manageable pieces for photo capture, AI analysis, and collection management. We focused on creating a minimum viable product where a user could create an entry based on an uploaded photo and then enter information into predefined fields. We used tailwind in order to make the front end prettier. One of us was entirely new to web development and the other was still mostly new. We tried to use Dynamic.xyz for authentication and to create a wallet that was abstracted for the user that is not familiar with blockchain. However, we ran into a lot of issues with TypeScript dependencies and were  not able to implement it.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/46nts/screenshots/5kv5i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/46nts/screenshots/0bndn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/46nts/screenshots/e5s18/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/elyiagrace/Archivault",
        "link": "https://ethglobal.com/showcase/archivault-46nts"
    },
    {
        "title": "IPFi Strategy",
        "brief_description": "Create and tokenize your trading strategies on UniSwap with Story Protocol",
        "long_description": "Create your own trading strategies in UniSwap, and tokenize them via Story as IP assets to allow other users to remix or mimic your trades. Users can use different defi concepts to create their strategies including limit orders, liquidity pools with customized fees and pairs, concentrated liquidity, etc. still figuring it out. UniSwap v4's documentation is limited, and this is also my first time leveraging the protocol amongst other things so the learning curve was a little steep. I did not get a chance to even integrate with story protocol unfortunately. Nothing notable for this submission unfortunately, but learned more about UniSwap overall.",
        "how_its_made": "still figuring it out. UniSwap v4's documentation is limited, and this is also my first time leveraging the protocol amongst other things so the learning curve was a little steep. I did not get a chance to even integrate with story protocol unfortunately. Nothing notable for this submission unfortunately, but learned more about UniSwap overall.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/kxcda/screenshots/38k1t/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxcda/screenshots/4qn5h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/kxcda/screenshots/n4f2h/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wanasim/ipfi-strategy",
        "link": "https://ethglobal.com/showcase/ipfi-strategy-kxcda"
    },
    {
        "title": "ReFy",
        "brief_description": "We're building a rewards system for businesses, where customers earn points on every purchase.   These points can be redeemed for gifts, driving customer loyalty and repeat visits.",
        "long_description": "RewardFy is a next-gen rewards system designed to boost customer engagement for retail businesses. It works by offering easy to use loyalty point-earning and gift redemption experiences. Customers are presented with promotional offers, such as earning 10 loyalty points for purchasing a specific item like a bag of chips. Upon making the purchase, customers instantly receive their loyalty points, which can be accumulated and spent on exclusive rewards. For example, a free burrito could be redeemed for 10 points. RewardFy integrates XMTP to create a personalized experience within a business's website interface (existing in the form of a chat bot). Customers can interact with a built-in bot to check their current point balance, discover new offers, and manage their account all in real-time. This integration allows for tracking of promotions, point redemption, a balance tracking system, in hopes of boosting revenues for the business.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/e3j91/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/qn1nc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/pabz8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/4aweu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Parth59/ReFy",
        "link": "https://ethglobal.com/showcase/refy-ppy1t"
    },
    {
        "title": "ReFy",
        "brief_description": "We're building a rewards system for businesses, where customers earn points on every purchase.   These points can be redeemed for gifts, driving customer loyalty and repeat visits.",
        "long_description": "RewardFy is a next-gen rewards system designed to boost customer engagement for retail businesses. It works by offering easy to use loyalty point-earning and gift redemption experiences. Customers are presented with promotional offers, such as earning 10 loyalty points for purchasing a specific item like a bag of chips. Upon making the purchase, customers instantly receive their loyalty points, which can be accumulated and spent on exclusive rewards. For example, a free burrito could be redeemed for 10 points. RewardFy integrates XMTP to create a personalized experience within a business's website interface (existing in the form of a chat bot). Customers can interact with a built-in bot to check their current point balance, discover new offers, and manage their account all in real-time. This integration allows for tracking of promotions, point redemption, a balance tracking system, in hopes of boosting revenues for the business.",
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/e3j91/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/qn1nc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/pabz8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ppy1t/screenshots/4aweu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Parth59/ReFy",
        "link": "https://ethglobal.com/showcase/refy-ppy1t"
    },
    {
        "title": "Anon Therapy",
        "brief_description": "Still waiting for that bull cycle to arrive? Well, you tried therapy and that didn't quite work out, did it? We built Anon Therapy just for you. Speak freely to our trained AI therapists that know how to help degens like you.",
        "long_description": "Still waiting for that bull cycle to arrive? Still getting rugged by influencers while your cousin at Deloitte bought their third Stanley cup? Terrified that this Thanksgiving your uncle is going to ask you about those memecoins you were talking about last year? Afraid your whole life was just a zero interest rate phenomenon? Well, you tried therapy and that didn't quite work out, did it? Your therapist thinks your NFTs are just so cute and those numbers in your spreadsheet aren't real anyway. Jaredfromsubway.eth sandwich attacking your DEX transactions isn't trauma?? We built Anon Therapy just for you. Speak freely to our trained AI therapists that know how to help degens like you. Speak freely because we let you own your own therapy chat logs. There's no dev team at BetterHelp poring over your chat logs and pointing and laughing here. In fact, you can show your chats to your therapist so they know your trauma is real. Bull market came roaring back and you feel on top of the world again? Just pretend these chats never happened and nobody will ever know that you were ever down this bad. Anon Therapy combines LLMs with blockchain technology to deliver and anonymous and secure product. Chat logs are stored on the Walrus network which provides fast and cheap decentralized storage. Dynamic is used for easy login using diverse web3 and web2 methods. We write hashes into a smart contract on Flow to easily port therapy sessions across different devices.",
        "how_its_made": "Anon Therapy combines LLMs with blockchain technology to deliver and anonymous and secure product. Chat logs are stored on the Walrus network which provides fast and cheap decentralized storage. Dynamic is used for easy login using diverse web3 and web2 methods. We write hashes into a smart contract on Flow to easily port therapy sessions across different devices.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/sjjk0/screenshots/k7to2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sjjk0/screenshots/ahkhc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sjjk0/screenshots/qewbo/default.jpg",
            "https://ethglobal.b-cdn.net/projects/sjjk0/screenshots/f3tkw/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Cryptonomic/anonTherapy",
        "link": "https://ethglobal.com/showcase/anon-therapy-sjjk0"
    },
    {
        "title": "TokenTally",
        "brief_description": "Empowering hackathons with decentralized, fair, and programmable judging.",
        "long_description": "Token Tally is a decentralized hackathon judging platform that gives judges a set amount of tokens to allocate across multiple projects as they see fit. After the judging round concludes, the tokens and any prize earnings are automatically distributed to team members using a smart contract and Circles programmable wallet, based on pre-determined allocation percentages. Powered by the Flow blockchain, Token Tally ensures transparent, fair, and automated reward distribution. we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js",
        "how_its_made": "we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js we used Flow and Circle build on node.js",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/yatrg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/an3zd/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/zx1jp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/0pu9c/default.jpg",
            "https://ethglobal.b-cdn.net/projects/pceqb/screenshots/yiyeu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/aismael234/Token-Tally",
        "link": "https://ethglobal.com/showcase/tokentally-pceqb"
    },
    {
        "title": "Stake2Meet",
        "brief_description": "Stake2Meet: Stake ETH to book, show up to reclaim, valuing your time.",
        "long_description": "Stake2Meet is a time-respecting tool built for professionals, leveraging blockchain technology to minimize no-shows in scheduled meetings. Using TypeScript and Solidity, it operates by having participants stake a small amount of ETH before they can book a meeting on your calendar. If they attend, the ETH is refunded; if not, you keep it, compensating for lost time. The platform utilizes Next.js for the frontend, Hardhat, and integrates RainbowKit for seamless wallet connections. Ideal for consultants and professionals, and just about anyone that values their time. Stake2Meet reduces spammed, non-committed bookings and ensures your time is valued. Ideal for consultants and professionals, and just about anyone that values their time. It reduces spammed, non-committed bookings and ensures your time is valued. Next.js for the frontend to make everything fast and responsive. For the blockchain side, it relies on Hardhat to deploy and manage Ethereum smart contracts. And to handle wallet connections,  integrated RainbowKit so users can easily connect and stake ETH. I had it all come together to create a platform where people stake ETH to book a meeting, with smart contracts handling everything in the background!",
        "how_its_made": "Next.js for the frontend to make everything fast and responsive. For the blockchain side, it relies on Hardhat to deploy and manage Ethereum smart contracts. And to handle wallet connections,  integrated RainbowKit so users can easily connect and stake ETH. I had it all come together to create a platform where people stake ETH to book a meeting, with smart contracts handling everything in the background!",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9c8do/screenshots/gcet9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9c8do/screenshots/bgx3m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9c8do/screenshots/ra4gc/default.jpg"
        ],
        "live_demo": "https://staketomeet.vercel.app/",
        "source_code": "https://github.com/TheWeb3Attorney/Stake2Meet.",
        "link": "https://ethglobal.com/showcase/stake2meet-9c8do"
    },
    {
        "title": "DAOsaster",
        "brief_description": "Built a decentralized, autonomous disaster response system using AI agents, drones, and blockchain to detect disasters and coordinate responses without relying on traditional infrastructure.",
        "long_description": "In disasters where traditional communication and coordination fail, our project introduces a decentralized, autonomous disaster response system leveraging AI agents, drones, and blockchain technology. We deploy a network of AI agents\u2014global, regional, and local\u2014that continuously monitor environments for signs of disasters. Upon detecting an event, these agents collaborate through a blockchain-based consensus mechanism to confirm the disaster, collect data, and coordinate responses. Key Features: Autonomous Agents: AI agents detect disasters and coordinate with other agents and human organizations.\nDecentralized Coordination: Blockchain is used for trust, identity verification, and tasking rescue efforts without reliance on centralized systems.\nAutonomous Drones: Integration of drones for real-time data collection and support in rescue operations.\nConsensus Building: Agents report disasters and build consensus across the network to validate events.\nShared Data Platform: Creation of a unified, distributed dataset that maintains a shared understanding of the situation among all participants.\nHow It Works: Monitoring and Detection: Agents continuously monitor various data sources and sensors for disaster indicators.\nConsensus and Reporting: Once a potential disaster is detected, agents report it and seek confirmation from others to build consensus.\nData Collection and Sharing: As confidence in the disaster report grows, more resources like drones are deployed to gather additional data.\nAutonomous Coordination: Agents autonomously coordinate the deployment of resources and communicate with human organizations for an effective response.\nHuman Collaboration: Organizations and individuals can interact with the agents, verify their identities through decentralized mechanisms, and contribute to the response efforts.\nImpact: This system enhances disaster preparedness and response by: Providing a resilient communication network that doesn't rely on traditional infrastructure.\nEnabling rapid, coordinated responses through autonomous decision-making.\nEnsuring trust and transparency via blockchain technology.\nFacilitating collaboration between autonomous systems and human responders.\nProject Structure: Our project includes various components such as AI agents, smart contracts for blockchain interaction, tokenization of AI agents, and front-end interfaces for user interaction. Each component is modular and contributes to the overall functionality of the decentralized disaster response system. Our project is constructed by seamlessly integrating a suite of advanced technologies to establish a decentralized, autonomous disaster response system. The initial phase involves data collection from local and global agents using drones that survey and gather crucial information from disaster-stricken areas. This data\u2014which includes high-resolution video files and photographs\u2014is stored on Walrus, a platform adept at handling large file sizes efficiently. To monetize and distribute this valuable content, we utilize Story Protocol, enabling entities like news journalists to mint and use the data. Any profits generated through this process are funneled back into a DAO (Decentralized Autonomous Organization) contract, which the AI agents use to manage the supply chain. This includes automating the purchase of essential supplies like food and arranging logistics such as flight tickets for volunteers. When a disaster occurs, the AI agents initiate communication among themselves via the SKALE chain, assigning roles and coordinating actions autonomously. They leverage the Graph Protocol to query and process data swiftly, ensuring a responsive and efficient operation. Volunteers play a vital role by running DStack on their local computers, which allows them to organize and upload data to automate tasks further. For secure and confidential computing, we employ the Phala Network to run local Trusted Execution Environments (TEEs), safeguarding sensitive information and processes. To bolster liquidity and funding for the DAO managed by the AI agents, users can tokenize any of the AI assets\u2014from drones to omni-gel devices\u2014thereby contributing to the community's resources. We have integrated Dynamic Wallet to streamline user onboarding and wallet interactions, making it easier for participants to engage with the platform and support the disaster response efforts. This collaborative integration of technologies not only enhances the efficiency and effectiveness of disaster response but also fosters a community-driven approach where both AI agents and humans work in tandem to mitigate the impacts of disasters.",
        "how_its_made": "Our project is constructed by seamlessly integrating a suite of advanced technologies to establish a decentralized, autonomous disaster response system. The initial phase involves data collection from local and global agents using drones that survey and gather crucial information from disaster-stricken areas. This data\u2014which includes high-resolution video files and photographs\u2014is stored on Walrus, a platform adept at handling large file sizes efficiently. To monetize and distribute this valuable content, we utilize Story Protocol, enabling entities like news journalists to mint and use the data. Any profits generated through this process are funneled back into a DAO (Decentralized Autonomous Organization) contract, which the AI agents use to manage the supply chain. This includes automating the purchase of essential supplies like food and arranging logistics such as flight tickets for volunteers. When a disaster occurs, the AI agents initiate communication among themselves via the SKALE chain, assigning roles and coordinating actions autonomously. They leverage the Graph Protocol to query and process data swiftly, ensuring a responsive and efficient operation. Volunteers play a vital role by running DStack on their local computers, which allows them to organize and upload data to automate tasks further. For secure and confidential computing, we employ the Phala Network to run local Trusted Execution Environments (TEEs), safeguarding sensitive information and processes. To bolster liquidity and funding for the DAO managed by the AI agents, users can tokenize any of the AI assets\u2014from drones to omni-gel devices\u2014thereby contributing to the community's resources. We have integrated Dynamic Wallet to streamline user onboarding and wallet interactions, making it easier for participants to engage with the platform and support the disaster response efforts. This collaborative integration of technologies not only enhances the efficiency and effectiveness of disaster response but also fosters a community-driven approach where both AI agents and humans work in tandem to mitigate the impacts of disasters.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/ngboi/screenshots/3itn3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ngboi/screenshots/dfuga/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ngboi/screenshots/kpva2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/ngboi/screenshots/3knzy/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/soma9574/daosaster-response",
        "link": "https://ethglobal.com/showcase/daosaster-ngboi"
    },
    {
        "title": "Permissionless GPT4",
        "brief_description": "Permissionless access to the OpenAI API using TEE and TLS Notary.",
        "long_description": "Ever been banned by OpenAI or Anthropic? Not anymore! This project combines TLS Notary and AWS Nitro Enclaves to create a privacy-preserving OpenAI API proxy access system. By integrating Multiparty Computation and Trusted Execution Environments, it guarantees the authenticity, privacy, and censorship resistance of API requests for any transactional API. Today, accessing powerful APIs like OpenAI\u2019s can often come with trade-offs\u2014whether it\u2019s giving up privacy, being restricted by service providers, or dealing with censorship. But what if you could bypass all of that? That\u2019s where TEEProxy comes in\u2014a cutting-edge system designed to give you secure, private, and permissionless access to OpenAI\u2019s API. At the core of TEEProxy is the combination of AWS Nitro Enclaves and TLS Notary, two state-of-the-art technologies that work together to create a fully encrypted environment. When you send a request to OpenAI through TEEProxy, you can be absolutely sure your data remains private. How? We\u2019ve enhanced the Nitro remote attestation process to give you extra guarantees. Every time you make a request, a unique identifier\u2014called a nonce\u2014is embedded into the attestation document. This ensures that the response is generated specifically for you and hasn\u2019t been pre-fetched or tampered with. Additionally, TEEProxy includes a TLS certificate fingerprint in the attestation. This fingerprint proves that the TLS session\u2014the encrypted connection between you and the API\u2014terminates inside the enclave, giving you even more assurance that your communication is secure. For Service Providers, this system guarantees that their API keys remain confidential, even from the miners who run the nodes. TEEProxy makes it possible for Service Providers to trust that their keys will not be exposed, while still offering seamless access to OpenAI\u2019s powerful API. As a User, you benefit from complete anonymity and protection. Your requests are processed securely within the enclave, so neither miners nor service providers can view or intercept your data. This ensures privacy and protection from surveillance or tracking. And beyond that, censorship resistance is a key feature of TEEProxy. Because of the distributed nature of the miners, no single entity\u2014including OpenAI\u2014can stop you from accessing the API. This is permissionless access, free from restrictions or blocks. TEEProxy is built to give you the strongest guarantees: complete privacy, authenticity of responses, censorship resistance, and security. By using Multiparty Computation (MPC) alongside TLS Notary, TEEProxy guarantees the authenticity of the OpenAI responses. You can be confident that the responses you receive haven\u2019t been altered. Even though the system adds some delay, up to two minutes due to cryptographic proofs, the peace of mind is well worth it. In a world where privacy, security, and censorship resistance are increasingly important, TEEProxy stands as a breakthrough solution. Whether you\u2019re a developer, a researcher, or an enterprise looking for OpenAI API access without compromising on security or privacy\u2014TEEProxy has you covered. TEEProxy \u2013 Your key to secure, permissionless OpenAI API access. In this project, I integrate TLS Notary into the AWS Nitro Enclave and enhance the Nitro remote attestation process to provide additional guarantees for all parties involved. To achieve this I modify the attestation document to include: While functional, TLS Notary introduces significant delays \u2014 up to two minutes per request \u2014 resulting in potential OpenAI timeouts.",
        "how_its_made": "In this project, I integrate TLS Notary into the AWS Nitro Enclave and enhance the Nitro remote attestation process to provide additional guarantees for all parties involved. To achieve this I modify the attestation document to include: While functional, TLS Notary introduces significant delays \u2014 up to two minutes per request \u2014 resulting in potential OpenAI timeouts.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h8oyg/screenshots/90sz1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8oyg/screenshots/azhvi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8oyg/screenshots/61j7x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8oyg/screenshots/x1bvi/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/vkleban/teegpt/",
        "link": "https://ethglobal.com/showcase/permissionless-gpt4-h8oyg"
    },
    {
        "title": "PicFable",
        "brief_description": "PicFable allows anyone to monetize their camera roll. Just upload your photos, set the price and terms of use, and you\u2019re done. Buyers can purchase the rights to use your images, remix them, or train AI models on them - with everything handled onchain.",
        "long_description": "PicFable is an image licensing hub powered by the blockchain. Similar to websites like Unsplash and Shutterstock, PicFable creates an easy way for people to discover and license images for various uses. PicFable\u2019s advantages come from its blockchain based architecture, which ensures data availability, transparency, and the ability to allow users to opt-in to being used for AI model training Using Story Protocol, PicFable enables creators to make money from their original images while specifying acceptable uses for their creations. For both professional and hobbyist photographers, PicFable represents a way to make money from stacks of unused digital images. We built this project on the Story Protocol using the Registration and Licensing modules allowing users to register their IP and assign licensing ensuring that they maintain control over their work. A user logs in through Dynamic with a Web2 like onboarding experience reducing friction. Photos are uploaded and stored on Walrus which allows the user to break their reliance on centralized systems. We then register the image on Story and assign a license as chosen by the user. Finally ENS URLs are created showcasing items available in a gallery view allowing users to create personalized pages. Some hacky workarounds were:",
        "how_its_made": "We built this project on the Story Protocol using the Registration and Licensing modules allowing users to register their IP and assign licensing ensuring that they maintain control over their work. A user logs in through Dynamic with a Web2 like onboarding experience reducing friction. Photos are uploaded and stored on Walrus which allows the user to break their reliance on centralized systems. We then register the image on Story and assign a license as chosen by the user. Finally ENS URLs are created showcasing items available in a gallery view allowing users to create personalized pages. Some hacky workarounds were:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/bzitq/screenshots/id88g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bzitq/screenshots/13adg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bzitq/screenshots/62jj9/default.jpg",
            "https://ethglobal.b-cdn.net/projects/bzitq/screenshots/1t7b9/default.jpg"
        ],
        "live_demo": "https://eth-global-sf-2024.vercel.app/",
        "source_code": "https://github.com/sergical/eth-global-sf-2024",
        "link": "https://ethglobal.com/showcase/picfable-bzitq"
    },
    {
        "title": "Found in Translation",
        "brief_description": "Decentralised system for real time language translations, using open-sourced AI wearables.",
        "long_description": "FoundInTranslation is a decentralised system for real time language translations using open-sourced AI wearables, a perfect marriage between AI and blockchain technology, our elegant attempt to do language transcriptions on the fly. It has a pay as you go model where a user can refill their transcription credits, and allows the user to log in with their EVM-compatible wallet and choose from several target and destination languages. Great for tourist travels, learning new languages with international friends, or watching your favourite foreign films with loved ones. This project utilizes Dynamic for onchain signup mechanism which also utilises Phala's TEE. After a user logs in and authenticates with the preferred wallet, we ask the user to choose a language in which they prefer the translation. We have deployed a smart contract on Polygon for our ERC20 token, which will be utilised by our consumers. The user speaks into the AI wearable Omi and the transcription is sent to the phala AI  agent which in turn does the translation depending on the user's translation language preference, which is further used to convert the translated text to audio in the UI running on next.js.",
        "how_its_made": "This project utilizes Dynamic for onchain signup mechanism which also utilises Phala's TEE. After a user logs in and authenticates with the preferred wallet, we ask the user to choose a language in which they prefer the translation. We have deployed a smart contract on Polygon for our ERC20 token, which will be utilised by our consumers. The user speaks into the AI wearable Omi and the transcription is sent to the phala AI  agent which in turn does the translation depending on the user's translation language preference, which is further used to convert the translated text to audio in the UI running on next.js.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/tdtwj/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/vt4hp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/mi0nn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/eww4m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/rju0g/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rxyws/screenshots/rg2xh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Prachi1615/FoundInTranslation",
        "link": "https://ethglobal.com/showcase/found-in-translation-rxyws"
    },
    {
        "title": "Archiv3",
        "brief_description": "A video archive aggregator that allows documentary makers to license clips from multiple archives with ease.",
        "long_description": "Documentaries are more popular than ever. Almost 50% of Americans continuously stream docs across all major video channels. Netflix is expected to spend over $1.5 billion on documentary and non-scripted content by next year. Video archive licensing right now is very clunky and often revolves around email. Archiv3 allows filmmakers large and small to pull down clips across multiple archives, allowing for a better product. Product is built on top of Story. Front-end is done through Scaffold ETH. Walrus is used for metadata and asset storage. Hackiest thing in here is a globally resetting array for easy iteration of royalty splits. I figured out that the SDK didn't support the latest smart contract features so I had to hard code a few variables to simulate some of those actions.",
        "how_its_made": "Product is built on top of Story. Front-end is done through Scaffold ETH. Walrus is used for metadata and asset storage. Hackiest thing in here is a globally resetting array for easy iteration of royalty splits. I figured out that the SDK didn't support the latest smart contract features so I had to hard code a few variables to simulate some of those actions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/183kk/screenshots/quncm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/183kk/screenshots/0s8eq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/183kk/screenshots/e6j4u/default.jpg"
        ],
        "live_demo": "https://archiv3-3snws40pz-hlauinfos-projects.vercel.app",
        "source_code": "https://github.com/hlauinfo/archiv3",
        "link": "https://ethglobal.com/showcase/archiv3-183kk"
    },
    {
        "title": "ETH Movie Voting",
        "brief_description": "The ETH Movie Database is a decentralized app built with React and Ethereum. It allows users to vote on movies transparently via MetaMask, recording votes on-chain for a secure, tamper-proof ranking system. A showcase of blockchain's potential in entertainment",
        "long_description": "The ETH Movie Database is a decentralized web application designed to let users rank and vote on movies in a transparent and secure manner. Built as a user-centric platform, it allows users to connect their Ethereum wallet using MetaMask and cast votes on a curated list of movies. The votes are recorded directly on the Ethereum blockchain, ensuring immutability and preventing tampering or manipulation. The application presents users with detailed movie information, including titles, release years, and posters. Users can upvote or downvote movies based on their preferences, and the app dynamically updates the movie rankings based on the community's interactions. The goal is to provide an engaging and transparent voting experience, showcasing how blockchain technology can be applied in entertainment. The ETH Movie Database is developed using React for the frontend, enabling a dynamic and responsive user interface. It integrates with the Ethereum blockchain using the ethers.js library for Web3 interactions. The application relies on MetaMask as the Ethereum provider, allowing users to securely connect their wallets and interact with the smart contract. Technical Details: Frontend: Built with React, the app displays a list of movies with images and current rankings. Users interact with the app through buttons to upvote or downvote, and the state updates in real-time based on the blockchain data.\nSmart Contract: The application\u2019s smart contract is deployed on the Ethereum network. It manages the voting logic, recording votes securely on-chain. The contract provides functions to upvote, downvote, and retrieve vote counts for each movie.\nState Management: The app uses React\u2019s state management to keep track of movie data. When the user connects their wallet and votes, the frontend interacts with the smart contract to update the votes and rankings, ensuring the UI reflects the latest state from the blockchain.\nBlockchain Interaction: MetaMask is used for user authentication and wallet connection. The app creates a Web3Provider using ethers.js to interact with the smart contract. Upon wallet connection, the app fetches and displays the latest voting data from the blockchain.\nThe ETH Movie Database showcases the potential of decentralized applications (dApps) and emphasizes secure, community-driven content ranking through blockchain technology.",
        "how_its_made": "The ETH Movie Database is developed using React for the frontend, enabling a dynamic and responsive user interface. It integrates with the Ethereum blockchain using the ethers.js library for Web3 interactions. The application relies on MetaMask as the Ethereum provider, allowing users to securely connect their wallets and interact with the smart contract. Technical Details: Frontend: Built with React, the app displays a list of movies with images and current rankings. Users interact with the app through buttons to upvote or downvote, and the state updates in real-time based on the blockchain data.\nSmart Contract: The application\u2019s smart contract is deployed on the Ethereum network. It manages the voting logic, recording votes securely on-chain. The contract provides functions to upvote, downvote, and retrieve vote counts for each movie.\nState Management: The app uses React\u2019s state management to keep track of movie data. When the user connects their wallet and votes, the frontend interacts with the smart contract to update the votes and rankings, ensuring the UI reflects the latest state from the blockchain.\nBlockchain Interaction: MetaMask is used for user authentication and wallet connection. The app creates a Web3Provider using ethers.js to interact with the smart contract. Upon wallet connection, the app fetches and displays the latest voting data from the blockchain.\nThe ETH Movie Database showcases the potential of decentralized applications (dApps) and emphasizes secure, community-driven content ranking through blockchain technology.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/msbpq/screenshots/9n4x5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/msbpq/screenshots/h7b8f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/msbpq/screenshots/254ru/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/alexhaeringer/ETHGlobal-SF24",
        "link": "https://ethglobal.com/showcase/eth-movie-voting-msbpq"
    },
    {
        "title": "Gameverse",
        "brief_description": "A chatbot integrating a text-based currency game and a real-world auction system",
        "long_description": "This project combines XMTP messaging and on-chain data storage to implement a currency-based game and auctioning system. Users can solve web3 trivia questions, run commands, be active in group chats to earn coins, and compete with each other by stealing coins from each other and competing to be the top coin holder on the leaderboard. All of these coins are stored on-chain on the SKALE Network, and can be traded for NFTs, collectibles and other tokens. Users in group chats can auction off items to the highest bidder, setting a bid increment and starting bid in an English auction format. The winner of the auction will receive an Open Frame link to pay for their item, and the owner will receive payment once payment has been successfully completed and verified. The project is designed to be a step forward in chatbot integration on-chain, combining an entertainment experience with real-world applications. The development of this project included using Converse's MessageKit framework to develop a chatbot interface. A particularly interesting part of the implementation was designing a custom message handler, as well as editing the source code of the MessageKit framework itself to allow bots to read all messages in group chats so that this handler could extend the existing command framework provided. Some other interesting applications were to create a MessageCollector class that would allow for the bot to \"listen\" to messages in response to a command, without needing for any advanced state-tracking or caching mechanism. This was done using Node.JS' in-built EventEmitter mechanism and event loops. The bot uses SKALE Network to store currency data, minimizing transaction backlog by committing data on-chain every hour in the form of snapshots. This is all handled by the bot's source code in a cron scheduler, making sure that the bot will never miss a snapshot. Data is committed and retrieved from the smart contract when necessary, taking advantage of SKALE's zero-gas mechanisms to completely cut out transaction fees and abstract away the on-chain mechanism of this bot, integrating into a seamless, simple experience for the end user. The bot's auction mechanism is developed using a smart contract on the AirDAO chain -- all details are public, allowing for integration into AirDAO's existing projects like AirQuest (a quest could be implemented for hosting 3 successful auctions etc.). More dev notes and details are included in the repository in the DEVNOTES.MD file.",
        "how_its_made": "The development of this project included using Converse's MessageKit framework to develop a chatbot interface. A particularly interesting part of the implementation was designing a custom message handler, as well as editing the source code of the MessageKit framework itself to allow bots to read all messages in group chats so that this handler could extend the existing command framework provided. Some other interesting applications were to create a MessageCollector class that would allow for the bot to \"listen\" to messages in response to a command, without needing for any advanced state-tracking or caching mechanism. This was done using Node.JS' in-built EventEmitter mechanism and event loops. The bot uses SKALE Network to store currency data, minimizing transaction backlog by committing data on-chain every hour in the form of snapshots. This is all handled by the bot's source code in a cron scheduler, making sure that the bot will never miss a snapshot. Data is committed and retrieved from the smart contract when necessary, taking advantage of SKALE's zero-gas mechanisms to completely cut out transaction fees and abstract away the on-chain mechanism of this bot, integrating into a seamless, simple experience for the end user. The bot's auction mechanism is developed using a smart contract on the AirDAO chain -- all details are public, allowing for integration into AirDAO's existing projects like AirQuest (a quest could be implemented for hosting 3 successful auctions etc.). More dev notes and details are included in the repository in the DEVNOTES.MD file.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/h8w91/screenshots/bzkp0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8w91/screenshots/gaovb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8w91/screenshots/tk5ro/default.jpg",
            "https://ethglobal.b-cdn.net/projects/h8w91/screenshots/xc6fn/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/keshramamurthy/gameverse-ethsf/",
        "link": "https://ethglobal.com/showcase/gameverse-h8w91"
    },
    {
        "title": "PolymarketAnalytics",
        "brief_description": "Polymarket Analytics allows you to fetch and analyze all trades made by any account on Polymarket, bypassing the platform's viewing limitations. Track profit and loss over time, inspect impactful trades, and uncover trading strategies. Built using Scaffold-ETH-2 and subgraphs.",
        "long_description": "Our project provides an analytics tool for Polymarket users. Polymarket does not allow users to view the complete trade history of an account, which limits their ability to analyze performance and strategies. We address this limitation by using subgraphs/substreams to fetch all trades made by any account on Polymarket. This enables users to: Future Plans: We plan to allow users to connect their own wallets and automatically copy trades made by other Polymarket traders using substreams. Substreams offer lower latency than subgraphs, minimizing tracking errors when copying trades. Implementation of this feature is currently on hold due to issues with the Application Binary Interface (ABI) of the Polymarket CTF Market, which prevents proper functionality. We built Polymarket Analytics using Scaffold-ETH-2 as our foundational template, which streamlined our setup process. Data Retrieval with Subgraphs/Substreams: We utilized multiple existing subgraphs and developed a custom subgraph to fetch detailed trade data from Polymarket. These subgraphs collect and organize on-chain data, making it accessible for analysis. Chart.js and similar libraries to visualize the data By using subgraphs we've created a tool that enhances transparency and strategy analysis for Polymarket users.",
        "how_its_made": "We built Polymarket Analytics using Scaffold-ETH-2 as our foundational template, which streamlined our setup process. Data Retrieval with Subgraphs/Substreams: We utilized multiple existing subgraphs and developed a custom subgraph to fetch detailed trade data from Polymarket. These subgraphs collect and organize on-chain data, making it accessible for analysis. Chart.js and similar libraries to visualize the data By using subgraphs we've created a tool that enhances transparency and strategy analysis for Polymarket users.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/e18yc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/6g706/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/fqwp8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/gwm5r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/vt1dm/screenshots/9vhuc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/HighDom/polymarket_analysis_v1",
        "link": "https://ethglobal.com/showcase/polymarketanalytics-vt1dm"
    },
    {
        "title": "SnapSafe",
        "brief_description": "The world's first secure screenshot app that prioritizes your privacy.",
        "long_description": "SnapSafe is the ultimate privacy-focused screenshot app. It empowers users to securely capture, edit, and organize screenshots without worrying about unauthorized access or data leaks. With advanced features like OCR for text extraction, decentralized storage, and a cross-platform dashboard, SnapSafe offers a seamless experience for managing images, all while ensuring your privacy is the top priority. In a world of growing data concerns, SnapSafe is the go-to solution for anyone seeking the perfect balance between functionality and security. We use IPFS/Walrus for storage. And we use SKALE/FLOW/MORPH to manage directory.\nWe use Electron to make the app fully cross-platform compatible, and after uploading the screenshots, it gets stored as directory in the chain.",
        "how_its_made": "We use IPFS/Walrus for storage. And we use SKALE/FLOW/MORPH to manage directory.\nWe use Electron to make the app fully cross-platform compatible, and after uploading the screenshots, it gets stored as directory in the chain.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/oa3mv/screenshots/811ze/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oa3mv/screenshots/k0pke/default.jpg",
            "https://ethglobal.b-cdn.net/projects/oa3mv/screenshots/i5y7o/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AllenAJ/SnapSafe",
        "link": "https://ethglobal.com/showcase/snapsafe-oa3mv"
    },
    {
        "title": "AutoSplit",
        "brief_description": "AutoSplit is an expense-sharing dApp that revolutionizes debt management. Define personalized debt thresholds, and watch as automated reimbursement requests with secure payment links are effortlessly dispatched\u2014all powered by the gas-free Skale Network.",
        "long_description": "AutoSplit is a decentralized application designed to simplify expense sharing and debt management among friends, colleagues, and groups. AutoSplit automates the entire process by allowing users to create groups, add participants, shared expenses, and set personalized debt thresholds. When a member's debt surpasses the limit set by the payer, the app automatically sends a notification with a secure payment link, eliminating the need for awkward conversations. Leveraging Sign Protocol, each expense generates a verifiable attestation sent via XMTP, ensuring transactions are secure and trustworthy. With real-time balance tracking and secure in-app messaging, AutoSplit fosters transparency and accountability, making shared finances seamless and stress-free. AutoSplit is built on the Skale Network, chosen for its zero gas fees, high throughput, and EVM compatibility, which are essential for handling numerous daily microtransactions cost-effectively. The frontend is developed using React with TypeScript to ensure a user-friendly and scalable interface. Smart contracts written in Solidity manage group creation, expense tracking, and debt thresholds, seamlessly interacting with the Skale blockchain. Integration with Sign Protocol allows each expense to generate secure, verifiable attestations sent via XMTP, enabling automated and trustworthy notifications. By combining Skale's robust infrastructure with Sign Protocol's security features, AutoSplit delivers a reliable and intuitive solution for managing shared expenses and repayments without the complexities of traditional Web3 applications.",
        "how_its_made": "AutoSplit is built on the Skale Network, chosen for its zero gas fees, high throughput, and EVM compatibility, which are essential for handling numerous daily microtransactions cost-effectively. The frontend is developed using React with TypeScript to ensure a user-friendly and scalable interface. Smart contracts written in Solidity manage group creation, expense tracking, and debt thresholds, seamlessly interacting with the Skale blockchain. Integration with Sign Protocol allows each expense to generate secure, verifiable attestations sent via XMTP, enabling automated and trustworthy notifications. By combining Skale's robust infrastructure with Sign Protocol's security features, AutoSplit delivers a reliable and intuitive solution for managing shared expenses and repayments without the complexities of traditional Web3 applications.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/varyw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/ivn7s/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/bes5f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/thdhy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dr6oj/screenshots/r57rt/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/MarouaBoudoukha/AutoSplit",
        "link": "https://ethglobal.com/showcase/autosplit-dr6oj"
    },
    {
        "title": "my own words",
        "brief_description": "Browser Extension for portable IP experimentation and interactions",
        "long_description": "my-own-words is a browser extension organizing the provenance and nuance of ideas on the Story Network. Users can create written work in the editor of their choice, highlight it, attach terms of fair use and register a snapshot of its provenance and permissions. There is AI support natively integrated into the project for users unfamiliar Story or IP to still have understanding, agency, and support as they navigate registering new works. We see this project being especially useful for two audiences: researchers and academics who very much value the provenance of ideas, creators and artists across industries. This project uses Pinata and IPFS for storage of text files, Polygon for tokenization of these files' content IDs, and Story SDK for registering these NFTs onchain with licensing terms. We used React, Typescript, ChakraUI, and Emma's original Procreate animations for the front end. For the backend, we used an express server, cors for browser extension to server communication. We also used the ChatGPT API to create and fine-tune our AI arbiter and AI also to auto-suggest recommendations for descriptions, licensing terms, etc. for a simple introduction to IP.",
        "how_its_made": "This project uses Pinata and IPFS for storage of text files, Polygon for tokenization of these files' content IDs, and Story SDK for registering these NFTs onchain with licensing terms. We used React, Typescript, ChakraUI, and Emma's original Procreate animations for the front end. For the backend, we used an express server, cors for browser extension to server communication. We also used the ChatGPT API to create and fine-tune our AI arbiter and AI also to auto-suggest recommendations for descriptions, licensing terms, etc. for a simple introduction to IP.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/d1a7h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/aakkc/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/8nhfp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/y5yav/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/ci8j4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/9uap2/screenshots/nxad7/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/emmanasseri/my-own-words",
        "link": "https://ethglobal.com/showcase/my-own-words-9uap2"
    },
    {
        "title": "Left Curve Simulator",
        "brief_description": "LCS is a dex where users press one button and automatically purchase 3 silly memecoins at random.",
        "long_description": "Buying memecoins is hard, that's why we built left curve simulator! With LCS even the dumbest left curve can buy memecoins with virtually no difficulties or strategy. LCS is a dex where users press one button and automatically purchase 3 silly memecoins at random. To decrease friction, we are utilizing unlimit crypto to allow users to onramp with debit or credit card, and start transacting with Ethereum. After they onramp, they just need to determine how much money they want to ape into memecoins. Once they decide they click generate and 3 random tokens are chosen, and purchased. To make sure only quality tokens are generated we filter tokens by minimum TVL of $5k, and have transactions which occurred within 24 hours. We also are passing the data through AI to make sure only tokens with silly names are chosen. tbdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddd",
        "how_its_made": "tbdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeddddddddddddddddddddddddddddddddddd",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/zzzqa/screenshots/kzm8r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zzzqa/screenshots/jep8i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/zzzqa/screenshots/cht3e/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/arrudagates/leftcurve",
        "link": "https://ethglobal.com/showcase/left-curve-simulator-zzzqa"
    },
    {
        "title": "IP Infinity",
        "brief_description": "The user will input their ENS; their NFTs are processed, labeled as a type of game object (character, equipment, other), and given stats based on its floor price and traits. The NFTs get put in a world with a procedurally generated map/world with full game functionality.",
        "long_description": "IP-Landers is a project that brings NFTs to life by creating an interactive game experience combining digital IP assets with an immersive world. The process begins when users input their ENS. Their NFTs are each processed and categorized by AI, getting transformed into game objects like characters or equipment. Each game object is assigned stats that reflect the floor price and its traits. These assets are then implemented into a procedurally generated game world built in Unreal Engine, providing an engaging and dynamic environment. The project's unique feature is the story's IP database, which allows users to share their NFT worlds and contribute to them with their own distinct characters and stories. IP-Landers was built using AI models, blockchain integration, and game development tools. Meta's Llama 3.2 vision model analyzes the NFT images, generating text descriptions that are categorized by the DeBERTa zero-shot classification model, sorting them into different types of objects. Unreal Engine powers the game, featuring procedurally generated landscapes and dungeons for a dynamic experience. Story Protocol's platform allows collaborative creativity without IP disputes. We implemented a unique solution to link NFT metadata to playable Unreal Engine assets.",
        "how_its_made": "IP-Landers was built using AI models, blockchain integration, and game development tools. Meta's Llama 3.2 vision model analyzes the NFT images, generating text descriptions that are categorized by the DeBERTa zero-shot classification model, sorting them into different types of objects. Unreal Engine powers the game, featuring procedurally generated landscapes and dungeons for a dynamic experience. Story Protocol's platform allows collaborative creativity without IP disputes. We implemented a unique solution to link NFT metadata to playable Unreal Engine assets.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/q0f4x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/k9j1o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/kuxja/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/ai31i/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/auzia/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mnkym/screenshots/oowia/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/edi3on/ip-infinity",
        "link": "https://ethglobal.com/showcase/ip-infinity-mnkym"
    },
    {
        "title": "ZK Wallet",
        "brief_description": "ZK Wallet improves wallet signature security and creates new authorization flows",
        "long_description": "ZK Wallet uses ZK to mask signatures both offchain and onchain and verifiable proof that the signature exists, drastically improving wallet accounts security against phishing and other malicious attacks. Morever, ZK powered proofs improve authorization flow within smart contracts, that increases safety and controls undesired outcomes directly. Within this project I show: I use:\nZK-EVM - Risc 0\nBackend - Rust\nGPU acceleration - Bonsai\nFrontEnd - TypeScript\nContracts - Solidity\nEssentially FrontEnd acts as a wallet and interacts with Backend through REST API to send and receive proofs. Backend connected to ZKVM as host to query proofs and verifications. FrontEnd also interacts with Contracts to verify proofs within Contract context.",
        "how_its_made": "I use:\nZK-EVM - Risc 0\nBackend - Rust\nGPU acceleration - Bonsai\nFrontEnd - TypeScript\nContracts - Solidity\nEssentially FrontEnd acts as a wallet and interacts with Backend through REST API to send and receive proofs. Backend connected to ZKVM as host to query proofs and verifications. FrontEnd also interacts with Contracts to verify proofs within Contract context.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/tnmaq/screenshots/z2xw2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tnmaq/screenshots/xdm3f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tnmaq/screenshots/a17z8/default.jpg",
            "https://ethglobal.b-cdn.net/projects/tnmaq/screenshots/ppkgv/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/altyni86/Eth_Global_Submit",
        "link": "https://ethglobal.com/showcase/zk-wallet-tnmaq"
    },
    {
        "title": "ExerciseTee",
        "brief_description": "Monitor your exercise from Whoop and shame you on twitter if you don't exercise for two consecutive days!",
        "long_description": null,
        "how_its_made": null,
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/qepxo/screenshots/0gb5v/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qepxo/screenshots/d9grq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/qepxo/screenshots/a096r/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/renchuqiao/tee-exercise",
        "link": "https://ethglobal.com/showcase/exercisetee-qepxo"
    },
    {
        "title": "Quantum Gate",
        "brief_description": "Quantum Gate unlocks EVM utilities on BTC Ordinals inscriptions.",
        "long_description": "NFT liquidity has gone to BTC Ordinals. What if we have ways to bring the liquidity back to the EVM ecosystem? This is an experimental project for showcasing EVM smart contract calls inside BTC Ordinals inscriptions. A MetaMask user visits a Quantum Gate inscription page and switches to a full-screen mode. S/he clicks on the \"unlock\" button and connects a wallet. The inscription prompts the user to sign a human-readable message and submit that signature to an EVM smart contract. The contract got called successfully and more EVM utilities were unlocked on Quantum Gate's BTC inscriptions. BTC Inscriptions are mostly html-based. BTC inscription are placed in a sandbox environment so that no external server calls are allowed. However, wallets such as MetaMask are injecting codes through web browsers. This provides an opportunity to place smart contract calls within BTC inscriptions.",
        "how_its_made": "BTC Inscriptions are mostly html-based. BTC inscription are placed in a sandbox environment so that no external server calls are allowed. However, wallets such as MetaMask are injecting codes through web browsers. This provides an opportunity to place smart contract calls within BTC inscriptions.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/7btoa/screenshots/1s2my/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7btoa/screenshots/8arxg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/7btoa/screenshots/j3b0f/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jackieeth/quantumgate-ethglobalsf2024",
        "link": "https://ethglobal.com/showcase/quantum-gate-7btoa"
    },
    {
        "title": "Power Agents",
        "brief_description": "Create, manage and chat with your AI agents from a XMTP group chat.",
        "long_description": "Power Agents is a collection of AI agents that you can spawn and chat with in an XMTP Group Chat. These agents are powered by Brian and leverage the CDP SDK to have their own wallets and funds to operate on behalf of the user. Each agent when it's created receives a poweragents.eth ENS subdomain, so that the user can easily remember it's handle when creating a new group chat, or when chatting with it outside of a group.\nWithin the group chat, you can chat with your agents and make them perform tasks. We developed the following Agents: This projects uses the following technologies: We also developed from scracth a nice way to spawn new XMTP bots inside the same repository at runtime without the need of re-deploying the project.",
        "how_its_made": "This projects uses the following technologies: We also developed from scracth a nice way to spawn new XMTP bots inside the same repository at runtime without the need of re-deploying the project.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/sorrv/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/gq11o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/1z4u3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/qgu4d/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/1dagu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/djqmb/screenshots/rxeux/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/builders-garden/power-agents",
        "link": "https://ethglobal.com/showcase/power-agents-djqmb"
    },
    {
        "title": "Essence Vault",
        "brief_description": "Essence Vault: a secure, efficient multisig wallet on Essential's declarative blockchain. #Essential #DeFi #Multisig #EthGlobal",
        "long_description": "Essence Vault is a multisig (multi-signature) wallet built on the Essential blockchain, leveraging the platform\u2019s declarative smart contract system to provide a secure, transparent, and efficient way to manage funds collectively. Multisig wallets require a predefined number of signatories (wallet holders) to approve any outgoing transaction, providing enhanced security and decentralized control over funds. Key Features of Essence Vault:\nm-of-n Approval System: The core functionality of Essence Vault is its m-of-n approval system. In simple terms: n is the total number of authorized members (or signatories) who can approve or reject a transaction.\nm is the minimum number of these members required to approve a transaction before it can be executed. This ensures that no single party can unilaterally control the wallet\u2019s funds. For example, if you have a 5-member wallet (n=5), and set m=3, at least 3 out of the 5 members must approve any fund transfers before it is executed.\nCreate a Multisig Wallet: At the start, an authorized user can create a new multisig wallet by providing a set of member addresses and specifying m, the minimum number of required approvals. This can be easily adjusted later as needed. Add/Remove Members: Wallet members can be added or removed based on the collective decision of existing members. The multisig wallet maintains flexibility by allowing changes in membership without disrupting operations or compromising security. Update m-of-n Configuration: If necessary, members can change the m value, adjusting the number of approvals required. This is especially useful if the organizational structure changes or the wallet grows in size. Fund Management (Receive & Send Funds): Receiving Funds: Anyone can send funds to the multisig wallet. It serves as a shared account for organizations, teams, or projects that need collective control over assets.\nSending Funds: To send funds, a transaction proposal is made, and the required number of members must approve it (based on the m-of-n rule) before the transfer is completed.\nTransaction Proposals: Any member can propose a transaction, such as sending funds to another wallet. Once proposed, other members must review and approve or reject the transaction. Approve Approvals: Members have the ability to approve a transaction proposal, and if they change their mind before the transaction is finalized, they can revoke their approval. This allows flexibility and ensures that all decisions are well-considered. View Transaction History: All transactions\u2014whether proposed, pending, approved, rejected, or completed\u2014are stored transparently on the blockchain. Users can easily view this history to ensure accountability. Security and Transparency: Built on Essential\u2019s declarative smart contracts, Essence Vault emphasizes simplicity, security, and auditability. By focusing on what should happen rather than how, it reduces the likelihood of vulnerabilities like reentrancy attacks that are common in other blockchain systems. Low Gas Costs: Thanks to Essential\u2019s blockchain optimizations, transaction costs are minimized, making Essence Vault a cost-effective solution for managing collective funds without the high fees typically associated with smart contract execution on imperative blockchains like Ethereum. Why Essence Vault?\nEssence Vault is ideal for organizations, venture capital funds, DeFi projects, DAOs, or any group that needs shared control over assets. It\u2019s particularly useful for managing treasury funds, handling collective investments, and ensuring that no single entity has unilateral access to funds. With its m-of-n approval system, all decisions are decentralized, preventing fraud, theft, or misuse of funds. Advantages of Using Essential Blockchain for Multisig Wallets:\nDeclarative Smart Contracts: Essence Vault leverages Essential\u2019s declarative nature, which allows smart contracts to focus on intent, making the logic simpler and reducing the risk of bugs and security vulnerabilities.\nEnhanced Security: By minimizing low-level control, the risk of errors or exploits is reduced, leading to a more secure wallet. This is especially critical for large or organizational funds.\nEfficiency and Cost Savings: Compared to other blockchains, Essential's structure optimizes for lower gas costs, ensuring that even high-frequency or complex transactions are cost-effective.\nScalability: As Essential is designed to support large-scale decentralized applications, Essence Vault is well-positioned to handle the demands of growing organizations or DAOs that may scale significantly over time.\nUse Cases:\nDecentralized Autonomous Organizations (DAOs): DAOs often manage collective treasuries, and Essence Vault\u2019s multisig model ensures that no single member can misappropriate funds. This m-of-n approval system also aligns with the decentralized decision-making model that DAOs are built upon. Venture Capital or Investment Funds: For groups of investors managing pooled funds, Essence Vault ensures that any outgoing transactions are approved by multiple stakeholders, safeguarding against unauthorized withdrawals or investments. Corporate Treasury Management: Essence Vault can be used by companies to manage internal budgets or decentralized teams that need to ensure financial decisions are made transparently and securely. Grant Funds or Non-Profits: When distributing grants or donations, it\u2019s important to ensure accountability. The multisig approval process guarantees that funds are only released after careful consideration and approval by trusted members. Future Roadmap for Essence Vault\nAs Essence Vault evolves, additional functionalities will be implemented to further enhance its capabilities: Revoke Approval: Members will be able to revoke their on-chain approval before a transaction is fully approved, providing flexibility and allowing members to reconsider decisions before execution.\nSet Time-Locked Approvals: On-chain time locks will be added, allowing transactions to be delayed for a specified time after receiving approvals, which adds an additional layer of protection for large or sensitive transfers.\nSet Transaction Limits: On-chain transaction limits will automatically adjust the number of required approvals based on the transaction size. For example, larger transactions could require more signatories or escalate to higher levels of the hierarchy, while smaller transactions may be executed with fewer approvals.\nStaking Wallet Funds: To optimize treasury management, a portion of the wallet's funds can be staked in DeFi protocols to earn passive income. AI and statistical models will analyze transaction history to suggest staking strategies and portfolio management, ensuring that funds not needed for immediate use are working to generate yield. Essence Vault was built using Pint for the smart contract, which simplifies logic by focusing on what needs to happen, ensuring security and reducing vulnerabilities. The frontend is written in Rust for performance and safety, leveraging WebAssembly for smooth cross-platform execution. Partnering with Essential allowed us to leverage declarative blockchain design.",
        "how_its_made": "Essence Vault was built using Pint for the smart contract, which simplifies logic by focusing on what needs to happen, ensuring security and reducing vulnerabilities. The frontend is written in Rust for performance and safety, leveraging WebAssembly for smooth cross-platform execution. Partnering with Essential allowed us to leverage declarative blockchain design.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/dmrve/screenshots/1h25k/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dmrve/screenshots/1rxjz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/dmrve/screenshots/jcnzc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/esphene/eth-global-sf-2024",
        "link": "https://ethglobal.com/showcase/essence-vault-dmrve"
    },
    {
        "title": "TipJar",
        "brief_description": "The Tip Jar is a DApp that gamifies tipping and incentives community use.",
        "long_description": "The Tip Jar is a decentralized application (DApp) built on the Ethereum blockchain, utilizing the SKALE network for gasless transactions. This platform allows users to send and receive tips in a user-friendly manner while contributing to a communal jar that encourages community support. Blockchain: Ethereum (via SKALE for gas-free transactions)\nSmart Contracts: Solidity for managing the tip jar and communal jar logic\nFrontend: Simple web app (HTML/CSS/JavaScript) with Metamask SDK integration\nBackend (optional): If you want to store extra user data or logs off-chain, you can use a server (e.g., Node.js, Express) or a decentralized storage solution like IPFS\nDeployment: SKALE network for Ethereum",
        "how_its_made": "Blockchain: Ethereum (via SKALE for gas-free transactions)\nSmart Contracts: Solidity for managing the tip jar and communal jar logic\nFrontend: Simple web app (HTML/CSS/JavaScript) with Metamask SDK integration\nBackend (optional): If you want to store extra user data or logs off-chain, you can use a server (e.g., Node.js, Express) or a decentralized storage solution like IPFS\nDeployment: SKALE network for Ethereum",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/789zv/screenshots/mj0x5/default.jpg",
            "https://ethglobal.b-cdn.net/projects/789zv/screenshots/84azi/default.jpg",
            "https://ethglobal.b-cdn.net/projects/789zv/screenshots/q7ztz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/789zv/screenshots/mu72f/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/deapinkme/ETHGlobalSF24/tree/main/demo",
        "link": "https://ethglobal.com/showcase/tipjar-789zv"
    },
    {
        "title": "Pinnect",
        "brief_description": "Pinnect: Interactive story co-creating platform that lets creators write and link stories on open-world.",
        "long_description": "Pinnect is an innovative open-world co-creation platform that revolutionizes how people interact with and conceive storytelling. It allows users to place their narratives within specific geographic locations on a virtual map, linking ideas and expanding upon existing tales contributed by others. This digital ecosystem supports a vibrant community of creators, from writers and artists to thinkers, who wish to leave their mark on a shared, evolving narrative landscape. Technology Stack:\nFrontend: Built with Swift for a native iOS experience, ensuring a smooth and intuitive user interface tailored for mobile devices.\nBackend: The backend runs on Node.js, utilizing Express.js for API management, which orchestrates interactions between the frontend, the database, and the blockchain components. Blockchain and Web3 Integration:\nEthereum Blockchain: Smart contracts written in Solidity handle DAO functionalities, content monetization, and IP management.\nStory Protocol: Integrates with Story Protocol for IP asset registration and management, leveraging its IPFi (Intellectual Property Finance) capabilities to create a market for buying and selling story-based IP assets.\nWeb3.js: Allows the mobile app to interact directly with Ethereum blockchain, enabling transactions such as voting, content posting, and royalty distributions directly from the user\u2019s device.",
        "how_its_made": "Technology Stack:\nFrontend: Built with Swift for a native iOS experience, ensuring a smooth and intuitive user interface tailored for mobile devices.\nBackend: The backend runs on Node.js, utilizing Express.js for API management, which orchestrates interactions between the frontend, the database, and the blockchain components. Blockchain and Web3 Integration:\nEthereum Blockchain: Smart contracts written in Solidity handle DAO functionalities, content monetization, and IP management.\nStory Protocol: Integrates with Story Protocol for IP asset registration and management, leveraging its IPFi (Intellectual Property Finance) capabilities to create a market for buying and selling story-based IP assets.\nWeb3.js: Allows the mobile app to interact directly with Ethereum blockchain, enabling transactions such as voting, content posting, and royalty distributions directly from the user\u2019s device.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/y1hnr/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/1gs02/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/4z8xq/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/cfw9o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/opnj0/default.jpg",
            "https://ethglobal.b-cdn.net/projects/j3531/screenshots/kigy3/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/AnnieTianyuHuang/ethSF24-proj",
        "link": "https://ethglobal.com/showcase/pinnect-j3531"
    },
    {
        "title": "JunLend",
        "brief_description": "One-click migration that guarantees better yield and liquidation protection.",
        "long_description": "JunLend features a simple one-click migration that guarantees better yield and liquidation protection. JunLend pools everyone's positions together. So if I'm borrowing USDC and you're supplying USDC, you can use your USDC to pay off my debt. In this pool, we match users' deposits/borrows to create win-win situations that boost the underlying yield efficiency. This also boosts the global health factor, creating this buffer for liquidations. Instead of AAVE liquidating you, JunLend would liquidate you through a fair Dutch auction that lets you keep the MEV surplus. JunLend will support many lending protocols and many different chains. It's strictly better to use JunLend over the vanilla option. The smart contracts use Uniswap v4 to flashloan so it can migrate a user's borrow position. Liquidations are handled with a Uniswap hook that lets users buy the capital in exchange for the debt. Chronicle powers the oracle for internal liquidations. The frontend is built with next.js and wagmi. Testing was done through Foundry.",
        "how_its_made": "The smart contracts use Uniswap v4 to flashloan so it can migrate a user's borrow position. Liquidations are handled with a Uniswap hook that lets users buy the capital in exchange for the debt. Chronicle powers the oracle for internal liquidations. The frontend is built with next.js and wagmi. Testing was done through Foundry.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/58snu/screenshots/j5j7r/default.jpg",
            "https://ethglobal.b-cdn.net/projects/58snu/screenshots/0a6eb/default.jpg",
            "https://ethglobal.b-cdn.net/projects/58snu/screenshots/6e3xc/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/jun1on/junlend",
        "link": "https://ethglobal.com/showcase/junlend-58snu"
    },
    {
        "title": "root4.fun",
        "brief_description": "memecoin launchpad built on Rootstock, offering easy tools for creating, buying, and selling memecoins. With AI-generated designs, seamless wallet connections, and credit card payments, it makes launching and sharing memecoins fun, fast, and accessible for everyone.",
        "long_description": "ROOT4.FUN is a memecoin launchpad built within the Rootstock (RSK) ecosystem, designed to make creating, buying, and selling memecoins as easy and accessible as possible. Our platform takes inspiration from projects like Pump.fun, but adds significant innovations to improve the user experience and functionality, with a focus on community-driven memecoins. We believe that memecoins hold potential beyond just speculation. They represent coins created by the community, for the community, making them a unique and valuable part of the crypto ecosystem. ROOT4.FUN offers four key functions to make memecoin creation and trading seamless: Create a MEMECOIN: Users can quickly generate and deploy their own memecoin on Rootstock. The process is streamlined through a smooth UI, and we even provide AI-generated suggestions for when users aren\u2019t sure what concept to meme. Buy a Coin: Users can easily purchase memecoins directly through the platform, with the option to pay using crypto wallets, credit cards, or email sign-ins. We aim to lower the barriers to entry for everyone, regardless of their technical expertise. Sell a Coin: Memecoin holders can easily list and sell their tokens through automated contracts. Automatic Creation of Liquidity Pools: Once a memecoin is created, liquidity pools are automatically established on decentralized exchanges like Uniswap once it reaches a bonding curve of 24 ETH(customizable).  This allows memecoins to have immediate market access Rootstock\nWe built the project on Rootstock . This gives us the stability and security of Bitcoin, while being EVM-compatible.\nwe built a contract that has 4 main functions, Create, Buy, Sell and once the bonding curve selected is reached it will be listed into decentralized exchanges. Phala Network AI Agents\nTheir AI agents are integrated to assist users in generating memecoin assets like names, images, and websites. We chose Phala because it runs  inside a Trusted Execution Environment (TEE), ensuring the integrity and security of the generated data.\nWhen users aren\u2019t sure what to meme, our platform calls on Phala\u2019s AI to generate these assets. The TEE guarantees that all HTML code and data produced by the AI is verifiable. Walrus for Decentralized Storage\nWe integrated Walrus to ensure all the AI-generated images, metadata, and websites are stored securely and accessibly.Walrus stores all the HTML and images generated by Phala\u2019s AI. This ensures that the content remains available. Privy and Dynamic for Wallet Connectivity:\nWhy We Chose Them: Both Privy and Dynamic are designed to provide frictionless wallet connectivity. Unlimit for Credit Card Payments\nWe wanted to make memecoin buying and selling as accessible as possible. With Unlimit, users can make purchases using credit cards as a payment gateway. Smart Contracts for Liquidity Management:\nOnce a memecoin is created, the system will automatically create a liquidity pool on Uniswap, but only once the bonding curve is reached. This ensures that there is sufficient demand and value established before providing liquidity. The bonding curve mechanism regulates the token supply and price dynamically as users buy into the memecoin. Once the required curve is reached, the smart contracts deploy the memecoin to Uniswap, creating an immediate liquidity pool.",
        "how_its_made": "Rootstock\nWe built the project on Rootstock . This gives us the stability and security of Bitcoin, while being EVM-compatible.\nwe built a contract that has 4 main functions, Create, Buy, Sell and once the bonding curve selected is reached it will be listed into decentralized exchanges. Phala Network AI Agents\nTheir AI agents are integrated to assist users in generating memecoin assets like names, images, and websites. We chose Phala because it runs  inside a Trusted Execution Environment (TEE), ensuring the integrity and security of the generated data.\nWhen users aren\u2019t sure what to meme, our platform calls on Phala\u2019s AI to generate these assets. The TEE guarantees that all HTML code and data produced by the AI is verifiable. Walrus for Decentralized Storage\nWe integrated Walrus to ensure all the AI-generated images, metadata, and websites are stored securely and accessibly.Walrus stores all the HTML and images generated by Phala\u2019s AI. This ensures that the content remains available. Privy and Dynamic for Wallet Connectivity:\nWhy We Chose Them: Both Privy and Dynamic are designed to provide frictionless wallet connectivity. Unlimit for Credit Card Payments\nWe wanted to make memecoin buying and selling as accessible as possible. With Unlimit, users can make purchases using credit cards as a payment gateway. Smart Contracts for Liquidity Management:\nOnce a memecoin is created, the system will automatically create a liquidity pool on Uniswap, but only once the bonding curve is reached. This ensures that there is sufficient demand and value established before providing liquidity. The bonding curve mechanism regulates the token supply and price dynamically as users buy into the memecoin. Once the required curve is reached, the smart contracts deploy the memecoin to Uniswap, creating an immediate liquidity pool.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/ohrvy/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/cxd96/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/57wy4/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/muutp/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/bzsoz/default.jpg",
            "https://ethglobal.b-cdn.net/projects/uubnf/screenshots/ov1bk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/shadowfaz16/root.fun.git",
        "link": "https://ethglobal.com/showcase/root4-fun-uubnf"
    },
    {
        "title": "TheLottery",
        "brief_description": "It's a cross chain lottery operated with LAyerZero, Dynamo, Ledger and ENS. Everybody from everywhere with everywallet can play",
        "long_description": "TheLottery is an innovative decentralized application that brings the excitement of lottery games to the blockchain world. Built with React and and Web3 technologies, this project offers a seamless and engaging user experience for participants across multiple blockchain networks. Key Features: Cross-chain Compatibility: Utilizing LayerZero technology, users can purchase tickets from any supported blockchain, expanding accessibility and liquidity across networks. Flexible Wallet Integration: The app integrates Dynamic for wallet connections, allowing users to interact with their preferred wallet solution, including hardware wallets like Ledger for enhanced security. Real-time Updates: The application provides live updates on the current jackpot size, time remaining until the next draw, and the number of tickets purchased, creating an engaging and dynamic user interface. ENS Integration: Winners' addresses are displayed using Ethereum Name Service (ENS) when available, adding a personal touch to the lottery experience. Animated UI: The interface features falling coin animations and smooth transitions, enhancing the visual appeal and user engagement. Smart Contract Powered: The core lottery logic is implemented in a Solidity smart contract, ensuring fairness and transparency in ticket purchases and winner selection. Chainlink VRF Integration: The lottery uses Chainlink's Verifiable Random Function (VRF) to guarantee truly random and tamper-proof winner selection. Automated Lottery Cycles: The smart contract manages lottery cycles, including ticket sales, drawing winners, and distributing prizes, with minimal manual intervention required. Technical Highlights: TheLottery demonstrates the potential of blockchain technology to create fair, transparent, and exciting gaming experiences across multiple networks, setting a new standard for decentralized lottery applications. Cross-chain Compatibility: Utilizing LayerZero technology, users can purchase tickets from any supported blockchain, expanding accessibility and liquidity across networks. Flexible Wallet Integration: The app integrates Dynamic for wallet connections, allowing users to interact with their preferred wallet solution, including hardware wallets like Ledger for enhanced security. Real-time Updates: The application provides live updates on the current jackpot size, time remaining until the next draw, and the number of tickets purchased, creating an engaging and dynamic user interface. ENS Integration: Winners' addresses are displayed using Ethereum Name Service (ENS) when available, adding a personal touch to the lottery experience.",
        "how_its_made": "Cross-chain Compatibility: Utilizing LayerZero technology, users can purchase tickets from any supported blockchain, expanding accessibility and liquidity across networks. Flexible Wallet Integration: The app integrates Dynamic for wallet connections, allowing users to interact with their preferred wallet solution, including hardware wallets like Ledger for enhanced security. Real-time Updates: The application provides live updates on the current jackpot size, time remaining until the next draw, and the number of tickets purchased, creating an engaging and dynamic user interface. ENS Integration: Winners' addresses are displayed using Ethereum Name Service (ENS) when available, adding a personal touch to the lottery experience.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/jy2xa/screenshots/r0uhs/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jy2xa/screenshots/x69o1/default.jpg",
            "https://ethglobal.b-cdn.net/projects/jy2xa/screenshots/4bkmh/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/TonioSnowden/TheLottery",
        "link": "https://ethglobal.com/showcase/thelottery-jy2xa"
    },
    {
        "title": "DeepTrust.eth",
        "brief_description": "SoTA On-chain proofs for LLM Model Executions. DeepTrust.eth makes sure that OpenAI, Anthropic, Groq be honest about the model they are serving.",
        "long_description": "The future will undoubtedly rely heavily on AI-powered applications and insights. But how can we ensure that the individuals or enterprises providing us with these models are trustworthy and credible? We identified two major problems that haven't been widely addressed: Centralized inference requires trust in an inference provider not to alter the model or data. For example, how can we be sure that OpenAI is providing responses from the more expensive GPT-4 model instead of cutting costs and using GPT-3.5?\nCentralized entities might manipulate or censor outputs, potentially affecting model fairness.\nTo address these issues, we proposed a solution using blockchain technology, creating a network of verification nodes that perform the checks for us. We introduced a novel plugin that can be integrated into all transformer architectures, which LLM models are based on. This plugin allows us to derive a deterministic term from each model by intercepting the LLM prior to the head layer (where randomness, such as temperature, is introduced). Since relying on a single source could be risky (due to potential dishonesty), our solution involves a network of models performing independent verifications. These outputs are then compared with those provided by enterprises like OpenAI, giving us a better chance to detect bad actors. Rather than checking every single request, we opted to sample 2-5% of all inference requests for verification. Additionally, we implemented a tokenomics system within the network. All inference clients must stake tokens to participate. If our platform detects dishonesty, these stakes will be slashed. Conversely, those who remain honest will see their trust score increase and will be rewarded with tokens. This system creates a strong incentive for participants to act with integrity. We primarily used two key technologies to achieve this solution: Polygon \u2013 We chose Polygon due to its scalability and low transaction costs. It allows us to build a transparent and efficient verification system, where transactions related to inference verifications and token staking/slashing are processed quickly and affordably. We find the documetation very friendly so it made our developer experience awesome! Lit Protocol \u2013 We leveraged Trusted Execution Environments (TEEs) to ensure that our model executions are isolated and protected from external interference. Lit Protocol was also one of the easiest platforms to develop on, as its setup process is much more straightforward compared to other providers.",
        "how_its_made": "We primarily used two key technologies to achieve this solution: Polygon \u2013 We chose Polygon due to its scalability and low transaction costs. It allows us to build a transparent and efficient verification system, where transactions related to inference verifications and token staking/slashing are processed quickly and affordably. We find the documetation very friendly so it made our developer experience awesome! Lit Protocol \u2013 We leveraged Trusted Execution Environments (TEEs) to ensure that our model executions are isolated and protected from external interference. Lit Protocol was also one of the easiest platforms to develop on, as its setup process is much more straightforward compared to other providers.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/6rv0v/screenshots/79yxh/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6rv0v/screenshots/3fycm/default.jpg",
            "https://ethglobal.b-cdn.net/projects/6rv0v/screenshots/fjy8v/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Jackmin801/DeepTrust.eth",
        "link": "https://ethglobal.com/showcase/deeptrust-eth-6rv0v"
    },
    {
        "title": "hoshi",
        "brief_description": "A web3 social media app that gives automatic IP rights to content creation through NFTs, making use of AI to identify derivative work.",
        "long_description": "Web2 social media apps are flawed. Today\u2019s social media platforms \u2014 TikTok, Instagram, YouTube \u2014 are powered by creators. From viral dances to popular memes, users are constantly sharing new ideas. Yet, there\u2019s a major problem: the original creators often go unrecognized and uncompensated. While larger creators and influencers who build on original trends or content reap the majority of credit and financial rewards, the originators of these ideas are not fairly rewarded. The root of this problem lies in the inability of current Web2 platforms to effectively prove content ownership or enforce fair revenue sharing. Creators are forced into an 'all or nothing' revenue system due to rigid copyright rules. We need a solution to provide a fair, transparent, and equitable content creation ecosystem where intellectual property rights are protected and content contributors are compensated based on their value added. hoshi aims to address these inequities by leveraging Web3 technology to create a platform where content creators can prove ownership, enforce fair use, and receive equitable compensation for their work. By giving IP rights to content creation through NFTs and an automated royalty distribution system, hoshi ensures that both original creators and those who contribute to or remix their work are fairly rewarded. 1.1 Automated AI-Powered Detection\nUses AI/ML to analyze content & determine an originality score across all other posts. We use an AI-based originality scoring system that quantifies the degree of contribution for each post. The more original the content, the higher the share of rewards allocated to the original creator. Users who remix or modify content receive proportional compensation based on their added value. An IP derivative tree is built based on these scores, to determine revenue flow sharing across all contributors based on their added value. 1.2 IP Ownership and Protection via NFTs\nhoshi ensures that creators retain full control over their IP by minting each piece of content uploaded to the platform as a non-fungible token (NFT). This provides verifiable proof of ownership and a permanent, immutable record on the blockchain, safeguarding against unauthorized use or plagiarism. 1.3 Smart Royalty Distribution\nhoshi employs a smart royalty distribution model that rewards original creators and those who contribute to or build upon their work. This system ensures that all contributors along the creative chain are fairly rewarded. Royalties are distributed through our native ERC20 token backed by ETH.  When a user interacts with a piece of content, some of their tokens are transferred from their wallet to the wallet of the content creator, and through our smart contract code, royalty distributions of derivative work is automatically paid. 2.1 Subscription-Based Revenue Withdrawal\nCreators can directly withdraw the underlying ETH tagged to the hoshi tokens and directly earn funds from their content. This is done by enabling a whitelist of wallet addresses who are allowed to unwrap the tokens, so as to prevent casual viewers from unwrapping their tokens as well. To join the whitelist and make money off your content, hoshi adopts an approach similar to twitter that requires content creators to pay a subscription fee to earn money off their content on our platform. hoshi reinvests the subscription fees back into the platform\u2019s liquidity pool. This subscription model not only facilitates monetization but also ensures the platform\u2019s long-term financial sustainability. We believe hoshi is the future of social media content creation, and we hope that you will join us in empowering creators with the recognition and rewards they deserve. To detect Copyright Infringement, we develop a proprietary AI pipeline to not only find the media and text that are similar in nature to the new post but also detect the specific location with the highest similarity. To detect textual similarity of captions, we use Cohere Embeddings to embed each caption into a vector. When a new post is provided, we similarly embed the new caption and compare against other vectors in the database. However, such an approach heavily focuses on semantic similarity since copyright infringement requires exact textual lifting, we utilise the BM25 method to conduct  full text search as well. The textual similarity score is thus a linear combination of the results from the vector and the full text search, making it robust and efficient. For the media detection, we use a similar approach using SIGLIP (https://arxiv.org/abs/2303.15343) embeddings and compare the input media using these embeddings. Again following the need for similarity beyond semantic meaning, we apply structural similarity scores based off the histogram of the image. We compute the following matrix (Correlation of Histogram, Intersection of Histogram and the Structural Similarity Index (https://www.imatest.com/docs/ssim/). To determine the location of the image that is most likely to be an infringement, we utilise a novel image localisation approach. We split the new image into many small patches and run a sliding window over the patches. Each patch in the window would have the same similarity score as all other patches in that particular iteration. After normalizing the scores, we would have a distribution of patches with varying similarity scores corresponding to a heatmap of the mini patches that are most similar to the existing original image. To extend this approach to videos, we split the video up into frames at a specified frames per second and perform the search over each frame. The final original result is determined by majority voting which makes our approach temporally robust. We made use of Dynamic Protocol for the user authentication. Making it easier for people to onboard onto Hoshi by allowing for email and Google account login and hiding login via wallets. We made use of ERC20 and ERC721 token contracts by openzeppelin so as to create custom logic to our tokens and NFTs to fit our needs. The metadata of the posts/NFTs are uploaded to IPFS, further adding to the decentralization of our platform. For the frontend, we used NextJS for the framework. We also used Three.js to create the 3D derivative graphs to show the connections between an original post and its derivatives.",
        "how_its_made": "To detect Copyright Infringement, we develop a proprietary AI pipeline to not only find the media and text that are similar in nature to the new post but also detect the specific location with the highest similarity. To detect textual similarity of captions, we use Cohere Embeddings to embed each caption into a vector. When a new post is provided, we similarly embed the new caption and compare against other vectors in the database. However, such an approach heavily focuses on semantic similarity since copyright infringement requires exact textual lifting, we utilise the BM25 method to conduct  full text search as well. The textual similarity score is thus a linear combination of the results from the vector and the full text search, making it robust and efficient. For the media detection, we use a similar approach using SIGLIP (https://arxiv.org/abs/2303.15343) embeddings and compare the input media using these embeddings. Again following the need for similarity beyond semantic meaning, we apply structural similarity scores based off the histogram of the image. We compute the following matrix (Correlation of Histogram, Intersection of Histogram and the Structural Similarity Index (https://www.imatest.com/docs/ssim/). To determine the location of the image that is most likely to be an infringement, we utilise a novel image localisation approach. We split the new image into many small patches and run a sliding window over the patches. Each patch in the window would have the same similarity score as all other patches in that particular iteration. After normalizing the scores, we would have a distribution of patches with varying similarity scores corresponding to a heatmap of the mini patches that are most similar to the existing original image. To extend this approach to videos, we split the video up into frames at a specified frames per second and perform the search over each frame. The final original result is determined by majority voting which makes our approach temporally robust. We made use of Dynamic Protocol for the user authentication. Making it easier for people to onboard onto Hoshi by allowing for email and Google account login and hiding login via wallets. We made use of ERC20 and ERC721 token contracts by openzeppelin so as to create custom logic to our tokens and NFTs to fit our needs. The metadata of the posts/NFTs are uploaded to IPFS, further adding to the decentralization of our platform. For the frontend, we used NextJS for the framework. We also used Three.js to create the 3D derivative graphs to show the connections between an original post and its derivatives.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/xkihw/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/wsg9f/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/48c0o/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/ew74h/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/183v2/default.jpg",
            "https://ethglobal.b-cdn.net/projects/xzzxj/screenshots/w8e1i/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/limrik/hoshi",
        "link": "https://ethglobal.com/showcase/hoshi-xzzxj"
    },
    {
        "title": "BulletPay",
        "brief_description": "BulletPay is a blockchain native payment protocol. It enables instance confirmation in face to face payment while keeping the assets safely on-chain.",
        "long_description": "BulletPay utilizes Pre Consensus Gateway and One Time Topup technologies to enable blockchain-native payments. Due to the decentralization of blockchain and the weak finality of its consensus algorithms, asset transfers typically experience delays ranging from seconds to minutes. This is unsuitable for face-to-face transactions, such as daily purchases, which require instant payment confirmation. Unlike channel technologies such as the Lightning Network, we believe that on-chain payments are more secure and reliable. Therefore, we focus on a blockchain-native approach to payments while addressing the issue of delays. We have developed the BulletPay protocol, which combines the efficiency of centralized payment gateways with the security of decentralized blockchains. Our protocol successfully resolves the delay issue, making blockchain payments feasible for real-world scenarios. We use Solidity to build smart contracts and Python to develop the backend. The BulletPay system includes top-up and payment steps for on-chain end users. After a user tops up, the indexer component monitors on-chain events. Each top-up creates an account that can be used multiple times but is not rechargeable. The top-up account can be spent with the spender's signature via the gateway. The gateway monitors the blockchain and tracks the spender's balance, allowing it to notify the merchant if the payment is successful or to reject the user before the payment processed by the blockchain. This constitutes the pre-consensus component. Importantly, assets remain on-chain, ensuring that the gateway cannot access users' assets for any other purpose, which enhances security.",
        "how_its_made": "We use Solidity to build smart contracts and Python to develop the backend. The BulletPay system includes top-up and payment steps for on-chain end users. After a user tops up, the indexer component monitors on-chain events. Each top-up creates an account that can be used multiple times but is not rechargeable. The top-up account can be spent with the spender's signature via the gateway. The gateway monitors the blockchain and tracks the spender's balance, allowing it to notify the merchant if the payment is successful or to reject the user before the payment processed by the blockchain. This constitutes the pre-consensus component. Importantly, assets remain on-chain, ensuring that the gateway cannot access users' assets for any other purpose, which enhances security.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/tz9ii/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/iusb7/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/keqp6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/wxn9x/default.jpg",
            "https://ethglobal.b-cdn.net/projects/rsx64/screenshots/c5qoq/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/Bullet-Pay/bulletpay_service",
        "link": "https://ethglobal.com/showcase/bulletpay-rsx64"
    },
    {
        "title": "tradealerts",
        "brief_description": "tradealerts notifies individuals or interest groups of trade events for a given policy.",
        "long_description": "This project is a social network crypto investors and interest groups.\nIt uses xmtp to timely deliver market signals based on a given policy.\nE.g. relay buy or sell signals for crypto currencies.\nThe signals themselves are generated by a separate backend application that ties into Coinbase to access market data. This project uses MessageKit by xmtp to deliver trade alerts to subscribed users or interest groups.\nIt is prototyped with MessageKit and connects to a backend using CDK by Coinbase.\nWe will try to host the application on Walrus.\nThree components play together:",
        "how_its_made": "This project uses MessageKit by xmtp to deliver trade alerts to subscribed users or interest groups.\nIt is prototyped with MessageKit and connects to a backend using CDK by Coinbase.\nWe will try to host the application on Walrus.\nThree components play together:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/43gav/screenshots/233x6/default.jpg",
            "https://ethglobal.b-cdn.net/projects/43gav/screenshots/qn4b3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/43gav/screenshots/juohk/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/wojtczyk/tradealerts",
        "link": "https://ethglobal.com/showcase/tradealerts-43gav"
    },
    {
        "title": "NFTap",
        "brief_description": "connect via ens by bumping phones with verifiable irl connections",
        "long_description": "This projects aims to verify and create memories based on irl connections easily by allowing users to exchange their ENS information by bumping their phones together. Afterwards, an NFT is minted to verify the meeting, where the image of the NFT makes use of the ENS avatars as well as the location, weather and time of day to generate an image that captures the vibe of the meeting. Afterwards, users can view their minted memories on-chain, and share them with friends and family This project uses React Native for the front end and NodeJS with WebSockets as the communication protocol between the FE and BE. We use Dynamic to allow users to sign up easily and ENS for sharing of personal information such as avatar and name information. For generating the NFT images, we use GenAI to generate unique images based on location data, weather data, time of day and ENS avatars. We decided to deploy and mint our NFT collection on the Polygon chain for its high speed and low transaction fees, meaning we are able to airdrop to users, saving them time and fees.",
        "how_its_made": "This project uses React Native for the front end and NodeJS with WebSockets as the communication protocol between the FE and BE. We use Dynamic to allow users to sign up easily and ENS for sharing of personal information such as avatar and name information. For generating the NFT images, we use GenAI to generate unique images based on location data, weather data, time of day and ENS avatars. We decided to deploy and mint our NFT collection on the Polygon chain for its high speed and low transaction fees, meaning we are able to airdrop to users, saving them time and fees.",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/mapd3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/b2n5m/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/k1zq3/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/qgukn/default.jpg",
            "https://ethglobal.b-cdn.net/projects/z0740/screenshots/f0vbu/default.jpg"
        ],
        "live_demo": null,
        "source_code": "https://github.com/danielliuzy/nftapp",
        "link": "https://ethglobal.com/showcase/nftap-z0740"
    },
    {
        "title": "Shared trading",
        "brief_description": "Let one person trade, but many people contribute and withdraw any time they want",
        "long_description": "Only got part of the project complete this hackathon! Clone the Repository: Set Up the Backend: Navigate to the backend directory and install dependencies: Create a .env file in the backend directory with the following content: Compile and Deploy Contracts: Compile the smart contracts: Deploy the contracts: Set Up the Frontend: Navigate to the frontend directory and install dependencies: Start the React Application: Open Your Browser: Neon VM to use EVM to deploy to Solana + a react app for interacting with the deployed contracts on the Neon VM testnet. Clone the Repository: Set Up the Backend: Navigate to the backend directory and install dependencies: Create a .env file in the backend directory with the following content: Compile and Deploy Contracts: Compile the smart contracts: Deploy the contracts: Set Up the Frontend: Navigate to the frontend directory and install dependencies: Start the React Application: Open Your Browser:",
        "how_its_made": "Neon VM to use EVM to deploy to Solana + a react app for interacting with the deployed contracts on the Neon VM testnet. Clone the Repository: Set Up the Backend: Navigate to the backend directory and install dependencies: Create a .env file in the backend directory with the following content: Compile and Deploy Contracts: Compile the smart contracts: Deploy the contracts: Set Up the Frontend: Navigate to the frontend directory and install dependencies: Start the React Application: Open Your Browser:",
        "screenshots": [
            "https://ethglobal.b-cdn.net/projects/mzh4z/screenshots/f95bg/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mzh4z/screenshots/of9eu/default.jpg",
            "https://ethglobal.b-cdn.net/projects/mzh4z/screenshots/og9o4/default.jpg"
        ],
        "live_demo": "https://ethglobalhack-4sufkljta-nathanmatons-projects.vercel.app/",
        "source_code": "https://github.com/NathanMaton/ethglobalhack",
        "link": "https://ethglobal.com/showcase/shared-trading-mzh4z"
    }
]